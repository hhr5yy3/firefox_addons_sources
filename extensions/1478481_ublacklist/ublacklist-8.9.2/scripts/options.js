"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/react@18.3.1/node_modules/react/cjs/react.production.min.js
  var require_react_production_min = __commonJS({
    "node_modules/.pnpm/react@18.3.1/node_modules/react/cjs/react.production.min.js"(exports) {
      "use strict";
      var l4 = Symbol.for("react.element");
      var n4 = Symbol.for("react.portal");
      var p4 = Symbol.for("react.fragment");
      var q2 = Symbol.for("react.strict_mode");
      var r3 = Symbol.for("react.profiler");
      var t5 = Symbol.for("react.provider");
      var u4 = Symbol.for("react.context");
      var v3 = Symbol.for("react.forward_ref");
      var w2 = Symbol.for("react.suspense");
      var x2 = Symbol.for("react.memo");
      var y3 = Symbol.for("react.lazy");
      var z2 = Symbol.iterator;
      function A(a4) {
        if (null === a4 || "object" !== typeof a4) return null;
        a4 = z2 && a4[z2] || a4["@@iterator"];
        return "function" === typeof a4 ? a4 : null;
      }
      var B = { isMounted: function() {
        return false;
      }, enqueueForceUpdate: function() {
      }, enqueueReplaceState: function() {
      }, enqueueSetState: function() {
      } };
      var C2 = Object.assign;
      var D = {};
      function E(a4, b4, e4) {
        this.props = a4;
        this.context = b4;
        this.refs = D;
        this.updater = e4 || B;
      }
      E.prototype.isReactComponent = {};
      E.prototype.setState = function(a4, b4) {
        if ("object" !== typeof a4 && "function" !== typeof a4 && null != a4) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, a4, b4, "setState");
      };
      E.prototype.forceUpdate = function(a4) {
        this.updater.enqueueForceUpdate(this, a4, "forceUpdate");
      };
      function F2() {
      }
      F2.prototype = E.prototype;
      function G(a4, b4, e4) {
        this.props = a4;
        this.context = b4;
        this.refs = D;
        this.updater = e4 || B;
      }
      var H2 = G.prototype = new F2();
      H2.constructor = G;
      C2(H2, E.prototype);
      H2.isPureReactComponent = true;
      var I2 = Array.isArray;
      var J2 = Object.prototype.hasOwnProperty;
      var K = { current: null };
      var L2 = { key: true, ref: true, __self: true, __source: true };
      function M2(a4, b4, e4) {
        var d3, c4 = {}, k2 = null, h4 = null;
        if (null != b4) for (d3 in void 0 !== b4.ref && (h4 = b4.ref), void 0 !== b4.key && (k2 = "" + b4.key), b4) J2.call(b4, d3) && !L2.hasOwnProperty(d3) && (c4[d3] = b4[d3]);
        var g3 = arguments.length - 2;
        if (1 === g3) c4.children = e4;
        else if (1 < g3) {
          for (var f3 = Array(g3), m3 = 0; m3 < g3; m3++) f3[m3] = arguments[m3 + 2];
          c4.children = f3;
        }
        if (a4 && a4.defaultProps) for (d3 in g3 = a4.defaultProps, g3) void 0 === c4[d3] && (c4[d3] = g3[d3]);
        return { $$typeof: l4, type: a4, key: k2, ref: h4, props: c4, _owner: K.current };
      }
      function N2(a4, b4) {
        return { $$typeof: l4, type: a4.type, key: b4, ref: a4.ref, props: a4.props, _owner: a4._owner };
      }
      function O(a4) {
        return "object" === typeof a4 && null !== a4 && a4.$$typeof === l4;
      }
      function escape(a4) {
        var b4 = { "=": "=0", ":": "=2" };
        return "$" + a4.replace(/[=:]/g, function(a5) {
          return b4[a5];
        });
      }
      var P = /\/+/g;
      function Q2(a4, b4) {
        return "object" === typeof a4 && null !== a4 && null != a4.key ? escape("" + a4.key) : b4.toString(36);
      }
      function R2(a4, b4, e4, d3, c4) {
        var k2 = typeof a4;
        if ("undefined" === k2 || "boolean" === k2) a4 = null;
        var h4 = false;
        if (null === a4) h4 = true;
        else switch (k2) {
          case "string":
          case "number":
            h4 = true;
            break;
          case "object":
            switch (a4.$$typeof) {
              case l4:
              case n4:
                h4 = true;
            }
        }
        if (h4) return h4 = a4, c4 = c4(h4), a4 = "" === d3 ? "." + Q2(h4, 0) : d3, I2(c4) ? (e4 = "", null != a4 && (e4 = a4.replace(P, "$&/") + "/"), R2(c4, b4, e4, "", function(a5) {
          return a5;
        })) : null != c4 && (O(c4) && (c4 = N2(c4, e4 + (!c4.key || h4 && h4.key === c4.key ? "" : ("" + c4.key).replace(P, "$&/") + "/") + a4)), b4.push(c4)), 1;
        h4 = 0;
        d3 = "" === d3 ? "." : d3 + ":";
        if (I2(a4)) for (var g3 = 0; g3 < a4.length; g3++) {
          k2 = a4[g3];
          var f3 = d3 + Q2(k2, g3);
          h4 += R2(k2, b4, e4, f3, c4);
        }
        else if (f3 = A(a4), "function" === typeof f3) for (a4 = f3.call(a4), g3 = 0; !(k2 = a4.next()).done; ) k2 = k2.value, f3 = d3 + Q2(k2, g3++), h4 += R2(k2, b4, e4, f3, c4);
        else if ("object" === k2) throw b4 = String(a4), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b4 ? "object with keys {" + Object.keys(a4).join(", ") + "}" : b4) + "). If you meant to render a collection of children, use an array instead.");
        return h4;
      }
      function S2(a4, b4, e4) {
        if (null == a4) return a4;
        var d3 = [], c4 = 0;
        R2(a4, d3, "", "", function(a5) {
          return b4.call(e4, a5, c4++);
        });
        return d3;
      }
      function T2(a4) {
        if (-1 === a4._status) {
          var b4 = a4._result;
          b4 = b4();
          b4.then(function(b5) {
            if (0 === a4._status || -1 === a4._status) a4._status = 1, a4._result = b5;
          }, function(b5) {
            if (0 === a4._status || -1 === a4._status) a4._status = 2, a4._result = b5;
          });
          -1 === a4._status && (a4._status = 0, a4._result = b4);
        }
        if (1 === a4._status) return a4._result.default;
        throw a4._result;
      }
      var U = { current: null };
      var V2 = { transition: null };
      var W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V2, ReactCurrentOwner: K };
      function X() {
        throw Error("act(...) is not supported in production builds of React.");
      }
      exports.Children = { map: S2, forEach: function(a4, b4, e4) {
        S2(a4, function() {
          b4.apply(this, arguments);
        }, e4);
      }, count: function(a4) {
        var b4 = 0;
        S2(a4, function() {
          b4++;
        });
        return b4;
      }, toArray: function(a4) {
        return S2(a4, function(a5) {
          return a5;
        }) || [];
      }, only: function(a4) {
        if (!O(a4)) throw Error("React.Children.only expected to receive a single React element child.");
        return a4;
      } };
      exports.Component = E;
      exports.Fragment = p4;
      exports.Profiler = r3;
      exports.PureComponent = G;
      exports.StrictMode = q2;
      exports.Suspense = w2;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
      exports.act = X;
      exports.cloneElement = function(a4, b4, e4) {
        if (null === a4 || void 0 === a4) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a4 + ".");
        var d3 = C2({}, a4.props), c4 = a4.key, k2 = a4.ref, h4 = a4._owner;
        if (null != b4) {
          void 0 !== b4.ref && (k2 = b4.ref, h4 = K.current);
          void 0 !== b4.key && (c4 = "" + b4.key);
          if (a4.type && a4.type.defaultProps) var g3 = a4.type.defaultProps;
          for (f3 in b4) J2.call(b4, f3) && !L2.hasOwnProperty(f3) && (d3[f3] = void 0 === b4[f3] && void 0 !== g3 ? g3[f3] : b4[f3]);
        }
        var f3 = arguments.length - 2;
        if (1 === f3) d3.children = e4;
        else if (1 < f3) {
          g3 = Array(f3);
          for (var m3 = 0; m3 < f3; m3++) g3[m3] = arguments[m3 + 2];
          d3.children = g3;
        }
        return { $$typeof: l4, type: a4.type, key: c4, ref: k2, props: d3, _owner: h4 };
      };
      exports.createContext = function(a4) {
        a4 = { $$typeof: u4, _currentValue: a4, _currentValue2: a4, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
        a4.Provider = { $$typeof: t5, _context: a4 };
        return a4.Consumer = a4;
      };
      exports.createElement = M2;
      exports.createFactory = function(a4) {
        var b4 = M2.bind(null, a4);
        b4.type = a4;
        return b4;
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(a4) {
        return { $$typeof: v3, render: a4 };
      };
      exports.isValidElement = O;
      exports.lazy = function(a4) {
        return { $$typeof: y3, _payload: { _status: -1, _result: a4 }, _init: T2 };
      };
      exports.memo = function(a4, b4) {
        return { $$typeof: x2, type: a4, compare: void 0 === b4 ? null : b4 };
      };
      exports.startTransition = function(a4) {
        var b4 = V2.transition;
        V2.transition = {};
        try {
          a4();
        } finally {
          V2.transition = b4;
        }
      };
      exports.unstable_act = X;
      exports.useCallback = function(a4, b4) {
        return U.current.useCallback(a4, b4);
      };
      exports.useContext = function(a4) {
        return U.current.useContext(a4);
      };
      exports.useDebugValue = function() {
      };
      exports.useDeferredValue = function(a4) {
        return U.current.useDeferredValue(a4);
      };
      exports.useEffect = function(a4, b4) {
        return U.current.useEffect(a4, b4);
      };
      exports.useId = function() {
        return U.current.useId();
      };
      exports.useImperativeHandle = function(a4, b4, e4) {
        return U.current.useImperativeHandle(a4, b4, e4);
      };
      exports.useInsertionEffect = function(a4, b4) {
        return U.current.useInsertionEffect(a4, b4);
      };
      exports.useLayoutEffect = function(a4, b4) {
        return U.current.useLayoutEffect(a4, b4);
      };
      exports.useMemo = function(a4, b4) {
        return U.current.useMemo(a4, b4);
      };
      exports.useReducer = function(a4, b4, e4) {
        return U.current.useReducer(a4, b4, e4);
      };
      exports.useRef = function(a4) {
        return U.current.useRef(a4);
      };
      exports.useState = function(a4) {
        return U.current.useState(a4);
      };
      exports.useSyncExternalStore = function(a4, b4, e4) {
        return U.current.useSyncExternalStore(a4, b4, e4);
      };
      exports.useTransition = function() {
        return U.current.useTransition();
      };
      exports.version = "18.3.1";
    }
  });

  // node_modules/.pnpm/react@18.3.1/node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/.pnpm/react@18.3.1/node_modules/react/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/cjs/scheduler.production.min.js
  var require_scheduler_production_min = __commonJS({
    "node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/cjs/scheduler.production.min.js"(exports) {
      "use strict";
      function f3(a4, b4) {
        var c4 = a4.length;
        a4.push(b4);
        a: for (; 0 < c4; ) {
          var d3 = c4 - 1 >>> 1, e4 = a4[d3];
          if (0 < g3(e4, b4)) a4[d3] = b4, a4[c4] = e4, c4 = d3;
          else break a;
        }
      }
      function h4(a4) {
        return 0 === a4.length ? null : a4[0];
      }
      function k2(a4) {
        if (0 === a4.length) return null;
        var b4 = a4[0], c4 = a4.pop();
        if (c4 !== b4) {
          a4[0] = c4;
          a: for (var d3 = 0, e4 = a4.length, w2 = e4 >>> 1; d3 < w2; ) {
            var m3 = 2 * (d3 + 1) - 1, C2 = a4[m3], n4 = m3 + 1, x2 = a4[n4];
            if (0 > g3(C2, c4)) n4 < e4 && 0 > g3(x2, C2) ? (a4[d3] = x2, a4[n4] = c4, d3 = n4) : (a4[d3] = C2, a4[m3] = c4, d3 = m3);
            else if (n4 < e4 && 0 > g3(x2, c4)) a4[d3] = x2, a4[n4] = c4, d3 = n4;
            else break a;
          }
        }
        return b4;
      }
      function g3(a4, b4) {
        var c4 = a4.sortIndex - b4.sortIndex;
        return 0 !== c4 ? c4 : a4.id - b4.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        l4 = performance;
        exports.unstable_now = function() {
          return l4.now();
        };
      } else {
        p4 = Date, q2 = p4.now();
        exports.unstable_now = function() {
          return p4.now() - q2;
        };
      }
      var l4;
      var p4;
      var q2;
      var r3 = [];
      var t5 = [];
      var u4 = 1;
      var v3 = null;
      var y3 = 3;
      var z2 = false;
      var A = false;
      var B = false;
      var D = "function" === typeof setTimeout ? setTimeout : null;
      var E = "function" === typeof clearTimeout ? clearTimeout : null;
      var F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G(a4) {
        for (var b4 = h4(t5); null !== b4; ) {
          if (null === b4.callback) k2(t5);
          else if (b4.startTime <= a4) k2(t5), b4.sortIndex = b4.expirationTime, f3(r3, b4);
          else break;
          b4 = h4(t5);
        }
      }
      function H2(a4) {
        B = false;
        G(a4);
        if (!A) if (null !== h4(r3)) A = true, I2(J2);
        else {
          var b4 = h4(t5);
          null !== b4 && K(H2, b4.startTime - a4);
        }
      }
      function J2(a4, b4) {
        A = false;
        B && (B = false, E(L2), L2 = -1);
        z2 = true;
        var c4 = y3;
        try {
          G(b4);
          for (v3 = h4(r3); null !== v3 && (!(v3.expirationTime > b4) || a4 && !M2()); ) {
            var d3 = v3.callback;
            if ("function" === typeof d3) {
              v3.callback = null;
              y3 = v3.priorityLevel;
              var e4 = d3(v3.expirationTime <= b4);
              b4 = exports.unstable_now();
              "function" === typeof e4 ? v3.callback = e4 : v3 === h4(r3) && k2(r3);
              G(b4);
            } else k2(r3);
            v3 = h4(r3);
          }
          if (null !== v3) var w2 = true;
          else {
            var m3 = h4(t5);
            null !== m3 && K(H2, m3.startTime - b4);
            w2 = false;
          }
          return w2;
        } finally {
          v3 = null, y3 = c4, z2 = false;
        }
      }
      var N2 = false;
      var O = null;
      var L2 = -1;
      var P = 5;
      var Q2 = -1;
      function M2() {
        return exports.unstable_now() - Q2 < P ? false : true;
      }
      function R2() {
        if (null !== O) {
          var a4 = exports.unstable_now();
          Q2 = a4;
          var b4 = true;
          try {
            b4 = O(true, a4);
          } finally {
            b4 ? S2() : (N2 = false, O = null);
          }
        } else N2 = false;
      }
      var S2;
      if ("function" === typeof F2) S2 = function() {
        F2(R2);
      };
      else if ("undefined" !== typeof MessageChannel) {
        T2 = new MessageChannel(), U = T2.port2;
        T2.port1.onmessage = R2;
        S2 = function() {
          U.postMessage(null);
        };
      } else S2 = function() {
        D(R2, 0);
      };
      var T2;
      var U;
      function I2(a4) {
        O = a4;
        N2 || (N2 = true, S2());
      }
      function K(a4, b4) {
        L2 = D(function() {
          a4(exports.unstable_now());
        }, b4);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(a4) {
        a4.callback = null;
      };
      exports.unstable_continueExecution = function() {
        A || z2 || (A = true, I2(J2));
      };
      exports.unstable_forceFrameRate = function(a4) {
        0 > a4 || 125 < a4 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a4 ? Math.floor(1e3 / a4) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return y3;
      };
      exports.unstable_getFirstCallbackNode = function() {
        return h4(r3);
      };
      exports.unstable_next = function(a4) {
        switch (y3) {
          case 1:
          case 2:
          case 3:
            var b4 = 3;
            break;
          default:
            b4 = y3;
        }
        var c4 = y3;
        y3 = b4;
        try {
          return a4();
        } finally {
          y3 = c4;
        }
      };
      exports.unstable_pauseExecution = function() {
      };
      exports.unstable_requestPaint = function() {
      };
      exports.unstable_runWithPriority = function(a4, b4) {
        switch (a4) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a4 = 3;
        }
        var c4 = y3;
        y3 = a4;
        try {
          return b4();
        } finally {
          y3 = c4;
        }
      };
      exports.unstable_scheduleCallback = function(a4, b4, c4) {
        var d3 = exports.unstable_now();
        "object" === typeof c4 && null !== c4 ? (c4 = c4.delay, c4 = "number" === typeof c4 && 0 < c4 ? d3 + c4 : d3) : c4 = d3;
        switch (a4) {
          case 1:
            var e4 = -1;
            break;
          case 2:
            e4 = 250;
            break;
          case 5:
            e4 = 1073741823;
            break;
          case 4:
            e4 = 1e4;
            break;
          default:
            e4 = 5e3;
        }
        e4 = c4 + e4;
        a4 = { id: u4++, callback: b4, priorityLevel: a4, startTime: c4, expirationTime: e4, sortIndex: -1 };
        c4 > d3 ? (a4.sortIndex = c4, f3(t5, a4), null === h4(r3) && a4 === h4(t5) && (B ? (E(L2), L2 = -1) : B = true, K(H2, c4 - d3))) : (a4.sortIndex = e4, f3(r3, a4), A || z2 || (A = true, I2(J2)));
        return a4;
      };
      exports.unstable_shouldYield = M2;
      exports.unstable_wrapCallback = function(a4) {
        var b4 = y3;
        return function() {
          var c4 = y3;
          y3 = b4;
          try {
            return a4.apply(this, arguments);
          } finally {
            y3 = c4;
          }
        };
      };
    }
  });

  // node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_scheduler_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/cjs/react-dom.production.min.js
  var require_react_dom_production_min = __commonJS({
    "node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/cjs/react-dom.production.min.js"(exports) {
      "use strict";
      var aa = require_react();
      var ca = require_scheduler();
      function p4(a4) {
        for (var b4 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a4, c4 = 1; c4 < arguments.length; c4++) b4 += "&args[]=" + encodeURIComponent(arguments[c4]);
        return "Minified React error #" + a4 + "; visit " + b4 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      var da = /* @__PURE__ */ new Set();
      var ea = {};
      function fa(a4, b4) {
        ha(a4, b4);
        ha(a4 + "Capture", b4);
      }
      function ha(a4, b4) {
        ea[a4] = b4;
        for (a4 = 0; a4 < b4.length; a4++) da.add(b4[a4]);
      }
      var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
      var ja = Object.prototype.hasOwnProperty;
      var ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
      var la = {};
      var ma = {};
      function oa(a4) {
        if (ja.call(ma, a4)) return true;
        if (ja.call(la, a4)) return false;
        if (ka.test(a4)) return ma[a4] = true;
        la[a4] = true;
        return false;
      }
      function pa(a4, b4, c4, d3) {
        if (null !== c4 && 0 === c4.type) return false;
        switch (typeof b4) {
          case "function":
          case "symbol":
            return true;
          case "boolean":
            if (d3) return false;
            if (null !== c4) return !c4.acceptsBooleans;
            a4 = a4.toLowerCase().slice(0, 5);
            return "data-" !== a4 && "aria-" !== a4;
          default:
            return false;
        }
      }
      function qa(a4, b4, c4, d3) {
        if (null === b4 || "undefined" === typeof b4 || pa(a4, b4, c4, d3)) return true;
        if (d3) return false;
        if (null !== c4) switch (c4.type) {
          case 3:
            return !b4;
          case 4:
            return false === b4;
          case 5:
            return isNaN(b4);
          case 6:
            return isNaN(b4) || 1 > b4;
        }
        return false;
      }
      function v3(a4, b4, c4, d3, e4, f3, g3) {
        this.acceptsBooleans = 2 === b4 || 3 === b4 || 4 === b4;
        this.attributeName = d3;
        this.attributeNamespace = e4;
        this.mustUseProperty = c4;
        this.propertyName = a4;
        this.type = b4;
        this.sanitizeURL = f3;
        this.removeEmptyString = g3;
      }
      var z2 = {};
      "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a4) {
        z2[a4] = new v3(a4, 0, false, a4, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a4) {
        var b4 = a4[0];
        z2[b4] = new v3(b4, 1, false, a4[1], null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a4) {
        z2[a4] = new v3(a4, 2, false, a4.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a4) {
        z2[a4] = new v3(a4, 2, false, a4, null, false, false);
      });
      "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a4) {
        z2[a4] = new v3(a4, 3, false, a4.toLowerCase(), null, false, false);
      });
      ["checked", "multiple", "muted", "selected"].forEach(function(a4) {
        z2[a4] = new v3(a4, 3, true, a4, null, false, false);
      });
      ["capture", "download"].forEach(function(a4) {
        z2[a4] = new v3(a4, 4, false, a4, null, false, false);
      });
      ["cols", "rows", "size", "span"].forEach(function(a4) {
        z2[a4] = new v3(a4, 6, false, a4, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(a4) {
        z2[a4] = new v3(a4, 5, false, a4.toLowerCase(), null, false, false);
      });
      var ra = /[\-:]([a-z])/g;
      function sa(a4) {
        return a4[1].toUpperCase();
      }
      "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a4) {
        var b4 = a4.replace(
          ra,
          sa
        );
        z2[b4] = new v3(b4, 1, false, a4, null, false, false);
      });
      "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a4) {
        var b4 = a4.replace(ra, sa);
        z2[b4] = new v3(b4, 1, false, a4, "http://www.w3.org/1999/xlink", false, false);
      });
      ["xml:base", "xml:lang", "xml:space"].forEach(function(a4) {
        var b4 = a4.replace(ra, sa);
        z2[b4] = new v3(b4, 1, false, a4, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(a4) {
        z2[a4] = new v3(a4, 1, false, a4.toLowerCase(), null, false, false);
      });
      z2.xlinkHref = new v3("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(a4) {
        z2[a4] = new v3(a4, 1, false, a4.toLowerCase(), null, true, true);
      });
      function ta(a4, b4, c4, d3) {
        var e4 = z2.hasOwnProperty(b4) ? z2[b4] : null;
        if (null !== e4 ? 0 !== e4.type : d3 || !(2 < b4.length) || "o" !== b4[0] && "O" !== b4[0] || "n" !== b4[1] && "N" !== b4[1]) qa(b4, c4, e4, d3) && (c4 = null), d3 || null === e4 ? oa(b4) && (null === c4 ? a4.removeAttribute(b4) : a4.setAttribute(b4, "" + c4)) : e4.mustUseProperty ? a4[e4.propertyName] = null === c4 ? 3 === e4.type ? false : "" : c4 : (b4 = e4.attributeName, d3 = e4.attributeNamespace, null === c4 ? a4.removeAttribute(b4) : (e4 = e4.type, c4 = 3 === e4 || 4 === e4 && true === c4 ? "" : "" + c4, d3 ? a4.setAttributeNS(d3, b4, c4) : a4.setAttribute(b4, c4)));
      }
      var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var va = Symbol.for("react.element");
      var wa = Symbol.for("react.portal");
      var ya = Symbol.for("react.fragment");
      var za = Symbol.for("react.strict_mode");
      var Aa = Symbol.for("react.profiler");
      var Ba = Symbol.for("react.provider");
      var Ca = Symbol.for("react.context");
      var Da = Symbol.for("react.forward_ref");
      var Ea = Symbol.for("react.suspense");
      var Fa = Symbol.for("react.suspense_list");
      var Ga = Symbol.for("react.memo");
      var Ha = Symbol.for("react.lazy");
      Symbol.for("react.scope");
      Symbol.for("react.debug_trace_mode");
      var Ia = Symbol.for("react.offscreen");
      Symbol.for("react.legacy_hidden");
      Symbol.for("react.cache");
      Symbol.for("react.tracing_marker");
      var Ja = Symbol.iterator;
      function Ka(a4) {
        if (null === a4 || "object" !== typeof a4) return null;
        a4 = Ja && a4[Ja] || a4["@@iterator"];
        return "function" === typeof a4 ? a4 : null;
      }
      var A = Object.assign;
      var La;
      function Ma(a4) {
        if (void 0 === La) try {
          throw Error();
        } catch (c4) {
          var b4 = c4.stack.trim().match(/\n( *(at )?)/);
          La = b4 && b4[1] || "";
        }
        return "\n" + La + a4;
      }
      var Na = false;
      function Oa(a4, b4) {
        if (!a4 || Na) return "";
        Na = true;
        var c4 = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (b4) if (b4 = function() {
            throw Error();
          }, Object.defineProperty(b4.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b4, []);
            } catch (l4) {
              var d3 = l4;
            }
            Reflect.construct(a4, [], b4);
          } else {
            try {
              b4.call();
            } catch (l4) {
              d3 = l4;
            }
            a4.call(b4.prototype);
          }
          else {
            try {
              throw Error();
            } catch (l4) {
              d3 = l4;
            }
            a4();
          }
        } catch (l4) {
          if (l4 && d3 && "string" === typeof l4.stack) {
            for (var e4 = l4.stack.split("\n"), f3 = d3.stack.split("\n"), g3 = e4.length - 1, h4 = f3.length - 1; 1 <= g3 && 0 <= h4 && e4[g3] !== f3[h4]; ) h4--;
            for (; 1 <= g3 && 0 <= h4; g3--, h4--) if (e4[g3] !== f3[h4]) {
              if (1 !== g3 || 1 !== h4) {
                do
                  if (g3--, h4--, 0 > h4 || e4[g3] !== f3[h4]) {
                    var k2 = "\n" + e4[g3].replace(" at new ", " at ");
                    a4.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a4.displayName));
                    return k2;
                  }
                while (1 <= g3 && 0 <= h4);
              }
              break;
            }
          }
        } finally {
          Na = false, Error.prepareStackTrace = c4;
        }
        return (a4 = a4 ? a4.displayName || a4.name : "") ? Ma(a4) : "";
      }
      function Pa(a4) {
        switch (a4.tag) {
          case 5:
            return Ma(a4.type);
          case 16:
            return Ma("Lazy");
          case 13:
            return Ma("Suspense");
          case 19:
            return Ma("SuspenseList");
          case 0:
          case 2:
          case 15:
            return a4 = Oa(a4.type, false), a4;
          case 11:
            return a4 = Oa(a4.type.render, false), a4;
          case 1:
            return a4 = Oa(a4.type, true), a4;
          default:
            return "";
        }
      }
      function Qa(a4) {
        if (null == a4) return null;
        if ("function" === typeof a4) return a4.displayName || a4.name || null;
        if ("string" === typeof a4) return a4;
        switch (a4) {
          case ya:
            return "Fragment";
          case wa:
            return "Portal";
          case Aa:
            return "Profiler";
          case za:
            return "StrictMode";
          case Ea:
            return "Suspense";
          case Fa:
            return "SuspenseList";
        }
        if ("object" === typeof a4) switch (a4.$$typeof) {
          case Ca:
            return (a4.displayName || "Context") + ".Consumer";
          case Ba:
            return (a4._context.displayName || "Context") + ".Provider";
          case Da:
            var b4 = a4.render;
            a4 = a4.displayName;
            a4 || (a4 = b4.displayName || b4.name || "", a4 = "" !== a4 ? "ForwardRef(" + a4 + ")" : "ForwardRef");
            return a4;
          case Ga:
            return b4 = a4.displayName || null, null !== b4 ? b4 : Qa(a4.type) || "Memo";
          case Ha:
            b4 = a4._payload;
            a4 = a4._init;
            try {
              return Qa(a4(b4));
            } catch (c4) {
            }
        }
        return null;
      }
      function Ra(a4) {
        var b4 = a4.type;
        switch (a4.tag) {
          case 24:
            return "Cache";
          case 9:
            return (b4.displayName || "Context") + ".Consumer";
          case 10:
            return (b4._context.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return a4 = b4.render, a4 = a4.displayName || a4.name || "", b4.displayName || ("" !== a4 ? "ForwardRef(" + a4 + ")" : "ForwardRef");
          case 7:
            return "Fragment";
          case 5:
            return b4;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return Qa(b4);
          case 8:
            return b4 === za ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 17:
          case 2:
          case 14:
          case 15:
            if ("function" === typeof b4) return b4.displayName || b4.name || null;
            if ("string" === typeof b4) return b4;
        }
        return null;
      }
      function Sa(a4) {
        switch (typeof a4) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return a4;
          case "object":
            return a4;
          default:
            return "";
        }
      }
      function Ta(a4) {
        var b4 = a4.type;
        return (a4 = a4.nodeName) && "input" === a4.toLowerCase() && ("checkbox" === b4 || "radio" === b4);
      }
      function Ua(a4) {
        var b4 = Ta(a4) ? "checked" : "value", c4 = Object.getOwnPropertyDescriptor(a4.constructor.prototype, b4), d3 = "" + a4[b4];
        if (!a4.hasOwnProperty(b4) && "undefined" !== typeof c4 && "function" === typeof c4.get && "function" === typeof c4.set) {
          var e4 = c4.get, f3 = c4.set;
          Object.defineProperty(a4, b4, { configurable: true, get: function() {
            return e4.call(this);
          }, set: function(a5) {
            d3 = "" + a5;
            f3.call(this, a5);
          } });
          Object.defineProperty(a4, b4, { enumerable: c4.enumerable });
          return { getValue: function() {
            return d3;
          }, setValue: function(a5) {
            d3 = "" + a5;
          }, stopTracking: function() {
            a4._valueTracker = null;
            delete a4[b4];
          } };
        }
      }
      function Va(a4) {
        a4._valueTracker || (a4._valueTracker = Ua(a4));
      }
      function Wa(a4) {
        if (!a4) return false;
        var b4 = a4._valueTracker;
        if (!b4) return true;
        var c4 = b4.getValue();
        var d3 = "";
        a4 && (d3 = Ta(a4) ? a4.checked ? "true" : "false" : a4.value);
        a4 = d3;
        return a4 !== c4 ? (b4.setValue(a4), true) : false;
      }
      function Xa(a4) {
        a4 = a4 || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof a4) return null;
        try {
          return a4.activeElement || a4.body;
        } catch (b4) {
          return a4.body;
        }
      }
      function Ya(a4, b4) {
        var c4 = b4.checked;
        return A({}, b4, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c4 ? c4 : a4._wrapperState.initialChecked });
      }
      function Za(a4, b4) {
        var c4 = null == b4.defaultValue ? "" : b4.defaultValue, d3 = null != b4.checked ? b4.checked : b4.defaultChecked;
        c4 = Sa(null != b4.value ? b4.value : c4);
        a4._wrapperState = { initialChecked: d3, initialValue: c4, controlled: "checkbox" === b4.type || "radio" === b4.type ? null != b4.checked : null != b4.value };
      }
      function ab(a4, b4) {
        b4 = b4.checked;
        null != b4 && ta(a4, "checked", b4, false);
      }
      function bb(a4, b4) {
        ab(a4, b4);
        var c4 = Sa(b4.value), d3 = b4.type;
        if (null != c4) if ("number" === d3) {
          if (0 === c4 && "" === a4.value || a4.value != c4) a4.value = "" + c4;
        } else a4.value !== "" + c4 && (a4.value = "" + c4);
        else if ("submit" === d3 || "reset" === d3) {
          a4.removeAttribute("value");
          return;
        }
        b4.hasOwnProperty("value") ? cb(a4, b4.type, c4) : b4.hasOwnProperty("defaultValue") && cb(a4, b4.type, Sa(b4.defaultValue));
        null == b4.checked && null != b4.defaultChecked && (a4.defaultChecked = !!b4.defaultChecked);
      }
      function db(a4, b4, c4) {
        if (b4.hasOwnProperty("value") || b4.hasOwnProperty("defaultValue")) {
          var d3 = b4.type;
          if (!("submit" !== d3 && "reset" !== d3 || void 0 !== b4.value && null !== b4.value)) return;
          b4 = "" + a4._wrapperState.initialValue;
          c4 || b4 === a4.value || (a4.value = b4);
          a4.defaultValue = b4;
        }
        c4 = a4.name;
        "" !== c4 && (a4.name = "");
        a4.defaultChecked = !!a4._wrapperState.initialChecked;
        "" !== c4 && (a4.name = c4);
      }
      function cb(a4, b4, c4) {
        if ("number" !== b4 || Xa(a4.ownerDocument) !== a4) null == c4 ? a4.defaultValue = "" + a4._wrapperState.initialValue : a4.defaultValue !== "" + c4 && (a4.defaultValue = "" + c4);
      }
      var eb = Array.isArray;
      function fb(a4, b4, c4, d3) {
        a4 = a4.options;
        if (b4) {
          b4 = {};
          for (var e4 = 0; e4 < c4.length; e4++) b4["$" + c4[e4]] = true;
          for (c4 = 0; c4 < a4.length; c4++) e4 = b4.hasOwnProperty("$" + a4[c4].value), a4[c4].selected !== e4 && (a4[c4].selected = e4), e4 && d3 && (a4[c4].defaultSelected = true);
        } else {
          c4 = "" + Sa(c4);
          b4 = null;
          for (e4 = 0; e4 < a4.length; e4++) {
            if (a4[e4].value === c4) {
              a4[e4].selected = true;
              d3 && (a4[e4].defaultSelected = true);
              return;
            }
            null !== b4 || a4[e4].disabled || (b4 = a4[e4]);
          }
          null !== b4 && (b4.selected = true);
        }
      }
      function gb(a4, b4) {
        if (null != b4.dangerouslySetInnerHTML) throw Error(p4(91));
        return A({}, b4, { value: void 0, defaultValue: void 0, children: "" + a4._wrapperState.initialValue });
      }
      function hb(a4, b4) {
        var c4 = b4.value;
        if (null == c4) {
          c4 = b4.children;
          b4 = b4.defaultValue;
          if (null != c4) {
            if (null != b4) throw Error(p4(92));
            if (eb(c4)) {
              if (1 < c4.length) throw Error(p4(93));
              c4 = c4[0];
            }
            b4 = c4;
          }
          null == b4 && (b4 = "");
          c4 = b4;
        }
        a4._wrapperState = { initialValue: Sa(c4) };
      }
      function ib(a4, b4) {
        var c4 = Sa(b4.value), d3 = Sa(b4.defaultValue);
        null != c4 && (c4 = "" + c4, c4 !== a4.value && (a4.value = c4), null == b4.defaultValue && a4.defaultValue !== c4 && (a4.defaultValue = c4));
        null != d3 && (a4.defaultValue = "" + d3);
      }
      function jb(a4) {
        var b4 = a4.textContent;
        b4 === a4._wrapperState.initialValue && "" !== b4 && null !== b4 && (a4.value = b4);
      }
      function kb(a4) {
        switch (a4) {
          case "svg":
            return "http://www.w3.org/2000/svg";
          case "math":
            return "http://www.w3.org/1998/Math/MathML";
          default:
            return "http://www.w3.org/1999/xhtml";
        }
      }
      function lb(a4, b4) {
        return null == a4 || "http://www.w3.org/1999/xhtml" === a4 ? kb(b4) : "http://www.w3.org/2000/svg" === a4 && "foreignObject" === b4 ? "http://www.w3.org/1999/xhtml" : a4;
      }
      var mb;
      var nb = function(a4) {
        return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b4, c4, d3, e4) {
          MSApp.execUnsafeLocalFunction(function() {
            return a4(b4, c4, d3, e4);
          });
        } : a4;
      }(function(a4, b4) {
        if ("http://www.w3.org/2000/svg" !== a4.namespaceURI || "innerHTML" in a4) a4.innerHTML = b4;
        else {
          mb = mb || document.createElement("div");
          mb.innerHTML = "<svg>" + b4.valueOf().toString() + "</svg>";
          for (b4 = mb.firstChild; a4.firstChild; ) a4.removeChild(a4.firstChild);
          for (; b4.firstChild; ) a4.appendChild(b4.firstChild);
        }
      });
      function ob(a4, b4) {
        if (b4) {
          var c4 = a4.firstChild;
          if (c4 && c4 === a4.lastChild && 3 === c4.nodeType) {
            c4.nodeValue = b4;
            return;
          }
        }
        a4.textContent = b4;
      }
      var pb = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      var qb = ["Webkit", "ms", "Moz", "O"];
      Object.keys(pb).forEach(function(a4) {
        qb.forEach(function(b4) {
          b4 = b4 + a4.charAt(0).toUpperCase() + a4.substring(1);
          pb[b4] = pb[a4];
        });
      });
      function rb(a4, b4, c4) {
        return null == b4 || "boolean" === typeof b4 || "" === b4 ? "" : c4 || "number" !== typeof b4 || 0 === b4 || pb.hasOwnProperty(a4) && pb[a4] ? ("" + b4).trim() : b4 + "px";
      }
      function sb(a4, b4) {
        a4 = a4.style;
        for (var c4 in b4) if (b4.hasOwnProperty(c4)) {
          var d3 = 0 === c4.indexOf("--"), e4 = rb(c4, b4[c4], d3);
          "float" === c4 && (c4 = "cssFloat");
          d3 ? a4.setProperty(c4, e4) : a4[c4] = e4;
        }
      }
      var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
      function ub(a4, b4) {
        if (b4) {
          if (tb[a4] && (null != b4.children || null != b4.dangerouslySetInnerHTML)) throw Error(p4(137, a4));
          if (null != b4.dangerouslySetInnerHTML) {
            if (null != b4.children) throw Error(p4(60));
            if ("object" !== typeof b4.dangerouslySetInnerHTML || !("__html" in b4.dangerouslySetInnerHTML)) throw Error(p4(61));
          }
          if (null != b4.style && "object" !== typeof b4.style) throw Error(p4(62));
        }
      }
      function vb(a4, b4) {
        if (-1 === a4.indexOf("-")) return "string" === typeof b4.is;
        switch (a4) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var wb = null;
      function xb(a4) {
        a4 = a4.target || a4.srcElement || window;
        a4.correspondingUseElement && (a4 = a4.correspondingUseElement);
        return 3 === a4.nodeType ? a4.parentNode : a4;
      }
      var yb = null;
      var zb = null;
      var Ab = null;
      function Bb(a4) {
        if (a4 = Cb(a4)) {
          if ("function" !== typeof yb) throw Error(p4(280));
          var b4 = a4.stateNode;
          b4 && (b4 = Db(b4), yb(a4.stateNode, a4.type, b4));
        }
      }
      function Eb(a4) {
        zb ? Ab ? Ab.push(a4) : Ab = [a4] : zb = a4;
      }
      function Fb() {
        if (zb) {
          var a4 = zb, b4 = Ab;
          Ab = zb = null;
          Bb(a4);
          if (b4) for (a4 = 0; a4 < b4.length; a4++) Bb(b4[a4]);
        }
      }
      function Gb(a4, b4) {
        return a4(b4);
      }
      function Hb() {
      }
      var Ib = false;
      function Jb(a4, b4, c4) {
        if (Ib) return a4(b4, c4);
        Ib = true;
        try {
          return Gb(a4, b4, c4);
        } finally {
          if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
        }
      }
      function Kb(a4, b4) {
        var c4 = a4.stateNode;
        if (null === c4) return null;
        var d3 = Db(c4);
        if (null === d3) return null;
        c4 = d3[b4];
        a: switch (b4) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d3 = !d3.disabled) || (a4 = a4.type, d3 = !("button" === a4 || "input" === a4 || "select" === a4 || "textarea" === a4));
            a4 = !d3;
            break a;
          default:
            a4 = false;
        }
        if (a4) return null;
        if (c4 && "function" !== typeof c4) throw Error(p4(231, b4, typeof c4));
        return c4;
      }
      var Lb = false;
      if (ia) try {
        Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a4) {
        Lb = false;
      }
      var Mb;
      function Nb(a4, b4, c4, d3, e4, f3, g3, h4, k2) {
        var l4 = Array.prototype.slice.call(arguments, 3);
        try {
          b4.apply(c4, l4);
        } catch (m3) {
          this.onError(m3);
        }
      }
      var Ob = false;
      var Pb = null;
      var Qb = false;
      var Rb = null;
      var Sb = { onError: function(a4) {
        Ob = true;
        Pb = a4;
      } };
      function Tb(a4, b4, c4, d3, e4, f3, g3, h4, k2) {
        Ob = false;
        Pb = null;
        Nb.apply(Sb, arguments);
      }
      function Ub(a4, b4, c4, d3, e4, f3, g3, h4, k2) {
        Tb.apply(this, arguments);
        if (Ob) {
          if (Ob) {
            var l4 = Pb;
            Ob = false;
            Pb = null;
          } else throw Error(p4(198));
          Qb || (Qb = true, Rb = l4);
        }
      }
      function Vb(a4) {
        var b4 = a4, c4 = a4;
        if (a4.alternate) for (; b4.return; ) b4 = b4.return;
        else {
          a4 = b4;
          do
            b4 = a4, 0 !== (b4.flags & 4098) && (c4 = b4.return), a4 = b4.return;
          while (a4);
        }
        return 3 === b4.tag ? c4 : null;
      }
      function Wb(a4) {
        if (13 === a4.tag) {
          var b4 = a4.memoizedState;
          null === b4 && (a4 = a4.alternate, null !== a4 && (b4 = a4.memoizedState));
          if (null !== b4) return b4.dehydrated;
        }
        return null;
      }
      function Xb(a4) {
        if (Vb(a4) !== a4) throw Error(p4(188));
      }
      function Yb(a4) {
        var b4 = a4.alternate;
        if (!b4) {
          b4 = Vb(a4);
          if (null === b4) throw Error(p4(188));
          return b4 !== a4 ? null : a4;
        }
        for (var c4 = a4, d3 = b4; ; ) {
          var e4 = c4.return;
          if (null === e4) break;
          var f3 = e4.alternate;
          if (null === f3) {
            d3 = e4.return;
            if (null !== d3) {
              c4 = d3;
              continue;
            }
            break;
          }
          if (e4.child === f3.child) {
            for (f3 = e4.child; f3; ) {
              if (f3 === c4) return Xb(e4), a4;
              if (f3 === d3) return Xb(e4), b4;
              f3 = f3.sibling;
            }
            throw Error(p4(188));
          }
          if (c4.return !== d3.return) c4 = e4, d3 = f3;
          else {
            for (var g3 = false, h4 = e4.child; h4; ) {
              if (h4 === c4) {
                g3 = true;
                c4 = e4;
                d3 = f3;
                break;
              }
              if (h4 === d3) {
                g3 = true;
                d3 = e4;
                c4 = f3;
                break;
              }
              h4 = h4.sibling;
            }
            if (!g3) {
              for (h4 = f3.child; h4; ) {
                if (h4 === c4) {
                  g3 = true;
                  c4 = f3;
                  d3 = e4;
                  break;
                }
                if (h4 === d3) {
                  g3 = true;
                  d3 = f3;
                  c4 = e4;
                  break;
                }
                h4 = h4.sibling;
              }
              if (!g3) throw Error(p4(189));
            }
          }
          if (c4.alternate !== d3) throw Error(p4(190));
        }
        if (3 !== c4.tag) throw Error(p4(188));
        return c4.stateNode.current === c4 ? a4 : b4;
      }
      function Zb(a4) {
        a4 = Yb(a4);
        return null !== a4 ? $b(a4) : null;
      }
      function $b(a4) {
        if (5 === a4.tag || 6 === a4.tag) return a4;
        for (a4 = a4.child; null !== a4; ) {
          var b4 = $b(a4);
          if (null !== b4) return b4;
          a4 = a4.sibling;
        }
        return null;
      }
      var ac = ca.unstable_scheduleCallback;
      var bc = ca.unstable_cancelCallback;
      var cc = ca.unstable_shouldYield;
      var dc = ca.unstable_requestPaint;
      var B = ca.unstable_now;
      var ec = ca.unstable_getCurrentPriorityLevel;
      var fc = ca.unstable_ImmediatePriority;
      var gc = ca.unstable_UserBlockingPriority;
      var hc = ca.unstable_NormalPriority;
      var ic = ca.unstable_LowPriority;
      var jc = ca.unstable_IdlePriority;
      var kc = null;
      var lc = null;
      function mc(a4) {
        if (lc && "function" === typeof lc.onCommitFiberRoot) try {
          lc.onCommitFiberRoot(kc, a4, void 0, 128 === (a4.current.flags & 128));
        } catch (b4) {
        }
      }
      var oc = Math.clz32 ? Math.clz32 : nc;
      var pc = Math.log;
      var qc = Math.LN2;
      function nc(a4) {
        a4 >>>= 0;
        return 0 === a4 ? 32 : 31 - (pc(a4) / qc | 0) | 0;
      }
      var rc = 64;
      var sc = 4194304;
      function tc(a4) {
        switch (a4 & -a4) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return a4 & 4194240;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return a4 & 130023424;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 1073741824;
          default:
            return a4;
        }
      }
      function uc(a4, b4) {
        var c4 = a4.pendingLanes;
        if (0 === c4) return 0;
        var d3 = 0, e4 = a4.suspendedLanes, f3 = a4.pingedLanes, g3 = c4 & 268435455;
        if (0 !== g3) {
          var h4 = g3 & ~e4;
          0 !== h4 ? d3 = tc(h4) : (f3 &= g3, 0 !== f3 && (d3 = tc(f3)));
        } else g3 = c4 & ~e4, 0 !== g3 ? d3 = tc(g3) : 0 !== f3 && (d3 = tc(f3));
        if (0 === d3) return 0;
        if (0 !== b4 && b4 !== d3 && 0 === (b4 & e4) && (e4 = d3 & -d3, f3 = b4 & -b4, e4 >= f3 || 16 === e4 && 0 !== (f3 & 4194240))) return b4;
        0 !== (d3 & 4) && (d3 |= c4 & 16);
        b4 = a4.entangledLanes;
        if (0 !== b4) for (a4 = a4.entanglements, b4 &= d3; 0 < b4; ) c4 = 31 - oc(b4), e4 = 1 << c4, d3 |= a4[c4], b4 &= ~e4;
        return d3;
      }
      function vc(a4, b4) {
        switch (a4) {
          case 1:
          case 2:
          case 4:
            return b4 + 250;
          case 8:
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return b4 + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return -1;
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function wc(a4, b4) {
        for (var c4 = a4.suspendedLanes, d3 = a4.pingedLanes, e4 = a4.expirationTimes, f3 = a4.pendingLanes; 0 < f3; ) {
          var g3 = 31 - oc(f3), h4 = 1 << g3, k2 = e4[g3];
          if (-1 === k2) {
            if (0 === (h4 & c4) || 0 !== (h4 & d3)) e4[g3] = vc(h4, b4);
          } else k2 <= b4 && (a4.expiredLanes |= h4);
          f3 &= ~h4;
        }
      }
      function xc(a4) {
        a4 = a4.pendingLanes & -1073741825;
        return 0 !== a4 ? a4 : a4 & 1073741824 ? 1073741824 : 0;
      }
      function yc() {
        var a4 = rc;
        rc <<= 1;
        0 === (rc & 4194240) && (rc = 64);
        return a4;
      }
      function zc(a4) {
        for (var b4 = [], c4 = 0; 31 > c4; c4++) b4.push(a4);
        return b4;
      }
      function Ac(a4, b4, c4) {
        a4.pendingLanes |= b4;
        536870912 !== b4 && (a4.suspendedLanes = 0, a4.pingedLanes = 0);
        a4 = a4.eventTimes;
        b4 = 31 - oc(b4);
        a4[b4] = c4;
      }
      function Bc(a4, b4) {
        var c4 = a4.pendingLanes & ~b4;
        a4.pendingLanes = b4;
        a4.suspendedLanes = 0;
        a4.pingedLanes = 0;
        a4.expiredLanes &= b4;
        a4.mutableReadLanes &= b4;
        a4.entangledLanes &= b4;
        b4 = a4.entanglements;
        var d3 = a4.eventTimes;
        for (a4 = a4.expirationTimes; 0 < c4; ) {
          var e4 = 31 - oc(c4), f3 = 1 << e4;
          b4[e4] = 0;
          d3[e4] = -1;
          a4[e4] = -1;
          c4 &= ~f3;
        }
      }
      function Cc(a4, b4) {
        var c4 = a4.entangledLanes |= b4;
        for (a4 = a4.entanglements; c4; ) {
          var d3 = 31 - oc(c4), e4 = 1 << d3;
          e4 & b4 | a4[d3] & b4 && (a4[d3] |= b4);
          c4 &= ~e4;
        }
      }
      var C2 = 0;
      function Dc(a4) {
        a4 &= -a4;
        return 1 < a4 ? 4 < a4 ? 0 !== (a4 & 268435455) ? 16 : 536870912 : 4 : 1;
      }
      var Ec;
      var Fc;
      var Gc;
      var Hc;
      var Ic;
      var Jc = false;
      var Kc = [];
      var Lc = null;
      var Mc = null;
      var Nc = null;
      var Oc = /* @__PURE__ */ new Map();
      var Pc = /* @__PURE__ */ new Map();
      var Qc = [];
      var Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
      function Sc(a4, b4) {
        switch (a4) {
          case "focusin":
          case "focusout":
            Lc = null;
            break;
          case "dragenter":
          case "dragleave":
            Mc = null;
            break;
          case "mouseover":
          case "mouseout":
            Nc = null;
            break;
          case "pointerover":
          case "pointerout":
            Oc.delete(b4.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            Pc.delete(b4.pointerId);
        }
      }
      function Tc(a4, b4, c4, d3, e4, f3) {
        if (null === a4 || a4.nativeEvent !== f3) return a4 = { blockedOn: b4, domEventName: c4, eventSystemFlags: d3, nativeEvent: f3, targetContainers: [e4] }, null !== b4 && (b4 = Cb(b4), null !== b4 && Fc(b4)), a4;
        a4.eventSystemFlags |= d3;
        b4 = a4.targetContainers;
        null !== e4 && -1 === b4.indexOf(e4) && b4.push(e4);
        return a4;
      }
      function Uc(a4, b4, c4, d3, e4) {
        switch (b4) {
          case "focusin":
            return Lc = Tc(Lc, a4, b4, c4, d3, e4), true;
          case "dragenter":
            return Mc = Tc(Mc, a4, b4, c4, d3, e4), true;
          case "mouseover":
            return Nc = Tc(Nc, a4, b4, c4, d3, e4), true;
          case "pointerover":
            var f3 = e4.pointerId;
            Oc.set(f3, Tc(Oc.get(f3) || null, a4, b4, c4, d3, e4));
            return true;
          case "gotpointercapture":
            return f3 = e4.pointerId, Pc.set(f3, Tc(Pc.get(f3) || null, a4, b4, c4, d3, e4)), true;
        }
        return false;
      }
      function Vc(a4) {
        var b4 = Wc(a4.target);
        if (null !== b4) {
          var c4 = Vb(b4);
          if (null !== c4) {
            if (b4 = c4.tag, 13 === b4) {
              if (b4 = Wb(c4), null !== b4) {
                a4.blockedOn = b4;
                Ic(a4.priority, function() {
                  Gc(c4);
                });
                return;
              }
            } else if (3 === b4 && c4.stateNode.current.memoizedState.isDehydrated) {
              a4.blockedOn = 3 === c4.tag ? c4.stateNode.containerInfo : null;
              return;
            }
          }
        }
        a4.blockedOn = null;
      }
      function Xc(a4) {
        if (null !== a4.blockedOn) return false;
        for (var b4 = a4.targetContainers; 0 < b4.length; ) {
          var c4 = Yc(a4.domEventName, a4.eventSystemFlags, b4[0], a4.nativeEvent);
          if (null === c4) {
            c4 = a4.nativeEvent;
            var d3 = new c4.constructor(c4.type, c4);
            wb = d3;
            c4.target.dispatchEvent(d3);
            wb = null;
          } else return b4 = Cb(c4), null !== b4 && Fc(b4), a4.blockedOn = c4, false;
          b4.shift();
        }
        return true;
      }
      function Zc(a4, b4, c4) {
        Xc(a4) && c4.delete(b4);
      }
      function $c() {
        Jc = false;
        null !== Lc && Xc(Lc) && (Lc = null);
        null !== Mc && Xc(Mc) && (Mc = null);
        null !== Nc && Xc(Nc) && (Nc = null);
        Oc.forEach(Zc);
        Pc.forEach(Zc);
      }
      function ad(a4, b4) {
        a4.blockedOn === b4 && (a4.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
      }
      function bd(a4) {
        function b4(b5) {
          return ad(b5, a4);
        }
        if (0 < Kc.length) {
          ad(Kc[0], a4);
          for (var c4 = 1; c4 < Kc.length; c4++) {
            var d3 = Kc[c4];
            d3.blockedOn === a4 && (d3.blockedOn = null);
          }
        }
        null !== Lc && ad(Lc, a4);
        null !== Mc && ad(Mc, a4);
        null !== Nc && ad(Nc, a4);
        Oc.forEach(b4);
        Pc.forEach(b4);
        for (c4 = 0; c4 < Qc.length; c4++) d3 = Qc[c4], d3.blockedOn === a4 && (d3.blockedOn = null);
        for (; 0 < Qc.length && (c4 = Qc[0], null === c4.blockedOn); ) Vc(c4), null === c4.blockedOn && Qc.shift();
      }
      var cd = ua.ReactCurrentBatchConfig;
      var dd = true;
      function ed(a4, b4, c4, d3) {
        var e4 = C2, f3 = cd.transition;
        cd.transition = null;
        try {
          C2 = 1, fd(a4, b4, c4, d3);
        } finally {
          C2 = e4, cd.transition = f3;
        }
      }
      function gd(a4, b4, c4, d3) {
        var e4 = C2, f3 = cd.transition;
        cd.transition = null;
        try {
          C2 = 4, fd(a4, b4, c4, d3);
        } finally {
          C2 = e4, cd.transition = f3;
        }
      }
      function fd(a4, b4, c4, d3) {
        if (dd) {
          var e4 = Yc(a4, b4, c4, d3);
          if (null === e4) hd(a4, b4, d3, id2, c4), Sc(a4, d3);
          else if (Uc(e4, a4, b4, c4, d3)) d3.stopPropagation();
          else if (Sc(a4, d3), b4 & 4 && -1 < Rc.indexOf(a4)) {
            for (; null !== e4; ) {
              var f3 = Cb(e4);
              null !== f3 && Ec(f3);
              f3 = Yc(a4, b4, c4, d3);
              null === f3 && hd(a4, b4, d3, id2, c4);
              if (f3 === e4) break;
              e4 = f3;
            }
            null !== e4 && d3.stopPropagation();
          } else hd(a4, b4, d3, null, c4);
        }
      }
      var id2 = null;
      function Yc(a4, b4, c4, d3) {
        id2 = null;
        a4 = xb(d3);
        a4 = Wc(a4);
        if (null !== a4) if (b4 = Vb(a4), null === b4) a4 = null;
        else if (c4 = b4.tag, 13 === c4) {
          a4 = Wb(b4);
          if (null !== a4) return a4;
          a4 = null;
        } else if (3 === c4) {
          if (b4.stateNode.current.memoizedState.isDehydrated) return 3 === b4.tag ? b4.stateNode.containerInfo : null;
          a4 = null;
        } else b4 !== a4 && (a4 = null);
        id2 = a4;
        return null;
      }
      function jd(a4) {
        switch (a4) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 1;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 4;
          case "message":
            switch (ec()) {
              case fc:
                return 1;
              case gc:
                return 4;
              case hc:
              case ic:
                return 16;
              case jc:
                return 536870912;
              default:
                return 16;
            }
          default:
            return 16;
        }
      }
      var kd = null;
      var ld = null;
      var md = null;
      function nd() {
        if (md) return md;
        var a4, b4 = ld, c4 = b4.length, d3, e4 = "value" in kd ? kd.value : kd.textContent, f3 = e4.length;
        for (a4 = 0; a4 < c4 && b4[a4] === e4[a4]; a4++) ;
        var g3 = c4 - a4;
        for (d3 = 1; d3 <= g3 && b4[c4 - d3] === e4[f3 - d3]; d3++) ;
        return md = e4.slice(a4, 1 < d3 ? 1 - d3 : void 0);
      }
      function od(a4) {
        var b4 = a4.keyCode;
        "charCode" in a4 ? (a4 = a4.charCode, 0 === a4 && 13 === b4 && (a4 = 13)) : a4 = b4;
        10 === a4 && (a4 = 13);
        return 32 <= a4 || 13 === a4 ? a4 : 0;
      }
      function pd() {
        return true;
      }
      function qd() {
        return false;
      }
      function rd(a4) {
        function b4(b5, d3, e4, f3, g3) {
          this._reactName = b5;
          this._targetInst = e4;
          this.type = d3;
          this.nativeEvent = f3;
          this.target = g3;
          this.currentTarget = null;
          for (var c4 in a4) a4.hasOwnProperty(c4) && (b5 = a4[c4], this[c4] = b5 ? b5(f3) : f3[c4]);
          this.isDefaultPrevented = (null != f3.defaultPrevented ? f3.defaultPrevented : false === f3.returnValue) ? pd : qd;
          this.isPropagationStopped = qd;
          return this;
        }
        A(b4.prototype, { preventDefault: function() {
          this.defaultPrevented = true;
          var a5 = this.nativeEvent;
          a5 && (a5.preventDefault ? a5.preventDefault() : "unknown" !== typeof a5.returnValue && (a5.returnValue = false), this.isDefaultPrevented = pd);
        }, stopPropagation: function() {
          var a5 = this.nativeEvent;
          a5 && (a5.stopPropagation ? a5.stopPropagation() : "unknown" !== typeof a5.cancelBubble && (a5.cancelBubble = true), this.isPropagationStopped = pd);
        }, persist: function() {
        }, isPersistent: pd });
        return b4;
      }
      var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a4) {
        return a4.timeStamp || Date.now();
      }, defaultPrevented: 0, isTrusted: 0 };
      var td = rd(sd);
      var ud = A({}, sd, { view: 0, detail: 0 });
      var vd = rd(ud);
      var wd;
      var xd;
      var yd;
      var Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a4) {
        return void 0 === a4.relatedTarget ? a4.fromElement === a4.srcElement ? a4.toElement : a4.fromElement : a4.relatedTarget;
      }, movementX: function(a4) {
        if ("movementX" in a4) return a4.movementX;
        a4 !== yd && (yd && "mousemove" === a4.type ? (wd = a4.screenX - yd.screenX, xd = a4.screenY - yd.screenY) : xd = wd = 0, yd = a4);
        return wd;
      }, movementY: function(a4) {
        return "movementY" in a4 ? a4.movementY : xd;
      } });
      var Bd = rd(Ad);
      var Cd = A({}, Ad, { dataTransfer: 0 });
      var Dd = rd(Cd);
      var Ed = A({}, ud, { relatedTarget: 0 });
      var Fd = rd(Ed);
      var Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Hd = rd(Gd);
      var Id = A({}, sd, { clipboardData: function(a4) {
        return "clipboardData" in a4 ? a4.clipboardData : window.clipboardData;
      } });
      var Jd = rd(Id);
      var Kd = A({}, sd, { data: 0 });
      var Ld = rd(Kd);
      var Md = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var Nd = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      var Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
      function Pd(a4) {
        var b4 = this.nativeEvent;
        return b4.getModifierState ? b4.getModifierState(a4) : (a4 = Od[a4]) ? !!b4[a4] : false;
      }
      function zd() {
        return Pd;
      }
      var Qd = A({}, ud, { key: function(a4) {
        if (a4.key) {
          var b4 = Md[a4.key] || a4.key;
          if ("Unidentified" !== b4) return b4;
        }
        return "keypress" === a4.type ? (a4 = od(a4), 13 === a4 ? "Enter" : String.fromCharCode(a4)) : "keydown" === a4.type || "keyup" === a4.type ? Nd[a4.keyCode] || "Unidentified" : "";
      }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a4) {
        return "keypress" === a4.type ? od(a4) : 0;
      }, keyCode: function(a4) {
        return "keydown" === a4.type || "keyup" === a4.type ? a4.keyCode : 0;
      }, which: function(a4) {
        return "keypress" === a4.type ? od(a4) : "keydown" === a4.type || "keyup" === a4.type ? a4.keyCode : 0;
      } });
      var Rd = rd(Qd);
      var Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 });
      var Td = rd(Sd);
      var Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd });
      var Vd = rd(Ud);
      var Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Xd = rd(Wd);
      var Yd = A({}, Ad, {
        deltaX: function(a4) {
          return "deltaX" in a4 ? a4.deltaX : "wheelDeltaX" in a4 ? -a4.wheelDeltaX : 0;
        },
        deltaY: function(a4) {
          return "deltaY" in a4 ? a4.deltaY : "wheelDeltaY" in a4 ? -a4.wheelDeltaY : "wheelDelta" in a4 ? -a4.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var Zd = rd(Yd);
      var $d = [9, 13, 27, 32];
      var ae = ia && "CompositionEvent" in window;
      var be = null;
      ia && "documentMode" in document && (be = document.documentMode);
      var ce = ia && "TextEvent" in window && !be;
      var de = ia && (!ae || be && 8 < be && 11 >= be);
      var ee2 = String.fromCharCode(32);
      var fe = false;
      function ge(a4, b4) {
        switch (a4) {
          case "keyup":
            return -1 !== $d.indexOf(b4.keyCode);
          case "keydown":
            return 229 !== b4.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function he(a4) {
        a4 = a4.detail;
        return "object" === typeof a4 && "data" in a4 ? a4.data : null;
      }
      var ie3 = false;
      function je(a4, b4) {
        switch (a4) {
          case "compositionend":
            return he(b4);
          case "keypress":
            if (32 !== b4.which) return null;
            fe = true;
            return ee2;
          case "textInput":
            return a4 = b4.data, a4 === ee2 && fe ? null : a4;
          default:
            return null;
        }
      }
      function ke2(a4, b4) {
        if (ie3) return "compositionend" === a4 || !ae && ge(a4, b4) ? (a4 = nd(), md = ld = kd = null, ie3 = false, a4) : null;
        switch (a4) {
          case "paste":
            return null;
          case "keypress":
            if (!(b4.ctrlKey || b4.altKey || b4.metaKey) || b4.ctrlKey && b4.altKey) {
              if (b4.char && 1 < b4.char.length) return b4.char;
              if (b4.which) return String.fromCharCode(b4.which);
            }
            return null;
          case "compositionend":
            return de && "ko" !== b4.locale ? null : b4.data;
          default:
            return null;
        }
      }
      var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
      function me(a4) {
        var b4 = a4 && a4.nodeName && a4.nodeName.toLowerCase();
        return "input" === b4 ? !!le[a4.type] : "textarea" === b4 ? true : false;
      }
      function ne(a4, b4, c4, d3) {
        Eb(d3);
        b4 = oe(b4, "onChange");
        0 < b4.length && (c4 = new td("onChange", "change", null, c4, d3), a4.push({ event: c4, listeners: b4 }));
      }
      var pe = null;
      var qe2 = null;
      function re2(a4) {
        se(a4, 0);
      }
      function te(a4) {
        var b4 = ue(a4);
        if (Wa(b4)) return a4;
      }
      function ve(a4, b4) {
        if ("change" === a4) return b4;
      }
      var we = false;
      if (ia) {
        if (ia) {
          ye = "oninput" in document;
          if (!ye) {
            ze = document.createElement("div");
            ze.setAttribute("oninput", "return;");
            ye = "function" === typeof ze.oninput;
          }
          xe2 = ye;
        } else xe2 = false;
        we = xe2 && (!document.documentMode || 9 < document.documentMode);
      }
      var xe2;
      var ye;
      var ze;
      function Ae() {
        pe && (pe.detachEvent("onpropertychange", Be), qe2 = pe = null);
      }
      function Be(a4) {
        if ("value" === a4.propertyName && te(qe2)) {
          var b4 = [];
          ne(b4, qe2, a4, xb(a4));
          Jb(re2, b4);
        }
      }
      function Ce2(a4, b4, c4) {
        "focusin" === a4 ? (Ae(), pe = b4, qe2 = c4, pe.attachEvent("onpropertychange", Be)) : "focusout" === a4 && Ae();
      }
      function De(a4) {
        if ("selectionchange" === a4 || "keyup" === a4 || "keydown" === a4) return te(qe2);
      }
      function Ee(a4, b4) {
        if ("click" === a4) return te(b4);
      }
      function Fe(a4, b4) {
        if ("input" === a4 || "change" === a4) return te(b4);
      }
      function Ge(a4, b4) {
        return a4 === b4 && (0 !== a4 || 1 / a4 === 1 / b4) || a4 !== a4 && b4 !== b4;
      }
      var He = "function" === typeof Object.is ? Object.is : Ge;
      function Ie2(a4, b4) {
        if (He(a4, b4)) return true;
        if ("object" !== typeof a4 || null === a4 || "object" !== typeof b4 || null === b4) return false;
        var c4 = Object.keys(a4), d3 = Object.keys(b4);
        if (c4.length !== d3.length) return false;
        for (d3 = 0; d3 < c4.length; d3++) {
          var e4 = c4[d3];
          if (!ja.call(b4, e4) || !He(a4[e4], b4[e4])) return false;
        }
        return true;
      }
      function Je(a4) {
        for (; a4 && a4.firstChild; ) a4 = a4.firstChild;
        return a4;
      }
      function Ke(a4, b4) {
        var c4 = Je(a4);
        a4 = 0;
        for (var d3; c4; ) {
          if (3 === c4.nodeType) {
            d3 = a4 + c4.textContent.length;
            if (a4 <= b4 && d3 >= b4) return { node: c4, offset: b4 - a4 };
            a4 = d3;
          }
          a: {
            for (; c4; ) {
              if (c4.nextSibling) {
                c4 = c4.nextSibling;
                break a;
              }
              c4 = c4.parentNode;
            }
            c4 = void 0;
          }
          c4 = Je(c4);
        }
      }
      function Le(a4, b4) {
        return a4 && b4 ? a4 === b4 ? true : a4 && 3 === a4.nodeType ? false : b4 && 3 === b4.nodeType ? Le(a4, b4.parentNode) : "contains" in a4 ? a4.contains(b4) : a4.compareDocumentPosition ? !!(a4.compareDocumentPosition(b4) & 16) : false : false;
      }
      function Me() {
        for (var a4 = window, b4 = Xa(); b4 instanceof a4.HTMLIFrameElement; ) {
          try {
            var c4 = "string" === typeof b4.contentWindow.location.href;
          } catch (d3) {
            c4 = false;
          }
          if (c4) a4 = b4.contentWindow;
          else break;
          b4 = Xa(a4.document);
        }
        return b4;
      }
      function Ne(a4) {
        var b4 = a4 && a4.nodeName && a4.nodeName.toLowerCase();
        return b4 && ("input" === b4 && ("text" === a4.type || "search" === a4.type || "tel" === a4.type || "url" === a4.type || "password" === a4.type) || "textarea" === b4 || "true" === a4.contentEditable);
      }
      function Oe2(a4) {
        var b4 = Me(), c4 = a4.focusedElem, d3 = a4.selectionRange;
        if (b4 !== c4 && c4 && c4.ownerDocument && Le(c4.ownerDocument.documentElement, c4)) {
          if (null !== d3 && Ne(c4)) {
            if (b4 = d3.start, a4 = d3.end, void 0 === a4 && (a4 = b4), "selectionStart" in c4) c4.selectionStart = b4, c4.selectionEnd = Math.min(a4, c4.value.length);
            else if (a4 = (b4 = c4.ownerDocument || document) && b4.defaultView || window, a4.getSelection) {
              a4 = a4.getSelection();
              var e4 = c4.textContent.length, f3 = Math.min(d3.start, e4);
              d3 = void 0 === d3.end ? f3 : Math.min(d3.end, e4);
              !a4.extend && f3 > d3 && (e4 = d3, d3 = f3, f3 = e4);
              e4 = Ke(c4, f3);
              var g3 = Ke(
                c4,
                d3
              );
              e4 && g3 && (1 !== a4.rangeCount || a4.anchorNode !== e4.node || a4.anchorOffset !== e4.offset || a4.focusNode !== g3.node || a4.focusOffset !== g3.offset) && (b4 = b4.createRange(), b4.setStart(e4.node, e4.offset), a4.removeAllRanges(), f3 > d3 ? (a4.addRange(b4), a4.extend(g3.node, g3.offset)) : (b4.setEnd(g3.node, g3.offset), a4.addRange(b4)));
            }
          }
          b4 = [];
          for (a4 = c4; a4 = a4.parentNode; ) 1 === a4.nodeType && b4.push({ element: a4, left: a4.scrollLeft, top: a4.scrollTop });
          "function" === typeof c4.focus && c4.focus();
          for (c4 = 0; c4 < b4.length; c4++) a4 = b4[c4], a4.element.scrollLeft = a4.left, a4.element.scrollTop = a4.top;
        }
      }
      var Pe = ia && "documentMode" in document && 11 >= document.documentMode;
      var Qe = null;
      var Re = null;
      var Se = null;
      var Te = false;
      function Ue(a4, b4, c4) {
        var d3 = c4.window === c4 ? c4.document : 9 === c4.nodeType ? c4 : c4.ownerDocument;
        Te || null == Qe || Qe !== Xa(d3) || (d3 = Qe, "selectionStart" in d3 && Ne(d3) ? d3 = { start: d3.selectionStart, end: d3.selectionEnd } : (d3 = (d3.ownerDocument && d3.ownerDocument.defaultView || window).getSelection(), d3 = { anchorNode: d3.anchorNode, anchorOffset: d3.anchorOffset, focusNode: d3.focusNode, focusOffset: d3.focusOffset }), Se && Ie2(Se, d3) || (Se = d3, d3 = oe(Re, "onSelect"), 0 < d3.length && (b4 = new td("onSelect", "select", null, b4, c4), a4.push({ event: b4, listeners: d3 }), b4.target = Qe)));
      }
      function Ve(a4, b4) {
        var c4 = {};
        c4[a4.toLowerCase()] = b4.toLowerCase();
        c4["Webkit" + a4] = "webkit" + b4;
        c4["Moz" + a4] = "moz" + b4;
        return c4;
      }
      var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") };
      var Xe = {};
      var Ye = {};
      ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
      function Ze(a4) {
        if (Xe[a4]) return Xe[a4];
        if (!We[a4]) return a4;
        var b4 = We[a4], c4;
        for (c4 in b4) if (b4.hasOwnProperty(c4) && c4 in Ye) return Xe[a4] = b4[c4];
        return a4;
      }
      var $e = Ze("animationend");
      var af = Ze("animationiteration");
      var bf = Ze("animationstart");
      var cf = Ze("transitionend");
      var df = /* @__PURE__ */ new Map();
      var ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
      function ff(a4, b4) {
        df.set(a4, b4);
        fa(b4, [a4]);
      }
      for (gf = 0; gf < ef.length; gf++) {
        hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
        ff(jf, "on" + kf);
      }
      var hf;
      var jf;
      var kf;
      var gf;
      ff($e, "onAnimationEnd");
      ff(af, "onAnimationIteration");
      ff(bf, "onAnimationStart");
      ff("dblclick", "onDoubleClick");
      ff("focusin", "onFocus");
      ff("focusout", "onBlur");
      ff(cf, "onTransitionEnd");
      ha("onMouseEnter", ["mouseout", "mouseover"]);
      ha("onMouseLeave", ["mouseout", "mouseover"]);
      ha("onPointerEnter", ["pointerout", "pointerover"]);
      ha("onPointerLeave", ["pointerout", "pointerover"]);
      fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
      fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
      fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
      fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
      var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
      var mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
      function nf(a4, b4, c4) {
        var d3 = a4.type || "unknown-event";
        a4.currentTarget = c4;
        Ub(d3, b4, void 0, a4);
        a4.currentTarget = null;
      }
      function se(a4, b4) {
        b4 = 0 !== (b4 & 4);
        for (var c4 = 0; c4 < a4.length; c4++) {
          var d3 = a4[c4], e4 = d3.event;
          d3 = d3.listeners;
          a: {
            var f3 = void 0;
            if (b4) for (var g3 = d3.length - 1; 0 <= g3; g3--) {
              var h4 = d3[g3], k2 = h4.instance, l4 = h4.currentTarget;
              h4 = h4.listener;
              if (k2 !== f3 && e4.isPropagationStopped()) break a;
              nf(e4, h4, l4);
              f3 = k2;
            }
            else for (g3 = 0; g3 < d3.length; g3++) {
              h4 = d3[g3];
              k2 = h4.instance;
              l4 = h4.currentTarget;
              h4 = h4.listener;
              if (k2 !== f3 && e4.isPropagationStopped()) break a;
              nf(e4, h4, l4);
              f3 = k2;
            }
          }
        }
        if (Qb) throw a4 = Rb, Qb = false, Rb = null, a4;
      }
      function D(a4, b4) {
        var c4 = b4[of];
        void 0 === c4 && (c4 = b4[of] = /* @__PURE__ */ new Set());
        var d3 = a4 + "__bubble";
        c4.has(d3) || (pf(b4, a4, 2, false), c4.add(d3));
      }
      function qf(a4, b4, c4) {
        var d3 = 0;
        b4 && (d3 |= 4);
        pf(c4, a4, d3, b4);
      }
      var rf = "_reactListening" + Math.random().toString(36).slice(2);
      function sf(a4) {
        if (!a4[rf]) {
          a4[rf] = true;
          da.forEach(function(b5) {
            "selectionchange" !== b5 && (mf.has(b5) || qf(b5, false, a4), qf(b5, true, a4));
          });
          var b4 = 9 === a4.nodeType ? a4 : a4.ownerDocument;
          null === b4 || b4[rf] || (b4[rf] = true, qf("selectionchange", false, b4));
        }
      }
      function pf(a4, b4, c4, d3) {
        switch (jd(b4)) {
          case 1:
            var e4 = ed;
            break;
          case 4:
            e4 = gd;
            break;
          default:
            e4 = fd;
        }
        c4 = e4.bind(null, b4, c4, a4);
        e4 = void 0;
        !Lb || "touchstart" !== b4 && "touchmove" !== b4 && "wheel" !== b4 || (e4 = true);
        d3 ? void 0 !== e4 ? a4.addEventListener(b4, c4, { capture: true, passive: e4 }) : a4.addEventListener(b4, c4, true) : void 0 !== e4 ? a4.addEventListener(b4, c4, { passive: e4 }) : a4.addEventListener(b4, c4, false);
      }
      function hd(a4, b4, c4, d3, e4) {
        var f3 = d3;
        if (0 === (b4 & 1) && 0 === (b4 & 2) && null !== d3) a: for (; ; ) {
          if (null === d3) return;
          var g3 = d3.tag;
          if (3 === g3 || 4 === g3) {
            var h4 = d3.stateNode.containerInfo;
            if (h4 === e4 || 8 === h4.nodeType && h4.parentNode === e4) break;
            if (4 === g3) for (g3 = d3.return; null !== g3; ) {
              var k2 = g3.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g3.stateNode.containerInfo, k2 === e4 || 8 === k2.nodeType && k2.parentNode === e4) return;
              }
              g3 = g3.return;
            }
            for (; null !== h4; ) {
              g3 = Wc(h4);
              if (null === g3) return;
              k2 = g3.tag;
              if (5 === k2 || 6 === k2) {
                d3 = f3 = g3;
                continue a;
              }
              h4 = h4.parentNode;
            }
          }
          d3 = d3.return;
        }
        Jb(function() {
          var d4 = f3, e5 = xb(c4), g4 = [];
          a: {
            var h5 = df.get(a4);
            if (void 0 !== h5) {
              var k3 = td, n4 = a4;
              switch (a4) {
                case "keypress":
                  if (0 === od(c4)) break a;
                case "keydown":
                case "keyup":
                  k3 = Rd;
                  break;
                case "focusin":
                  n4 = "focus";
                  k3 = Fd;
                  break;
                case "focusout":
                  n4 = "blur";
                  k3 = Fd;
                  break;
                case "beforeblur":
                case "afterblur":
                  k3 = Fd;
                  break;
                case "click":
                  if (2 === c4.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  k3 = Bd;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  k3 = Dd;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  k3 = Vd;
                  break;
                case $e:
                case af:
                case bf:
                  k3 = Hd;
                  break;
                case cf:
                  k3 = Xd;
                  break;
                case "scroll":
                  k3 = vd;
                  break;
                case "wheel":
                  k3 = Zd;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  k3 = Jd;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  k3 = Td;
              }
              var t5 = 0 !== (b4 & 4), J2 = !t5 && "scroll" === a4, x2 = t5 ? null !== h5 ? h5 + "Capture" : null : h5;
              t5 = [];
              for (var w2 = d4, u4; null !== w2; ) {
                u4 = w2;
                var F2 = u4.stateNode;
                5 === u4.tag && null !== F2 && (u4 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t5.push(tf(w2, F2, u4))));
                if (J2) break;
                w2 = w2.return;
              }
              0 < t5.length && (h5 = new k3(h5, n4, null, c4, e5), g4.push({ event: h5, listeners: t5 }));
            }
          }
          if (0 === (b4 & 7)) {
            a: {
              h5 = "mouseover" === a4 || "pointerover" === a4;
              k3 = "mouseout" === a4 || "pointerout" === a4;
              if (h5 && c4 !== wb && (n4 = c4.relatedTarget || c4.fromElement) && (Wc(n4) || n4[uf])) break a;
              if (k3 || h5) {
                h5 = e5.window === e5 ? e5 : (h5 = e5.ownerDocument) ? h5.defaultView || h5.parentWindow : window;
                if (k3) {
                  if (n4 = c4.relatedTarget || c4.toElement, k3 = d4, n4 = n4 ? Wc(n4) : null, null !== n4 && (J2 = Vb(n4), n4 !== J2 || 5 !== n4.tag && 6 !== n4.tag)) n4 = null;
                } else k3 = null, n4 = d4;
                if (k3 !== n4) {
                  t5 = Bd;
                  F2 = "onMouseLeave";
                  x2 = "onMouseEnter";
                  w2 = "mouse";
                  if ("pointerout" === a4 || "pointerover" === a4) t5 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
                  J2 = null == k3 ? h5 : ue(k3);
                  u4 = null == n4 ? h5 : ue(n4);
                  h5 = new t5(F2, w2 + "leave", k3, c4, e5);
                  h5.target = J2;
                  h5.relatedTarget = u4;
                  F2 = null;
                  Wc(e5) === d4 && (t5 = new t5(x2, w2 + "enter", n4, c4, e5), t5.target = u4, t5.relatedTarget = J2, F2 = t5);
                  J2 = F2;
                  if (k3 && n4) b: {
                    t5 = k3;
                    x2 = n4;
                    w2 = 0;
                    for (u4 = t5; u4; u4 = vf(u4)) w2++;
                    u4 = 0;
                    for (F2 = x2; F2; F2 = vf(F2)) u4++;
                    for (; 0 < w2 - u4; ) t5 = vf(t5), w2--;
                    for (; 0 < u4 - w2; ) x2 = vf(x2), u4--;
                    for (; w2--; ) {
                      if (t5 === x2 || null !== x2 && t5 === x2.alternate) break b;
                      t5 = vf(t5);
                      x2 = vf(x2);
                    }
                    t5 = null;
                  }
                  else t5 = null;
                  null !== k3 && wf(g4, h5, k3, t5, false);
                  null !== n4 && null !== J2 && wf(g4, J2, n4, t5, true);
                }
              }
            }
            a: {
              h5 = d4 ? ue(d4) : window;
              k3 = h5.nodeName && h5.nodeName.toLowerCase();
              if ("select" === k3 || "input" === k3 && "file" === h5.type) var na = ve;
              else if (me(h5)) if (we) na = Fe;
              else {
                na = De;
                var xa = Ce2;
              }
              else (k3 = h5.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h5.type || "radio" === h5.type) && (na = Ee);
              if (na && (na = na(a4, d4))) {
                ne(g4, na, c4, e5);
                break a;
              }
              xa && xa(a4, h5, d4);
              "focusout" === a4 && (xa = h5._wrapperState) && xa.controlled && "number" === h5.type && cb(h5, "number", h5.value);
            }
            xa = d4 ? ue(d4) : window;
            switch (a4) {
              case "focusin":
                if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d4, Se = null;
                break;
              case "focusout":
                Se = Re = Qe = null;
                break;
              case "mousedown":
                Te = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                Te = false;
                Ue(g4, c4, e5);
                break;
              case "selectionchange":
                if (Pe) break;
              case "keydown":
              case "keyup":
                Ue(g4, c4, e5);
            }
            var $a;
            if (ae) b: {
              switch (a4) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
            else ie3 ? ge(a4, c4) && (ba = "onCompositionEnd") : "keydown" === a4 && 229 === c4.keyCode && (ba = "onCompositionStart");
            ba && (de && "ko" !== c4.locale && (ie3 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie3 && ($a = nd()) : (kd = e5, ld = "value" in kd ? kd.value : kd.textContent, ie3 = true)), xa = oe(d4, ba), 0 < xa.length && (ba = new Ld(ba, a4, null, c4, e5), g4.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c4), null !== $a && (ba.data = $a))));
            if ($a = ce ? je(a4, c4) : ke2(a4, c4)) d4 = oe(d4, "onBeforeInput"), 0 < d4.length && (e5 = new Ld("onBeforeInput", "beforeinput", null, c4, e5), g4.push({ event: e5, listeners: d4 }), e5.data = $a);
          }
          se(g4, b4);
        });
      }
      function tf(a4, b4, c4) {
        return { instance: a4, listener: b4, currentTarget: c4 };
      }
      function oe(a4, b4) {
        for (var c4 = b4 + "Capture", d3 = []; null !== a4; ) {
          var e4 = a4, f3 = e4.stateNode;
          5 === e4.tag && null !== f3 && (e4 = f3, f3 = Kb(a4, c4), null != f3 && d3.unshift(tf(a4, f3, e4)), f3 = Kb(a4, b4), null != f3 && d3.push(tf(a4, f3, e4)));
          a4 = a4.return;
        }
        return d3;
      }
      function vf(a4) {
        if (null === a4) return null;
        do
          a4 = a4.return;
        while (a4 && 5 !== a4.tag);
        return a4 ? a4 : null;
      }
      function wf(a4, b4, c4, d3, e4) {
        for (var f3 = b4._reactName, g3 = []; null !== c4 && c4 !== d3; ) {
          var h4 = c4, k2 = h4.alternate, l4 = h4.stateNode;
          if (null !== k2 && k2 === d3) break;
          5 === h4.tag && null !== l4 && (h4 = l4, e4 ? (k2 = Kb(c4, f3), null != k2 && g3.unshift(tf(c4, k2, h4))) : e4 || (k2 = Kb(c4, f3), null != k2 && g3.push(tf(c4, k2, h4))));
          c4 = c4.return;
        }
        0 !== g3.length && a4.push({ event: b4, listeners: g3 });
      }
      var xf = /\r\n?/g;
      var yf = /\u0000|\uFFFD/g;
      function zf(a4) {
        return ("string" === typeof a4 ? a4 : "" + a4).replace(xf, "\n").replace(yf, "");
      }
      function Af(a4, b4, c4) {
        b4 = zf(b4);
        if (zf(a4) !== b4 && c4) throw Error(p4(425));
      }
      function Bf() {
      }
      var Cf = null;
      var Df = null;
      function Ef(a4, b4) {
        return "textarea" === a4 || "noscript" === a4 || "string" === typeof b4.children || "number" === typeof b4.children || "object" === typeof b4.dangerouslySetInnerHTML && null !== b4.dangerouslySetInnerHTML && null != b4.dangerouslySetInnerHTML.__html;
      }
      var Ff = "function" === typeof setTimeout ? setTimeout : void 0;
      var Gf = "function" === typeof clearTimeout ? clearTimeout : void 0;
      var Hf = "function" === typeof Promise ? Promise : void 0;
      var Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a4) {
        return Hf.resolve(null).then(a4).catch(If);
      } : Ff;
      function If(a4) {
        setTimeout(function() {
          throw a4;
        });
      }
      function Kf(a4, b4) {
        var c4 = b4, d3 = 0;
        do {
          var e4 = c4.nextSibling;
          a4.removeChild(c4);
          if (e4 && 8 === e4.nodeType) if (c4 = e4.data, "/$" === c4) {
            if (0 === d3) {
              a4.removeChild(e4);
              bd(b4);
              return;
            }
            d3--;
          } else "$" !== c4 && "$?" !== c4 && "$!" !== c4 || d3++;
          c4 = e4;
        } while (c4);
        bd(b4);
      }
      function Lf(a4) {
        for (; null != a4; a4 = a4.nextSibling) {
          var b4 = a4.nodeType;
          if (1 === b4 || 3 === b4) break;
          if (8 === b4) {
            b4 = a4.data;
            if ("$" === b4 || "$!" === b4 || "$?" === b4) break;
            if ("/$" === b4) return null;
          }
        }
        return a4;
      }
      function Mf(a4) {
        a4 = a4.previousSibling;
        for (var b4 = 0; a4; ) {
          if (8 === a4.nodeType) {
            var c4 = a4.data;
            if ("$" === c4 || "$!" === c4 || "$?" === c4) {
              if (0 === b4) return a4;
              b4--;
            } else "/$" === c4 && b4++;
          }
          a4 = a4.previousSibling;
        }
        return null;
      }
      var Nf = Math.random().toString(36).slice(2);
      var Of = "__reactFiber$" + Nf;
      var Pf = "__reactProps$" + Nf;
      var uf = "__reactContainer$" + Nf;
      var of = "__reactEvents$" + Nf;
      var Qf = "__reactListeners$" + Nf;
      var Rf = "__reactHandles$" + Nf;
      function Wc(a4) {
        var b4 = a4[Of];
        if (b4) return b4;
        for (var c4 = a4.parentNode; c4; ) {
          if (b4 = c4[uf] || c4[Of]) {
            c4 = b4.alternate;
            if (null !== b4.child || null !== c4 && null !== c4.child) for (a4 = Mf(a4); null !== a4; ) {
              if (c4 = a4[Of]) return c4;
              a4 = Mf(a4);
            }
            return b4;
          }
          a4 = c4;
          c4 = a4.parentNode;
        }
        return null;
      }
      function Cb(a4) {
        a4 = a4[Of] || a4[uf];
        return !a4 || 5 !== a4.tag && 6 !== a4.tag && 13 !== a4.tag && 3 !== a4.tag ? null : a4;
      }
      function ue(a4) {
        if (5 === a4.tag || 6 === a4.tag) return a4.stateNode;
        throw Error(p4(33));
      }
      function Db(a4) {
        return a4[Pf] || null;
      }
      var Sf = [];
      var Tf = -1;
      function Uf(a4) {
        return { current: a4 };
      }
      function E(a4) {
        0 > Tf || (a4.current = Sf[Tf], Sf[Tf] = null, Tf--);
      }
      function G(a4, b4) {
        Tf++;
        Sf[Tf] = a4.current;
        a4.current = b4;
      }
      var Vf = {};
      var H2 = Uf(Vf);
      var Wf = Uf(false);
      var Xf = Vf;
      function Yf(a4, b4) {
        var c4 = a4.type.contextTypes;
        if (!c4) return Vf;
        var d3 = a4.stateNode;
        if (d3 && d3.__reactInternalMemoizedUnmaskedChildContext === b4) return d3.__reactInternalMemoizedMaskedChildContext;
        var e4 = {}, f3;
        for (f3 in c4) e4[f3] = b4[f3];
        d3 && (a4 = a4.stateNode, a4.__reactInternalMemoizedUnmaskedChildContext = b4, a4.__reactInternalMemoizedMaskedChildContext = e4);
        return e4;
      }
      function Zf(a4) {
        a4 = a4.childContextTypes;
        return null !== a4 && void 0 !== a4;
      }
      function $f() {
        E(Wf);
        E(H2);
      }
      function ag(a4, b4, c4) {
        if (H2.current !== Vf) throw Error(p4(168));
        G(H2, b4);
        G(Wf, c4);
      }
      function bg(a4, b4, c4) {
        var d3 = a4.stateNode;
        b4 = b4.childContextTypes;
        if ("function" !== typeof d3.getChildContext) return c4;
        d3 = d3.getChildContext();
        for (var e4 in d3) if (!(e4 in b4)) throw Error(p4(108, Ra(a4) || "Unknown", e4));
        return A({}, c4, d3);
      }
      function cg(a4) {
        a4 = (a4 = a4.stateNode) && a4.__reactInternalMemoizedMergedChildContext || Vf;
        Xf = H2.current;
        G(H2, a4);
        G(Wf, Wf.current);
        return true;
      }
      function dg(a4, b4, c4) {
        var d3 = a4.stateNode;
        if (!d3) throw Error(p4(169));
        c4 ? (a4 = bg(a4, b4, Xf), d3.__reactInternalMemoizedMergedChildContext = a4, E(Wf), E(H2), G(H2, a4)) : E(Wf);
        G(Wf, c4);
      }
      var eg = null;
      var fg = false;
      var gg = false;
      function hg(a4) {
        null === eg ? eg = [a4] : eg.push(a4);
      }
      function ig(a4) {
        fg = true;
        hg(a4);
      }
      function jg() {
        if (!gg && null !== eg) {
          gg = true;
          var a4 = 0, b4 = C2;
          try {
            var c4 = eg;
            for (C2 = 1; a4 < c4.length; a4++) {
              var d3 = c4[a4];
              do
                d3 = d3(true);
              while (null !== d3);
            }
            eg = null;
            fg = false;
          } catch (e4) {
            throw null !== eg && (eg = eg.slice(a4 + 1)), ac(fc, jg), e4;
          } finally {
            C2 = b4, gg = false;
          }
        }
        return null;
      }
      var kg = [];
      var lg = 0;
      var mg = null;
      var ng = 0;
      var og = [];
      var pg = 0;
      var qg = null;
      var rg = 1;
      var sg = "";
      function tg(a4, b4) {
        kg[lg++] = ng;
        kg[lg++] = mg;
        mg = a4;
        ng = b4;
      }
      function ug(a4, b4, c4) {
        og[pg++] = rg;
        og[pg++] = sg;
        og[pg++] = qg;
        qg = a4;
        var d3 = rg;
        a4 = sg;
        var e4 = 32 - oc(d3) - 1;
        d3 &= ~(1 << e4);
        c4 += 1;
        var f3 = 32 - oc(b4) + e4;
        if (30 < f3) {
          var g3 = e4 - e4 % 5;
          f3 = (d3 & (1 << g3) - 1).toString(32);
          d3 >>= g3;
          e4 -= g3;
          rg = 1 << 32 - oc(b4) + e4 | c4 << e4 | d3;
          sg = f3 + a4;
        } else rg = 1 << f3 | c4 << e4 | d3, sg = a4;
      }
      function vg(a4) {
        null !== a4.return && (tg(a4, 1), ug(a4, 1, 0));
      }
      function wg(a4) {
        for (; a4 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
        for (; a4 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
      }
      var xg = null;
      var yg = null;
      var I2 = false;
      var zg = null;
      function Ag(a4, b4) {
        var c4 = Bg(5, null, null, 0);
        c4.elementType = "DELETED";
        c4.stateNode = b4;
        c4.return = a4;
        b4 = a4.deletions;
        null === b4 ? (a4.deletions = [c4], a4.flags |= 16) : b4.push(c4);
      }
      function Cg(a4, b4) {
        switch (a4.tag) {
          case 5:
            var c4 = a4.type;
            b4 = 1 !== b4.nodeType || c4.toLowerCase() !== b4.nodeName.toLowerCase() ? null : b4;
            return null !== b4 ? (a4.stateNode = b4, xg = a4, yg = Lf(b4.firstChild), true) : false;
          case 6:
            return b4 = "" === a4.pendingProps || 3 !== b4.nodeType ? null : b4, null !== b4 ? (a4.stateNode = b4, xg = a4, yg = null, true) : false;
          case 13:
            return b4 = 8 !== b4.nodeType ? null : b4, null !== b4 ? (c4 = null !== qg ? { id: rg, overflow: sg } : null, a4.memoizedState = { dehydrated: b4, treeContext: c4, retryLane: 1073741824 }, c4 = Bg(18, null, null, 0), c4.stateNode = b4, c4.return = a4, a4.child = c4, xg = a4, yg = null, true) : false;
          default:
            return false;
        }
      }
      function Dg(a4) {
        return 0 !== (a4.mode & 1) && 0 === (a4.flags & 128);
      }
      function Eg(a4) {
        if (I2) {
          var b4 = yg;
          if (b4) {
            var c4 = b4;
            if (!Cg(a4, b4)) {
              if (Dg(a4)) throw Error(p4(418));
              b4 = Lf(c4.nextSibling);
              var d3 = xg;
              b4 && Cg(a4, b4) ? Ag(d3, c4) : (a4.flags = a4.flags & -4097 | 2, I2 = false, xg = a4);
            }
          } else {
            if (Dg(a4)) throw Error(p4(418));
            a4.flags = a4.flags & -4097 | 2;
            I2 = false;
            xg = a4;
          }
        }
      }
      function Fg(a4) {
        for (a4 = a4.return; null !== a4 && 5 !== a4.tag && 3 !== a4.tag && 13 !== a4.tag; ) a4 = a4.return;
        xg = a4;
      }
      function Gg(a4) {
        if (a4 !== xg) return false;
        if (!I2) return Fg(a4), I2 = true, false;
        var b4;
        (b4 = 3 !== a4.tag) && !(b4 = 5 !== a4.tag) && (b4 = a4.type, b4 = "head" !== b4 && "body" !== b4 && !Ef(a4.type, a4.memoizedProps));
        if (b4 && (b4 = yg)) {
          if (Dg(a4)) throw Hg(), Error(p4(418));
          for (; b4; ) Ag(a4, b4), b4 = Lf(b4.nextSibling);
        }
        Fg(a4);
        if (13 === a4.tag) {
          a4 = a4.memoizedState;
          a4 = null !== a4 ? a4.dehydrated : null;
          if (!a4) throw Error(p4(317));
          a: {
            a4 = a4.nextSibling;
            for (b4 = 0; a4; ) {
              if (8 === a4.nodeType) {
                var c4 = a4.data;
                if ("/$" === c4) {
                  if (0 === b4) {
                    yg = Lf(a4.nextSibling);
                    break a;
                  }
                  b4--;
                } else "$" !== c4 && "$!" !== c4 && "$?" !== c4 || b4++;
              }
              a4 = a4.nextSibling;
            }
            yg = null;
          }
        } else yg = xg ? Lf(a4.stateNode.nextSibling) : null;
        return true;
      }
      function Hg() {
        for (var a4 = yg; a4; ) a4 = Lf(a4.nextSibling);
      }
      function Ig() {
        yg = xg = null;
        I2 = false;
      }
      function Jg(a4) {
        null === zg ? zg = [a4] : zg.push(a4);
      }
      var Kg = ua.ReactCurrentBatchConfig;
      function Lg(a4, b4, c4) {
        a4 = c4.ref;
        if (null !== a4 && "function" !== typeof a4 && "object" !== typeof a4) {
          if (c4._owner) {
            c4 = c4._owner;
            if (c4) {
              if (1 !== c4.tag) throw Error(p4(309));
              var d3 = c4.stateNode;
            }
            if (!d3) throw Error(p4(147, a4));
            var e4 = d3, f3 = "" + a4;
            if (null !== b4 && null !== b4.ref && "function" === typeof b4.ref && b4.ref._stringRef === f3) return b4.ref;
            b4 = function(a5) {
              var b5 = e4.refs;
              null === a5 ? delete b5[f3] : b5[f3] = a5;
            };
            b4._stringRef = f3;
            return b4;
          }
          if ("string" !== typeof a4) throw Error(p4(284));
          if (!c4._owner) throw Error(p4(290, a4));
        }
        return a4;
      }
      function Mg(a4, b4) {
        a4 = Object.prototype.toString.call(b4);
        throw Error(p4(31, "[object Object]" === a4 ? "object with keys {" + Object.keys(b4).join(", ") + "}" : a4));
      }
      function Ng(a4) {
        var b4 = a4._init;
        return b4(a4._payload);
      }
      function Og(a4) {
        function b4(b5, c5) {
          if (a4) {
            var d4 = b5.deletions;
            null === d4 ? (b5.deletions = [c5], b5.flags |= 16) : d4.push(c5);
          }
        }
        function c4(c5, d4) {
          if (!a4) return null;
          for (; null !== d4; ) b4(c5, d4), d4 = d4.sibling;
          return null;
        }
        function d3(a5, b5) {
          for (a5 = /* @__PURE__ */ new Map(); null !== b5; ) null !== b5.key ? a5.set(b5.key, b5) : a5.set(b5.index, b5), b5 = b5.sibling;
          return a5;
        }
        function e4(a5, b5) {
          a5 = Pg(a5, b5);
          a5.index = 0;
          a5.sibling = null;
          return a5;
        }
        function f3(b5, c5, d4) {
          b5.index = d4;
          if (!a4) return b5.flags |= 1048576, c5;
          d4 = b5.alternate;
          if (null !== d4) return d4 = d4.index, d4 < c5 ? (b5.flags |= 2, c5) : d4;
          b5.flags |= 2;
          return c5;
        }
        function g3(b5) {
          a4 && null === b5.alternate && (b5.flags |= 2);
          return b5;
        }
        function h4(a5, b5, c5, d4) {
          if (null === b5 || 6 !== b5.tag) return b5 = Qg(c5, a5.mode, d4), b5.return = a5, b5;
          b5 = e4(b5, c5);
          b5.return = a5;
          return b5;
        }
        function k2(a5, b5, c5, d4) {
          var f4 = c5.type;
          if (f4 === ya) return m3(a5, b5, c5.props.children, d4, c5.key);
          if (null !== b5 && (b5.elementType === f4 || "object" === typeof f4 && null !== f4 && f4.$$typeof === Ha && Ng(f4) === b5.type)) return d4 = e4(b5, c5.props), d4.ref = Lg(a5, b5, c5), d4.return = a5, d4;
          d4 = Rg(c5.type, c5.key, c5.props, null, a5.mode, d4);
          d4.ref = Lg(a5, b5, c5);
          d4.return = a5;
          return d4;
        }
        function l4(a5, b5, c5, d4) {
          if (null === b5 || 4 !== b5.tag || b5.stateNode.containerInfo !== c5.containerInfo || b5.stateNode.implementation !== c5.implementation) return b5 = Sg(c5, a5.mode, d4), b5.return = a5, b5;
          b5 = e4(b5, c5.children || []);
          b5.return = a5;
          return b5;
        }
        function m3(a5, b5, c5, d4, f4) {
          if (null === b5 || 7 !== b5.tag) return b5 = Tg(c5, a5.mode, d4, f4), b5.return = a5, b5;
          b5 = e4(b5, c5);
          b5.return = a5;
          return b5;
        }
        function q2(a5, b5, c5) {
          if ("string" === typeof b5 && "" !== b5 || "number" === typeof b5) return b5 = Qg("" + b5, a5.mode, c5), b5.return = a5, b5;
          if ("object" === typeof b5 && null !== b5) {
            switch (b5.$$typeof) {
              case va:
                return c5 = Rg(b5.type, b5.key, b5.props, null, a5.mode, c5), c5.ref = Lg(a5, null, b5), c5.return = a5, c5;
              case wa:
                return b5 = Sg(b5, a5.mode, c5), b5.return = a5, b5;
              case Ha:
                var d4 = b5._init;
                return q2(a5, d4(b5._payload), c5);
            }
            if (eb(b5) || Ka(b5)) return b5 = Tg(b5, a5.mode, c5, null), b5.return = a5, b5;
            Mg(a5, b5);
          }
          return null;
        }
        function r3(a5, b5, c5, d4) {
          var e5 = null !== b5 ? b5.key : null;
          if ("string" === typeof c5 && "" !== c5 || "number" === typeof c5) return null !== e5 ? null : h4(a5, b5, "" + c5, d4);
          if ("object" === typeof c5 && null !== c5) {
            switch (c5.$$typeof) {
              case va:
                return c5.key === e5 ? k2(a5, b5, c5, d4) : null;
              case wa:
                return c5.key === e5 ? l4(a5, b5, c5, d4) : null;
              case Ha:
                return e5 = c5._init, r3(
                  a5,
                  b5,
                  e5(c5._payload),
                  d4
                );
            }
            if (eb(c5) || Ka(c5)) return null !== e5 ? null : m3(a5, b5, c5, d4, null);
            Mg(a5, c5);
          }
          return null;
        }
        function y3(a5, b5, c5, d4, e5) {
          if ("string" === typeof d4 && "" !== d4 || "number" === typeof d4) return a5 = a5.get(c5) || null, h4(b5, a5, "" + d4, e5);
          if ("object" === typeof d4 && null !== d4) {
            switch (d4.$$typeof) {
              case va:
                return a5 = a5.get(null === d4.key ? c5 : d4.key) || null, k2(b5, a5, d4, e5);
              case wa:
                return a5 = a5.get(null === d4.key ? c5 : d4.key) || null, l4(b5, a5, d4, e5);
              case Ha:
                var f4 = d4._init;
                return y3(a5, b5, c5, f4(d4._payload), e5);
            }
            if (eb(d4) || Ka(d4)) return a5 = a5.get(c5) || null, m3(b5, a5, d4, e5, null);
            Mg(b5, d4);
          }
          return null;
        }
        function n4(e5, g4, h5, k3) {
          for (var l5 = null, m4 = null, u4 = g4, w2 = g4 = 0, x2 = null; null !== u4 && w2 < h5.length; w2++) {
            u4.index > w2 ? (x2 = u4, u4 = null) : x2 = u4.sibling;
            var n5 = r3(e5, u4, h5[w2], k3);
            if (null === n5) {
              null === u4 && (u4 = x2);
              break;
            }
            a4 && u4 && null === n5.alternate && b4(e5, u4);
            g4 = f3(n5, g4, w2);
            null === m4 ? l5 = n5 : m4.sibling = n5;
            m4 = n5;
            u4 = x2;
          }
          if (w2 === h5.length) return c4(e5, u4), I2 && tg(e5, w2), l5;
          if (null === u4) {
            for (; w2 < h5.length; w2++) u4 = q2(e5, h5[w2], k3), null !== u4 && (g4 = f3(u4, g4, w2), null === m4 ? l5 = u4 : m4.sibling = u4, m4 = u4);
            I2 && tg(e5, w2);
            return l5;
          }
          for (u4 = d3(e5, u4); w2 < h5.length; w2++) x2 = y3(u4, e5, w2, h5[w2], k3), null !== x2 && (a4 && null !== x2.alternate && u4.delete(null === x2.key ? w2 : x2.key), g4 = f3(x2, g4, w2), null === m4 ? l5 = x2 : m4.sibling = x2, m4 = x2);
          a4 && u4.forEach(function(a5) {
            return b4(e5, a5);
          });
          I2 && tg(e5, w2);
          return l5;
        }
        function t5(e5, g4, h5, k3) {
          var l5 = Ka(h5);
          if ("function" !== typeof l5) throw Error(p4(150));
          h5 = l5.call(h5);
          if (null == h5) throw Error(p4(151));
          for (var u4 = l5 = null, m4 = g4, w2 = g4 = 0, x2 = null, n5 = h5.next(); null !== m4 && !n5.done; w2++, n5 = h5.next()) {
            m4.index > w2 ? (x2 = m4, m4 = null) : x2 = m4.sibling;
            var t6 = r3(e5, m4, n5.value, k3);
            if (null === t6) {
              null === m4 && (m4 = x2);
              break;
            }
            a4 && m4 && null === t6.alternate && b4(e5, m4);
            g4 = f3(t6, g4, w2);
            null === u4 ? l5 = t6 : u4.sibling = t6;
            u4 = t6;
            m4 = x2;
          }
          if (n5.done) return c4(
            e5,
            m4
          ), I2 && tg(e5, w2), l5;
          if (null === m4) {
            for (; !n5.done; w2++, n5 = h5.next()) n5 = q2(e5, n5.value, k3), null !== n5 && (g4 = f3(n5, g4, w2), null === u4 ? l5 = n5 : u4.sibling = n5, u4 = n5);
            I2 && tg(e5, w2);
            return l5;
          }
          for (m4 = d3(e5, m4); !n5.done; w2++, n5 = h5.next()) n5 = y3(m4, e5, w2, n5.value, k3), null !== n5 && (a4 && null !== n5.alternate && m4.delete(null === n5.key ? w2 : n5.key), g4 = f3(n5, g4, w2), null === u4 ? l5 = n5 : u4.sibling = n5, u4 = n5);
          a4 && m4.forEach(function(a5) {
            return b4(e5, a5);
          });
          I2 && tg(e5, w2);
          return l5;
        }
        function J2(a5, d4, f4, h5) {
          "object" === typeof f4 && null !== f4 && f4.type === ya && null === f4.key && (f4 = f4.props.children);
          if ("object" === typeof f4 && null !== f4) {
            switch (f4.$$typeof) {
              case va:
                a: {
                  for (var k3 = f4.key, l5 = d4; null !== l5; ) {
                    if (l5.key === k3) {
                      k3 = f4.type;
                      if (k3 === ya) {
                        if (7 === l5.tag) {
                          c4(a5, l5.sibling);
                          d4 = e4(l5, f4.props.children);
                          d4.return = a5;
                          a5 = d4;
                          break a;
                        }
                      } else if (l5.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l5.type) {
                        c4(a5, l5.sibling);
                        d4 = e4(l5, f4.props);
                        d4.ref = Lg(a5, l5, f4);
                        d4.return = a5;
                        a5 = d4;
                        break a;
                      }
                      c4(a5, l5);
                      break;
                    } else b4(a5, l5);
                    l5 = l5.sibling;
                  }
                  f4.type === ya ? (d4 = Tg(f4.props.children, a5.mode, h5, f4.key), d4.return = a5, a5 = d4) : (h5 = Rg(f4.type, f4.key, f4.props, null, a5.mode, h5), h5.ref = Lg(a5, d4, f4), h5.return = a5, a5 = h5);
                }
                return g3(a5);
              case wa:
                a: {
                  for (l5 = f4.key; null !== d4; ) {
                    if (d4.key === l5) if (4 === d4.tag && d4.stateNode.containerInfo === f4.containerInfo && d4.stateNode.implementation === f4.implementation) {
                      c4(a5, d4.sibling);
                      d4 = e4(d4, f4.children || []);
                      d4.return = a5;
                      a5 = d4;
                      break a;
                    } else {
                      c4(a5, d4);
                      break;
                    }
                    else b4(a5, d4);
                    d4 = d4.sibling;
                  }
                  d4 = Sg(f4, a5.mode, h5);
                  d4.return = a5;
                  a5 = d4;
                }
                return g3(a5);
              case Ha:
                return l5 = f4._init, J2(a5, d4, l5(f4._payload), h5);
            }
            if (eb(f4)) return n4(a5, d4, f4, h5);
            if (Ka(f4)) return t5(a5, d4, f4, h5);
            Mg(a5, f4);
          }
          return "string" === typeof f4 && "" !== f4 || "number" === typeof f4 ? (f4 = "" + f4, null !== d4 && 6 === d4.tag ? (c4(a5, d4.sibling), d4 = e4(d4, f4), d4.return = a5, a5 = d4) : (c4(a5, d4), d4 = Qg(f4, a5.mode, h5), d4.return = a5, a5 = d4), g3(a5)) : c4(a5, d4);
        }
        return J2;
      }
      var Ug = Og(true);
      var Vg = Og(false);
      var Wg = Uf(null);
      var Xg = null;
      var Yg = null;
      var Zg = null;
      function $g() {
        Zg = Yg = Xg = null;
      }
      function ah(a4) {
        var b4 = Wg.current;
        E(Wg);
        a4._currentValue = b4;
      }
      function bh(a4, b4, c4) {
        for (; null !== a4; ) {
          var d3 = a4.alternate;
          (a4.childLanes & b4) !== b4 ? (a4.childLanes |= b4, null !== d3 && (d3.childLanes |= b4)) : null !== d3 && (d3.childLanes & b4) !== b4 && (d3.childLanes |= b4);
          if (a4 === c4) break;
          a4 = a4.return;
        }
      }
      function ch(a4, b4) {
        Xg = a4;
        Zg = Yg = null;
        a4 = a4.dependencies;
        null !== a4 && null !== a4.firstContext && (0 !== (a4.lanes & b4) && (dh = true), a4.firstContext = null);
      }
      function eh(a4) {
        var b4 = a4._currentValue;
        if (Zg !== a4) if (a4 = { context: a4, memoizedValue: b4, next: null }, null === Yg) {
          if (null === Xg) throw Error(p4(308));
          Yg = a4;
          Xg.dependencies = { lanes: 0, firstContext: a4 };
        } else Yg = Yg.next = a4;
        return b4;
      }
      var fh = null;
      function gh(a4) {
        null === fh ? fh = [a4] : fh.push(a4);
      }
      function hh(a4, b4, c4, d3) {
        var e4 = b4.interleaved;
        null === e4 ? (c4.next = c4, gh(b4)) : (c4.next = e4.next, e4.next = c4);
        b4.interleaved = c4;
        return ih(a4, d3);
      }
      function ih(a4, b4) {
        a4.lanes |= b4;
        var c4 = a4.alternate;
        null !== c4 && (c4.lanes |= b4);
        c4 = a4;
        for (a4 = a4.return; null !== a4; ) a4.childLanes |= b4, c4 = a4.alternate, null !== c4 && (c4.childLanes |= b4), c4 = a4, a4 = a4.return;
        return 3 === c4.tag ? c4.stateNode : null;
      }
      var jh = false;
      function kh(a4) {
        a4.updateQueue = { baseState: a4.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
      }
      function lh(a4, b4) {
        a4 = a4.updateQueue;
        b4.updateQueue === a4 && (b4.updateQueue = { baseState: a4.baseState, firstBaseUpdate: a4.firstBaseUpdate, lastBaseUpdate: a4.lastBaseUpdate, shared: a4.shared, effects: a4.effects });
      }
      function mh(a4, b4) {
        return { eventTime: a4, lane: b4, tag: 0, payload: null, callback: null, next: null };
      }
      function nh(a4, b4, c4) {
        var d3 = a4.updateQueue;
        if (null === d3) return null;
        d3 = d3.shared;
        if (0 !== (K & 2)) {
          var e4 = d3.pending;
          null === e4 ? b4.next = b4 : (b4.next = e4.next, e4.next = b4);
          d3.pending = b4;
          return ih(a4, c4);
        }
        e4 = d3.interleaved;
        null === e4 ? (b4.next = b4, gh(d3)) : (b4.next = e4.next, e4.next = b4);
        d3.interleaved = b4;
        return ih(a4, c4);
      }
      function oh(a4, b4, c4) {
        b4 = b4.updateQueue;
        if (null !== b4 && (b4 = b4.shared, 0 !== (c4 & 4194240))) {
          var d3 = b4.lanes;
          d3 &= a4.pendingLanes;
          c4 |= d3;
          b4.lanes = c4;
          Cc(a4, c4);
        }
      }
      function ph(a4, b4) {
        var c4 = a4.updateQueue, d3 = a4.alternate;
        if (null !== d3 && (d3 = d3.updateQueue, c4 === d3)) {
          var e4 = null, f3 = null;
          c4 = c4.firstBaseUpdate;
          if (null !== c4) {
            do {
              var g3 = { eventTime: c4.eventTime, lane: c4.lane, tag: c4.tag, payload: c4.payload, callback: c4.callback, next: null };
              null === f3 ? e4 = f3 = g3 : f3 = f3.next = g3;
              c4 = c4.next;
            } while (null !== c4);
            null === f3 ? e4 = f3 = b4 : f3 = f3.next = b4;
          } else e4 = f3 = b4;
          c4 = { baseState: d3.baseState, firstBaseUpdate: e4, lastBaseUpdate: f3, shared: d3.shared, effects: d3.effects };
          a4.updateQueue = c4;
          return;
        }
        a4 = c4.lastBaseUpdate;
        null === a4 ? c4.firstBaseUpdate = b4 : a4.next = b4;
        c4.lastBaseUpdate = b4;
      }
      function qh(a4, b4, c4, d3) {
        var e4 = a4.updateQueue;
        jh = false;
        var f3 = e4.firstBaseUpdate, g3 = e4.lastBaseUpdate, h4 = e4.shared.pending;
        if (null !== h4) {
          e4.shared.pending = null;
          var k2 = h4, l4 = k2.next;
          k2.next = null;
          null === g3 ? f3 = l4 : g3.next = l4;
          g3 = k2;
          var m3 = a4.alternate;
          null !== m3 && (m3 = m3.updateQueue, h4 = m3.lastBaseUpdate, h4 !== g3 && (null === h4 ? m3.firstBaseUpdate = l4 : h4.next = l4, m3.lastBaseUpdate = k2));
        }
        if (null !== f3) {
          var q2 = e4.baseState;
          g3 = 0;
          m3 = l4 = k2 = null;
          h4 = f3;
          do {
            var r3 = h4.lane, y3 = h4.eventTime;
            if ((d3 & r3) === r3) {
              null !== m3 && (m3 = m3.next = {
                eventTime: y3,
                lane: 0,
                tag: h4.tag,
                payload: h4.payload,
                callback: h4.callback,
                next: null
              });
              a: {
                var n4 = a4, t5 = h4;
                r3 = b4;
                y3 = c4;
                switch (t5.tag) {
                  case 1:
                    n4 = t5.payload;
                    if ("function" === typeof n4) {
                      q2 = n4.call(y3, q2, r3);
                      break a;
                    }
                    q2 = n4;
                    break a;
                  case 3:
                    n4.flags = n4.flags & -65537 | 128;
                  case 0:
                    n4 = t5.payload;
                    r3 = "function" === typeof n4 ? n4.call(y3, q2, r3) : n4;
                    if (null === r3 || void 0 === r3) break a;
                    q2 = A({}, q2, r3);
                    break a;
                  case 2:
                    jh = true;
                }
              }
              null !== h4.callback && 0 !== h4.lane && (a4.flags |= 64, r3 = e4.effects, null === r3 ? e4.effects = [h4] : r3.push(h4));
            } else y3 = { eventTime: y3, lane: r3, tag: h4.tag, payload: h4.payload, callback: h4.callback, next: null }, null === m3 ? (l4 = m3 = y3, k2 = q2) : m3 = m3.next = y3, g3 |= r3;
            h4 = h4.next;
            if (null === h4) if (h4 = e4.shared.pending, null === h4) break;
            else r3 = h4, h4 = r3.next, r3.next = null, e4.lastBaseUpdate = r3, e4.shared.pending = null;
          } while (1);
          null === m3 && (k2 = q2);
          e4.baseState = k2;
          e4.firstBaseUpdate = l4;
          e4.lastBaseUpdate = m3;
          b4 = e4.shared.interleaved;
          if (null !== b4) {
            e4 = b4;
            do
              g3 |= e4.lane, e4 = e4.next;
            while (e4 !== b4);
          } else null === f3 && (e4.shared.lanes = 0);
          rh |= g3;
          a4.lanes = g3;
          a4.memoizedState = q2;
        }
      }
      function sh(a4, b4, c4) {
        a4 = b4.effects;
        b4.effects = null;
        if (null !== a4) for (b4 = 0; b4 < a4.length; b4++) {
          var d3 = a4[b4], e4 = d3.callback;
          if (null !== e4) {
            d3.callback = null;
            d3 = c4;
            if ("function" !== typeof e4) throw Error(p4(191, e4));
            e4.call(d3);
          }
        }
      }
      var th = {};
      var uh = Uf(th);
      var vh = Uf(th);
      var wh = Uf(th);
      function xh(a4) {
        if (a4 === th) throw Error(p4(174));
        return a4;
      }
      function yh(a4, b4) {
        G(wh, b4);
        G(vh, a4);
        G(uh, th);
        a4 = b4.nodeType;
        switch (a4) {
          case 9:
          case 11:
            b4 = (b4 = b4.documentElement) ? b4.namespaceURI : lb(null, "");
            break;
          default:
            a4 = 8 === a4 ? b4.parentNode : b4, b4 = a4.namespaceURI || null, a4 = a4.tagName, b4 = lb(b4, a4);
        }
        E(uh);
        G(uh, b4);
      }
      function zh() {
        E(uh);
        E(vh);
        E(wh);
      }
      function Ah(a4) {
        xh(wh.current);
        var b4 = xh(uh.current);
        var c4 = lb(b4, a4.type);
        b4 !== c4 && (G(vh, a4), G(uh, c4));
      }
      function Bh(a4) {
        vh.current === a4 && (E(uh), E(vh));
      }
      var L2 = Uf(0);
      function Ch(a4) {
        for (var b4 = a4; null !== b4; ) {
          if (13 === b4.tag) {
            var c4 = b4.memoizedState;
            if (null !== c4 && (c4 = c4.dehydrated, null === c4 || "$?" === c4.data || "$!" === c4.data)) return b4;
          } else if (19 === b4.tag && void 0 !== b4.memoizedProps.revealOrder) {
            if (0 !== (b4.flags & 128)) return b4;
          } else if (null !== b4.child) {
            b4.child.return = b4;
            b4 = b4.child;
            continue;
          }
          if (b4 === a4) break;
          for (; null === b4.sibling; ) {
            if (null === b4.return || b4.return === a4) return null;
            b4 = b4.return;
          }
          b4.sibling.return = b4.return;
          b4 = b4.sibling;
        }
        return null;
      }
      var Dh = [];
      function Eh() {
        for (var a4 = 0; a4 < Dh.length; a4++) Dh[a4]._workInProgressVersionPrimary = null;
        Dh.length = 0;
      }
      var Fh = ua.ReactCurrentDispatcher;
      var Gh = ua.ReactCurrentBatchConfig;
      var Hh = 0;
      var M2 = null;
      var N2 = null;
      var O = null;
      var Ih = false;
      var Jh = false;
      var Kh = 0;
      var Lh = 0;
      function P() {
        throw Error(p4(321));
      }
      function Mh(a4, b4) {
        if (null === b4) return false;
        for (var c4 = 0; c4 < b4.length && c4 < a4.length; c4++) if (!He(a4[c4], b4[c4])) return false;
        return true;
      }
      function Nh(a4, b4, c4, d3, e4, f3) {
        Hh = f3;
        M2 = b4;
        b4.memoizedState = null;
        b4.updateQueue = null;
        b4.lanes = 0;
        Fh.current = null === a4 || null === a4.memoizedState ? Oh : Ph;
        a4 = c4(d3, e4);
        if (Jh) {
          f3 = 0;
          do {
            Jh = false;
            Kh = 0;
            if (25 <= f3) throw Error(p4(301));
            f3 += 1;
            O = N2 = null;
            b4.updateQueue = null;
            Fh.current = Qh;
            a4 = c4(d3, e4);
          } while (Jh);
        }
        Fh.current = Rh;
        b4 = null !== N2 && null !== N2.next;
        Hh = 0;
        O = N2 = M2 = null;
        Ih = false;
        if (b4) throw Error(p4(300));
        return a4;
      }
      function Sh() {
        var a4 = 0 !== Kh;
        Kh = 0;
        return a4;
      }
      function Th() {
        var a4 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
        null === O ? M2.memoizedState = O = a4 : O = O.next = a4;
        return O;
      }
      function Uh() {
        if (null === N2) {
          var a4 = M2.alternate;
          a4 = null !== a4 ? a4.memoizedState : null;
        } else a4 = N2.next;
        var b4 = null === O ? M2.memoizedState : O.next;
        if (null !== b4) O = b4, N2 = a4;
        else {
          if (null === a4) throw Error(p4(310));
          N2 = a4;
          a4 = { memoizedState: N2.memoizedState, baseState: N2.baseState, baseQueue: N2.baseQueue, queue: N2.queue, next: null };
          null === O ? M2.memoizedState = O = a4 : O = O.next = a4;
        }
        return O;
      }
      function Vh(a4, b4) {
        return "function" === typeof b4 ? b4(a4) : b4;
      }
      function Wh(a4) {
        var b4 = Uh(), c4 = b4.queue;
        if (null === c4) throw Error(p4(311));
        c4.lastRenderedReducer = a4;
        var d3 = N2, e4 = d3.baseQueue, f3 = c4.pending;
        if (null !== f3) {
          if (null !== e4) {
            var g3 = e4.next;
            e4.next = f3.next;
            f3.next = g3;
          }
          d3.baseQueue = e4 = f3;
          c4.pending = null;
        }
        if (null !== e4) {
          f3 = e4.next;
          d3 = d3.baseState;
          var h4 = g3 = null, k2 = null, l4 = f3;
          do {
            var m3 = l4.lane;
            if ((Hh & m3) === m3) null !== k2 && (k2 = k2.next = { lane: 0, action: l4.action, hasEagerState: l4.hasEagerState, eagerState: l4.eagerState, next: null }), d3 = l4.hasEagerState ? l4.eagerState : a4(d3, l4.action);
            else {
              var q2 = {
                lane: m3,
                action: l4.action,
                hasEagerState: l4.hasEagerState,
                eagerState: l4.eagerState,
                next: null
              };
              null === k2 ? (h4 = k2 = q2, g3 = d3) : k2 = k2.next = q2;
              M2.lanes |= m3;
              rh |= m3;
            }
            l4 = l4.next;
          } while (null !== l4 && l4 !== f3);
          null === k2 ? g3 = d3 : k2.next = h4;
          He(d3, b4.memoizedState) || (dh = true);
          b4.memoizedState = d3;
          b4.baseState = g3;
          b4.baseQueue = k2;
          c4.lastRenderedState = d3;
        }
        a4 = c4.interleaved;
        if (null !== a4) {
          e4 = a4;
          do
            f3 = e4.lane, M2.lanes |= f3, rh |= f3, e4 = e4.next;
          while (e4 !== a4);
        } else null === e4 && (c4.lanes = 0);
        return [b4.memoizedState, c4.dispatch];
      }
      function Xh(a4) {
        var b4 = Uh(), c4 = b4.queue;
        if (null === c4) throw Error(p4(311));
        c4.lastRenderedReducer = a4;
        var d3 = c4.dispatch, e4 = c4.pending, f3 = b4.memoizedState;
        if (null !== e4) {
          c4.pending = null;
          var g3 = e4 = e4.next;
          do
            f3 = a4(f3, g3.action), g3 = g3.next;
          while (g3 !== e4);
          He(f3, b4.memoizedState) || (dh = true);
          b4.memoizedState = f3;
          null === b4.baseQueue && (b4.baseState = f3);
          c4.lastRenderedState = f3;
        }
        return [f3, d3];
      }
      function Yh() {
      }
      function Zh(a4, b4) {
        var c4 = M2, d3 = Uh(), e4 = b4(), f3 = !He(d3.memoizedState, e4);
        f3 && (d3.memoizedState = e4, dh = true);
        d3 = d3.queue;
        $h(ai.bind(null, c4, d3, a4), [a4]);
        if (d3.getSnapshot !== b4 || f3 || null !== O && O.memoizedState.tag & 1) {
          c4.flags |= 2048;
          bi(9, ci.bind(null, c4, d3, e4, b4), void 0, null);
          if (null === Q2) throw Error(p4(349));
          0 !== (Hh & 30) || di(c4, b4, e4);
        }
        return e4;
      }
      function di(a4, b4, c4) {
        a4.flags |= 16384;
        a4 = { getSnapshot: b4, value: c4 };
        b4 = M2.updateQueue;
        null === b4 ? (b4 = { lastEffect: null, stores: null }, M2.updateQueue = b4, b4.stores = [a4]) : (c4 = b4.stores, null === c4 ? b4.stores = [a4] : c4.push(a4));
      }
      function ci(a4, b4, c4, d3) {
        b4.value = c4;
        b4.getSnapshot = d3;
        ei(b4) && fi(a4);
      }
      function ai(a4, b4, c4) {
        return c4(function() {
          ei(b4) && fi(a4);
        });
      }
      function ei(a4) {
        var b4 = a4.getSnapshot;
        a4 = a4.value;
        try {
          var c4 = b4();
          return !He(a4, c4);
        } catch (d3) {
          return true;
        }
      }
      function fi(a4) {
        var b4 = ih(a4, 1);
        null !== b4 && gi(b4, a4, 1, -1);
      }
      function hi(a4) {
        var b4 = Th();
        "function" === typeof a4 && (a4 = a4());
        b4.memoizedState = b4.baseState = a4;
        a4 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a4 };
        b4.queue = a4;
        a4 = a4.dispatch = ii.bind(null, M2, a4);
        return [b4.memoizedState, a4];
      }
      function bi(a4, b4, c4, d3) {
        a4 = { tag: a4, create: b4, destroy: c4, deps: d3, next: null };
        b4 = M2.updateQueue;
        null === b4 ? (b4 = { lastEffect: null, stores: null }, M2.updateQueue = b4, b4.lastEffect = a4.next = a4) : (c4 = b4.lastEffect, null === c4 ? b4.lastEffect = a4.next = a4 : (d3 = c4.next, c4.next = a4, a4.next = d3, b4.lastEffect = a4));
        return a4;
      }
      function ji() {
        return Uh().memoizedState;
      }
      function ki(a4, b4, c4, d3) {
        var e4 = Th();
        M2.flags |= a4;
        e4.memoizedState = bi(1 | b4, c4, void 0, void 0 === d3 ? null : d3);
      }
      function li(a4, b4, c4, d3) {
        var e4 = Uh();
        d3 = void 0 === d3 ? null : d3;
        var f3 = void 0;
        if (null !== N2) {
          var g3 = N2.memoizedState;
          f3 = g3.destroy;
          if (null !== d3 && Mh(d3, g3.deps)) {
            e4.memoizedState = bi(b4, c4, f3, d3);
            return;
          }
        }
        M2.flags |= a4;
        e4.memoizedState = bi(1 | b4, c4, f3, d3);
      }
      function mi(a4, b4) {
        return ki(8390656, 8, a4, b4);
      }
      function $h(a4, b4) {
        return li(2048, 8, a4, b4);
      }
      function ni(a4, b4) {
        return li(4, 2, a4, b4);
      }
      function oi(a4, b4) {
        return li(4, 4, a4, b4);
      }
      function pi(a4, b4) {
        if ("function" === typeof b4) return a4 = a4(), b4(a4), function() {
          b4(null);
        };
        if (null !== b4 && void 0 !== b4) return a4 = a4(), b4.current = a4, function() {
          b4.current = null;
        };
      }
      function qi(a4, b4, c4) {
        c4 = null !== c4 && void 0 !== c4 ? c4.concat([a4]) : null;
        return li(4, 4, pi.bind(null, b4, a4), c4);
      }
      function ri() {
      }
      function si(a4, b4) {
        var c4 = Uh();
        b4 = void 0 === b4 ? null : b4;
        var d3 = c4.memoizedState;
        if (null !== d3 && null !== b4 && Mh(b4, d3[1])) return d3[0];
        c4.memoizedState = [a4, b4];
        return a4;
      }
      function ti(a4, b4) {
        var c4 = Uh();
        b4 = void 0 === b4 ? null : b4;
        var d3 = c4.memoizedState;
        if (null !== d3 && null !== b4 && Mh(b4, d3[1])) return d3[0];
        a4 = a4();
        c4.memoizedState = [a4, b4];
        return a4;
      }
      function ui(a4, b4, c4) {
        if (0 === (Hh & 21)) return a4.baseState && (a4.baseState = false, dh = true), a4.memoizedState = c4;
        He(c4, b4) || (c4 = yc(), M2.lanes |= c4, rh |= c4, a4.baseState = true);
        return b4;
      }
      function vi(a4, b4) {
        var c4 = C2;
        C2 = 0 !== c4 && 4 > c4 ? c4 : 4;
        a4(true);
        var d3 = Gh.transition;
        Gh.transition = {};
        try {
          a4(false), b4();
        } finally {
          C2 = c4, Gh.transition = d3;
        }
      }
      function wi() {
        return Uh().memoizedState;
      }
      function xi(a4, b4, c4) {
        var d3 = yi(a4);
        c4 = { lane: d3, action: c4, hasEagerState: false, eagerState: null, next: null };
        if (zi(a4)) Ai(b4, c4);
        else if (c4 = hh(a4, b4, c4, d3), null !== c4) {
          var e4 = R2();
          gi(c4, a4, d3, e4);
          Bi(c4, b4, d3);
        }
      }
      function ii(a4, b4, c4) {
        var d3 = yi(a4), e4 = { lane: d3, action: c4, hasEagerState: false, eagerState: null, next: null };
        if (zi(a4)) Ai(b4, e4);
        else {
          var f3 = a4.alternate;
          if (0 === a4.lanes && (null === f3 || 0 === f3.lanes) && (f3 = b4.lastRenderedReducer, null !== f3)) try {
            var g3 = b4.lastRenderedState, h4 = f3(g3, c4);
            e4.hasEagerState = true;
            e4.eagerState = h4;
            if (He(h4, g3)) {
              var k2 = b4.interleaved;
              null === k2 ? (e4.next = e4, gh(b4)) : (e4.next = k2.next, k2.next = e4);
              b4.interleaved = e4;
              return;
            }
          } catch (l4) {
          } finally {
          }
          c4 = hh(a4, b4, e4, d3);
          null !== c4 && (e4 = R2(), gi(c4, a4, d3, e4), Bi(c4, b4, d3));
        }
      }
      function zi(a4) {
        var b4 = a4.alternate;
        return a4 === M2 || null !== b4 && b4 === M2;
      }
      function Ai(a4, b4) {
        Jh = Ih = true;
        var c4 = a4.pending;
        null === c4 ? b4.next = b4 : (b4.next = c4.next, c4.next = b4);
        a4.pending = b4;
      }
      function Bi(a4, b4, c4) {
        if (0 !== (c4 & 4194240)) {
          var d3 = b4.lanes;
          d3 &= a4.pendingLanes;
          c4 |= d3;
          b4.lanes = c4;
          Cc(a4, c4);
        }
      }
      var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false };
      var Oh = { readContext: eh, useCallback: function(a4, b4) {
        Th().memoizedState = [a4, void 0 === b4 ? null : b4];
        return a4;
      }, useContext: eh, useEffect: mi, useImperativeHandle: function(a4, b4, c4) {
        c4 = null !== c4 && void 0 !== c4 ? c4.concat([a4]) : null;
        return ki(
          4194308,
          4,
          pi.bind(null, b4, a4),
          c4
        );
      }, useLayoutEffect: function(a4, b4) {
        return ki(4194308, 4, a4, b4);
      }, useInsertionEffect: function(a4, b4) {
        return ki(4, 2, a4, b4);
      }, useMemo: function(a4, b4) {
        var c4 = Th();
        b4 = void 0 === b4 ? null : b4;
        a4 = a4();
        c4.memoizedState = [a4, b4];
        return a4;
      }, useReducer: function(a4, b4, c4) {
        var d3 = Th();
        b4 = void 0 !== c4 ? c4(b4) : b4;
        d3.memoizedState = d3.baseState = b4;
        a4 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a4, lastRenderedState: b4 };
        d3.queue = a4;
        a4 = a4.dispatch = xi.bind(null, M2, a4);
        return [d3.memoizedState, a4];
      }, useRef: function(a4) {
        var b4 = Th();
        a4 = { current: a4 };
        return b4.memoizedState = a4;
      }, useState: hi, useDebugValue: ri, useDeferredValue: function(a4) {
        return Th().memoizedState = a4;
      }, useTransition: function() {
        var a4 = hi(false), b4 = a4[0];
        a4 = vi.bind(null, a4[1]);
        Th().memoizedState = a4;
        return [b4, a4];
      }, useMutableSource: function() {
      }, useSyncExternalStore: function(a4, b4, c4) {
        var d3 = M2, e4 = Th();
        if (I2) {
          if (void 0 === c4) throw Error(p4(407));
          c4 = c4();
        } else {
          c4 = b4();
          if (null === Q2) throw Error(p4(349));
          0 !== (Hh & 30) || di(d3, b4, c4);
        }
        e4.memoizedState = c4;
        var f3 = { value: c4, getSnapshot: b4 };
        e4.queue = f3;
        mi(ai.bind(
          null,
          d3,
          f3,
          a4
        ), [a4]);
        d3.flags |= 2048;
        bi(9, ci.bind(null, d3, f3, c4, b4), void 0, null);
        return c4;
      }, useId: function() {
        var a4 = Th(), b4 = Q2.identifierPrefix;
        if (I2) {
          var c4 = sg;
          var d3 = rg;
          c4 = (d3 & ~(1 << 32 - oc(d3) - 1)).toString(32) + c4;
          b4 = ":" + b4 + "R" + c4;
          c4 = Kh++;
          0 < c4 && (b4 += "H" + c4.toString(32));
          b4 += ":";
        } else c4 = Lh++, b4 = ":" + b4 + "r" + c4.toString(32) + ":";
        return a4.memoizedState = b4;
      }, unstable_isNewReconciler: false };
      var Ph = {
        readContext: eh,
        useCallback: si,
        useContext: eh,
        useEffect: $h,
        useImperativeHandle: qi,
        useInsertionEffect: ni,
        useLayoutEffect: oi,
        useMemo: ti,
        useReducer: Wh,
        useRef: ji,
        useState: function() {
          return Wh(Vh);
        },
        useDebugValue: ri,
        useDeferredValue: function(a4) {
          var b4 = Uh();
          return ui(b4, N2.memoizedState, a4);
        },
        useTransition: function() {
          var a4 = Wh(Vh)[0], b4 = Uh().memoizedState;
          return [a4, b4];
        },
        useMutableSource: Yh,
        useSyncExternalStore: Zh,
        useId: wi,
        unstable_isNewReconciler: false
      };
      var Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
        return Xh(Vh);
      }, useDebugValue: ri, useDeferredValue: function(a4) {
        var b4 = Uh();
        return null === N2 ? b4.memoizedState = a4 : ui(b4, N2.memoizedState, a4);
      }, useTransition: function() {
        var a4 = Xh(Vh)[0], b4 = Uh().memoizedState;
        return [a4, b4];
      }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
      function Ci(a4, b4) {
        if (a4 && a4.defaultProps) {
          b4 = A({}, b4);
          a4 = a4.defaultProps;
          for (var c4 in a4) void 0 === b4[c4] && (b4[c4] = a4[c4]);
          return b4;
        }
        return b4;
      }
      function Di(a4, b4, c4, d3) {
        b4 = a4.memoizedState;
        c4 = c4(d3, b4);
        c4 = null === c4 || void 0 === c4 ? b4 : A({}, b4, c4);
        a4.memoizedState = c4;
        0 === a4.lanes && (a4.updateQueue.baseState = c4);
      }
      var Ei = { isMounted: function(a4) {
        return (a4 = a4._reactInternals) ? Vb(a4) === a4 : false;
      }, enqueueSetState: function(a4, b4, c4) {
        a4 = a4._reactInternals;
        var d3 = R2(), e4 = yi(a4), f3 = mh(d3, e4);
        f3.payload = b4;
        void 0 !== c4 && null !== c4 && (f3.callback = c4);
        b4 = nh(a4, f3, e4);
        null !== b4 && (gi(b4, a4, e4, d3), oh(b4, a4, e4));
      }, enqueueReplaceState: function(a4, b4, c4) {
        a4 = a4._reactInternals;
        var d3 = R2(), e4 = yi(a4), f3 = mh(d3, e4);
        f3.tag = 1;
        f3.payload = b4;
        void 0 !== c4 && null !== c4 && (f3.callback = c4);
        b4 = nh(a4, f3, e4);
        null !== b4 && (gi(b4, a4, e4, d3), oh(b4, a4, e4));
      }, enqueueForceUpdate: function(a4, b4) {
        a4 = a4._reactInternals;
        var c4 = R2(), d3 = yi(a4), e4 = mh(c4, d3);
        e4.tag = 2;
        void 0 !== b4 && null !== b4 && (e4.callback = b4);
        b4 = nh(a4, e4, d3);
        null !== b4 && (gi(b4, a4, d3, c4), oh(b4, a4, d3));
      } };
      function Fi(a4, b4, c4, d3, e4, f3, g3) {
        a4 = a4.stateNode;
        return "function" === typeof a4.shouldComponentUpdate ? a4.shouldComponentUpdate(d3, f3, g3) : b4.prototype && b4.prototype.isPureReactComponent ? !Ie2(c4, d3) || !Ie2(e4, f3) : true;
      }
      function Gi(a4, b4, c4) {
        var d3 = false, e4 = Vf;
        var f3 = b4.contextType;
        "object" === typeof f3 && null !== f3 ? f3 = eh(f3) : (e4 = Zf(b4) ? Xf : H2.current, d3 = b4.contextTypes, f3 = (d3 = null !== d3 && void 0 !== d3) ? Yf(a4, e4) : Vf);
        b4 = new b4(c4, f3);
        a4.memoizedState = null !== b4.state && void 0 !== b4.state ? b4.state : null;
        b4.updater = Ei;
        a4.stateNode = b4;
        b4._reactInternals = a4;
        d3 && (a4 = a4.stateNode, a4.__reactInternalMemoizedUnmaskedChildContext = e4, a4.__reactInternalMemoizedMaskedChildContext = f3);
        return b4;
      }
      function Hi(a4, b4, c4, d3) {
        a4 = b4.state;
        "function" === typeof b4.componentWillReceiveProps && b4.componentWillReceiveProps(c4, d3);
        "function" === typeof b4.UNSAFE_componentWillReceiveProps && b4.UNSAFE_componentWillReceiveProps(c4, d3);
        b4.state !== a4 && Ei.enqueueReplaceState(b4, b4.state, null);
      }
      function Ii(a4, b4, c4, d3) {
        var e4 = a4.stateNode;
        e4.props = c4;
        e4.state = a4.memoizedState;
        e4.refs = {};
        kh(a4);
        var f3 = b4.contextType;
        "object" === typeof f3 && null !== f3 ? e4.context = eh(f3) : (f3 = Zf(b4) ? Xf : H2.current, e4.context = Yf(a4, f3));
        e4.state = a4.memoizedState;
        f3 = b4.getDerivedStateFromProps;
        "function" === typeof f3 && (Di(a4, b4, f3, c4), e4.state = a4.memoizedState);
        "function" === typeof b4.getDerivedStateFromProps || "function" === typeof e4.getSnapshotBeforeUpdate || "function" !== typeof e4.UNSAFE_componentWillMount && "function" !== typeof e4.componentWillMount || (b4 = e4.state, "function" === typeof e4.componentWillMount && e4.componentWillMount(), "function" === typeof e4.UNSAFE_componentWillMount && e4.UNSAFE_componentWillMount(), b4 !== e4.state && Ei.enqueueReplaceState(e4, e4.state, null), qh(a4, c4, e4, d3), e4.state = a4.memoizedState);
        "function" === typeof e4.componentDidMount && (a4.flags |= 4194308);
      }
      function Ji(a4, b4) {
        try {
          var c4 = "", d3 = b4;
          do
            c4 += Pa(d3), d3 = d3.return;
          while (d3);
          var e4 = c4;
        } catch (f3) {
          e4 = "\nError generating stack: " + f3.message + "\n" + f3.stack;
        }
        return { value: a4, source: b4, stack: e4, digest: null };
      }
      function Ki(a4, b4, c4) {
        return { value: a4, source: null, stack: null != c4 ? c4 : null, digest: null != b4 ? b4 : null };
      }
      function Li(a4, b4) {
        try {
          console.error(b4.value);
        } catch (c4) {
          setTimeout(function() {
            throw c4;
          });
        }
      }
      var Mi = "function" === typeof WeakMap ? WeakMap : Map;
      function Ni(a4, b4, c4) {
        c4 = mh(-1, c4);
        c4.tag = 3;
        c4.payload = { element: null };
        var d3 = b4.value;
        c4.callback = function() {
          Oi || (Oi = true, Pi = d3);
          Li(a4, b4);
        };
        return c4;
      }
      function Qi(a4, b4, c4) {
        c4 = mh(-1, c4);
        c4.tag = 3;
        var d3 = a4.type.getDerivedStateFromError;
        if ("function" === typeof d3) {
          var e4 = b4.value;
          c4.payload = function() {
            return d3(e4);
          };
          c4.callback = function() {
            Li(a4, b4);
          };
        }
        var f3 = a4.stateNode;
        null !== f3 && "function" === typeof f3.componentDidCatch && (c4.callback = function() {
          Li(a4, b4);
          "function" !== typeof d3 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
          var c5 = b4.stack;
          this.componentDidCatch(b4.value, { componentStack: null !== c5 ? c5 : "" });
        });
        return c4;
      }
      function Si(a4, b4, c4) {
        var d3 = a4.pingCache;
        if (null === d3) {
          d3 = a4.pingCache = new Mi();
          var e4 = /* @__PURE__ */ new Set();
          d3.set(b4, e4);
        } else e4 = d3.get(b4), void 0 === e4 && (e4 = /* @__PURE__ */ new Set(), d3.set(b4, e4));
        e4.has(c4) || (e4.add(c4), a4 = Ti.bind(null, a4, b4, c4), b4.then(a4, a4));
      }
      function Ui(a4) {
        do {
          var b4;
          if (b4 = 13 === a4.tag) b4 = a4.memoizedState, b4 = null !== b4 ? null !== b4.dehydrated ? true : false : true;
          if (b4) return a4;
          a4 = a4.return;
        } while (null !== a4);
        return null;
      }
      function Vi(a4, b4, c4, d3, e4) {
        if (0 === (a4.mode & 1)) return a4 === b4 ? a4.flags |= 65536 : (a4.flags |= 128, c4.flags |= 131072, c4.flags &= -52805, 1 === c4.tag && (null === c4.alternate ? c4.tag = 17 : (b4 = mh(-1, 1), b4.tag = 2, nh(c4, b4, 1))), c4.lanes |= 1), a4;
        a4.flags |= 65536;
        a4.lanes = e4;
        return a4;
      }
      var Wi = ua.ReactCurrentOwner;
      var dh = false;
      function Xi(a4, b4, c4, d3) {
        b4.child = null === a4 ? Vg(b4, null, c4, d3) : Ug(b4, a4.child, c4, d3);
      }
      function Yi(a4, b4, c4, d3, e4) {
        c4 = c4.render;
        var f3 = b4.ref;
        ch(b4, e4);
        d3 = Nh(a4, b4, c4, d3, f3, e4);
        c4 = Sh();
        if (null !== a4 && !dh) return b4.updateQueue = a4.updateQueue, b4.flags &= -2053, a4.lanes &= ~e4, Zi(a4, b4, e4);
        I2 && c4 && vg(b4);
        b4.flags |= 1;
        Xi(a4, b4, d3, e4);
        return b4.child;
      }
      function $i(a4, b4, c4, d3, e4) {
        if (null === a4) {
          var f3 = c4.type;
          if ("function" === typeof f3 && !aj(f3) && void 0 === f3.defaultProps && null === c4.compare && void 0 === c4.defaultProps) return b4.tag = 15, b4.type = f3, bj(a4, b4, f3, d3, e4);
          a4 = Rg(c4.type, null, d3, b4, b4.mode, e4);
          a4.ref = b4.ref;
          a4.return = b4;
          return b4.child = a4;
        }
        f3 = a4.child;
        if (0 === (a4.lanes & e4)) {
          var g3 = f3.memoizedProps;
          c4 = c4.compare;
          c4 = null !== c4 ? c4 : Ie2;
          if (c4(g3, d3) && a4.ref === b4.ref) return Zi(a4, b4, e4);
        }
        b4.flags |= 1;
        a4 = Pg(f3, d3);
        a4.ref = b4.ref;
        a4.return = b4;
        return b4.child = a4;
      }
      function bj(a4, b4, c4, d3, e4) {
        if (null !== a4) {
          var f3 = a4.memoizedProps;
          if (Ie2(f3, d3) && a4.ref === b4.ref) if (dh = false, b4.pendingProps = d3 = f3, 0 !== (a4.lanes & e4)) 0 !== (a4.flags & 131072) && (dh = true);
          else return b4.lanes = a4.lanes, Zi(a4, b4, e4);
        }
        return cj(a4, b4, c4, d3, e4);
      }
      function dj(a4, b4, c4) {
        var d3 = b4.pendingProps, e4 = d3.children, f3 = null !== a4 ? a4.memoizedState : null;
        if ("hidden" === d3.mode) if (0 === (b4.mode & 1)) b4.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c4;
        else {
          if (0 === (c4 & 1073741824)) return a4 = null !== f3 ? f3.baseLanes | c4 : c4, b4.lanes = b4.childLanes = 1073741824, b4.memoizedState = { baseLanes: a4, cachePool: null, transitions: null }, b4.updateQueue = null, G(ej, fj), fj |= a4, null;
          b4.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d3 = null !== f3 ? f3.baseLanes : c4;
          G(ej, fj);
          fj |= d3;
        }
        else null !== f3 ? (d3 = f3.baseLanes | c4, b4.memoizedState = null) : d3 = c4, G(ej, fj), fj |= d3;
        Xi(a4, b4, e4, c4);
        return b4.child;
      }
      function gj(a4, b4) {
        var c4 = b4.ref;
        if (null === a4 && null !== c4 || null !== a4 && a4.ref !== c4) b4.flags |= 512, b4.flags |= 2097152;
      }
      function cj(a4, b4, c4, d3, e4) {
        var f3 = Zf(c4) ? Xf : H2.current;
        f3 = Yf(b4, f3);
        ch(b4, e4);
        c4 = Nh(a4, b4, c4, d3, f3, e4);
        d3 = Sh();
        if (null !== a4 && !dh) return b4.updateQueue = a4.updateQueue, b4.flags &= -2053, a4.lanes &= ~e4, Zi(a4, b4, e4);
        I2 && d3 && vg(b4);
        b4.flags |= 1;
        Xi(a4, b4, c4, e4);
        return b4.child;
      }
      function hj(a4, b4, c4, d3, e4) {
        if (Zf(c4)) {
          var f3 = true;
          cg(b4);
        } else f3 = false;
        ch(b4, e4);
        if (null === b4.stateNode) ij(a4, b4), Gi(b4, c4, d3), Ii(b4, c4, d3, e4), d3 = true;
        else if (null === a4) {
          var g3 = b4.stateNode, h4 = b4.memoizedProps;
          g3.props = h4;
          var k2 = g3.context, l4 = c4.contextType;
          "object" === typeof l4 && null !== l4 ? l4 = eh(l4) : (l4 = Zf(c4) ? Xf : H2.current, l4 = Yf(b4, l4));
          var m3 = c4.getDerivedStateFromProps, q2 = "function" === typeof m3 || "function" === typeof g3.getSnapshotBeforeUpdate;
          q2 || "function" !== typeof g3.UNSAFE_componentWillReceiveProps && "function" !== typeof g3.componentWillReceiveProps || (h4 !== d3 || k2 !== l4) && Hi(b4, g3, d3, l4);
          jh = false;
          var r3 = b4.memoizedState;
          g3.state = r3;
          qh(b4, d3, g3, e4);
          k2 = b4.memoizedState;
          h4 !== d3 || r3 !== k2 || Wf.current || jh ? ("function" === typeof m3 && (Di(b4, c4, m3, d3), k2 = b4.memoizedState), (h4 = jh || Fi(b4, c4, h4, d3, r3, k2, l4)) ? (q2 || "function" !== typeof g3.UNSAFE_componentWillMount && "function" !== typeof g3.componentWillMount || ("function" === typeof g3.componentWillMount && g3.componentWillMount(), "function" === typeof g3.UNSAFE_componentWillMount && g3.UNSAFE_componentWillMount()), "function" === typeof g3.componentDidMount && (b4.flags |= 4194308)) : ("function" === typeof g3.componentDidMount && (b4.flags |= 4194308), b4.memoizedProps = d3, b4.memoizedState = k2), g3.props = d3, g3.state = k2, g3.context = l4, d3 = h4) : ("function" === typeof g3.componentDidMount && (b4.flags |= 4194308), d3 = false);
        } else {
          g3 = b4.stateNode;
          lh(a4, b4);
          h4 = b4.memoizedProps;
          l4 = b4.type === b4.elementType ? h4 : Ci(b4.type, h4);
          g3.props = l4;
          q2 = b4.pendingProps;
          r3 = g3.context;
          k2 = c4.contextType;
          "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c4) ? Xf : H2.current, k2 = Yf(b4, k2));
          var y3 = c4.getDerivedStateFromProps;
          (m3 = "function" === typeof y3 || "function" === typeof g3.getSnapshotBeforeUpdate) || "function" !== typeof g3.UNSAFE_componentWillReceiveProps && "function" !== typeof g3.componentWillReceiveProps || (h4 !== q2 || r3 !== k2) && Hi(b4, g3, d3, k2);
          jh = false;
          r3 = b4.memoizedState;
          g3.state = r3;
          qh(b4, d3, g3, e4);
          var n4 = b4.memoizedState;
          h4 !== q2 || r3 !== n4 || Wf.current || jh ? ("function" === typeof y3 && (Di(b4, c4, y3, d3), n4 = b4.memoizedState), (l4 = jh || Fi(b4, c4, l4, d3, r3, n4, k2) || false) ? (m3 || "function" !== typeof g3.UNSAFE_componentWillUpdate && "function" !== typeof g3.componentWillUpdate || ("function" === typeof g3.componentWillUpdate && g3.componentWillUpdate(d3, n4, k2), "function" === typeof g3.UNSAFE_componentWillUpdate && g3.UNSAFE_componentWillUpdate(d3, n4, k2)), "function" === typeof g3.componentDidUpdate && (b4.flags |= 4), "function" === typeof g3.getSnapshotBeforeUpdate && (b4.flags |= 1024)) : ("function" !== typeof g3.componentDidUpdate || h4 === a4.memoizedProps && r3 === a4.memoizedState || (b4.flags |= 4), "function" !== typeof g3.getSnapshotBeforeUpdate || h4 === a4.memoizedProps && r3 === a4.memoizedState || (b4.flags |= 1024), b4.memoizedProps = d3, b4.memoizedState = n4), g3.props = d3, g3.state = n4, g3.context = k2, d3 = l4) : ("function" !== typeof g3.componentDidUpdate || h4 === a4.memoizedProps && r3 === a4.memoizedState || (b4.flags |= 4), "function" !== typeof g3.getSnapshotBeforeUpdate || h4 === a4.memoizedProps && r3 === a4.memoizedState || (b4.flags |= 1024), d3 = false);
        }
        return jj(a4, b4, c4, d3, f3, e4);
      }
      function jj(a4, b4, c4, d3, e4, f3) {
        gj(a4, b4);
        var g3 = 0 !== (b4.flags & 128);
        if (!d3 && !g3) return e4 && dg(b4, c4, false), Zi(a4, b4, f3);
        d3 = b4.stateNode;
        Wi.current = b4;
        var h4 = g3 && "function" !== typeof c4.getDerivedStateFromError ? null : d3.render();
        b4.flags |= 1;
        null !== a4 && g3 ? (b4.child = Ug(b4, a4.child, null, f3), b4.child = Ug(b4, null, h4, f3)) : Xi(a4, b4, h4, f3);
        b4.memoizedState = d3.state;
        e4 && dg(b4, c4, true);
        return b4.child;
      }
      function kj(a4) {
        var b4 = a4.stateNode;
        b4.pendingContext ? ag(a4, b4.pendingContext, b4.pendingContext !== b4.context) : b4.context && ag(a4, b4.context, false);
        yh(a4, b4.containerInfo);
      }
      function lj(a4, b4, c4, d3, e4) {
        Ig();
        Jg(e4);
        b4.flags |= 256;
        Xi(a4, b4, c4, d3);
        return b4.child;
      }
      var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
      function nj(a4) {
        return { baseLanes: a4, cachePool: null, transitions: null };
      }
      function oj(a4, b4, c4) {
        var d3 = b4.pendingProps, e4 = L2.current, f3 = false, g3 = 0 !== (b4.flags & 128), h4;
        (h4 = g3) || (h4 = null !== a4 && null === a4.memoizedState ? false : 0 !== (e4 & 2));
        if (h4) f3 = true, b4.flags &= -129;
        else if (null === a4 || null !== a4.memoizedState) e4 |= 1;
        G(L2, e4 & 1);
        if (null === a4) {
          Eg(b4);
          a4 = b4.memoizedState;
          if (null !== a4 && (a4 = a4.dehydrated, null !== a4)) return 0 === (b4.mode & 1) ? b4.lanes = 1 : "$!" === a4.data ? b4.lanes = 8 : b4.lanes = 1073741824, null;
          g3 = d3.children;
          a4 = d3.fallback;
          return f3 ? (d3 = b4.mode, f3 = b4.child, g3 = { mode: "hidden", children: g3 }, 0 === (d3 & 1) && null !== f3 ? (f3.childLanes = 0, f3.pendingProps = g3) : f3 = pj(g3, d3, 0, null), a4 = Tg(a4, d3, c4, null), f3.return = b4, a4.return = b4, f3.sibling = a4, b4.child = f3, b4.child.memoizedState = nj(c4), b4.memoizedState = mj, a4) : qj(b4, g3);
        }
        e4 = a4.memoizedState;
        if (null !== e4 && (h4 = e4.dehydrated, null !== h4)) return rj(a4, b4, g3, d3, h4, e4, c4);
        if (f3) {
          f3 = d3.fallback;
          g3 = b4.mode;
          e4 = a4.child;
          h4 = e4.sibling;
          var k2 = { mode: "hidden", children: d3.children };
          0 === (g3 & 1) && b4.child !== e4 ? (d3 = b4.child, d3.childLanes = 0, d3.pendingProps = k2, b4.deletions = null) : (d3 = Pg(e4, k2), d3.subtreeFlags = e4.subtreeFlags & 14680064);
          null !== h4 ? f3 = Pg(h4, f3) : (f3 = Tg(f3, g3, c4, null), f3.flags |= 2);
          f3.return = b4;
          d3.return = b4;
          d3.sibling = f3;
          b4.child = d3;
          d3 = f3;
          f3 = b4.child;
          g3 = a4.child.memoizedState;
          g3 = null === g3 ? nj(c4) : { baseLanes: g3.baseLanes | c4, cachePool: null, transitions: g3.transitions };
          f3.memoizedState = g3;
          f3.childLanes = a4.childLanes & ~c4;
          b4.memoizedState = mj;
          return d3;
        }
        f3 = a4.child;
        a4 = f3.sibling;
        d3 = Pg(f3, { mode: "visible", children: d3.children });
        0 === (b4.mode & 1) && (d3.lanes = c4);
        d3.return = b4;
        d3.sibling = null;
        null !== a4 && (c4 = b4.deletions, null === c4 ? (b4.deletions = [a4], b4.flags |= 16) : c4.push(a4));
        b4.child = d3;
        b4.memoizedState = null;
        return d3;
      }
      function qj(a4, b4) {
        b4 = pj({ mode: "visible", children: b4 }, a4.mode, 0, null);
        b4.return = a4;
        return a4.child = b4;
      }
      function sj(a4, b4, c4, d3) {
        null !== d3 && Jg(d3);
        Ug(b4, a4.child, null, c4);
        a4 = qj(b4, b4.pendingProps.children);
        a4.flags |= 2;
        b4.memoizedState = null;
        return a4;
      }
      function rj(a4, b4, c4, d3, e4, f3, g3) {
        if (c4) {
          if (b4.flags & 256) return b4.flags &= -257, d3 = Ki(Error(p4(422))), sj(a4, b4, g3, d3);
          if (null !== b4.memoizedState) return b4.child = a4.child, b4.flags |= 128, null;
          f3 = d3.fallback;
          e4 = b4.mode;
          d3 = pj({ mode: "visible", children: d3.children }, e4, 0, null);
          f3 = Tg(f3, e4, g3, null);
          f3.flags |= 2;
          d3.return = b4;
          f3.return = b4;
          d3.sibling = f3;
          b4.child = d3;
          0 !== (b4.mode & 1) && Ug(b4, a4.child, null, g3);
          b4.child.memoizedState = nj(g3);
          b4.memoizedState = mj;
          return f3;
        }
        if (0 === (b4.mode & 1)) return sj(a4, b4, g3, null);
        if ("$!" === e4.data) {
          d3 = e4.nextSibling && e4.nextSibling.dataset;
          if (d3) var h4 = d3.dgst;
          d3 = h4;
          f3 = Error(p4(419));
          d3 = Ki(f3, d3, void 0);
          return sj(a4, b4, g3, d3);
        }
        h4 = 0 !== (g3 & a4.childLanes);
        if (dh || h4) {
          d3 = Q2;
          if (null !== d3) {
            switch (g3 & -g3) {
              case 4:
                e4 = 2;
                break;
              case 16:
                e4 = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                e4 = 32;
                break;
              case 536870912:
                e4 = 268435456;
                break;
              default:
                e4 = 0;
            }
            e4 = 0 !== (e4 & (d3.suspendedLanes | g3)) ? 0 : e4;
            0 !== e4 && e4 !== f3.retryLane && (f3.retryLane = e4, ih(a4, e4), gi(d3, a4, e4, -1));
          }
          tj();
          d3 = Ki(Error(p4(421)));
          return sj(a4, b4, g3, d3);
        }
        if ("$?" === e4.data) return b4.flags |= 128, b4.child = a4.child, b4 = uj.bind(null, a4), e4._reactRetry = b4, null;
        a4 = f3.treeContext;
        yg = Lf(e4.nextSibling);
        xg = b4;
        I2 = true;
        zg = null;
        null !== a4 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a4.id, sg = a4.overflow, qg = b4);
        b4 = qj(b4, d3.children);
        b4.flags |= 4096;
        return b4;
      }
      function vj(a4, b4, c4) {
        a4.lanes |= b4;
        var d3 = a4.alternate;
        null !== d3 && (d3.lanes |= b4);
        bh(a4.return, b4, c4);
      }
      function wj(a4, b4, c4, d3, e4) {
        var f3 = a4.memoizedState;
        null === f3 ? a4.memoizedState = { isBackwards: b4, rendering: null, renderingStartTime: 0, last: d3, tail: c4, tailMode: e4 } : (f3.isBackwards = b4, f3.rendering = null, f3.renderingStartTime = 0, f3.last = d3, f3.tail = c4, f3.tailMode = e4);
      }
      function xj(a4, b4, c4) {
        var d3 = b4.pendingProps, e4 = d3.revealOrder, f3 = d3.tail;
        Xi(a4, b4, d3.children, c4);
        d3 = L2.current;
        if (0 !== (d3 & 2)) d3 = d3 & 1 | 2, b4.flags |= 128;
        else {
          if (null !== a4 && 0 !== (a4.flags & 128)) a: for (a4 = b4.child; null !== a4; ) {
            if (13 === a4.tag) null !== a4.memoizedState && vj(a4, c4, b4);
            else if (19 === a4.tag) vj(a4, c4, b4);
            else if (null !== a4.child) {
              a4.child.return = a4;
              a4 = a4.child;
              continue;
            }
            if (a4 === b4) break a;
            for (; null === a4.sibling; ) {
              if (null === a4.return || a4.return === b4) break a;
              a4 = a4.return;
            }
            a4.sibling.return = a4.return;
            a4 = a4.sibling;
          }
          d3 &= 1;
        }
        G(L2, d3);
        if (0 === (b4.mode & 1)) b4.memoizedState = null;
        else switch (e4) {
          case "forwards":
            c4 = b4.child;
            for (e4 = null; null !== c4; ) a4 = c4.alternate, null !== a4 && null === Ch(a4) && (e4 = c4), c4 = c4.sibling;
            c4 = e4;
            null === c4 ? (e4 = b4.child, b4.child = null) : (e4 = c4.sibling, c4.sibling = null);
            wj(b4, false, e4, c4, f3);
            break;
          case "backwards":
            c4 = null;
            e4 = b4.child;
            for (b4.child = null; null !== e4; ) {
              a4 = e4.alternate;
              if (null !== a4 && null === Ch(a4)) {
                b4.child = e4;
                break;
              }
              a4 = e4.sibling;
              e4.sibling = c4;
              c4 = e4;
              e4 = a4;
            }
            wj(b4, true, c4, null, f3);
            break;
          case "together":
            wj(b4, false, null, null, void 0);
            break;
          default:
            b4.memoizedState = null;
        }
        return b4.child;
      }
      function ij(a4, b4) {
        0 === (b4.mode & 1) && null !== a4 && (a4.alternate = null, b4.alternate = null, b4.flags |= 2);
      }
      function Zi(a4, b4, c4) {
        null !== a4 && (b4.dependencies = a4.dependencies);
        rh |= b4.lanes;
        if (0 === (c4 & b4.childLanes)) return null;
        if (null !== a4 && b4.child !== a4.child) throw Error(p4(153));
        if (null !== b4.child) {
          a4 = b4.child;
          c4 = Pg(a4, a4.pendingProps);
          b4.child = c4;
          for (c4.return = b4; null !== a4.sibling; ) a4 = a4.sibling, c4 = c4.sibling = Pg(a4, a4.pendingProps), c4.return = b4;
          c4.sibling = null;
        }
        return b4.child;
      }
      function yj(a4, b4, c4) {
        switch (b4.tag) {
          case 3:
            kj(b4);
            Ig();
            break;
          case 5:
            Ah(b4);
            break;
          case 1:
            Zf(b4.type) && cg(b4);
            break;
          case 4:
            yh(b4, b4.stateNode.containerInfo);
            break;
          case 10:
            var d3 = b4.type._context, e4 = b4.memoizedProps.value;
            G(Wg, d3._currentValue);
            d3._currentValue = e4;
            break;
          case 13:
            d3 = b4.memoizedState;
            if (null !== d3) {
              if (null !== d3.dehydrated) return G(L2, L2.current & 1), b4.flags |= 128, null;
              if (0 !== (c4 & b4.child.childLanes)) return oj(a4, b4, c4);
              G(L2, L2.current & 1);
              a4 = Zi(a4, b4, c4);
              return null !== a4 ? a4.sibling : null;
            }
            G(L2, L2.current & 1);
            break;
          case 19:
            d3 = 0 !== (c4 & b4.childLanes);
            if (0 !== (a4.flags & 128)) {
              if (d3) return xj(a4, b4, c4);
              b4.flags |= 128;
            }
            e4 = b4.memoizedState;
            null !== e4 && (e4.rendering = null, e4.tail = null, e4.lastEffect = null);
            G(L2, L2.current);
            if (d3) break;
            else return null;
          case 22:
          case 23:
            return b4.lanes = 0, dj(a4, b4, c4);
        }
        return Zi(a4, b4, c4);
      }
      var zj;
      var Aj;
      var Bj;
      var Cj;
      zj = function(a4, b4) {
        for (var c4 = b4.child; null !== c4; ) {
          if (5 === c4.tag || 6 === c4.tag) a4.appendChild(c4.stateNode);
          else if (4 !== c4.tag && null !== c4.child) {
            c4.child.return = c4;
            c4 = c4.child;
            continue;
          }
          if (c4 === b4) break;
          for (; null === c4.sibling; ) {
            if (null === c4.return || c4.return === b4) return;
            c4 = c4.return;
          }
          c4.sibling.return = c4.return;
          c4 = c4.sibling;
        }
      };
      Aj = function() {
      };
      Bj = function(a4, b4, c4, d3) {
        var e4 = a4.memoizedProps;
        if (e4 !== d3) {
          a4 = b4.stateNode;
          xh(uh.current);
          var f3 = null;
          switch (c4) {
            case "input":
              e4 = Ya(a4, e4);
              d3 = Ya(a4, d3);
              f3 = [];
              break;
            case "select":
              e4 = A({}, e4, { value: void 0 });
              d3 = A({}, d3, { value: void 0 });
              f3 = [];
              break;
            case "textarea":
              e4 = gb(a4, e4);
              d3 = gb(a4, d3);
              f3 = [];
              break;
            default:
              "function" !== typeof e4.onClick && "function" === typeof d3.onClick && (a4.onclick = Bf);
          }
          ub(c4, d3);
          var g3;
          c4 = null;
          for (l4 in e4) if (!d3.hasOwnProperty(l4) && e4.hasOwnProperty(l4) && null != e4[l4]) if ("style" === l4) {
            var h4 = e4[l4];
            for (g3 in h4) h4.hasOwnProperty(g3) && (c4 || (c4 = {}), c4[g3] = "");
          } else "dangerouslySetInnerHTML" !== l4 && "children" !== l4 && "suppressContentEditableWarning" !== l4 && "suppressHydrationWarning" !== l4 && "autoFocus" !== l4 && (ea.hasOwnProperty(l4) ? f3 || (f3 = []) : (f3 = f3 || []).push(l4, null));
          for (l4 in d3) {
            var k2 = d3[l4];
            h4 = null != e4 ? e4[l4] : void 0;
            if (d3.hasOwnProperty(l4) && k2 !== h4 && (null != k2 || null != h4)) if ("style" === l4) if (h4) {
              for (g3 in h4) !h4.hasOwnProperty(g3) || k2 && k2.hasOwnProperty(g3) || (c4 || (c4 = {}), c4[g3] = "");
              for (g3 in k2) k2.hasOwnProperty(g3) && h4[g3] !== k2[g3] && (c4 || (c4 = {}), c4[g3] = k2[g3]);
            } else c4 || (f3 || (f3 = []), f3.push(
              l4,
              c4
            )), c4 = k2;
            else "dangerouslySetInnerHTML" === l4 ? (k2 = k2 ? k2.__html : void 0, h4 = h4 ? h4.__html : void 0, null != k2 && h4 !== k2 && (f3 = f3 || []).push(l4, k2)) : "children" === l4 ? "string" !== typeof k2 && "number" !== typeof k2 || (f3 = f3 || []).push(l4, "" + k2) : "suppressContentEditableWarning" !== l4 && "suppressHydrationWarning" !== l4 && (ea.hasOwnProperty(l4) ? (null != k2 && "onScroll" === l4 && D("scroll", a4), f3 || h4 === k2 || (f3 = [])) : (f3 = f3 || []).push(l4, k2));
          }
          c4 && (f3 = f3 || []).push("style", c4);
          var l4 = f3;
          if (b4.updateQueue = l4) b4.flags |= 4;
        }
      };
      Cj = function(a4, b4, c4, d3) {
        c4 !== d3 && (b4.flags |= 4);
      };
      function Dj(a4, b4) {
        if (!I2) switch (a4.tailMode) {
          case "hidden":
            b4 = a4.tail;
            for (var c4 = null; null !== b4; ) null !== b4.alternate && (c4 = b4), b4 = b4.sibling;
            null === c4 ? a4.tail = null : c4.sibling = null;
            break;
          case "collapsed":
            c4 = a4.tail;
            for (var d3 = null; null !== c4; ) null !== c4.alternate && (d3 = c4), c4 = c4.sibling;
            null === d3 ? b4 || null === a4.tail ? a4.tail = null : a4.tail.sibling = null : d3.sibling = null;
        }
      }
      function S2(a4) {
        var b4 = null !== a4.alternate && a4.alternate.child === a4.child, c4 = 0, d3 = 0;
        if (b4) for (var e4 = a4.child; null !== e4; ) c4 |= e4.lanes | e4.childLanes, d3 |= e4.subtreeFlags & 14680064, d3 |= e4.flags & 14680064, e4.return = a4, e4 = e4.sibling;
        else for (e4 = a4.child; null !== e4; ) c4 |= e4.lanes | e4.childLanes, d3 |= e4.subtreeFlags, d3 |= e4.flags, e4.return = a4, e4 = e4.sibling;
        a4.subtreeFlags |= d3;
        a4.childLanes = c4;
        return b4;
      }
      function Ej(a4, b4, c4) {
        var d3 = b4.pendingProps;
        wg(b4);
        switch (b4.tag) {
          case 2:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return S2(b4), null;
          case 1:
            return Zf(b4.type) && $f(), S2(b4), null;
          case 3:
            d3 = b4.stateNode;
            zh();
            E(Wf);
            E(H2);
            Eh();
            d3.pendingContext && (d3.context = d3.pendingContext, d3.pendingContext = null);
            if (null === a4 || null === a4.child) Gg(b4) ? b4.flags |= 4 : null === a4 || a4.memoizedState.isDehydrated && 0 === (b4.flags & 256) || (b4.flags |= 1024, null !== zg && (Fj(zg), zg = null));
            Aj(a4, b4);
            S2(b4);
            return null;
          case 5:
            Bh(b4);
            var e4 = xh(wh.current);
            c4 = b4.type;
            if (null !== a4 && null != b4.stateNode) Bj(a4, b4, c4, d3, e4), a4.ref !== b4.ref && (b4.flags |= 512, b4.flags |= 2097152);
            else {
              if (!d3) {
                if (null === b4.stateNode) throw Error(p4(166));
                S2(b4);
                return null;
              }
              a4 = xh(uh.current);
              if (Gg(b4)) {
                d3 = b4.stateNode;
                c4 = b4.type;
                var f3 = b4.memoizedProps;
                d3[Of] = b4;
                d3[Pf] = f3;
                a4 = 0 !== (b4.mode & 1);
                switch (c4) {
                  case "dialog":
                    D("cancel", d3);
                    D("close", d3);
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", d3);
                    break;
                  case "video":
                  case "audio":
                    for (e4 = 0; e4 < lf.length; e4++) D(lf[e4], d3);
                    break;
                  case "source":
                    D("error", d3);
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      d3
                    );
                    D("load", d3);
                    break;
                  case "details":
                    D("toggle", d3);
                    break;
                  case "input":
                    Za(d3, f3);
                    D("invalid", d3);
                    break;
                  case "select":
                    d3._wrapperState = { wasMultiple: !!f3.multiple };
                    D("invalid", d3);
                    break;
                  case "textarea":
                    hb(d3, f3), D("invalid", d3);
                }
                ub(c4, f3);
                e4 = null;
                for (var g3 in f3) if (f3.hasOwnProperty(g3)) {
                  var h4 = f3[g3];
                  "children" === g3 ? "string" === typeof h4 ? d3.textContent !== h4 && (true !== f3.suppressHydrationWarning && Af(d3.textContent, h4, a4), e4 = ["children", h4]) : "number" === typeof h4 && d3.textContent !== "" + h4 && (true !== f3.suppressHydrationWarning && Af(
                    d3.textContent,
                    h4,
                    a4
                  ), e4 = ["children", "" + h4]) : ea.hasOwnProperty(g3) && null != h4 && "onScroll" === g3 && D("scroll", d3);
                }
                switch (c4) {
                  case "input":
                    Va(d3);
                    db(d3, f3, true);
                    break;
                  case "textarea":
                    Va(d3);
                    jb(d3);
                    break;
                  case "select":
                  case "option":
                    break;
                  default:
                    "function" === typeof f3.onClick && (d3.onclick = Bf);
                }
                d3 = e4;
                b4.updateQueue = d3;
                null !== d3 && (b4.flags |= 4);
              } else {
                g3 = 9 === e4.nodeType ? e4 : e4.ownerDocument;
                "http://www.w3.org/1999/xhtml" === a4 && (a4 = kb(c4));
                "http://www.w3.org/1999/xhtml" === a4 ? "script" === c4 ? (a4 = g3.createElement("div"), a4.innerHTML = "<script><\/script>", a4 = a4.removeChild(a4.firstChild)) : "string" === typeof d3.is ? a4 = g3.createElement(c4, { is: d3.is }) : (a4 = g3.createElement(c4), "select" === c4 && (g3 = a4, d3.multiple ? g3.multiple = true : d3.size && (g3.size = d3.size))) : a4 = g3.createElementNS(a4, c4);
                a4[Of] = b4;
                a4[Pf] = d3;
                zj(a4, b4, false, false);
                b4.stateNode = a4;
                a: {
                  g3 = vb(c4, d3);
                  switch (c4) {
                    case "dialog":
                      D("cancel", a4);
                      D("close", a4);
                      e4 = d3;
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      D("load", a4);
                      e4 = d3;
                      break;
                    case "video":
                    case "audio":
                      for (e4 = 0; e4 < lf.length; e4++) D(lf[e4], a4);
                      e4 = d3;
                      break;
                    case "source":
                      D("error", a4);
                      e4 = d3;
                      break;
                    case "img":
                    case "image":
                    case "link":
                      D(
                        "error",
                        a4
                      );
                      D("load", a4);
                      e4 = d3;
                      break;
                    case "details":
                      D("toggle", a4);
                      e4 = d3;
                      break;
                    case "input":
                      Za(a4, d3);
                      e4 = Ya(a4, d3);
                      D("invalid", a4);
                      break;
                    case "option":
                      e4 = d3;
                      break;
                    case "select":
                      a4._wrapperState = { wasMultiple: !!d3.multiple };
                      e4 = A({}, d3, { value: void 0 });
                      D("invalid", a4);
                      break;
                    case "textarea":
                      hb(a4, d3);
                      e4 = gb(a4, d3);
                      D("invalid", a4);
                      break;
                    default:
                      e4 = d3;
                  }
                  ub(c4, e4);
                  h4 = e4;
                  for (f3 in h4) if (h4.hasOwnProperty(f3)) {
                    var k2 = h4[f3];
                    "style" === f3 ? sb(a4, k2) : "dangerouslySetInnerHTML" === f3 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a4, k2)) : "children" === f3 ? "string" === typeof k2 ? ("textarea" !== c4 || "" !== k2) && ob(a4, k2) : "number" === typeof k2 && ob(a4, "" + k2) : "suppressContentEditableWarning" !== f3 && "suppressHydrationWarning" !== f3 && "autoFocus" !== f3 && (ea.hasOwnProperty(f3) ? null != k2 && "onScroll" === f3 && D("scroll", a4) : null != k2 && ta(a4, f3, k2, g3));
                  }
                  switch (c4) {
                    case "input":
                      Va(a4);
                      db(a4, d3, false);
                      break;
                    case "textarea":
                      Va(a4);
                      jb(a4);
                      break;
                    case "option":
                      null != d3.value && a4.setAttribute("value", "" + Sa(d3.value));
                      break;
                    case "select":
                      a4.multiple = !!d3.multiple;
                      f3 = d3.value;
                      null != f3 ? fb(a4, !!d3.multiple, f3, false) : null != d3.defaultValue && fb(
                        a4,
                        !!d3.multiple,
                        d3.defaultValue,
                        true
                      );
                      break;
                    default:
                      "function" === typeof e4.onClick && (a4.onclick = Bf);
                  }
                  switch (c4) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      d3 = !!d3.autoFocus;
                      break a;
                    case "img":
                      d3 = true;
                      break a;
                    default:
                      d3 = false;
                  }
                }
                d3 && (b4.flags |= 4);
              }
              null !== b4.ref && (b4.flags |= 512, b4.flags |= 2097152);
            }
            S2(b4);
            return null;
          case 6:
            if (a4 && null != b4.stateNode) Cj(a4, b4, a4.memoizedProps, d3);
            else {
              if ("string" !== typeof d3 && null === b4.stateNode) throw Error(p4(166));
              c4 = xh(wh.current);
              xh(uh.current);
              if (Gg(b4)) {
                d3 = b4.stateNode;
                c4 = b4.memoizedProps;
                d3[Of] = b4;
                if (f3 = d3.nodeValue !== c4) {
                  if (a4 = xg, null !== a4) switch (a4.tag) {
                    case 3:
                      Af(d3.nodeValue, c4, 0 !== (a4.mode & 1));
                      break;
                    case 5:
                      true !== a4.memoizedProps.suppressHydrationWarning && Af(d3.nodeValue, c4, 0 !== (a4.mode & 1));
                  }
                }
                f3 && (b4.flags |= 4);
              } else d3 = (9 === c4.nodeType ? c4 : c4.ownerDocument).createTextNode(d3), d3[Of] = b4, b4.stateNode = d3;
            }
            S2(b4);
            return null;
          case 13:
            E(L2);
            d3 = b4.memoizedState;
            if (null === a4 || null !== a4.memoizedState && null !== a4.memoizedState.dehydrated) {
              if (I2 && null !== yg && 0 !== (b4.mode & 1) && 0 === (b4.flags & 128)) Hg(), Ig(), b4.flags |= 98560, f3 = false;
              else if (f3 = Gg(b4), null !== d3 && null !== d3.dehydrated) {
                if (null === a4) {
                  if (!f3) throw Error(p4(318));
                  f3 = b4.memoizedState;
                  f3 = null !== f3 ? f3.dehydrated : null;
                  if (!f3) throw Error(p4(317));
                  f3[Of] = b4;
                } else Ig(), 0 === (b4.flags & 128) && (b4.memoizedState = null), b4.flags |= 4;
                S2(b4);
                f3 = false;
              } else null !== zg && (Fj(zg), zg = null), f3 = true;
              if (!f3) return b4.flags & 65536 ? b4 : null;
            }
            if (0 !== (b4.flags & 128)) return b4.lanes = c4, b4;
            d3 = null !== d3;
            d3 !== (null !== a4 && null !== a4.memoizedState) && d3 && (b4.child.flags |= 8192, 0 !== (b4.mode & 1) && (null === a4 || 0 !== (L2.current & 1) ? 0 === T2 && (T2 = 3) : tj()));
            null !== b4.updateQueue && (b4.flags |= 4);
            S2(b4);
            return null;
          case 4:
            return zh(), Aj(a4, b4), null === a4 && sf(b4.stateNode.containerInfo), S2(b4), null;
          case 10:
            return ah(b4.type._context), S2(b4), null;
          case 17:
            return Zf(b4.type) && $f(), S2(b4), null;
          case 19:
            E(L2);
            f3 = b4.memoizedState;
            if (null === f3) return S2(b4), null;
            d3 = 0 !== (b4.flags & 128);
            g3 = f3.rendering;
            if (null === g3) if (d3) Dj(f3, false);
            else {
              if (0 !== T2 || null !== a4 && 0 !== (a4.flags & 128)) for (a4 = b4.child; null !== a4; ) {
                g3 = Ch(a4);
                if (null !== g3) {
                  b4.flags |= 128;
                  Dj(f3, false);
                  d3 = g3.updateQueue;
                  null !== d3 && (b4.updateQueue = d3, b4.flags |= 4);
                  b4.subtreeFlags = 0;
                  d3 = c4;
                  for (c4 = b4.child; null !== c4; ) f3 = c4, a4 = d3, f3.flags &= 14680066, g3 = f3.alternate, null === g3 ? (f3.childLanes = 0, f3.lanes = a4, f3.child = null, f3.subtreeFlags = 0, f3.memoizedProps = null, f3.memoizedState = null, f3.updateQueue = null, f3.dependencies = null, f3.stateNode = null) : (f3.childLanes = g3.childLanes, f3.lanes = g3.lanes, f3.child = g3.child, f3.subtreeFlags = 0, f3.deletions = null, f3.memoizedProps = g3.memoizedProps, f3.memoizedState = g3.memoizedState, f3.updateQueue = g3.updateQueue, f3.type = g3.type, a4 = g3.dependencies, f3.dependencies = null === a4 ? null : { lanes: a4.lanes, firstContext: a4.firstContext }), c4 = c4.sibling;
                  G(L2, L2.current & 1 | 2);
                  return b4.child;
                }
                a4 = a4.sibling;
              }
              null !== f3.tail && B() > Gj && (b4.flags |= 128, d3 = true, Dj(f3, false), b4.lanes = 4194304);
            }
            else {
              if (!d3) if (a4 = Ch(g3), null !== a4) {
                if (b4.flags |= 128, d3 = true, c4 = a4.updateQueue, null !== c4 && (b4.updateQueue = c4, b4.flags |= 4), Dj(f3, true), null === f3.tail && "hidden" === f3.tailMode && !g3.alternate && !I2) return S2(b4), null;
              } else 2 * B() - f3.renderingStartTime > Gj && 1073741824 !== c4 && (b4.flags |= 128, d3 = true, Dj(f3, false), b4.lanes = 4194304);
              f3.isBackwards ? (g3.sibling = b4.child, b4.child = g3) : (c4 = f3.last, null !== c4 ? c4.sibling = g3 : b4.child = g3, f3.last = g3);
            }
            if (null !== f3.tail) return b4 = f3.tail, f3.rendering = b4, f3.tail = b4.sibling, f3.renderingStartTime = B(), b4.sibling = null, c4 = L2.current, G(L2, d3 ? c4 & 1 | 2 : c4 & 1), b4;
            S2(b4);
            return null;
          case 22:
          case 23:
            return Hj(), d3 = null !== b4.memoizedState, null !== a4 && null !== a4.memoizedState !== d3 && (b4.flags |= 8192), d3 && 0 !== (b4.mode & 1) ? 0 !== (fj & 1073741824) && (S2(b4), b4.subtreeFlags & 6 && (b4.flags |= 8192)) : S2(b4), null;
          case 24:
            return null;
          case 25:
            return null;
        }
        throw Error(p4(156, b4.tag));
      }
      function Ij(a4, b4) {
        wg(b4);
        switch (b4.tag) {
          case 1:
            return Zf(b4.type) && $f(), a4 = b4.flags, a4 & 65536 ? (b4.flags = a4 & -65537 | 128, b4) : null;
          case 3:
            return zh(), E(Wf), E(H2), Eh(), a4 = b4.flags, 0 !== (a4 & 65536) && 0 === (a4 & 128) ? (b4.flags = a4 & -65537 | 128, b4) : null;
          case 5:
            return Bh(b4), null;
          case 13:
            E(L2);
            a4 = b4.memoizedState;
            if (null !== a4 && null !== a4.dehydrated) {
              if (null === b4.alternate) throw Error(p4(340));
              Ig();
            }
            a4 = b4.flags;
            return a4 & 65536 ? (b4.flags = a4 & -65537 | 128, b4) : null;
          case 19:
            return E(L2), null;
          case 4:
            return zh(), null;
          case 10:
            return ah(b4.type._context), null;
          case 22:
          case 23:
            return Hj(), null;
          case 24:
            return null;
          default:
            return null;
        }
      }
      var Jj = false;
      var U = false;
      var Kj = "function" === typeof WeakSet ? WeakSet : Set;
      var V2 = null;
      function Lj(a4, b4) {
        var c4 = a4.ref;
        if (null !== c4) if ("function" === typeof c4) try {
          c4(null);
        } catch (d3) {
          W(a4, b4, d3);
        }
        else c4.current = null;
      }
      function Mj(a4, b4, c4) {
        try {
          c4();
        } catch (d3) {
          W(a4, b4, d3);
        }
      }
      var Nj = false;
      function Oj(a4, b4) {
        Cf = dd;
        a4 = Me();
        if (Ne(a4)) {
          if ("selectionStart" in a4) var c4 = { start: a4.selectionStart, end: a4.selectionEnd };
          else a: {
            c4 = (c4 = a4.ownerDocument) && c4.defaultView || window;
            var d3 = c4.getSelection && c4.getSelection();
            if (d3 && 0 !== d3.rangeCount) {
              c4 = d3.anchorNode;
              var e4 = d3.anchorOffset, f3 = d3.focusNode;
              d3 = d3.focusOffset;
              try {
                c4.nodeType, f3.nodeType;
              } catch (F2) {
                c4 = null;
                break a;
              }
              var g3 = 0, h4 = -1, k2 = -1, l4 = 0, m3 = 0, q2 = a4, r3 = null;
              b: for (; ; ) {
                for (var y3; ; ) {
                  q2 !== c4 || 0 !== e4 && 3 !== q2.nodeType || (h4 = g3 + e4);
                  q2 !== f3 || 0 !== d3 && 3 !== q2.nodeType || (k2 = g3 + d3);
                  3 === q2.nodeType && (g3 += q2.nodeValue.length);
                  if (null === (y3 = q2.firstChild)) break;
                  r3 = q2;
                  q2 = y3;
                }
                for (; ; ) {
                  if (q2 === a4) break b;
                  r3 === c4 && ++l4 === e4 && (h4 = g3);
                  r3 === f3 && ++m3 === d3 && (k2 = g3);
                  if (null !== (y3 = q2.nextSibling)) break;
                  q2 = r3;
                  r3 = q2.parentNode;
                }
                q2 = y3;
              }
              c4 = -1 === h4 || -1 === k2 ? null : { start: h4, end: k2 };
            } else c4 = null;
          }
          c4 = c4 || { start: 0, end: 0 };
        } else c4 = null;
        Df = { focusedElem: a4, selectionRange: c4 };
        dd = false;
        for (V2 = b4; null !== V2; ) if (b4 = V2, a4 = b4.child, 0 !== (b4.subtreeFlags & 1028) && null !== a4) a4.return = b4, V2 = a4;
        else for (; null !== V2; ) {
          b4 = V2;
          try {
            var n4 = b4.alternate;
            if (0 !== (b4.flags & 1024)) switch (b4.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n4) {
                  var t5 = n4.memoizedProps, J2 = n4.memoizedState, x2 = b4.stateNode, w2 = x2.getSnapshotBeforeUpdate(b4.elementType === b4.type ? t5 : Ci(b4.type, t5), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u4 = b4.stateNode.containerInfo;
                1 === u4.nodeType ? u4.textContent = "" : 9 === u4.nodeType && u4.documentElement && u4.removeChild(u4.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p4(163));
            }
          } catch (F2) {
            W(b4, b4.return, F2);
          }
          a4 = b4.sibling;
          if (null !== a4) {
            a4.return = b4.return;
            V2 = a4;
            break;
          }
          V2 = b4.return;
        }
        n4 = Nj;
        Nj = false;
        return n4;
      }
      function Pj(a4, b4, c4) {
        var d3 = b4.updateQueue;
        d3 = null !== d3 ? d3.lastEffect : null;
        if (null !== d3) {
          var e4 = d3 = d3.next;
          do {
            if ((e4.tag & a4) === a4) {
              var f3 = e4.destroy;
              e4.destroy = void 0;
              void 0 !== f3 && Mj(b4, c4, f3);
            }
            e4 = e4.next;
          } while (e4 !== d3);
        }
      }
      function Qj(a4, b4) {
        b4 = b4.updateQueue;
        b4 = null !== b4 ? b4.lastEffect : null;
        if (null !== b4) {
          var c4 = b4 = b4.next;
          do {
            if ((c4.tag & a4) === a4) {
              var d3 = c4.create;
              c4.destroy = d3();
            }
            c4 = c4.next;
          } while (c4 !== b4);
        }
      }
      function Rj(a4) {
        var b4 = a4.ref;
        if (null !== b4) {
          var c4 = a4.stateNode;
          switch (a4.tag) {
            case 5:
              a4 = c4;
              break;
            default:
              a4 = c4;
          }
          "function" === typeof b4 ? b4(a4) : b4.current = a4;
        }
      }
      function Sj(a4) {
        var b4 = a4.alternate;
        null !== b4 && (a4.alternate = null, Sj(b4));
        a4.child = null;
        a4.deletions = null;
        a4.sibling = null;
        5 === a4.tag && (b4 = a4.stateNode, null !== b4 && (delete b4[Of], delete b4[Pf], delete b4[of], delete b4[Qf], delete b4[Rf]));
        a4.stateNode = null;
        a4.return = null;
        a4.dependencies = null;
        a4.memoizedProps = null;
        a4.memoizedState = null;
        a4.pendingProps = null;
        a4.stateNode = null;
        a4.updateQueue = null;
      }
      function Tj(a4) {
        return 5 === a4.tag || 3 === a4.tag || 4 === a4.tag;
      }
      function Uj(a4) {
        a: for (; ; ) {
          for (; null === a4.sibling; ) {
            if (null === a4.return || Tj(a4.return)) return null;
            a4 = a4.return;
          }
          a4.sibling.return = a4.return;
          for (a4 = a4.sibling; 5 !== a4.tag && 6 !== a4.tag && 18 !== a4.tag; ) {
            if (a4.flags & 2) continue a;
            if (null === a4.child || 4 === a4.tag) continue a;
            else a4.child.return = a4, a4 = a4.child;
          }
          if (!(a4.flags & 2)) return a4.stateNode;
        }
      }
      function Vj(a4, b4, c4) {
        var d3 = a4.tag;
        if (5 === d3 || 6 === d3) a4 = a4.stateNode, b4 ? 8 === c4.nodeType ? c4.parentNode.insertBefore(a4, b4) : c4.insertBefore(a4, b4) : (8 === c4.nodeType ? (b4 = c4.parentNode, b4.insertBefore(a4, c4)) : (b4 = c4, b4.appendChild(a4)), c4 = c4._reactRootContainer, null !== c4 && void 0 !== c4 || null !== b4.onclick || (b4.onclick = Bf));
        else if (4 !== d3 && (a4 = a4.child, null !== a4)) for (Vj(a4, b4, c4), a4 = a4.sibling; null !== a4; ) Vj(a4, b4, c4), a4 = a4.sibling;
      }
      function Wj(a4, b4, c4) {
        var d3 = a4.tag;
        if (5 === d3 || 6 === d3) a4 = a4.stateNode, b4 ? c4.insertBefore(a4, b4) : c4.appendChild(a4);
        else if (4 !== d3 && (a4 = a4.child, null !== a4)) for (Wj(a4, b4, c4), a4 = a4.sibling; null !== a4; ) Wj(a4, b4, c4), a4 = a4.sibling;
      }
      var X = null;
      var Xj = false;
      function Yj(a4, b4, c4) {
        for (c4 = c4.child; null !== c4; ) Zj(a4, b4, c4), c4 = c4.sibling;
      }
      function Zj(a4, b4, c4) {
        if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
          lc.onCommitFiberUnmount(kc, c4);
        } catch (h4) {
        }
        switch (c4.tag) {
          case 5:
            U || Lj(c4, b4);
          case 6:
            var d3 = X, e4 = Xj;
            X = null;
            Yj(a4, b4, c4);
            X = d3;
            Xj = e4;
            null !== X && (Xj ? (a4 = X, c4 = c4.stateNode, 8 === a4.nodeType ? a4.parentNode.removeChild(c4) : a4.removeChild(c4)) : X.removeChild(c4.stateNode));
            break;
          case 18:
            null !== X && (Xj ? (a4 = X, c4 = c4.stateNode, 8 === a4.nodeType ? Kf(a4.parentNode, c4) : 1 === a4.nodeType && Kf(a4, c4), bd(a4)) : Kf(X, c4.stateNode));
            break;
          case 4:
            d3 = X;
            e4 = Xj;
            X = c4.stateNode.containerInfo;
            Xj = true;
            Yj(a4, b4, c4);
            X = d3;
            Xj = e4;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            if (!U && (d3 = c4.updateQueue, null !== d3 && (d3 = d3.lastEffect, null !== d3))) {
              e4 = d3 = d3.next;
              do {
                var f3 = e4, g3 = f3.destroy;
                f3 = f3.tag;
                void 0 !== g3 && (0 !== (f3 & 2) ? Mj(c4, b4, g3) : 0 !== (f3 & 4) && Mj(c4, b4, g3));
                e4 = e4.next;
              } while (e4 !== d3);
            }
            Yj(a4, b4, c4);
            break;
          case 1:
            if (!U && (Lj(c4, b4), d3 = c4.stateNode, "function" === typeof d3.componentWillUnmount)) try {
              d3.props = c4.memoizedProps, d3.state = c4.memoizedState, d3.componentWillUnmount();
            } catch (h4) {
              W(c4, b4, h4);
            }
            Yj(a4, b4, c4);
            break;
          case 21:
            Yj(a4, b4, c4);
            break;
          case 22:
            c4.mode & 1 ? (U = (d3 = U) || null !== c4.memoizedState, Yj(a4, b4, c4), U = d3) : Yj(a4, b4, c4);
            break;
          default:
            Yj(a4, b4, c4);
        }
      }
      function ak(a4) {
        var b4 = a4.updateQueue;
        if (null !== b4) {
          a4.updateQueue = null;
          var c4 = a4.stateNode;
          null === c4 && (c4 = a4.stateNode = new Kj());
          b4.forEach(function(b5) {
            var d3 = bk.bind(null, a4, b5);
            c4.has(b5) || (c4.add(b5), b5.then(d3, d3));
          });
        }
      }
      function ck(a4, b4) {
        var c4 = b4.deletions;
        if (null !== c4) for (var d3 = 0; d3 < c4.length; d3++) {
          var e4 = c4[d3];
          try {
            var f3 = a4, g3 = b4, h4 = g3;
            a: for (; null !== h4; ) {
              switch (h4.tag) {
                case 5:
                  X = h4.stateNode;
                  Xj = false;
                  break a;
                case 3:
                  X = h4.stateNode.containerInfo;
                  Xj = true;
                  break a;
                case 4:
                  X = h4.stateNode.containerInfo;
                  Xj = true;
                  break a;
              }
              h4 = h4.return;
            }
            if (null === X) throw Error(p4(160));
            Zj(f3, g3, e4);
            X = null;
            Xj = false;
            var k2 = e4.alternate;
            null !== k2 && (k2.return = null);
            e4.return = null;
          } catch (l4) {
            W(e4, b4, l4);
          }
        }
        if (b4.subtreeFlags & 12854) for (b4 = b4.child; null !== b4; ) dk(b4, a4), b4 = b4.sibling;
      }
      function dk(a4, b4) {
        var c4 = a4.alternate, d3 = a4.flags;
        switch (a4.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            ck(b4, a4);
            ek(a4);
            if (d3 & 4) {
              try {
                Pj(3, a4, a4.return), Qj(3, a4);
              } catch (t5) {
                W(a4, a4.return, t5);
              }
              try {
                Pj(5, a4, a4.return);
              } catch (t5) {
                W(a4, a4.return, t5);
              }
            }
            break;
          case 1:
            ck(b4, a4);
            ek(a4);
            d3 & 512 && null !== c4 && Lj(c4, c4.return);
            break;
          case 5:
            ck(b4, a4);
            ek(a4);
            d3 & 512 && null !== c4 && Lj(c4, c4.return);
            if (a4.flags & 32) {
              var e4 = a4.stateNode;
              try {
                ob(e4, "");
              } catch (t5) {
                W(a4, a4.return, t5);
              }
            }
            if (d3 & 4 && (e4 = a4.stateNode, null != e4)) {
              var f3 = a4.memoizedProps, g3 = null !== c4 ? c4.memoizedProps : f3, h4 = a4.type, k2 = a4.updateQueue;
              a4.updateQueue = null;
              if (null !== k2) try {
                "input" === h4 && "radio" === f3.type && null != f3.name && ab(e4, f3);
                vb(h4, g3);
                var l4 = vb(h4, f3);
                for (g3 = 0; g3 < k2.length; g3 += 2) {
                  var m3 = k2[g3], q2 = k2[g3 + 1];
                  "style" === m3 ? sb(e4, q2) : "dangerouslySetInnerHTML" === m3 ? nb(e4, q2) : "children" === m3 ? ob(e4, q2) : ta(e4, m3, q2, l4);
                }
                switch (h4) {
                  case "input":
                    bb(e4, f3);
                    break;
                  case "textarea":
                    ib(e4, f3);
                    break;
                  case "select":
                    var r3 = e4._wrapperState.wasMultiple;
                    e4._wrapperState.wasMultiple = !!f3.multiple;
                    var y3 = f3.value;
                    null != y3 ? fb(e4, !!f3.multiple, y3, false) : r3 !== !!f3.multiple && (null != f3.defaultValue ? fb(
                      e4,
                      !!f3.multiple,
                      f3.defaultValue,
                      true
                    ) : fb(e4, !!f3.multiple, f3.multiple ? [] : "", false));
                }
                e4[Pf] = f3;
              } catch (t5) {
                W(a4, a4.return, t5);
              }
            }
            break;
          case 6:
            ck(b4, a4);
            ek(a4);
            if (d3 & 4) {
              if (null === a4.stateNode) throw Error(p4(162));
              e4 = a4.stateNode;
              f3 = a4.memoizedProps;
              try {
                e4.nodeValue = f3;
              } catch (t5) {
                W(a4, a4.return, t5);
              }
            }
            break;
          case 3:
            ck(b4, a4);
            ek(a4);
            if (d3 & 4 && null !== c4 && c4.memoizedState.isDehydrated) try {
              bd(b4.containerInfo);
            } catch (t5) {
              W(a4, a4.return, t5);
            }
            break;
          case 4:
            ck(b4, a4);
            ek(a4);
            break;
          case 13:
            ck(b4, a4);
            ek(a4);
            e4 = a4.child;
            e4.flags & 8192 && (f3 = null !== e4.memoizedState, e4.stateNode.isHidden = f3, !f3 || null !== e4.alternate && null !== e4.alternate.memoizedState || (fk = B()));
            d3 & 4 && ak(a4);
            break;
          case 22:
            m3 = null !== c4 && null !== c4.memoizedState;
            a4.mode & 1 ? (U = (l4 = U) || m3, ck(b4, a4), U = l4) : ck(b4, a4);
            ek(a4);
            if (d3 & 8192) {
              l4 = null !== a4.memoizedState;
              if ((a4.stateNode.isHidden = l4) && !m3 && 0 !== (a4.mode & 1)) for (V2 = a4, m3 = a4.child; null !== m3; ) {
                for (q2 = V2 = m3; null !== V2; ) {
                  r3 = V2;
                  y3 = r3.child;
                  switch (r3.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Pj(4, r3, r3.return);
                      break;
                    case 1:
                      Lj(r3, r3.return);
                      var n4 = r3.stateNode;
                      if ("function" === typeof n4.componentWillUnmount) {
                        d3 = r3;
                        c4 = r3.return;
                        try {
                          b4 = d3, n4.props = b4.memoizedProps, n4.state = b4.memoizedState, n4.componentWillUnmount();
                        } catch (t5) {
                          W(d3, c4, t5);
                        }
                      }
                      break;
                    case 5:
                      Lj(r3, r3.return);
                      break;
                    case 22:
                      if (null !== r3.memoizedState) {
                        gk(q2);
                        continue;
                      }
                  }
                  null !== y3 ? (y3.return = r3, V2 = y3) : gk(q2);
                }
                m3 = m3.sibling;
              }
              a: for (m3 = null, q2 = a4; ; ) {
                if (5 === q2.tag) {
                  if (null === m3) {
                    m3 = q2;
                    try {
                      e4 = q2.stateNode, l4 ? (f3 = e4.style, "function" === typeof f3.setProperty ? f3.setProperty("display", "none", "important") : f3.display = "none") : (h4 = q2.stateNode, k2 = q2.memoizedProps.style, g3 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h4.style.display = rb("display", g3));
                    } catch (t5) {
                      W(a4, a4.return, t5);
                    }
                  }
                } else if (6 === q2.tag) {
                  if (null === m3) try {
                    q2.stateNode.nodeValue = l4 ? "" : q2.memoizedProps;
                  } catch (t5) {
                    W(a4, a4.return, t5);
                  }
                } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a4) && null !== q2.child) {
                  q2.child.return = q2;
                  q2 = q2.child;
                  continue;
                }
                if (q2 === a4) break a;
                for (; null === q2.sibling; ) {
                  if (null === q2.return || q2.return === a4) break a;
                  m3 === q2 && (m3 = null);
                  q2 = q2.return;
                }
                m3 === q2 && (m3 = null);
                q2.sibling.return = q2.return;
                q2 = q2.sibling;
              }
            }
            break;
          case 19:
            ck(b4, a4);
            ek(a4);
            d3 & 4 && ak(a4);
            break;
          case 21:
            break;
          default:
            ck(
              b4,
              a4
            ), ek(a4);
        }
      }
      function ek(a4) {
        var b4 = a4.flags;
        if (b4 & 2) {
          try {
            a: {
              for (var c4 = a4.return; null !== c4; ) {
                if (Tj(c4)) {
                  var d3 = c4;
                  break a;
                }
                c4 = c4.return;
              }
              throw Error(p4(160));
            }
            switch (d3.tag) {
              case 5:
                var e4 = d3.stateNode;
                d3.flags & 32 && (ob(e4, ""), d3.flags &= -33);
                var f3 = Uj(a4);
                Wj(a4, f3, e4);
                break;
              case 3:
              case 4:
                var g3 = d3.stateNode.containerInfo, h4 = Uj(a4);
                Vj(a4, h4, g3);
                break;
              default:
                throw Error(p4(161));
            }
          } catch (k2) {
            W(a4, a4.return, k2);
          }
          a4.flags &= -3;
        }
        b4 & 4096 && (a4.flags &= -4097);
      }
      function hk(a4, b4, c4) {
        V2 = a4;
        ik(a4, b4, c4);
      }
      function ik(a4, b4, c4) {
        for (var d3 = 0 !== (a4.mode & 1); null !== V2; ) {
          var e4 = V2, f3 = e4.child;
          if (22 === e4.tag && d3) {
            var g3 = null !== e4.memoizedState || Jj;
            if (!g3) {
              var h4 = e4.alternate, k2 = null !== h4 && null !== h4.memoizedState || U;
              h4 = Jj;
              var l4 = U;
              Jj = g3;
              if ((U = k2) && !l4) for (V2 = e4; null !== V2; ) g3 = V2, k2 = g3.child, 22 === g3.tag && null !== g3.memoizedState ? jk(e4) : null !== k2 ? (k2.return = g3, V2 = k2) : jk(e4);
              for (; null !== f3; ) V2 = f3, ik(f3, b4, c4), f3 = f3.sibling;
              V2 = e4;
              Jj = h4;
              U = l4;
            }
            kk(a4, b4, c4);
          } else 0 !== (e4.subtreeFlags & 8772) && null !== f3 ? (f3.return = e4, V2 = f3) : kk(a4, b4, c4);
        }
      }
      function kk(a4) {
        for (; null !== V2; ) {
          var b4 = V2;
          if (0 !== (b4.flags & 8772)) {
            var c4 = b4.alternate;
            try {
              if (0 !== (b4.flags & 8772)) switch (b4.tag) {
                case 0:
                case 11:
                case 15:
                  U || Qj(5, b4);
                  break;
                case 1:
                  var d3 = b4.stateNode;
                  if (b4.flags & 4 && !U) if (null === c4) d3.componentDidMount();
                  else {
                    var e4 = b4.elementType === b4.type ? c4.memoizedProps : Ci(b4.type, c4.memoizedProps);
                    d3.componentDidUpdate(e4, c4.memoizedState, d3.__reactInternalSnapshotBeforeUpdate);
                  }
                  var f3 = b4.updateQueue;
                  null !== f3 && sh(b4, f3, d3);
                  break;
                case 3:
                  var g3 = b4.updateQueue;
                  if (null !== g3) {
                    c4 = null;
                    if (null !== b4.child) switch (b4.child.tag) {
                      case 5:
                        c4 = b4.child.stateNode;
                        break;
                      case 1:
                        c4 = b4.child.stateNode;
                    }
                    sh(b4, g3, c4);
                  }
                  break;
                case 5:
                  var h4 = b4.stateNode;
                  if (null === c4 && b4.flags & 4) {
                    c4 = h4;
                    var k2 = b4.memoizedProps;
                    switch (b4.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k2.autoFocus && c4.focus();
                        break;
                      case "img":
                        k2.src && (c4.src = k2.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b4.memoizedState) {
                    var l4 = b4.alternate;
                    if (null !== l4) {
                      var m3 = l4.memoizedState;
                      if (null !== m3) {
                        var q2 = m3.dehydrated;
                        null !== q2 && bd(q2);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p4(163));
              }
              U || b4.flags & 512 && Rj(b4);
            } catch (r3) {
              W(b4, b4.return, r3);
            }
          }
          if (b4 === a4) {
            V2 = null;
            break;
          }
          c4 = b4.sibling;
          if (null !== c4) {
            c4.return = b4.return;
            V2 = c4;
            break;
          }
          V2 = b4.return;
        }
      }
      function gk(a4) {
        for (; null !== V2; ) {
          var b4 = V2;
          if (b4 === a4) {
            V2 = null;
            break;
          }
          var c4 = b4.sibling;
          if (null !== c4) {
            c4.return = b4.return;
            V2 = c4;
            break;
          }
          V2 = b4.return;
        }
      }
      function jk(a4) {
        for (; null !== V2; ) {
          var b4 = V2;
          try {
            switch (b4.tag) {
              case 0:
              case 11:
              case 15:
                var c4 = b4.return;
                try {
                  Qj(4, b4);
                } catch (k2) {
                  W(b4, c4, k2);
                }
                break;
              case 1:
                var d3 = b4.stateNode;
                if ("function" === typeof d3.componentDidMount) {
                  var e4 = b4.return;
                  try {
                    d3.componentDidMount();
                  } catch (k2) {
                    W(b4, e4, k2);
                  }
                }
                var f3 = b4.return;
                try {
                  Rj(b4);
                } catch (k2) {
                  W(b4, f3, k2);
                }
                break;
              case 5:
                var g3 = b4.return;
                try {
                  Rj(b4);
                } catch (k2) {
                  W(b4, g3, k2);
                }
            }
          } catch (k2) {
            W(b4, b4.return, k2);
          }
          if (b4 === a4) {
            V2 = null;
            break;
          }
          var h4 = b4.sibling;
          if (null !== h4) {
            h4.return = b4.return;
            V2 = h4;
            break;
          }
          V2 = b4.return;
        }
      }
      var lk = Math.ceil;
      var mk = ua.ReactCurrentDispatcher;
      var nk = ua.ReactCurrentOwner;
      var ok = ua.ReactCurrentBatchConfig;
      var K = 0;
      var Q2 = null;
      var Y2 = null;
      var Z = 0;
      var fj = 0;
      var ej = Uf(0);
      var T2 = 0;
      var pk = null;
      var rh = 0;
      var qk = 0;
      var rk = 0;
      var sk = null;
      var tk = null;
      var fk = 0;
      var Gj = Infinity;
      var uk = null;
      var Oi = false;
      var Pi = null;
      var Ri = null;
      var vk = false;
      var wk = null;
      var xk = 0;
      var yk = 0;
      var zk = null;
      var Ak = -1;
      var Bk = 0;
      function R2() {
        return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
      }
      function yi(a4) {
        if (0 === (a4.mode & 1)) return 1;
        if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
        if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
        a4 = C2;
        if (0 !== a4) return a4;
        a4 = window.event;
        a4 = void 0 === a4 ? 16 : jd(a4.type);
        return a4;
      }
      function gi(a4, b4, c4, d3) {
        if (50 < yk) throw yk = 0, zk = null, Error(p4(185));
        Ac(a4, c4, d3);
        if (0 === (K & 2) || a4 !== Q2) a4 === Q2 && (0 === (K & 2) && (qk |= c4), 4 === T2 && Ck(a4, Z)), Dk(a4, d3), 1 === c4 && 0 === K && 0 === (b4.mode & 1) && (Gj = B() + 500, fg && jg());
      }
      function Dk(a4, b4) {
        var c4 = a4.callbackNode;
        wc(a4, b4);
        var d3 = uc(a4, a4 === Q2 ? Z : 0);
        if (0 === d3) null !== c4 && bc(c4), a4.callbackNode = null, a4.callbackPriority = 0;
        else if (b4 = d3 & -d3, a4.callbackPriority !== b4) {
          null != c4 && bc(c4);
          if (1 === b4) 0 === a4.tag ? ig(Ek.bind(null, a4)) : hg(Ek.bind(null, a4)), Jf(function() {
            0 === (K & 6) && jg();
          }), c4 = null;
          else {
            switch (Dc(d3)) {
              case 1:
                c4 = fc;
                break;
              case 4:
                c4 = gc;
                break;
              case 16:
                c4 = hc;
                break;
              case 536870912:
                c4 = jc;
                break;
              default:
                c4 = hc;
            }
            c4 = Fk(c4, Gk.bind(null, a4));
          }
          a4.callbackPriority = b4;
          a4.callbackNode = c4;
        }
      }
      function Gk(a4, b4) {
        Ak = -1;
        Bk = 0;
        if (0 !== (K & 6)) throw Error(p4(327));
        var c4 = a4.callbackNode;
        if (Hk() && a4.callbackNode !== c4) return null;
        var d3 = uc(a4, a4 === Q2 ? Z : 0);
        if (0 === d3) return null;
        if (0 !== (d3 & 30) || 0 !== (d3 & a4.expiredLanes) || b4) b4 = Ik(a4, d3);
        else {
          b4 = d3;
          var e4 = K;
          K |= 2;
          var f3 = Jk();
          if (Q2 !== a4 || Z !== b4) uk = null, Gj = B() + 500, Kk(a4, b4);
          do
            try {
              Lk();
              break;
            } catch (h4) {
              Mk(a4, h4);
            }
          while (1);
          $g();
          mk.current = f3;
          K = e4;
          null !== Y2 ? b4 = 0 : (Q2 = null, Z = 0, b4 = T2);
        }
        if (0 !== b4) {
          2 === b4 && (e4 = xc(a4), 0 !== e4 && (d3 = e4, b4 = Nk(a4, e4)));
          if (1 === b4) throw c4 = pk, Kk(a4, 0), Ck(a4, d3), Dk(a4, B()), c4;
          if (6 === b4) Ck(a4, d3);
          else {
            e4 = a4.current.alternate;
            if (0 === (d3 & 30) && !Ok(e4) && (b4 = Ik(a4, d3), 2 === b4 && (f3 = xc(a4), 0 !== f3 && (d3 = f3, b4 = Nk(a4, f3))), 1 === b4)) throw c4 = pk, Kk(a4, 0), Ck(a4, d3), Dk(a4, B()), c4;
            a4.finishedWork = e4;
            a4.finishedLanes = d3;
            switch (b4) {
              case 0:
              case 1:
                throw Error(p4(345));
              case 2:
                Pk(a4, tk, uk);
                break;
              case 3:
                Ck(a4, d3);
                if ((d3 & 130023424) === d3 && (b4 = fk + 500 - B(), 10 < b4)) {
                  if (0 !== uc(a4, 0)) break;
                  e4 = a4.suspendedLanes;
                  if ((e4 & d3) !== d3) {
                    R2();
                    a4.pingedLanes |= a4.suspendedLanes & e4;
                    break;
                  }
                  a4.timeoutHandle = Ff(Pk.bind(null, a4, tk, uk), b4);
                  break;
                }
                Pk(a4, tk, uk);
                break;
              case 4:
                Ck(a4, d3);
                if ((d3 & 4194240) === d3) break;
                b4 = a4.eventTimes;
                for (e4 = -1; 0 < d3; ) {
                  var g3 = 31 - oc(d3);
                  f3 = 1 << g3;
                  g3 = b4[g3];
                  g3 > e4 && (e4 = g3);
                  d3 &= ~f3;
                }
                d3 = e4;
                d3 = B() - d3;
                d3 = (120 > d3 ? 120 : 480 > d3 ? 480 : 1080 > d3 ? 1080 : 1920 > d3 ? 1920 : 3e3 > d3 ? 3e3 : 4320 > d3 ? 4320 : 1960 * lk(d3 / 1960)) - d3;
                if (10 < d3) {
                  a4.timeoutHandle = Ff(Pk.bind(null, a4, tk, uk), d3);
                  break;
                }
                Pk(a4, tk, uk);
                break;
              case 5:
                Pk(a4, tk, uk);
                break;
              default:
                throw Error(p4(329));
            }
          }
        }
        Dk(a4, B());
        return a4.callbackNode === c4 ? Gk.bind(null, a4) : null;
      }
      function Nk(a4, b4) {
        var c4 = sk;
        a4.current.memoizedState.isDehydrated && (Kk(a4, b4).flags |= 256);
        a4 = Ik(a4, b4);
        2 !== a4 && (b4 = tk, tk = c4, null !== b4 && Fj(b4));
        return a4;
      }
      function Fj(a4) {
        null === tk ? tk = a4 : tk.push.apply(tk, a4);
      }
      function Ok(a4) {
        for (var b4 = a4; ; ) {
          if (b4.flags & 16384) {
            var c4 = b4.updateQueue;
            if (null !== c4 && (c4 = c4.stores, null !== c4)) for (var d3 = 0; d3 < c4.length; d3++) {
              var e4 = c4[d3], f3 = e4.getSnapshot;
              e4 = e4.value;
              try {
                if (!He(f3(), e4)) return false;
              } catch (g3) {
                return false;
              }
            }
          }
          c4 = b4.child;
          if (b4.subtreeFlags & 16384 && null !== c4) c4.return = b4, b4 = c4;
          else {
            if (b4 === a4) break;
            for (; null === b4.sibling; ) {
              if (null === b4.return || b4.return === a4) return true;
              b4 = b4.return;
            }
            b4.sibling.return = b4.return;
            b4 = b4.sibling;
          }
        }
        return true;
      }
      function Ck(a4, b4) {
        b4 &= ~rk;
        b4 &= ~qk;
        a4.suspendedLanes |= b4;
        a4.pingedLanes &= ~b4;
        for (a4 = a4.expirationTimes; 0 < b4; ) {
          var c4 = 31 - oc(b4), d3 = 1 << c4;
          a4[c4] = -1;
          b4 &= ~d3;
        }
      }
      function Ek(a4) {
        if (0 !== (K & 6)) throw Error(p4(327));
        Hk();
        var b4 = uc(a4, 0);
        if (0 === (b4 & 1)) return Dk(a4, B()), null;
        var c4 = Ik(a4, b4);
        if (0 !== a4.tag && 2 === c4) {
          var d3 = xc(a4);
          0 !== d3 && (b4 = d3, c4 = Nk(a4, d3));
        }
        if (1 === c4) throw c4 = pk, Kk(a4, 0), Ck(a4, b4), Dk(a4, B()), c4;
        if (6 === c4) throw Error(p4(345));
        a4.finishedWork = a4.current.alternate;
        a4.finishedLanes = b4;
        Pk(a4, tk, uk);
        Dk(a4, B());
        return null;
      }
      function Qk(a4, b4) {
        var c4 = K;
        K |= 1;
        try {
          return a4(b4);
        } finally {
          K = c4, 0 === K && (Gj = B() + 500, fg && jg());
        }
      }
      function Rk(a4) {
        null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
        var b4 = K;
        K |= 1;
        var c4 = ok.transition, d3 = C2;
        try {
          if (ok.transition = null, C2 = 1, a4) return a4();
        } finally {
          C2 = d3, ok.transition = c4, K = b4, 0 === (K & 6) && jg();
        }
      }
      function Hj() {
        fj = ej.current;
        E(ej);
      }
      function Kk(a4, b4) {
        a4.finishedWork = null;
        a4.finishedLanes = 0;
        var c4 = a4.timeoutHandle;
        -1 !== c4 && (a4.timeoutHandle = -1, Gf(c4));
        if (null !== Y2) for (c4 = Y2.return; null !== c4; ) {
          var d3 = c4;
          wg(d3);
          switch (d3.tag) {
            case 1:
              d3 = d3.type.childContextTypes;
              null !== d3 && void 0 !== d3 && $f();
              break;
            case 3:
              zh();
              E(Wf);
              E(H2);
              Eh();
              break;
            case 5:
              Bh(d3);
              break;
            case 4:
              zh();
              break;
            case 13:
              E(L2);
              break;
            case 19:
              E(L2);
              break;
            case 10:
              ah(d3.type._context);
              break;
            case 22:
            case 23:
              Hj();
          }
          c4 = c4.return;
        }
        Q2 = a4;
        Y2 = a4 = Pg(a4.current, null);
        Z = fj = b4;
        T2 = 0;
        pk = null;
        rk = qk = rh = 0;
        tk = sk = null;
        if (null !== fh) {
          for (b4 = 0; b4 < fh.length; b4++) if (c4 = fh[b4], d3 = c4.interleaved, null !== d3) {
            c4.interleaved = null;
            var e4 = d3.next, f3 = c4.pending;
            if (null !== f3) {
              var g3 = f3.next;
              f3.next = e4;
              d3.next = g3;
            }
            c4.pending = d3;
          }
          fh = null;
        }
        return a4;
      }
      function Mk(a4, b4) {
        do {
          var c4 = Y2;
          try {
            $g();
            Fh.current = Rh;
            if (Ih) {
              for (var d3 = M2.memoizedState; null !== d3; ) {
                var e4 = d3.queue;
                null !== e4 && (e4.pending = null);
                d3 = d3.next;
              }
              Ih = false;
            }
            Hh = 0;
            O = N2 = M2 = null;
            Jh = false;
            Kh = 0;
            nk.current = null;
            if (null === c4 || null === c4.return) {
              T2 = 1;
              pk = b4;
              Y2 = null;
              break;
            }
            a: {
              var f3 = a4, g3 = c4.return, h4 = c4, k2 = b4;
              b4 = Z;
              h4.flags |= 32768;
              if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
                var l4 = k2, m3 = h4, q2 = m3.tag;
                if (0 === (m3.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
                  var r3 = m3.alternate;
                  r3 ? (m3.updateQueue = r3.updateQueue, m3.memoizedState = r3.memoizedState, m3.lanes = r3.lanes) : (m3.updateQueue = null, m3.memoizedState = null);
                }
                var y3 = Ui(g3);
                if (null !== y3) {
                  y3.flags &= -257;
                  Vi(y3, g3, h4, f3, b4);
                  y3.mode & 1 && Si(f3, l4, b4);
                  b4 = y3;
                  k2 = l4;
                  var n4 = b4.updateQueue;
                  if (null === n4) {
                    var t5 = /* @__PURE__ */ new Set();
                    t5.add(k2);
                    b4.updateQueue = t5;
                  } else n4.add(k2);
                  break a;
                } else {
                  if (0 === (b4 & 1)) {
                    Si(f3, l4, b4);
                    tj();
                    break a;
                  }
                  k2 = Error(p4(426));
                }
              } else if (I2 && h4.mode & 1) {
                var J2 = Ui(g3);
                if (null !== J2) {
                  0 === (J2.flags & 65536) && (J2.flags |= 256);
                  Vi(J2, g3, h4, f3, b4);
                  Jg(Ji(k2, h4));
                  break a;
                }
              }
              f3 = k2 = Ji(k2, h4);
              4 !== T2 && (T2 = 2);
              null === sk ? sk = [f3] : sk.push(f3);
              f3 = g3;
              do {
                switch (f3.tag) {
                  case 3:
                    f3.flags |= 65536;
                    b4 &= -b4;
                    f3.lanes |= b4;
                    var x2 = Ni(f3, k2, b4);
                    ph(f3, x2);
                    break a;
                  case 1:
                    h4 = k2;
                    var w2 = f3.type, u4 = f3.stateNode;
                    if (0 === (f3.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u4 && "function" === typeof u4.componentDidCatch && (null === Ri || !Ri.has(u4)))) {
                      f3.flags |= 65536;
                      b4 &= -b4;
                      f3.lanes |= b4;
                      var F2 = Qi(f3, h4, b4);
                      ph(f3, F2);
                      break a;
                    }
                }
                f3 = f3.return;
              } while (null !== f3);
            }
            Sk(c4);
          } catch (na) {
            b4 = na;
            Y2 === c4 && null !== c4 && (Y2 = c4 = c4.return);
            continue;
          }
          break;
        } while (1);
      }
      function Jk() {
        var a4 = mk.current;
        mk.current = Rh;
        return null === a4 ? Rh : a4;
      }
      function tj() {
        if (0 === T2 || 3 === T2 || 2 === T2) T2 = 4;
        null === Q2 || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q2, Z);
      }
      function Ik(a4, b4) {
        var c4 = K;
        K |= 2;
        var d3 = Jk();
        if (Q2 !== a4 || Z !== b4) uk = null, Kk(a4, b4);
        do
          try {
            Tk();
            break;
          } catch (e4) {
            Mk(a4, e4);
          }
        while (1);
        $g();
        K = c4;
        mk.current = d3;
        if (null !== Y2) throw Error(p4(261));
        Q2 = null;
        Z = 0;
        return T2;
      }
      function Tk() {
        for (; null !== Y2; ) Uk(Y2);
      }
      function Lk() {
        for (; null !== Y2 && !cc(); ) Uk(Y2);
      }
      function Uk(a4) {
        var b4 = Vk(a4.alternate, a4, fj);
        a4.memoizedProps = a4.pendingProps;
        null === b4 ? Sk(a4) : Y2 = b4;
        nk.current = null;
      }
      function Sk(a4) {
        var b4 = a4;
        do {
          var c4 = b4.alternate;
          a4 = b4.return;
          if (0 === (b4.flags & 32768)) {
            if (c4 = Ej(c4, b4, fj), null !== c4) {
              Y2 = c4;
              return;
            }
          } else {
            c4 = Ij(c4, b4);
            if (null !== c4) {
              c4.flags &= 32767;
              Y2 = c4;
              return;
            }
            if (null !== a4) a4.flags |= 32768, a4.subtreeFlags = 0, a4.deletions = null;
            else {
              T2 = 6;
              Y2 = null;
              return;
            }
          }
          b4 = b4.sibling;
          if (null !== b4) {
            Y2 = b4;
            return;
          }
          Y2 = b4 = a4;
        } while (null !== b4);
        0 === T2 && (T2 = 5);
      }
      function Pk(a4, b4, c4) {
        var d3 = C2, e4 = ok.transition;
        try {
          ok.transition = null, C2 = 1, Wk(a4, b4, c4, d3);
        } finally {
          ok.transition = e4, C2 = d3;
        }
        return null;
      }
      function Wk(a4, b4, c4, d3) {
        do
          Hk();
        while (null !== wk);
        if (0 !== (K & 6)) throw Error(p4(327));
        c4 = a4.finishedWork;
        var e4 = a4.finishedLanes;
        if (null === c4) return null;
        a4.finishedWork = null;
        a4.finishedLanes = 0;
        if (c4 === a4.current) throw Error(p4(177));
        a4.callbackNode = null;
        a4.callbackPriority = 0;
        var f3 = c4.lanes | c4.childLanes;
        Bc(a4, f3);
        a4 === Q2 && (Y2 = Q2 = null, Z = 0);
        0 === (c4.subtreeFlags & 2064) && 0 === (c4.flags & 2064) || vk || (vk = true, Fk(hc, function() {
          Hk();
          return null;
        }));
        f3 = 0 !== (c4.flags & 15990);
        if (0 !== (c4.subtreeFlags & 15990) || f3) {
          f3 = ok.transition;
          ok.transition = null;
          var g3 = C2;
          C2 = 1;
          var h4 = K;
          K |= 4;
          nk.current = null;
          Oj(a4, c4);
          dk(c4, a4);
          Oe2(Df);
          dd = !!Cf;
          Df = Cf = null;
          a4.current = c4;
          hk(c4, a4, e4);
          dc();
          K = h4;
          C2 = g3;
          ok.transition = f3;
        } else a4.current = c4;
        vk && (vk = false, wk = a4, xk = e4);
        f3 = a4.pendingLanes;
        0 === f3 && (Ri = null);
        mc(c4.stateNode, d3);
        Dk(a4, B());
        if (null !== b4) for (d3 = a4.onRecoverableError, c4 = 0; c4 < b4.length; c4++) e4 = b4[c4], d3(e4.value, { componentStack: e4.stack, digest: e4.digest });
        if (Oi) throw Oi = false, a4 = Pi, Pi = null, a4;
        0 !== (xk & 1) && 0 !== a4.tag && Hk();
        f3 = a4.pendingLanes;
        0 !== (f3 & 1) ? a4 === zk ? yk++ : (yk = 0, zk = a4) : yk = 0;
        jg();
        return null;
      }
      function Hk() {
        if (null !== wk) {
          var a4 = Dc(xk), b4 = ok.transition, c4 = C2;
          try {
            ok.transition = null;
            C2 = 16 > a4 ? 16 : a4;
            if (null === wk) var d3 = false;
            else {
              a4 = wk;
              wk = null;
              xk = 0;
              if (0 !== (K & 6)) throw Error(p4(331));
              var e4 = K;
              K |= 4;
              for (V2 = a4.current; null !== V2; ) {
                var f3 = V2, g3 = f3.child;
                if (0 !== (V2.flags & 16)) {
                  var h4 = f3.deletions;
                  if (null !== h4) {
                    for (var k2 = 0; k2 < h4.length; k2++) {
                      var l4 = h4[k2];
                      for (V2 = l4; null !== V2; ) {
                        var m3 = V2;
                        switch (m3.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Pj(8, m3, f3);
                        }
                        var q2 = m3.child;
                        if (null !== q2) q2.return = m3, V2 = q2;
                        else for (; null !== V2; ) {
                          m3 = V2;
                          var r3 = m3.sibling, y3 = m3.return;
                          Sj(m3);
                          if (m3 === l4) {
                            V2 = null;
                            break;
                          }
                          if (null !== r3) {
                            r3.return = y3;
                            V2 = r3;
                            break;
                          }
                          V2 = y3;
                        }
                      }
                    }
                    var n4 = f3.alternate;
                    if (null !== n4) {
                      var t5 = n4.child;
                      if (null !== t5) {
                        n4.child = null;
                        do {
                          var J2 = t5.sibling;
                          t5.sibling = null;
                          t5 = J2;
                        } while (null !== t5);
                      }
                    }
                    V2 = f3;
                  }
                }
                if (0 !== (f3.subtreeFlags & 2064) && null !== g3) g3.return = f3, V2 = g3;
                else b: for (; null !== V2; ) {
                  f3 = V2;
                  if (0 !== (f3.flags & 2048)) switch (f3.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(9, f3, f3.return);
                  }
                  var x2 = f3.sibling;
                  if (null !== x2) {
                    x2.return = f3.return;
                    V2 = x2;
                    break b;
                  }
                  V2 = f3.return;
                }
              }
              var w2 = a4.current;
              for (V2 = w2; null !== V2; ) {
                g3 = V2;
                var u4 = g3.child;
                if (0 !== (g3.subtreeFlags & 2064) && null !== u4) u4.return = g3, V2 = u4;
                else b: for (g3 = w2; null !== V2; ) {
                  h4 = V2;
                  if (0 !== (h4.flags & 2048)) try {
                    switch (h4.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(9, h4);
                    }
                  } catch (na) {
                    W(h4, h4.return, na);
                  }
                  if (h4 === g3) {
                    V2 = null;
                    break b;
                  }
                  var F2 = h4.sibling;
                  if (null !== F2) {
                    F2.return = h4.return;
                    V2 = F2;
                    break b;
                  }
                  V2 = h4.return;
                }
              }
              K = e4;
              jg();
              if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
                lc.onPostCommitFiberRoot(kc, a4);
              } catch (na) {
              }
              d3 = true;
            }
            return d3;
          } finally {
            C2 = c4, ok.transition = b4;
          }
        }
        return false;
      }
      function Xk(a4, b4, c4) {
        b4 = Ji(c4, b4);
        b4 = Ni(a4, b4, 1);
        a4 = nh(a4, b4, 1);
        b4 = R2();
        null !== a4 && (Ac(a4, 1, b4), Dk(a4, b4));
      }
      function W(a4, b4, c4) {
        if (3 === a4.tag) Xk(a4, a4, c4);
        else for (; null !== b4; ) {
          if (3 === b4.tag) {
            Xk(b4, a4, c4);
            break;
          } else if (1 === b4.tag) {
            var d3 = b4.stateNode;
            if ("function" === typeof b4.type.getDerivedStateFromError || "function" === typeof d3.componentDidCatch && (null === Ri || !Ri.has(d3))) {
              a4 = Ji(c4, a4);
              a4 = Qi(b4, a4, 1);
              b4 = nh(b4, a4, 1);
              a4 = R2();
              null !== b4 && (Ac(b4, 1, a4), Dk(b4, a4));
              break;
            }
          }
          b4 = b4.return;
        }
      }
      function Ti(a4, b4, c4) {
        var d3 = a4.pingCache;
        null !== d3 && d3.delete(b4);
        b4 = R2();
        a4.pingedLanes |= a4.suspendedLanes & c4;
        Q2 === a4 && (Z & c4) === c4 && (4 === T2 || 3 === T2 && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a4, 0) : rk |= c4);
        Dk(a4, b4);
      }
      function Yk(a4, b4) {
        0 === b4 && (0 === (a4.mode & 1) ? b4 = 1 : (b4 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
        var c4 = R2();
        a4 = ih(a4, b4);
        null !== a4 && (Ac(a4, b4, c4), Dk(a4, c4));
      }
      function uj(a4) {
        var b4 = a4.memoizedState, c4 = 0;
        null !== b4 && (c4 = b4.retryLane);
        Yk(a4, c4);
      }
      function bk(a4, b4) {
        var c4 = 0;
        switch (a4.tag) {
          case 13:
            var d3 = a4.stateNode;
            var e4 = a4.memoizedState;
            null !== e4 && (c4 = e4.retryLane);
            break;
          case 19:
            d3 = a4.stateNode;
            break;
          default:
            throw Error(p4(314));
        }
        null !== d3 && d3.delete(b4);
        Yk(a4, c4);
      }
      var Vk;
      Vk = function(a4, b4, c4) {
        if (null !== a4) if (a4.memoizedProps !== b4.pendingProps || Wf.current) dh = true;
        else {
          if (0 === (a4.lanes & c4) && 0 === (b4.flags & 128)) return dh = false, yj(a4, b4, c4);
          dh = 0 !== (a4.flags & 131072) ? true : false;
        }
        else dh = false, I2 && 0 !== (b4.flags & 1048576) && ug(b4, ng, b4.index);
        b4.lanes = 0;
        switch (b4.tag) {
          case 2:
            var d3 = b4.type;
            ij(a4, b4);
            a4 = b4.pendingProps;
            var e4 = Yf(b4, H2.current);
            ch(b4, c4);
            e4 = Nh(null, b4, d3, a4, e4, c4);
            var f3 = Sh();
            b4.flags |= 1;
            "object" === typeof e4 && null !== e4 && "function" === typeof e4.render && void 0 === e4.$$typeof ? (b4.tag = 1, b4.memoizedState = null, b4.updateQueue = null, Zf(d3) ? (f3 = true, cg(b4)) : f3 = false, b4.memoizedState = null !== e4.state && void 0 !== e4.state ? e4.state : null, kh(b4), e4.updater = Ei, b4.stateNode = e4, e4._reactInternals = b4, Ii(b4, d3, a4, c4), b4 = jj(null, b4, d3, true, f3, c4)) : (b4.tag = 0, I2 && f3 && vg(b4), Xi(null, b4, e4, c4), b4 = b4.child);
            return b4;
          case 16:
            d3 = b4.elementType;
            a: {
              ij(a4, b4);
              a4 = b4.pendingProps;
              e4 = d3._init;
              d3 = e4(d3._payload);
              b4.type = d3;
              e4 = b4.tag = Zk(d3);
              a4 = Ci(d3, a4);
              switch (e4) {
                case 0:
                  b4 = cj(null, b4, d3, a4, c4);
                  break a;
                case 1:
                  b4 = hj(null, b4, d3, a4, c4);
                  break a;
                case 11:
                  b4 = Yi(null, b4, d3, a4, c4);
                  break a;
                case 14:
                  b4 = $i(null, b4, d3, Ci(d3.type, a4), c4);
                  break a;
              }
              throw Error(p4(
                306,
                d3,
                ""
              ));
            }
            return b4;
          case 0:
            return d3 = b4.type, e4 = b4.pendingProps, e4 = b4.elementType === d3 ? e4 : Ci(d3, e4), cj(a4, b4, d3, e4, c4);
          case 1:
            return d3 = b4.type, e4 = b4.pendingProps, e4 = b4.elementType === d3 ? e4 : Ci(d3, e4), hj(a4, b4, d3, e4, c4);
          case 3:
            a: {
              kj(b4);
              if (null === a4) throw Error(p4(387));
              d3 = b4.pendingProps;
              f3 = b4.memoizedState;
              e4 = f3.element;
              lh(a4, b4);
              qh(b4, d3, null, c4);
              var g3 = b4.memoizedState;
              d3 = g3.element;
              if (f3.isDehydrated) if (f3 = { element: d3, isDehydrated: false, cache: g3.cache, pendingSuspenseBoundaries: g3.pendingSuspenseBoundaries, transitions: g3.transitions }, b4.updateQueue.baseState = f3, b4.memoizedState = f3, b4.flags & 256) {
                e4 = Ji(Error(p4(423)), b4);
                b4 = lj(a4, b4, d3, c4, e4);
                break a;
              } else if (d3 !== e4) {
                e4 = Ji(Error(p4(424)), b4);
                b4 = lj(a4, b4, d3, c4, e4);
                break a;
              } else for (yg = Lf(b4.stateNode.containerInfo.firstChild), xg = b4, I2 = true, zg = null, c4 = Vg(b4, null, d3, c4), b4.child = c4; c4; ) c4.flags = c4.flags & -3 | 4096, c4 = c4.sibling;
              else {
                Ig();
                if (d3 === e4) {
                  b4 = Zi(a4, b4, c4);
                  break a;
                }
                Xi(a4, b4, d3, c4);
              }
              b4 = b4.child;
            }
            return b4;
          case 5:
            return Ah(b4), null === a4 && Eg(b4), d3 = b4.type, e4 = b4.pendingProps, f3 = null !== a4 ? a4.memoizedProps : null, g3 = e4.children, Ef(d3, e4) ? g3 = null : null !== f3 && Ef(d3, f3) && (b4.flags |= 32), gj(a4, b4), Xi(a4, b4, g3, c4), b4.child;
          case 6:
            return null === a4 && Eg(b4), null;
          case 13:
            return oj(a4, b4, c4);
          case 4:
            return yh(b4, b4.stateNode.containerInfo), d3 = b4.pendingProps, null === a4 ? b4.child = Ug(b4, null, d3, c4) : Xi(a4, b4, d3, c4), b4.child;
          case 11:
            return d3 = b4.type, e4 = b4.pendingProps, e4 = b4.elementType === d3 ? e4 : Ci(d3, e4), Yi(a4, b4, d3, e4, c4);
          case 7:
            return Xi(a4, b4, b4.pendingProps, c4), b4.child;
          case 8:
            return Xi(a4, b4, b4.pendingProps.children, c4), b4.child;
          case 12:
            return Xi(a4, b4, b4.pendingProps.children, c4), b4.child;
          case 10:
            a: {
              d3 = b4.type._context;
              e4 = b4.pendingProps;
              f3 = b4.memoizedProps;
              g3 = e4.value;
              G(Wg, d3._currentValue);
              d3._currentValue = g3;
              if (null !== f3) if (He(f3.value, g3)) {
                if (f3.children === e4.children && !Wf.current) {
                  b4 = Zi(a4, b4, c4);
                  break a;
                }
              } else for (f3 = b4.child, null !== f3 && (f3.return = b4); null !== f3; ) {
                var h4 = f3.dependencies;
                if (null !== h4) {
                  g3 = f3.child;
                  for (var k2 = h4.firstContext; null !== k2; ) {
                    if (k2.context === d3) {
                      if (1 === f3.tag) {
                        k2 = mh(-1, c4 & -c4);
                        k2.tag = 2;
                        var l4 = f3.updateQueue;
                        if (null !== l4) {
                          l4 = l4.shared;
                          var m3 = l4.pending;
                          null === m3 ? k2.next = k2 : (k2.next = m3.next, m3.next = k2);
                          l4.pending = k2;
                        }
                      }
                      f3.lanes |= c4;
                      k2 = f3.alternate;
                      null !== k2 && (k2.lanes |= c4);
                      bh(
                        f3.return,
                        c4,
                        b4
                      );
                      h4.lanes |= c4;
                      break;
                    }
                    k2 = k2.next;
                  }
                } else if (10 === f3.tag) g3 = f3.type === b4.type ? null : f3.child;
                else if (18 === f3.tag) {
                  g3 = f3.return;
                  if (null === g3) throw Error(p4(341));
                  g3.lanes |= c4;
                  h4 = g3.alternate;
                  null !== h4 && (h4.lanes |= c4);
                  bh(g3, c4, b4);
                  g3 = f3.sibling;
                } else g3 = f3.child;
                if (null !== g3) g3.return = f3;
                else for (g3 = f3; null !== g3; ) {
                  if (g3 === b4) {
                    g3 = null;
                    break;
                  }
                  f3 = g3.sibling;
                  if (null !== f3) {
                    f3.return = g3.return;
                    g3 = f3;
                    break;
                  }
                  g3 = g3.return;
                }
                f3 = g3;
              }
              Xi(a4, b4, e4.children, c4);
              b4 = b4.child;
            }
            return b4;
          case 9:
            return e4 = b4.type, d3 = b4.pendingProps.children, ch(b4, c4), e4 = eh(e4), d3 = d3(e4), b4.flags |= 1, Xi(a4, b4, d3, c4), b4.child;
          case 14:
            return d3 = b4.type, e4 = Ci(d3, b4.pendingProps), e4 = Ci(d3.type, e4), $i(a4, b4, d3, e4, c4);
          case 15:
            return bj(a4, b4, b4.type, b4.pendingProps, c4);
          case 17:
            return d3 = b4.type, e4 = b4.pendingProps, e4 = b4.elementType === d3 ? e4 : Ci(d3, e4), ij(a4, b4), b4.tag = 1, Zf(d3) ? (a4 = true, cg(b4)) : a4 = false, ch(b4, c4), Gi(b4, d3, e4), Ii(b4, d3, e4, c4), jj(null, b4, d3, true, a4, c4);
          case 19:
            return xj(a4, b4, c4);
          case 22:
            return dj(a4, b4, c4);
        }
        throw Error(p4(156, b4.tag));
      };
      function Fk(a4, b4) {
        return ac(a4, b4);
      }
      function $k(a4, b4, c4, d3) {
        this.tag = a4;
        this.key = c4;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = b4;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = d3;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function Bg(a4, b4, c4, d3) {
        return new $k(a4, b4, c4, d3);
      }
      function aj(a4) {
        a4 = a4.prototype;
        return !(!a4 || !a4.isReactComponent);
      }
      function Zk(a4) {
        if ("function" === typeof a4) return aj(a4) ? 1 : 0;
        if (void 0 !== a4 && null !== a4) {
          a4 = a4.$$typeof;
          if (a4 === Da) return 11;
          if (a4 === Ga) return 14;
        }
        return 2;
      }
      function Pg(a4, b4) {
        var c4 = a4.alternate;
        null === c4 ? (c4 = Bg(a4.tag, b4, a4.key, a4.mode), c4.elementType = a4.elementType, c4.type = a4.type, c4.stateNode = a4.stateNode, c4.alternate = a4, a4.alternate = c4) : (c4.pendingProps = b4, c4.type = a4.type, c4.flags = 0, c4.subtreeFlags = 0, c4.deletions = null);
        c4.flags = a4.flags & 14680064;
        c4.childLanes = a4.childLanes;
        c4.lanes = a4.lanes;
        c4.child = a4.child;
        c4.memoizedProps = a4.memoizedProps;
        c4.memoizedState = a4.memoizedState;
        c4.updateQueue = a4.updateQueue;
        b4 = a4.dependencies;
        c4.dependencies = null === b4 ? null : { lanes: b4.lanes, firstContext: b4.firstContext };
        c4.sibling = a4.sibling;
        c4.index = a4.index;
        c4.ref = a4.ref;
        return c4;
      }
      function Rg(a4, b4, c4, d3, e4, f3) {
        var g3 = 2;
        d3 = a4;
        if ("function" === typeof a4) aj(a4) && (g3 = 1);
        else if ("string" === typeof a4) g3 = 5;
        else a: switch (a4) {
          case ya:
            return Tg(c4.children, e4, f3, b4);
          case za:
            g3 = 8;
            e4 |= 8;
            break;
          case Aa:
            return a4 = Bg(12, c4, b4, e4 | 2), a4.elementType = Aa, a4.lanes = f3, a4;
          case Ea:
            return a4 = Bg(13, c4, b4, e4), a4.elementType = Ea, a4.lanes = f3, a4;
          case Fa:
            return a4 = Bg(19, c4, b4, e4), a4.elementType = Fa, a4.lanes = f3, a4;
          case Ia:
            return pj(c4, e4, f3, b4);
          default:
            if ("object" === typeof a4 && null !== a4) switch (a4.$$typeof) {
              case Ba:
                g3 = 10;
                break a;
              case Ca:
                g3 = 9;
                break a;
              case Da:
                g3 = 11;
                break a;
              case Ga:
                g3 = 14;
                break a;
              case Ha:
                g3 = 16;
                d3 = null;
                break a;
            }
            throw Error(p4(130, null == a4 ? a4 : typeof a4, ""));
        }
        b4 = Bg(g3, c4, b4, e4);
        b4.elementType = a4;
        b4.type = d3;
        b4.lanes = f3;
        return b4;
      }
      function Tg(a4, b4, c4, d3) {
        a4 = Bg(7, a4, d3, b4);
        a4.lanes = c4;
        return a4;
      }
      function pj(a4, b4, c4, d3) {
        a4 = Bg(22, a4, d3, b4);
        a4.elementType = Ia;
        a4.lanes = c4;
        a4.stateNode = { isHidden: false };
        return a4;
      }
      function Qg(a4, b4, c4) {
        a4 = Bg(6, a4, null, b4);
        a4.lanes = c4;
        return a4;
      }
      function Sg(a4, b4, c4) {
        b4 = Bg(4, null !== a4.children ? a4.children : [], a4.key, b4);
        b4.lanes = c4;
        b4.stateNode = { containerInfo: a4.containerInfo, pendingChildren: null, implementation: a4.implementation };
        return b4;
      }
      function al(a4, b4, c4, d3, e4) {
        this.tag = b4;
        this.containerInfo = a4;
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.pendingContext = this.context = null;
        this.callbackPriority = 0;
        this.eventTimes = zc(0);
        this.expirationTimes = zc(-1);
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = zc(0);
        this.identifierPrefix = d3;
        this.onRecoverableError = e4;
        this.mutableSourceEagerHydrationData = null;
      }
      function bl(a4, b4, c4, d3, e4, f3, g3, h4, k2) {
        a4 = new al(a4, b4, c4, h4, k2);
        1 === b4 ? (b4 = 1, true === f3 && (b4 |= 8)) : b4 = 0;
        f3 = Bg(3, null, null, b4);
        a4.current = f3;
        f3.stateNode = a4;
        f3.memoizedState = { element: d3, isDehydrated: c4, cache: null, transitions: null, pendingSuspenseBoundaries: null };
        kh(f3);
        return a4;
      }
      function cl(a4, b4, c4) {
        var d3 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return { $$typeof: wa, key: null == d3 ? null : "" + d3, children: a4, containerInfo: b4, implementation: c4 };
      }
      function dl(a4) {
        if (!a4) return Vf;
        a4 = a4._reactInternals;
        a: {
          if (Vb(a4) !== a4 || 1 !== a4.tag) throw Error(p4(170));
          var b4 = a4;
          do {
            switch (b4.tag) {
              case 3:
                b4 = b4.stateNode.context;
                break a;
              case 1:
                if (Zf(b4.type)) {
                  b4 = b4.stateNode.__reactInternalMemoizedMergedChildContext;
                  break a;
                }
            }
            b4 = b4.return;
          } while (null !== b4);
          throw Error(p4(171));
        }
        if (1 === a4.tag) {
          var c4 = a4.type;
          if (Zf(c4)) return bg(a4, c4, b4);
        }
        return b4;
      }
      function el(a4, b4, c4, d3, e4, f3, g3, h4, k2) {
        a4 = bl(c4, d3, true, a4, e4, f3, g3, h4, k2);
        a4.context = dl(null);
        c4 = a4.current;
        d3 = R2();
        e4 = yi(c4);
        f3 = mh(d3, e4);
        f3.callback = void 0 !== b4 && null !== b4 ? b4 : null;
        nh(c4, f3, e4);
        a4.current.lanes = e4;
        Ac(a4, e4, d3);
        Dk(a4, d3);
        return a4;
      }
      function fl(a4, b4, c4, d3) {
        var e4 = b4.current, f3 = R2(), g3 = yi(e4);
        c4 = dl(c4);
        null === b4.context ? b4.context = c4 : b4.pendingContext = c4;
        b4 = mh(f3, g3);
        b4.payload = { element: a4 };
        d3 = void 0 === d3 ? null : d3;
        null !== d3 && (b4.callback = d3);
        a4 = nh(e4, b4, g3);
        null !== a4 && (gi(a4, e4, g3, f3), oh(a4, e4, g3));
        return g3;
      }
      function gl(a4) {
        a4 = a4.current;
        if (!a4.child) return null;
        switch (a4.child.tag) {
          case 5:
            return a4.child.stateNode;
          default:
            return a4.child.stateNode;
        }
      }
      function hl(a4, b4) {
        a4 = a4.memoizedState;
        if (null !== a4 && null !== a4.dehydrated) {
          var c4 = a4.retryLane;
          a4.retryLane = 0 !== c4 && c4 < b4 ? c4 : b4;
        }
      }
      function il(a4, b4) {
        hl(a4, b4);
        (a4 = a4.alternate) && hl(a4, b4);
      }
      function jl() {
        return null;
      }
      var kl = "function" === typeof reportError ? reportError : function(a4) {
        console.error(a4);
      };
      function ll(a4) {
        this._internalRoot = a4;
      }
      ml.prototype.render = ll.prototype.render = function(a4) {
        var b4 = this._internalRoot;
        if (null === b4) throw Error(p4(409));
        fl(a4, b4, null, null);
      };
      ml.prototype.unmount = ll.prototype.unmount = function() {
        var a4 = this._internalRoot;
        if (null !== a4) {
          this._internalRoot = null;
          var b4 = a4.containerInfo;
          Rk(function() {
            fl(null, a4, null, null);
          });
          b4[uf] = null;
        }
      };
      function ml(a4) {
        this._internalRoot = a4;
      }
      ml.prototype.unstable_scheduleHydration = function(a4) {
        if (a4) {
          var b4 = Hc();
          a4 = { blockedOn: null, target: a4, priority: b4 };
          for (var c4 = 0; c4 < Qc.length && 0 !== b4 && b4 < Qc[c4].priority; c4++) ;
          Qc.splice(c4, 0, a4);
          0 === c4 && Vc(a4);
        }
      };
      function nl(a4) {
        return !(!a4 || 1 !== a4.nodeType && 9 !== a4.nodeType && 11 !== a4.nodeType);
      }
      function ol(a4) {
        return !(!a4 || 1 !== a4.nodeType && 9 !== a4.nodeType && 11 !== a4.nodeType && (8 !== a4.nodeType || " react-mount-point-unstable " !== a4.nodeValue));
      }
      function pl() {
      }
      function ql(a4, b4, c4, d3, e4) {
        if (e4) {
          if ("function" === typeof d3) {
            var f3 = d3;
            d3 = function() {
              var a5 = gl(g3);
              f3.call(a5);
            };
          }
          var g3 = el(b4, d3, a4, 0, null, false, false, "", pl);
          a4._reactRootContainer = g3;
          a4[uf] = g3.current;
          sf(8 === a4.nodeType ? a4.parentNode : a4);
          Rk();
          return g3;
        }
        for (; e4 = a4.lastChild; ) a4.removeChild(e4);
        if ("function" === typeof d3) {
          var h4 = d3;
          d3 = function() {
            var a5 = gl(k2);
            h4.call(a5);
          };
        }
        var k2 = bl(a4, 0, false, null, null, false, false, "", pl);
        a4._reactRootContainer = k2;
        a4[uf] = k2.current;
        sf(8 === a4.nodeType ? a4.parentNode : a4);
        Rk(function() {
          fl(b4, k2, c4, d3);
        });
        return k2;
      }
      function rl(a4, b4, c4, d3, e4) {
        var f3 = c4._reactRootContainer;
        if (f3) {
          var g3 = f3;
          if ("function" === typeof e4) {
            var h4 = e4;
            e4 = function() {
              var a5 = gl(g3);
              h4.call(a5);
            };
          }
          fl(b4, g3, a4, e4);
        } else g3 = ql(c4, b4, a4, e4, d3);
        return gl(g3);
      }
      Ec = function(a4) {
        switch (a4.tag) {
          case 3:
            var b4 = a4.stateNode;
            if (b4.current.memoizedState.isDehydrated) {
              var c4 = tc(b4.pendingLanes);
              0 !== c4 && (Cc(b4, c4 | 1), Dk(b4, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
            }
            break;
          case 13:
            Rk(function() {
              var b5 = ih(a4, 1);
              if (null !== b5) {
                var c5 = R2();
                gi(b5, a4, 1, c5);
              }
            }), il(a4, 1);
        }
      };
      Fc = function(a4) {
        if (13 === a4.tag) {
          var b4 = ih(a4, 134217728);
          if (null !== b4) {
            var c4 = R2();
            gi(b4, a4, 134217728, c4);
          }
          il(a4, 134217728);
        }
      };
      Gc = function(a4) {
        if (13 === a4.tag) {
          var b4 = yi(a4), c4 = ih(a4, b4);
          if (null !== c4) {
            var d3 = R2();
            gi(c4, a4, b4, d3);
          }
          il(a4, b4);
        }
      };
      Hc = function() {
        return C2;
      };
      Ic = function(a4, b4) {
        var c4 = C2;
        try {
          return C2 = a4, b4();
        } finally {
          C2 = c4;
        }
      };
      yb = function(a4, b4, c4) {
        switch (b4) {
          case "input":
            bb(a4, c4);
            b4 = c4.name;
            if ("radio" === c4.type && null != b4) {
              for (c4 = a4; c4.parentNode; ) c4 = c4.parentNode;
              c4 = c4.querySelectorAll("input[name=" + JSON.stringify("" + b4) + '][type="radio"]');
              for (b4 = 0; b4 < c4.length; b4++) {
                var d3 = c4[b4];
                if (d3 !== a4 && d3.form === a4.form) {
                  var e4 = Db(d3);
                  if (!e4) throw Error(p4(90));
                  Wa(d3);
                  bb(d3, e4);
                }
              }
            }
            break;
          case "textarea":
            ib(a4, c4);
            break;
          case "select":
            b4 = c4.value, null != b4 && fb(a4, !!c4.multiple, b4, false);
        }
      };
      Gb = Qk;
      Hb = Rk;
      var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] };
      var tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
      var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a4) {
        a4 = Zb(a4);
        return null === a4 ? null : a4.stateNode;
      }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!vl.isDisabled && vl.supportsFiber) try {
          kc = vl.inject(ul), lc = vl;
        } catch (a4) {
        }
      }
      var vl;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
      exports.createPortal = function(a4, b4) {
        var c4 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!nl(b4)) throw Error(p4(200));
        return cl(a4, b4, null, c4);
      };
      exports.createRoot = function(a4, b4) {
        if (!nl(a4)) throw Error(p4(299));
        var c4 = false, d3 = "", e4 = kl;
        null !== b4 && void 0 !== b4 && (true === b4.unstable_strictMode && (c4 = true), void 0 !== b4.identifierPrefix && (d3 = b4.identifierPrefix), void 0 !== b4.onRecoverableError && (e4 = b4.onRecoverableError));
        b4 = bl(a4, 1, false, null, null, c4, false, d3, e4);
        a4[uf] = b4.current;
        sf(8 === a4.nodeType ? a4.parentNode : a4);
        return new ll(b4);
      };
      exports.findDOMNode = function(a4) {
        if (null == a4) return null;
        if (1 === a4.nodeType) return a4;
        var b4 = a4._reactInternals;
        if (void 0 === b4) {
          if ("function" === typeof a4.render) throw Error(p4(188));
          a4 = Object.keys(a4).join(",");
          throw Error(p4(268, a4));
        }
        a4 = Zb(b4);
        a4 = null === a4 ? null : a4.stateNode;
        return a4;
      };
      exports.flushSync = function(a4) {
        return Rk(a4);
      };
      exports.hydrate = function(a4, b4, c4) {
        if (!ol(b4)) throw Error(p4(200));
        return rl(null, a4, b4, true, c4);
      };
      exports.hydrateRoot = function(a4, b4, c4) {
        if (!nl(a4)) throw Error(p4(405));
        var d3 = null != c4 && c4.hydratedSources || null, e4 = false, f3 = "", g3 = kl;
        null !== c4 && void 0 !== c4 && (true === c4.unstable_strictMode && (e4 = true), void 0 !== c4.identifierPrefix && (f3 = c4.identifierPrefix), void 0 !== c4.onRecoverableError && (g3 = c4.onRecoverableError));
        b4 = el(b4, null, a4, 1, null != c4 ? c4 : null, e4, false, f3, g3);
        a4[uf] = b4.current;
        sf(a4);
        if (d3) for (a4 = 0; a4 < d3.length; a4++) c4 = d3[a4], e4 = c4._getVersion, e4 = e4(c4._source), null == b4.mutableSourceEagerHydrationData ? b4.mutableSourceEagerHydrationData = [c4, e4] : b4.mutableSourceEagerHydrationData.push(
          c4,
          e4
        );
        return new ml(b4);
      };
      exports.render = function(a4, b4, c4) {
        if (!ol(b4)) throw Error(p4(200));
        return rl(null, a4, b4, false, c4);
      };
      exports.unmountComponentAtNode = function(a4) {
        if (!ol(a4)) throw Error(p4(40));
        return a4._reactRootContainer ? (Rk(function() {
          rl(null, null, a4, false, function() {
            a4._reactRootContainer = null;
            a4[uf] = null;
          });
        }), true) : false;
      };
      exports.unstable_batchedUpdates = Qk;
      exports.unstable_renderSubtreeIntoContainer = function(a4, b4, c4, d3) {
        if (!ol(c4)) throw Error(p4(200));
        if (null == a4 || void 0 === a4._reactInternals) throw Error(p4(38));
        return rl(a4, b4, c4, false, d3);
      };
      exports.version = "18.3.1-next-f1338f8080-20240426";
    }
  });

  // node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/client.js"(exports) {
      "use strict";
      var m3 = require_react_dom();
      if (true) {
        exports.createRoot = m3.createRoot;
        exports.hydrateRoot = m3.hydrateRoot;
      } else {
        i4 = m3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        exports.createRoot = function(c4, o4) {
          i4.usingClientEntryPoint = true;
          try {
            return m3.createRoot(c4, o4);
          } finally {
            i4.usingClientEntryPoint = false;
          }
        };
        exports.hydrateRoot = function(c4, h4, o4) {
          i4.usingClientEntryPoint = true;
          try {
            return m3.hydrateRoot(c4, h4, o4);
          } finally {
            i4.usingClientEntryPoint = false;
          }
        };
      }
      var i4;
    }
  });

  // node_modules/.pnpm/react@18.3.1/node_modules/react/cjs/react-jsx-runtime.production.min.js
  var require_react_jsx_runtime_production_min = __commonJS({
    "node_modules/.pnpm/react@18.3.1/node_modules/react/cjs/react-jsx-runtime.production.min.js"(exports) {
      "use strict";
      var f3 = require_react();
      var k2 = Symbol.for("react.element");
      var l4 = Symbol.for("react.fragment");
      var m3 = Object.prototype.hasOwnProperty;
      var n4 = f3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
      var p4 = { key: true, ref: true, __self: true, __source: true };
      function q2(c4, a4, g3) {
        var b4, d3 = {}, e4 = null, h4 = null;
        void 0 !== g3 && (e4 = "" + g3);
        void 0 !== a4.key && (e4 = "" + a4.key);
        void 0 !== a4.ref && (h4 = a4.ref);
        for (b4 in a4) m3.call(a4, b4) && !p4.hasOwnProperty(b4) && (d3[b4] = a4[b4]);
        if (c4 && c4.defaultProps) for (b4 in a4 = c4.defaultProps, a4) void 0 === d3[b4] && (d3[b4] = a4[b4]);
        return { $$typeof: k2, type: c4, key: e4, ref: h4, props: d3, _owner: n4.current };
      }
      exports.Fragment = l4;
      exports.jsx = q2;
      exports.jsxs = q2;
    }
  });

  // node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_jsx_runtime_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/dayjs.min.js
  var require_dayjs_min = __commonJS({
    "node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/dayjs.min.js"(exports, module) {
      !function(t5, e4) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = e4() : "function" == typeof define && define.amd ? define(e4) : (t5 = "undefined" != typeof globalThis ? globalThis : t5 || self).dayjs = e4();
      }(exports, function() {
        "use strict";
        var t5 = 1e3, e4 = 6e4, n4 = 36e5, r3 = "millisecond", i4 = "second", s4 = "minute", u4 = "hour", a4 = "day", o4 = "week", c4 = "month", f3 = "quarter", h4 = "year", d3 = "date", l4 = "Invalid Date", $3 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y3 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t6) {
          var e5 = ["th", "st", "nd", "rd"], n5 = t6 % 100;
          return "[" + t6 + (e5[(n5 - 20) % 10] || e5[n5] || e5[0]) + "]";
        } }, m3 = function(t6, e5, n5) {
          var r4 = String(t6);
          return !r4 || r4.length >= e5 ? t6 : "" + Array(e5 + 1 - r4.length).join(n5) + t6;
        }, v3 = { s: m3, z: function(t6) {
          var e5 = -t6.utcOffset(), n5 = Math.abs(e5), r4 = Math.floor(n5 / 60), i5 = n5 % 60;
          return (e5 <= 0 ? "+" : "-") + m3(r4, 2, "0") + ":" + m3(i5, 2, "0");
        }, m: function t6(e5, n5) {
          if (e5.date() < n5.date()) return -t6(n5, e5);
          var r4 = 12 * (n5.year() - e5.year()) + (n5.month() - e5.month()), i5 = e5.clone().add(r4, c4), s5 = n5 - i5 < 0, u5 = e5.clone().add(r4 + (s5 ? -1 : 1), c4);
          return +(-(r4 + (n5 - i5) / (s5 ? i5 - u5 : u5 - i5)) || 0);
        }, a: function(t6) {
          return t6 < 0 ? Math.ceil(t6) || 0 : Math.floor(t6);
        }, p: function(t6) {
          return { M: c4, y: h4, w: o4, d: a4, D: d3, h: u4, m: s4, s: i4, ms: r3, Q: f3 }[t6] || String(t6 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t6) {
          return void 0 === t6;
        } }, g3 = "en", D = {};
        D[g3] = M2;
        var p4 = "$isDayjsObject", S2 = function(t6) {
          return t6 instanceof _2 || !(!t6 || !t6[p4]);
        }, w2 = function t6(e5, n5, r4) {
          var i5;
          if (!e5) return g3;
          if ("string" == typeof e5) {
            var s5 = e5.toLowerCase();
            D[s5] && (i5 = s5), n5 && (D[s5] = n5, i5 = s5);
            var u5 = e5.split("-");
            if (!i5 && u5.length > 1) return t6(u5[0]);
          } else {
            var a5 = e5.name;
            D[a5] = e5, i5 = a5;
          }
          return !r4 && i5 && (g3 = i5), i5 || !r4 && g3;
        }, O = function(t6, e5) {
          if (S2(t6)) return t6.clone();
          var n5 = "object" == typeof e5 ? e5 : {};
          return n5.date = t6, n5.args = arguments, new _2(n5);
        }, b4 = v3;
        b4.l = w2, b4.i = S2, b4.w = function(t6, e5) {
          return O(t6, { locale: e5.$L, utc: e5.$u, x: e5.$x, $offset: e5.$offset });
        };
        var _2 = function() {
          function M3(t6) {
            this.$L = w2(t6.locale, null, true), this.parse(t6), this.$x = this.$x || t6.x || {}, this[p4] = true;
          }
          var m4 = M3.prototype;
          return m4.parse = function(t6) {
            this.$d = function(t7) {
              var e5 = t7.date, n5 = t7.utc;
              if (null === e5) return /* @__PURE__ */ new Date(NaN);
              if (b4.u(e5)) return /* @__PURE__ */ new Date();
              if (e5 instanceof Date) return new Date(e5);
              if ("string" == typeof e5 && !/Z$/i.test(e5)) {
                var r4 = e5.match($3);
                if (r4) {
                  var i5 = r4[2] - 1 || 0, s5 = (r4[7] || "0").substring(0, 3);
                  return n5 ? new Date(Date.UTC(r4[1], i5, r4[3] || 1, r4[4] || 0, r4[5] || 0, r4[6] || 0, s5)) : new Date(r4[1], i5, r4[3] || 1, r4[4] || 0, r4[5] || 0, r4[6] || 0, s5);
                }
              }
              return new Date(e5);
            }(t6), this.init();
          }, m4.init = function() {
            var t6 = this.$d;
            this.$y = t6.getFullYear(), this.$M = t6.getMonth(), this.$D = t6.getDate(), this.$W = t6.getDay(), this.$H = t6.getHours(), this.$m = t6.getMinutes(), this.$s = t6.getSeconds(), this.$ms = t6.getMilliseconds();
          }, m4.$utils = function() {
            return b4;
          }, m4.isValid = function() {
            return !(this.$d.toString() === l4);
          }, m4.isSame = function(t6, e5) {
            var n5 = O(t6);
            return this.startOf(e5) <= n5 && n5 <= this.endOf(e5);
          }, m4.isAfter = function(t6, e5) {
            return O(t6) < this.startOf(e5);
          }, m4.isBefore = function(t6, e5) {
            return this.endOf(e5) < O(t6);
          }, m4.$g = function(t6, e5, n5) {
            return b4.u(t6) ? this[e5] : this.set(n5, t6);
          }, m4.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m4.valueOf = function() {
            return this.$d.getTime();
          }, m4.startOf = function(t6, e5) {
            var n5 = this, r4 = !!b4.u(e5) || e5, f4 = b4.p(t6), l5 = function(t7, e6) {
              var i5 = b4.w(n5.$u ? Date.UTC(n5.$y, e6, t7) : new Date(n5.$y, e6, t7), n5);
              return r4 ? i5 : i5.endOf(a4);
            }, $4 = function(t7, e6) {
              return b4.w(n5.toDate()[t7].apply(n5.toDate("s"), (r4 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e6)), n5);
            }, y4 = this.$W, M4 = this.$M, m5 = this.$D, v4 = "set" + (this.$u ? "UTC" : "");
            switch (f4) {
              case h4:
                return r4 ? l5(1, 0) : l5(31, 11);
              case c4:
                return r4 ? l5(1, M4) : l5(0, M4 + 1);
              case o4:
                var g4 = this.$locale().weekStart || 0, D2 = (y4 < g4 ? y4 + 7 : y4) - g4;
                return l5(r4 ? m5 - D2 : m5 + (6 - D2), M4);
              case a4:
              case d3:
                return $4(v4 + "Hours", 0);
              case u4:
                return $4(v4 + "Minutes", 1);
              case s4:
                return $4(v4 + "Seconds", 2);
              case i4:
                return $4(v4 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m4.endOf = function(t6) {
            return this.startOf(t6, false);
          }, m4.$set = function(t6, e5) {
            var n5, o5 = b4.p(t6), f4 = "set" + (this.$u ? "UTC" : ""), l5 = (n5 = {}, n5[a4] = f4 + "Date", n5[d3] = f4 + "Date", n5[c4] = f4 + "Month", n5[h4] = f4 + "FullYear", n5[u4] = f4 + "Hours", n5[s4] = f4 + "Minutes", n5[i4] = f4 + "Seconds", n5[r3] = f4 + "Milliseconds", n5)[o5], $4 = o5 === a4 ? this.$D + (e5 - this.$W) : e5;
            if (o5 === c4 || o5 === h4) {
              var y4 = this.clone().set(d3, 1);
              y4.$d[l5]($4), y4.init(), this.$d = y4.set(d3, Math.min(this.$D, y4.daysInMonth())).$d;
            } else l5 && this.$d[l5]($4);
            return this.init(), this;
          }, m4.set = function(t6, e5) {
            return this.clone().$set(t6, e5);
          }, m4.get = function(t6) {
            return this[b4.p(t6)]();
          }, m4.add = function(r4, f4) {
            var d4, l5 = this;
            r4 = Number(r4);
            var $4 = b4.p(f4), y4 = function(t6) {
              var e5 = O(l5);
              return b4.w(e5.date(e5.date() + Math.round(t6 * r4)), l5);
            };
            if ($4 === c4) return this.set(c4, this.$M + r4);
            if ($4 === h4) return this.set(h4, this.$y + r4);
            if ($4 === a4) return y4(1);
            if ($4 === o4) return y4(7);
            var M4 = (d4 = {}, d4[s4] = e4, d4[u4] = n4, d4[i4] = t5, d4)[$4] || 1, m5 = this.$d.getTime() + r4 * M4;
            return b4.w(m5, this);
          }, m4.subtract = function(t6, e5) {
            return this.add(-1 * t6, e5);
          }, m4.format = function(t6) {
            var e5 = this, n5 = this.$locale();
            if (!this.isValid()) return n5.invalidDate || l4;
            var r4 = t6 || "YYYY-MM-DDTHH:mm:ssZ", i5 = b4.z(this), s5 = this.$H, u5 = this.$m, a5 = this.$M, o5 = n5.weekdays, c5 = n5.months, f4 = n5.meridiem, h5 = function(t7, n6, i6, s6) {
              return t7 && (t7[n6] || t7(e5, r4)) || i6[n6].slice(0, s6);
            }, d4 = function(t7) {
              return b4.s(s5 % 12 || 12, t7, "0");
            }, $4 = f4 || function(t7, e6, n6) {
              var r5 = t7 < 12 ? "AM" : "PM";
              return n6 ? r5.toLowerCase() : r5;
            };
            return r4.replace(y3, function(t7, r5) {
              return r5 || function(t8) {
                switch (t8) {
                  case "YY":
                    return String(e5.$y).slice(-2);
                  case "YYYY":
                    return b4.s(e5.$y, 4, "0");
                  case "M":
                    return a5 + 1;
                  case "MM":
                    return b4.s(a5 + 1, 2, "0");
                  case "MMM":
                    return h5(n5.monthsShort, a5, c5, 3);
                  case "MMMM":
                    return h5(c5, a5);
                  case "D":
                    return e5.$D;
                  case "DD":
                    return b4.s(e5.$D, 2, "0");
                  case "d":
                    return String(e5.$W);
                  case "dd":
                    return h5(n5.weekdaysMin, e5.$W, o5, 2);
                  case "ddd":
                    return h5(n5.weekdaysShort, e5.$W, o5, 3);
                  case "dddd":
                    return o5[e5.$W];
                  case "H":
                    return String(s5);
                  case "HH":
                    return b4.s(s5, 2, "0");
                  case "h":
                    return d4(1);
                  case "hh":
                    return d4(2);
                  case "a":
                    return $4(s5, u5, true);
                  case "A":
                    return $4(s5, u5, false);
                  case "m":
                    return String(u5);
                  case "mm":
                    return b4.s(u5, 2, "0");
                  case "s":
                    return String(e5.$s);
                  case "ss":
                    return b4.s(e5.$s, 2, "0");
                  case "SSS":
                    return b4.s(e5.$ms, 3, "0");
                  case "Z":
                    return i5;
                }
                return null;
              }(t7) || i5.replace(":", "");
            });
          }, m4.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m4.diff = function(r4, d4, l5) {
            var $4, y4 = this, M4 = b4.p(d4), m5 = O(r4), v4 = (m5.utcOffset() - this.utcOffset()) * e4, g4 = this - m5, D2 = function() {
              return b4.m(y4, m5);
            };
            switch (M4) {
              case h4:
                $4 = D2() / 12;
                break;
              case c4:
                $4 = D2();
                break;
              case f3:
                $4 = D2() / 3;
                break;
              case o4:
                $4 = (g4 - v4) / 6048e5;
                break;
              case a4:
                $4 = (g4 - v4) / 864e5;
                break;
              case u4:
                $4 = g4 / n4;
                break;
              case s4:
                $4 = g4 / e4;
                break;
              case i4:
                $4 = g4 / t5;
                break;
              default:
                $4 = g4;
            }
            return l5 ? $4 : b4.a($4);
          }, m4.daysInMonth = function() {
            return this.endOf(c4).$D;
          }, m4.$locale = function() {
            return D[this.$L];
          }, m4.locale = function(t6, e5) {
            if (!t6) return this.$L;
            var n5 = this.clone(), r4 = w2(t6, e5, true);
            return r4 && (n5.$L = r4), n5;
          }, m4.clone = function() {
            return b4.w(this.$d, this);
          }, m4.toDate = function() {
            return new Date(this.valueOf());
          }, m4.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m4.toISOString = function() {
            return this.$d.toISOString();
          }, m4.toString = function() {
            return this.$d.toUTCString();
          }, M3;
        }(), k2 = _2.prototype;
        return O.prototype = k2, [["$ms", r3], ["$s", i4], ["$m", s4], ["$H", u4], ["$W", a4], ["$M", c4], ["$y", h4], ["$D", d3]].forEach(function(t6) {
          k2[t6[1]] = function(e5) {
            return this.$g(e5, t6[0], t6[1]);
          };
        }), O.extend = function(t6, e5) {
          return t6.$i || (t6(e5, _2, O), t6.$i = true), O;
        }, O.locale = w2, O.isDayjs = S2, O.unix = function(t6) {
          return O(1e3 * t6);
        }, O.en = D[g3], O.Ls = D, O.p = {}, O;
      });
    }
  });

  // node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/plugin/relativeTime.js
  var require_relativeTime = __commonJS({
    "node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/plugin/relativeTime.js"(exports, module) {
      !function(r3, e4) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = e4() : "function" == typeof define && define.amd ? define(e4) : (r3 = "undefined" != typeof globalThis ? globalThis : r3 || self).dayjs_plugin_relativeTime = e4();
      }(exports, function() {
        "use strict";
        return function(r3, e4, t5) {
          r3 = r3 || {};
          var n4 = e4.prototype, o4 = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
          function i4(r4, e5, t6, o5) {
            return n4.fromToBase(r4, e5, t6, o5);
          }
          t5.en.relativeTime = o4, n4.fromToBase = function(e5, n5, i5, d4, u4) {
            for (var f3, a4, s4, l4 = i5.$locale().relativeTime || o4, h4 = r3.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], m3 = h4.length, c4 = 0; c4 < m3; c4 += 1) {
              var y3 = h4[c4];
              y3.d && (f3 = d4 ? t5(e5).diff(i5, y3.d, true) : i5.diff(e5, y3.d, true));
              var p4 = (r3.rounding || Math.round)(Math.abs(f3));
              if (s4 = f3 > 0, p4 <= y3.r || !y3.r) {
                p4 <= 1 && c4 > 0 && (y3 = h4[c4 - 1]);
                var v3 = l4[y3.l];
                u4 && (p4 = u4("" + p4)), a4 = "string" == typeof v3 ? v3.replace("%d", p4) : v3(p4, n5, y3.l, s4);
                break;
              }
            }
            if (n5) return a4;
            var M2 = s4 ? l4.future : l4.past;
            return "function" == typeof M2 ? M2(a4) : M2.replace("%s", a4);
          }, n4.to = function(r4, e5) {
            return i4(r4, e5, this, true);
          }, n4.from = function(r4, e5) {
            return i4(r4, e5, this);
          };
          var d3 = function(r4) {
            return r4.$u ? t5.utc() : t5();
          };
          n4.toNow = function(r4) {
            return this.to(d3(this), r4);
          }, n4.fromNow = function(r4) {
            return this.from(d3(this), r4);
          };
        };
      });
    }
  });

  // node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/de.js
  var require_de = __commonJS({
    "node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/de.js"(exports, module) {
      !function(e4, n4) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = n4(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], n4) : (e4 = "undefined" != typeof globalThis ? globalThis : e4 || self).dayjs_locale_de = n4(e4.dayjs);
      }(exports, function(e4) {
        "use strict";
        function n4(e5) {
          return e5 && "object" == typeof e5 && "default" in e5 ? e5 : { default: e5 };
        }
        var t5 = n4(e4), a4 = { s: "ein paar Sekunden", m: ["eine Minute", "einer Minute"], mm: "%d Minuten", h: ["eine Stunde", "einer Stunde"], hh: "%d Stunden", d: ["ein Tag", "einem Tag"], dd: ["%d Tage", "%d Tagen"], M: ["ein Monat", "einem Monat"], MM: ["%d Monate", "%d Monaten"], y: ["ein Jahr", "einem Jahr"], yy: ["%d Jahre", "%d Jahren"] };
        function i4(e5, n5, t6) {
          var i5 = a4[t6];
          return Array.isArray(i5) && (i5 = i5[n5 ? 0 : 1]), i5.replace("%d", e5);
        }
        var r3 = { name: "de", weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"), weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"), weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), months: "Januar_Februar_M\xE4rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Feb._M\xE4rz_Apr._Mai_Juni_Juli_Aug._Sept._Okt._Nov._Dez.".split("_"), ordinal: function(e5) {
          return e5 + ".";
        }, weekStart: 1, yearStart: 4, formats: { LTS: "HH:mm:ss", LT: "HH:mm", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" }, relativeTime: { future: "in %s", past: "vor %s", s: i4, m: i4, mm: i4, h: i4, hh: i4, d: i4, dd: i4, M: i4, MM: i4, y: i4, yy: i4 } };
        return t5.default.locale(r3, null, true), r3;
      });
    }
  });

  // node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/es.js
  var require_es = __commonJS({
    "node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/es.js"(exports, module) {
      !function(e4, o4) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = o4(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], o4) : (e4 = "undefined" != typeof globalThis ? globalThis : e4 || self).dayjs_locale_es = o4(e4.dayjs);
      }(exports, function(e4) {
        "use strict";
        function o4(e5) {
          return e5 && "object" == typeof e5 && "default" in e5 ? e5 : { default: e5 };
        }
        var s4 = o4(e4), d3 = { name: "es", monthsShort: "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), weekdays: "domingo_lunes_martes_mi\xE9rcoles_jueves_viernes_s\xE1bado".split("_"), weekdaysShort: "dom._lun._mar._mi\xE9._jue._vie._s\xE1b.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_s\xE1".split("_"), months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), weekStart: 1, formats: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un d\xEDa", dd: "%d d\xEDas", M: "un mes", MM: "%d meses", y: "un a\xF1o", yy: "%d a\xF1os" }, ordinal: function(e5) {
          return e5 + "\xBA";
        } };
        return s4.default.locale(d3, null, true), d3;
      });
    }
  });

  // node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/fr.js
  var require_fr = __commonJS({
    "node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/fr.js"(exports, module) {
      !function(e4, n4) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = n4(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], n4) : (e4 = "undefined" != typeof globalThis ? globalThis : e4 || self).dayjs_locale_fr = n4(e4.dayjs);
      }(exports, function(e4) {
        "use strict";
        function n4(e5) {
          return e5 && "object" == typeof e5 && "default" in e5 ? e5 : { default: e5 };
        }
        var t5 = n4(e4), i4 = { name: "fr", weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"), weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"), weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"), months: "janvier_f\xE9vrier_mars_avril_mai_juin_juillet_ao\xFBt_septembre_octobre_novembre_d\xE9cembre".split("_"), monthsShort: "janv._f\xE9vr._mars_avr._mai_juin_juil._ao\xFBt_sept._oct._nov._d\xE9c.".split("_"), weekStart: 1, yearStart: 4, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, relativeTime: { future: "dans %s", past: "il y a %s", s: "quelques secondes", m: "une minute", mm: "%d minutes", h: "une heure", hh: "%d heures", d: "un jour", dd: "%d jours", M: "un mois", MM: "%d mois", y: "un an", yy: "%d ans" }, ordinal: function(e5) {
          return "" + e5 + (1 === e5 ? "er" : "");
        } };
        return t5.default.locale(i4, null, true), i4;
      });
    }
  });

  // node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/ja.js
  var require_ja = __commonJS({
    "node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/ja.js"(exports, module) {
      !function(e4, _2) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = _2(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], _2) : (e4 = "undefined" != typeof globalThis ? globalThis : e4 || self).dayjs_locale_ja = _2(e4.dayjs);
      }(exports, function(e4) {
        "use strict";
        function _2(e5) {
          return e5 && "object" == typeof e5 && "default" in e5 ? e5 : { default: e5 };
        }
        var t5 = _2(e4), d3 = { name: "ja", weekdays: "\u65E5\u66DC\u65E5_\u6708\u66DC\u65E5_\u706B\u66DC\u65E5_\u6C34\u66DC\u65E5_\u6728\u66DC\u65E5_\u91D1\u66DC\u65E5_\u571F\u66DC\u65E5".split("_"), weekdaysShort: "\u65E5_\u6708_\u706B_\u6C34_\u6728_\u91D1_\u571F".split("_"), weekdaysMin: "\u65E5_\u6708_\u706B_\u6C34_\u6728_\u91D1_\u571F".split("_"), months: "1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"), monthsShort: "1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"), ordinal: function(e5) {
          return e5 + "\u65E5";
        }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY\u5E74M\u6708D\u65E5", LLL: "YYYY\u5E74M\u6708D\u65E5 HH:mm", LLLL: "YYYY\u5E74M\u6708D\u65E5 dddd HH:mm", l: "YYYY/MM/DD", ll: "YYYY\u5E74M\u6708D\u65E5", lll: "YYYY\u5E74M\u6708D\u65E5 HH:mm", llll: "YYYY\u5E74M\u6708D\u65E5(ddd) HH:mm" }, meridiem: function(e5) {
          return e5 < 12 ? "\u5348\u524D" : "\u5348\u5F8C";
        }, relativeTime: { future: "%s\u5F8C", past: "%s\u524D", s: "\u6570\u79D2", m: "1\u5206", mm: "%d\u5206", h: "1\u6642\u9593", hh: "%d\u6642\u9593", d: "1\u65E5", dd: "%d\u65E5", M: "1\u30F6\u6708", MM: "%d\u30F6\u6708", y: "1\u5E74", yy: "%d\u5E74" } };
        return t5.default.locale(d3, null, true), d3;
      });
    }
  });

  // node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/ko.js
  var require_ko = __commonJS({
    "node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/ko.js"(exports, module) {
      !function(e4, _2) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = _2(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], _2) : (e4 = "undefined" != typeof globalThis ? globalThis : e4 || self).dayjs_locale_ko = _2(e4.dayjs);
      }(exports, function(e4) {
        "use strict";
        function _2(e5) {
          return e5 && "object" == typeof e5 && "default" in e5 ? e5 : { default: e5 };
        }
        var d3 = _2(e4), t5 = { name: "ko", weekdays: "\uC77C\uC694\uC77C_\uC6D4\uC694\uC77C_\uD654\uC694\uC77C_\uC218\uC694\uC77C_\uBAA9\uC694\uC77C_\uAE08\uC694\uC77C_\uD1A0\uC694\uC77C".split("_"), weekdaysShort: "\uC77C_\uC6D4_\uD654_\uC218_\uBAA9_\uAE08_\uD1A0".split("_"), weekdaysMin: "\uC77C_\uC6D4_\uD654_\uC218_\uBAA9_\uAE08_\uD1A0".split("_"), months: "1\uC6D4_2\uC6D4_3\uC6D4_4\uC6D4_5\uC6D4_6\uC6D4_7\uC6D4_8\uC6D4_9\uC6D4_10\uC6D4_11\uC6D4_12\uC6D4".split("_"), monthsShort: "1\uC6D4_2\uC6D4_3\uC6D4_4\uC6D4_5\uC6D4_6\uC6D4_7\uC6D4_8\uC6D4_9\uC6D4_10\uC6D4_11\uC6D4_12\uC6D4".split("_"), ordinal: function(e5) {
          return e5 + "\uC77C";
        }, formats: { LT: "A h:mm", LTS: "A h:mm:ss", L: "YYYY.MM.DD.", LL: "YYYY\uB144 MMMM D\uC77C", LLL: "YYYY\uB144 MMMM D\uC77C A h:mm", LLLL: "YYYY\uB144 MMMM D\uC77C dddd A h:mm", l: "YYYY.MM.DD.", ll: "YYYY\uB144 MMMM D\uC77C", lll: "YYYY\uB144 MMMM D\uC77C A h:mm", llll: "YYYY\uB144 MMMM D\uC77C dddd A h:mm" }, meridiem: function(e5) {
          return e5 < 12 ? "\uC624\uC804" : "\uC624\uD6C4";
        }, relativeTime: { future: "%s \uD6C4", past: "%s \uC804", s: "\uBA87 \uCD08", m: "1\uBD84", mm: "%d\uBD84", h: "\uD55C \uC2DC\uAC04", hh: "%d\uC2DC\uAC04", d: "\uD558\uB8E8", dd: "%d\uC77C", M: "\uD55C \uB2EC", MM: "%d\uB2EC", y: "\uC77C \uB144", yy: "%d\uB144" } };
        return d3.default.locale(t5, null, true), t5;
      });
    }
  });

  // node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/pl.js
  var require_pl = __commonJS({
    "node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/pl.js"(exports, module) {
      !function(e4, t5) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = t5(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], t5) : (e4 = "undefined" != typeof globalThis ? globalThis : e4 || self).dayjs_locale_pl = t5(e4.dayjs);
      }(exports, function(e4) {
        "use strict";
        function t5(e5) {
          return e5 && "object" == typeof e5 && "default" in e5 ? e5 : { default: e5 };
        }
        var i4 = t5(e4);
        function a4(e5) {
          return e5 % 10 < 5 && e5 % 10 > 1 && ~~(e5 / 10) % 10 != 1;
        }
        function n4(e5, t6, i5) {
          var n5 = e5 + " ";
          switch (i5) {
            case "m":
              return t6 ? "minuta" : "minut\u0119";
            case "mm":
              return n5 + (a4(e5) ? "minuty" : "minut");
            case "h":
              return t6 ? "godzina" : "godzin\u0119";
            case "hh":
              return n5 + (a4(e5) ? "godziny" : "godzin");
            case "MM":
              return n5 + (a4(e5) ? "miesi\u0105ce" : "miesi\u0119cy");
            case "yy":
              return n5 + (a4(e5) ? "lata" : "lat");
          }
        }
        var r3 = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrze\u015Bnia_pa\u017Adziernika_listopada_grudnia".split("_"), _2 = "stycze\u0144_luty_marzec_kwiecie\u0144_maj_czerwiec_lipiec_sierpie\u0144_wrzesie\u0144_pa\u017Adziernik_listopad_grudzie\u0144".split("_"), s4 = /D MMMM/, d3 = function(e5, t6) {
          return s4.test(t6) ? r3[e5.month()] : _2[e5.month()];
        };
        d3.s = _2, d3.f = r3;
        var o4 = { name: "pl", weekdays: "niedziela_poniedzia\u0142ek_wtorek_\u015Broda_czwartek_pi\u0105tek_sobota".split("_"), weekdaysShort: "ndz_pon_wt_\u015Br_czw_pt_sob".split("_"), weekdaysMin: "Nd_Pn_Wt_\u015Ar_Cz_Pt_So".split("_"), months: d3, monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa\u017A_lis_gru".split("_"), ordinal: function(e5) {
          return e5 + ".";
        }, weekStart: 1, yearStart: 4, relativeTime: { future: "za %s", past: "%s temu", s: "kilka sekund", m: n4, mm: n4, h: n4, hh: n4, d: "1 dzie\u0144", dd: "%d dni", M: "miesi\u0105c", MM: n4, y: "rok", yy: n4 }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" } };
        return i4.default.locale(o4, null, true), o4;
      });
    }
  });

  // node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/pt-br.js
  var require_pt_br = __commonJS({
    "node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/pt-br.js"(exports, module) {
      !function(e4, o4) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = o4(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], o4) : (e4 = "undefined" != typeof globalThis ? globalThis : e4 || self).dayjs_locale_pt_br = o4(e4.dayjs);
      }(exports, function(e4) {
        "use strict";
        function o4(e5) {
          return e5 && "object" == typeof e5 && "default" in e5 ? e5 : { default: e5 };
        }
        var a4 = o4(e4), s4 = { name: "pt-br", weekdays: "domingo_segunda-feira_ter\xE7a-feira_quarta-feira_quinta-feira_sexta-feira_s\xE1bado".split("_"), weekdaysShort: "dom_seg_ter_qua_qui_sex_s\xE1b".split("_"), weekdaysMin: "Do_2\xAA_3\xAA_4\xAA_5\xAA_6\xAA_S\xE1".split("_"), months: "janeiro_fevereiro_mar\xE7o_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"), monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"), ordinal: function(e5) {
          return e5 + "\xBA";
        }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY [\xE0s] HH:mm", LLLL: "dddd, D [de] MMMM [de] YYYY [\xE0s] HH:mm" }, relativeTime: { future: "em %s", past: "h\xE1 %s", s: "poucos segundos", m: "um minuto", mm: "%d minutos", h: "uma hora", hh: "%d horas", d: "um dia", dd: "%d dias", M: "um m\xEAs", MM: "%d meses", y: "um ano", yy: "%d anos" } };
        return a4.default.locale(s4, null, true), s4;
      });
    }
  });

  // node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/ru.js
  var require_ru = __commonJS({
    "node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/ru.js"(exports, module) {
      !function(_2, t5) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = t5(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], t5) : (_2 = "undefined" != typeof globalThis ? globalThis : _2 || self).dayjs_locale_ru = t5(_2.dayjs);
      }(exports, function(_2) {
        "use strict";
        function t5(_3) {
          return _3 && "object" == typeof _3 && "default" in _3 ? _3 : { default: _3 };
        }
        var e4 = t5(_2), n4 = "\u044F\u043D\u0432\u0430\u0440\u044F_\u0444\u0435\u0432\u0440\u0430\u043B\u044F_\u043C\u0430\u0440\u0442\u0430_\u0430\u043F\u0440\u0435\u043B\u044F_\u043C\u0430\u044F_\u0438\u044E\u043D\u044F_\u0438\u044E\u043B\u044F_\u0430\u0432\u0433\u0443\u0441\u0442\u0430_\u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044F_\u043E\u043A\u0442\u044F\u0431\u0440\u044F_\u043D\u043E\u044F\u0431\u0440\u044F_\u0434\u0435\u043A\u0430\u0431\u0440\u044F".split("_"), s4 = "\u044F\u043D\u0432\u0430\u0440\u044C_\u0444\u0435\u0432\u0440\u0430\u043B\u044C_\u043C\u0430\u0440\u0442_\u0430\u043F\u0440\u0435\u043B\u044C_\u043C\u0430\u0439_\u0438\u044E\u043D\u044C_\u0438\u044E\u043B\u044C_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044C_\u043E\u043A\u0442\u044F\u0431\u0440\u044C_\u043D\u043E\u044F\u0431\u0440\u044C_\u0434\u0435\u043A\u0430\u0431\u0440\u044C".split("_"), r3 = "\u044F\u043D\u0432._\u0444\u0435\u0432\u0440._\u043C\u0430\u0440._\u0430\u043F\u0440._\u043C\u0430\u044F_\u0438\u044E\u043D\u044F_\u0438\u044E\u043B\u044F_\u0430\u0432\u0433._\u0441\u0435\u043D\u0442._\u043E\u043A\u0442._\u043D\u043E\u044F\u0431._\u0434\u0435\u043A.".split("_"), o4 = "\u044F\u043D\u0432._\u0444\u0435\u0432\u0440._\u043C\u0430\u0440\u0442_\u0430\u043F\u0440._\u043C\u0430\u0439_\u0438\u044E\u043D\u044C_\u0438\u044E\u043B\u044C_\u0430\u0432\u0433._\u0441\u0435\u043D\u0442._\u043E\u043A\u0442._\u043D\u043E\u044F\u0431._\u0434\u0435\u043A.".split("_"), i4 = /D[oD]?(\[[^[\]]*\]|\s)+MMMM?/;
        function d3(_3, t6, e5) {
          var n5, s5;
          return "m" === e5 ? t6 ? "\u043C\u0438\u043D\u0443\u0442\u0430" : "\u043C\u0438\u043D\u0443\u0442\u0443" : _3 + " " + (n5 = +_3, s5 = { mm: t6 ? "\u043C\u0438\u043D\u0443\u0442\u0430_\u043C\u0438\u043D\u0443\u0442\u044B_\u043C\u0438\u043D\u0443\u0442" : "\u043C\u0438\u043D\u0443\u0442\u0443_\u043C\u0438\u043D\u0443\u0442\u044B_\u043C\u0438\u043D\u0443\u0442", hh: "\u0447\u0430\u0441_\u0447\u0430\u0441\u0430_\u0447\u0430\u0441\u043E\u0432", dd: "\u0434\u0435\u043D\u044C_\u0434\u043D\u044F_\u0434\u043D\u0435\u0439", MM: "\u043C\u0435\u0441\u044F\u0446_\u043C\u0435\u0441\u044F\u0446\u0430_\u043C\u0435\u0441\u044F\u0446\u0435\u0432", yy: "\u0433\u043E\u0434_\u0433\u043E\u0434\u0430_\u043B\u0435\u0442" }[e5].split("_"), n5 % 10 == 1 && n5 % 100 != 11 ? s5[0] : n5 % 10 >= 2 && n5 % 10 <= 4 && (n5 % 100 < 10 || n5 % 100 >= 20) ? s5[1] : s5[2]);
        }
        var u4 = function(_3, t6) {
          return i4.test(t6) ? n4[_3.month()] : s4[_3.month()];
        };
        u4.s = s4, u4.f = n4;
        var a4 = function(_3, t6) {
          return i4.test(t6) ? r3[_3.month()] : o4[_3.month()];
        };
        a4.s = o4, a4.f = r3;
        var m3 = { name: "ru", weekdays: "\u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435_\u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A_\u0432\u0442\u043E\u0440\u043D\u0438\u043A_\u0441\u0440\u0435\u0434\u0430_\u0447\u0435\u0442\u0432\u0435\u0440\u0433_\u043F\u044F\u0442\u043D\u0438\u0446\u0430_\u0441\u0443\u0431\u0431\u043E\u0442\u0430".split("_"), weekdaysShort: "\u0432\u0441\u043A_\u043F\u043D\u0434_\u0432\u0442\u0440_\u0441\u0440\u0434_\u0447\u0442\u0432_\u043F\u0442\u043D_\u0441\u0431\u0442".split("_"), weekdaysMin: "\u0432\u0441_\u043F\u043D_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043F\u0442_\u0441\u0431".split("_"), months: u4, monthsShort: a4, weekStart: 1, yearStart: 4, formats: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY \u0433.", LLL: "D MMMM YYYY \u0433., H:mm", LLLL: "dddd, D MMMM YYYY \u0433., H:mm" }, relativeTime: { future: "\u0447\u0435\u0440\u0435\u0437 %s", past: "%s \u043D\u0430\u0437\u0430\u0434", s: "\u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E \u0441\u0435\u043A\u0443\u043D\u0434", m: d3, mm: d3, h: "\u0447\u0430\u0441", hh: d3, d: "\u0434\u0435\u043D\u044C", dd: d3, M: "\u043C\u0435\u0441\u044F\u0446", MM: d3, y: "\u0433\u043E\u0434", yy: d3 }, ordinal: function(_3) {
          return _3;
        }, meridiem: function(_3) {
          return _3 < 4 ? "\u043D\u043E\u0447\u0438" : _3 < 12 ? "\u0443\u0442\u0440\u0430" : _3 < 17 ? "\u0434\u043D\u044F" : "\u0432\u0435\u0447\u0435\u0440\u0430";
        } };
        return e4.default.locale(m3, null, true), m3;
      });
    }
  });

  // node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/tr.js
  var require_tr = __commonJS({
    "node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/tr.js"(exports, module) {
      !function(a4, e4) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = e4(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], e4) : (a4 = "undefined" != typeof globalThis ? globalThis : a4 || self).dayjs_locale_tr = e4(a4.dayjs);
      }(exports, function(a4) {
        "use strict";
        function e4(a5) {
          return a5 && "object" == typeof a5 && "default" in a5 ? a5 : { default: a5 };
        }
        var t5 = e4(a4), _2 = { name: "tr", weekdays: "Pazar_Pazartesi_Sal\u0131_\xC7ar\u015Famba_Per\u015Fembe_Cuma_Cumartesi".split("_"), weekdaysShort: "Paz_Pts_Sal_\xC7ar_Per_Cum_Cts".split("_"), weekdaysMin: "Pz_Pt_Sa_\xC7a_Pe_Cu_Ct".split("_"), months: "Ocak_\u015Eubat_Mart_Nisan_May\u0131s_Haziran_Temmuz_A\u011Fustos_Eyl\xFCl_Ekim_Kas\u0131m_Aral\u0131k".split("_"), monthsShort: "Oca_\u015Eub_Mar_Nis_May_Haz_Tem_A\u011Fu_Eyl_Eki_Kas_Ara".split("_"), weekStart: 1, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, relativeTime: { future: "%s sonra", past: "%s \xF6nce", s: "birka\xE7 saniye", m: "bir dakika", mm: "%d dakika", h: "bir saat", hh: "%d saat", d: "bir g\xFCn", dd: "%d g\xFCn", M: "bir ay", MM: "%d ay", y: "bir y\u0131l", yy: "%d y\u0131l" }, ordinal: function(a5) {
          return a5 + ".";
        } };
        return t5.default.locale(_2, null, true), _2;
      });
    }
  });

  // node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/uk.js
  var require_uk = __commonJS({
    "node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/uk.js"(exports, module) {
      !function(_2, e4) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = e4(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], e4) : (_2 = "undefined" != typeof globalThis ? globalThis : _2 || self).dayjs_locale_uk = e4(_2.dayjs);
      }(exports, function(_2) {
        "use strict";
        function e4(_3) {
          return _3 && "object" == typeof _3 && "default" in _3 ? _3 : { default: _3 };
        }
        var t5 = e4(_2), s4 = "\u0441\u0456\u0447\u043D\u044F_\u043B\u044E\u0442\u043E\u0433\u043E_\u0431\u0435\u0440\u0435\u0437\u043D\u044F_\u043A\u0432\u0456\u0442\u043D\u044F_\u0442\u0440\u0430\u0432\u043D\u044F_\u0447\u0435\u0440\u0432\u043D\u044F_\u043B\u0438\u043F\u043D\u044F_\u0441\u0435\u0440\u043F\u043D\u044F_\u0432\u0435\u0440\u0435\u0441\u043D\u044F_\u0436\u043E\u0432\u0442\u043D\u044F_\u043B\u0438\u0441\u0442\u043E\u043F\u0430\u0434\u0430_\u0433\u0440\u0443\u0434\u043D\u044F".split("_"), n4 = "\u0441\u0456\u0447\u0435\u043D\u044C_\u043B\u044E\u0442\u0438\u0439_\u0431\u0435\u0440\u0435\u0437\u0435\u043D\u044C_\u043A\u0432\u0456\u0442\u0435\u043D\u044C_\u0442\u0440\u0430\u0432\u0435\u043D\u044C_\u0447\u0435\u0440\u0432\u0435\u043D\u044C_\u043B\u0438\u043F\u0435\u043D\u044C_\u0441\u0435\u0440\u043F\u0435\u043D\u044C_\u0432\u0435\u0440\u0435\u0441\u0435\u043D\u044C_\u0436\u043E\u0432\u0442\u0435\u043D\u044C_\u043B\u0438\u0441\u0442\u043E\u043F\u0430\u0434_\u0433\u0440\u0443\u0434\u0435\u043D\u044C".split("_"), o4 = /D[oD]?(\[[^[\]]*\]|\s)+MMMM?/;
        function d3(_3, e5, t6) {
          var s5, n5;
          return "m" === t6 ? e5 ? "\u0445\u0432\u0438\u043B\u0438\u043D\u0430" : "\u0445\u0432\u0438\u043B\u0438\u043D\u0443" : "h" === t6 ? e5 ? "\u0433\u043E\u0434\u0438\u043D\u0430" : "\u0433\u043E\u0434\u0438\u043D\u0443" : _3 + " " + (s5 = +_3, n5 = { ss: e5 ? "\u0441\u0435\u043A\u0443\u043D\u0434\u0430_\u0441\u0435\u043A\u0443\u043D\u0434\u0438_\u0441\u0435\u043A\u0443\u043D\u0434" : "\u0441\u0435\u043A\u0443\u043D\u0434\u0443_\u0441\u0435\u043A\u0443\u043D\u0434\u0438_\u0441\u0435\u043A\u0443\u043D\u0434", mm: e5 ? "\u0445\u0432\u0438\u043B\u0438\u043D\u0430_\u0445\u0432\u0438\u043B\u0438\u043D\u0438_\u0445\u0432\u0438\u043B\u0438\u043D" : "\u0445\u0432\u0438\u043B\u0438\u043D\u0443_\u0445\u0432\u0438\u043B\u0438\u043D\u0438_\u0445\u0432\u0438\u043B\u0438\u043D", hh: e5 ? "\u0433\u043E\u0434\u0438\u043D\u0430_\u0433\u043E\u0434\u0438\u043D\u0438_\u0433\u043E\u0434\u0438\u043D" : "\u0433\u043E\u0434\u0438\u043D\u0443_\u0433\u043E\u0434\u0438\u043D\u0438_\u0433\u043E\u0434\u0438\u043D", dd: "\u0434\u0435\u043D\u044C_\u0434\u043D\u0456_\u0434\u043D\u0456\u0432", MM: "\u043C\u0456\u0441\u044F\u0446\u044C_\u043C\u0456\u0441\u044F\u0446\u0456_\u043C\u0456\u0441\u044F\u0446\u0456\u0432", yy: "\u0440\u0456\u043A_\u0440\u043E\u043A\u0438_\u0440\u043E\u043A\u0456\u0432" }[t6].split("_"), s5 % 10 == 1 && s5 % 100 != 11 ? n5[0] : s5 % 10 >= 2 && s5 % 10 <= 4 && (s5 % 100 < 10 || s5 % 100 >= 20) ? n5[1] : n5[2]);
        }
        var i4 = function(_3, e5) {
          return o4.test(e5) ? s4[_3.month()] : n4[_3.month()];
        };
        i4.s = n4, i4.f = s4;
        var r3 = { name: "uk", weekdays: "\u043D\u0435\u0434\u0456\u043B\u044F_\u043F\u043E\u043D\u0435\u0434\u0456\u043B\u043E\u043A_\u0432\u0456\u0432\u0442\u043E\u0440\u043E\u043A_\u0441\u0435\u0440\u0435\u0434\u0430_\u0447\u0435\u0442\u0432\u0435\u0440_\u043F\u2019\u044F\u0442\u043D\u0438\u0446\u044F_\u0441\u0443\u0431\u043E\u0442\u0430".split("_"), weekdaysShort: "\u043D\u0434\u043B_\u043F\u043D\u0434_\u0432\u0442\u0440_\u0441\u0440\u0434_\u0447\u0442\u0432_\u043F\u0442\u043D_\u0441\u0431\u0442".split("_"), weekdaysMin: "\u043D\u0434_\u043F\u043D_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043F\u0442_\u0441\u0431".split("_"), months: i4, monthsShort: "\u0441\u0456\u0447_\u043B\u044E\u0442_\u0431\u0435\u0440_\u043A\u0432\u0456\u0442_\u0442\u0440\u0430\u0432_\u0447\u0435\u0440\u0432_\u043B\u0438\u043F_\u0441\u0435\u0440\u043F_\u0432\u0435\u0440_\u0436\u043E\u0432\u0442_\u043B\u0438\u0441\u0442_\u0433\u0440\u0443\u0434".split("_"), weekStart: 1, relativeTime: { future: "\u0437\u0430 %s", past: "%s \u0442\u043E\u043C\u0443", s: "\u0434\u0435\u043A\u0456\u043B\u044C\u043A\u0430 \u0441\u0435\u043A\u0443\u043D\u0434", m: d3, mm: d3, h: d3, hh: d3, d: "\u0434\u0435\u043D\u044C", dd: d3, M: "\u043C\u0456\u0441\u044F\u0446\u044C", MM: d3, y: "\u0440\u0456\u043A", yy: d3 }, ordinal: function(_3) {
          return _3;
        }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY \u0440.", LLL: "D MMMM YYYY \u0440., HH:mm", LLLL: "dddd, D MMMM YYYY \u0440., HH:mm" } };
        return t5.default.locale(r3, null, true), r3;
      });
    }
  });

  // node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/zh-cn.js
  var require_zh_cn = __commonJS({
    "node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/zh-cn.js"(exports, module) {
      !function(e4, _2) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = _2(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], _2) : (e4 = "undefined" != typeof globalThis ? globalThis : e4 || self).dayjs_locale_zh_cn = _2(e4.dayjs);
      }(exports, function(e4) {
        "use strict";
        function _2(e5) {
          return e5 && "object" == typeof e5 && "default" in e5 ? e5 : { default: e5 };
        }
        var t5 = _2(e4), d3 = { name: "zh-cn", weekdays: "\u661F\u671F\u65E5_\u661F\u671F\u4E00_\u661F\u671F\u4E8C_\u661F\u671F\u4E09_\u661F\u671F\u56DB_\u661F\u671F\u4E94_\u661F\u671F\u516D".split("_"), weekdaysShort: "\u5468\u65E5_\u5468\u4E00_\u5468\u4E8C_\u5468\u4E09_\u5468\u56DB_\u5468\u4E94_\u5468\u516D".split("_"), weekdaysMin: "\u65E5_\u4E00_\u4E8C_\u4E09_\u56DB_\u4E94_\u516D".split("_"), months: "\u4E00\u6708_\u4E8C\u6708_\u4E09\u6708_\u56DB\u6708_\u4E94\u6708_\u516D\u6708_\u4E03\u6708_\u516B\u6708_\u4E5D\u6708_\u5341\u6708_\u5341\u4E00\u6708_\u5341\u4E8C\u6708".split("_"), monthsShort: "1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"), ordinal: function(e5, _3) {
          return "W" === _3 ? e5 + "\u5468" : e5 + "\u65E5";
        }, weekStart: 1, yearStart: 4, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY\u5E74M\u6708D\u65E5", LLL: "YYYY\u5E74M\u6708D\u65E5Ah\u70B9mm\u5206", LLLL: "YYYY\u5E74M\u6708D\u65E5ddddAh\u70B9mm\u5206", l: "YYYY/M/D", ll: "YYYY\u5E74M\u6708D\u65E5", lll: "YYYY\u5E74M\u6708D\u65E5 HH:mm", llll: "YYYY\u5E74M\u6708D\u65E5dddd HH:mm" }, relativeTime: { future: "%s\u5185", past: "%s\u524D", s: "\u51E0\u79D2", m: "1 \u5206\u949F", mm: "%d \u5206\u949F", h: "1 \u5C0F\u65F6", hh: "%d \u5C0F\u65F6", d: "1 \u5929", dd: "%d \u5929", M: "1 \u4E2A\u6708", MM: "%d \u4E2A\u6708", y: "1 \u5E74", yy: "%d \u5E74" }, meridiem: function(e5, _3) {
          var t6 = 100 * e5 + _3;
          return t6 < 600 ? "\u51CC\u6668" : t6 < 900 ? "\u65E9\u4E0A" : t6 < 1100 ? "\u4E0A\u5348" : t6 < 1300 ? "\u4E2D\u5348" : t6 < 1800 ? "\u4E0B\u5348" : "\u665A\u4E0A";
        } };
        return t5.default.locale(d3, null, true), d3;
      });
    }
  });

  // node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/zh-tw.js
  var require_zh_tw = __commonJS({
    "node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/locale/zh-tw.js"(exports, module) {
      !function(_2, e4) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = e4(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], e4) : (_2 = "undefined" != typeof globalThis ? globalThis : _2 || self).dayjs_locale_zh_tw = e4(_2.dayjs);
      }(exports, function(_2) {
        "use strict";
        function e4(_3) {
          return _3 && "object" == typeof _3 && "default" in _3 ? _3 : { default: _3 };
        }
        var t5 = e4(_2), d3 = { name: "zh-tw", weekdays: "\u661F\u671F\u65E5_\u661F\u671F\u4E00_\u661F\u671F\u4E8C_\u661F\u671F\u4E09_\u661F\u671F\u56DB_\u661F\u671F\u4E94_\u661F\u671F\u516D".split("_"), weekdaysShort: "\u9031\u65E5_\u9031\u4E00_\u9031\u4E8C_\u9031\u4E09_\u9031\u56DB_\u9031\u4E94_\u9031\u516D".split("_"), weekdaysMin: "\u65E5_\u4E00_\u4E8C_\u4E09_\u56DB_\u4E94_\u516D".split("_"), months: "\u4E00\u6708_\u4E8C\u6708_\u4E09\u6708_\u56DB\u6708_\u4E94\u6708_\u516D\u6708_\u4E03\u6708_\u516B\u6708_\u4E5D\u6708_\u5341\u6708_\u5341\u4E00\u6708_\u5341\u4E8C\u6708".split("_"), monthsShort: "1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"), ordinal: function(_3, e5) {
          return "W" === e5 ? _3 + "\u9031" : _3 + "\u65E5";
        }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY\u5E74M\u6708D\u65E5", LLL: "YYYY\u5E74M\u6708D\u65E5 HH:mm", LLLL: "YYYY\u5E74M\u6708D\u65E5dddd HH:mm", l: "YYYY/M/D", ll: "YYYY\u5E74M\u6708D\u65E5", lll: "YYYY\u5E74M\u6708D\u65E5 HH:mm", llll: "YYYY\u5E74M\u6708D\u65E5dddd HH:mm" }, relativeTime: { future: "%s\u5167", past: "%s\u524D", s: "\u5E7E\u79D2", m: "1 \u5206\u9418", mm: "%d \u5206\u9418", h: "1 \u5C0F\u6642", hh: "%d \u5C0F\u6642", d: "1 \u5929", dd: "%d \u5929", M: "1 \u500B\u6708", MM: "%d \u500B\u6708", y: "1 \u5E74", yy: "%d \u5E74" }, meridiem: function(_3, e5) {
          var t6 = 100 * _3 + e5;
          return t6 < 600 ? "\u51CC\u6668" : t6 < 900 ? "\u65E9\u4E0A" : t6 < 1100 ? "\u4E0A\u5348" : t6 < 1300 ? "\u4E2D\u5348" : t6 < 1800 ? "\u4E0B\u5348" : "\u665A\u4E0A";
        } };
        return t5.default.locale(d3, null, true), d3;
      });
    }
  });

  // node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/plugin/duration.js
  var require_duration = __commonJS({
    "node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/plugin/duration.js"(exports, module) {
      !function(t5, s4) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = s4() : "function" == typeof define && define.amd ? define(s4) : (t5 = "undefined" != typeof globalThis ? globalThis : t5 || self).dayjs_plugin_duration = s4();
      }(exports, function() {
        "use strict";
        var t5, s4, n4 = 1e3, i4 = 6e4, e4 = 36e5, r3 = 864e5, o4 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, u4 = 31536e6, d3 = 2628e6, a4 = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, h4 = { years: u4, months: d3, days: r3, hours: e4, minutes: i4, seconds: n4, milliseconds: 1, weeks: 6048e5 }, c4 = function(t6) {
          return t6 instanceof g3;
        }, f3 = function(t6, s5, n5) {
          return new g3(t6, n5, s5.$l);
        }, m3 = function(t6) {
          return s4.p(t6) + "s";
        }, l4 = function(t6) {
          return t6 < 0;
        }, $3 = function(t6) {
          return l4(t6) ? Math.ceil(t6) : Math.floor(t6);
        }, y3 = function(t6) {
          return Math.abs(t6);
        }, v3 = function(t6, s5) {
          return t6 ? l4(t6) ? { negative: true, format: "" + y3(t6) + s5 } : { negative: false, format: "" + t6 + s5 } : { negative: false, format: "" };
        }, g3 = function() {
          function l5(t6, s5, n5) {
            var i5 = this;
            if (this.$d = {}, this.$l = n5, void 0 === t6 && (this.$ms = 0, this.parseFromMilliseconds()), s5) return f3(t6 * h4[m3(s5)], this);
            if ("number" == typeof t6) return this.$ms = t6, this.parseFromMilliseconds(), this;
            if ("object" == typeof t6) return Object.keys(t6).forEach(function(s6) {
              i5.$d[m3(s6)] = t6[s6];
            }), this.calMilliseconds(), this;
            if ("string" == typeof t6) {
              var e5 = t6.match(a4);
              if (e5) {
                var r4 = e5.slice(2).map(function(t7) {
                  return null != t7 ? Number(t7) : 0;
                });
                return this.$d.years = r4[0], this.$d.months = r4[1], this.$d.weeks = r4[2], this.$d.days = r4[3], this.$d.hours = r4[4], this.$d.minutes = r4[5], this.$d.seconds = r4[6], this.calMilliseconds(), this;
              }
            }
            return this;
          }
          var y4 = l5.prototype;
          return y4.calMilliseconds = function() {
            var t6 = this;
            this.$ms = Object.keys(this.$d).reduce(function(s5, n5) {
              return s5 + (t6.$d[n5] || 0) * h4[n5];
            }, 0);
          }, y4.parseFromMilliseconds = function() {
            var t6 = this.$ms;
            this.$d.years = $3(t6 / u4), t6 %= u4, this.$d.months = $3(t6 / d3), t6 %= d3, this.$d.days = $3(t6 / r3), t6 %= r3, this.$d.hours = $3(t6 / e4), t6 %= e4, this.$d.minutes = $3(t6 / i4), t6 %= i4, this.$d.seconds = $3(t6 / n4), t6 %= n4, this.$d.milliseconds = t6;
          }, y4.toISOString = function() {
            var t6 = v3(this.$d.years, "Y"), s5 = v3(this.$d.months, "M"), n5 = +this.$d.days || 0;
            this.$d.weeks && (n5 += 7 * this.$d.weeks);
            var i5 = v3(n5, "D"), e5 = v3(this.$d.hours, "H"), r4 = v3(this.$d.minutes, "M"), o5 = this.$d.seconds || 0;
            this.$d.milliseconds && (o5 += this.$d.milliseconds / 1e3, o5 = Math.round(1e3 * o5) / 1e3);
            var u5 = v3(o5, "S"), d4 = t6.negative || s5.negative || i5.negative || e5.negative || r4.negative || u5.negative, a5 = e5.format || r4.format || u5.format ? "T" : "", h5 = (d4 ? "-" : "") + "P" + t6.format + s5.format + i5.format + a5 + e5.format + r4.format + u5.format;
            return "P" === h5 || "-P" === h5 ? "P0D" : h5;
          }, y4.toJSON = function() {
            return this.toISOString();
          }, y4.format = function(t6) {
            var n5 = t6 || "YYYY-MM-DDTHH:mm:ss", i5 = { Y: this.$d.years, YY: s4.s(this.$d.years, 2, "0"), YYYY: s4.s(this.$d.years, 4, "0"), M: this.$d.months, MM: s4.s(this.$d.months, 2, "0"), D: this.$d.days, DD: s4.s(this.$d.days, 2, "0"), H: this.$d.hours, HH: s4.s(this.$d.hours, 2, "0"), m: this.$d.minutes, mm: s4.s(this.$d.minutes, 2, "0"), s: this.$d.seconds, ss: s4.s(this.$d.seconds, 2, "0"), SSS: s4.s(this.$d.milliseconds, 3, "0") };
            return n5.replace(o4, function(t7, s5) {
              return s5 || String(i5[t7]);
            });
          }, y4.as = function(t6) {
            return this.$ms / h4[m3(t6)];
          }, y4.get = function(t6) {
            var s5 = this.$ms, n5 = m3(t6);
            return "milliseconds" === n5 ? s5 %= 1e3 : s5 = "weeks" === n5 ? $3(s5 / h4[n5]) : this.$d[n5], s5 || 0;
          }, y4.add = function(t6, s5, n5) {
            var i5;
            return i5 = s5 ? t6 * h4[m3(s5)] : c4(t6) ? t6.$ms : f3(t6, this).$ms, f3(this.$ms + i5 * (n5 ? -1 : 1), this);
          }, y4.subtract = function(t6, s5) {
            return this.add(t6, s5, true);
          }, y4.locale = function(t6) {
            var s5 = this.clone();
            return s5.$l = t6, s5;
          }, y4.clone = function() {
            return f3(this.$ms, this);
          }, y4.humanize = function(s5) {
            return t5().add(this.$ms, "ms").locale(this.$l).fromNow(!s5);
          }, y4.valueOf = function() {
            return this.asMilliseconds();
          }, y4.milliseconds = function() {
            return this.get("milliseconds");
          }, y4.asMilliseconds = function() {
            return this.as("milliseconds");
          }, y4.seconds = function() {
            return this.get("seconds");
          }, y4.asSeconds = function() {
            return this.as("seconds");
          }, y4.minutes = function() {
            return this.get("minutes");
          }, y4.asMinutes = function() {
            return this.as("minutes");
          }, y4.hours = function() {
            return this.get("hours");
          }, y4.asHours = function() {
            return this.as("hours");
          }, y4.days = function() {
            return this.get("days");
          }, y4.asDays = function() {
            return this.as("days");
          }, y4.weeks = function() {
            return this.get("weeks");
          }, y4.asWeeks = function() {
            return this.as("weeks");
          }, y4.months = function() {
            return this.get("months");
          }, y4.asMonths = function() {
            return this.as("months");
          }, y4.years = function() {
            return this.get("years");
          }, y4.asYears = function() {
            return this.as("years");
          }, l5;
        }(), p4 = function(t6, s5, n5) {
          return t6.add(s5.years() * n5, "y").add(s5.months() * n5, "M").add(s5.days() * n5, "d").add(s5.hours() * n5, "h").add(s5.minutes() * n5, "m").add(s5.seconds() * n5, "s").add(s5.milliseconds() * n5, "ms");
        };
        return function(n5, i5, e5) {
          t5 = e5, s4 = e5().$utils(), e5.duration = function(t6, s5) {
            var n6 = e5.locale();
            return f3(t6, { $l: n6 }, s5);
          }, e5.isDuration = c4;
          var r4 = i5.prototype.add, o5 = i5.prototype.subtract;
          i5.prototype.add = function(t6, s5) {
            return c4(t6) ? p4(this, t6, 1) : r4.bind(this)(t6, s5);
          }, i5.prototype.subtract = function(t6, s5) {
            return c4(t6) ? p4(this, t6, -1) : o5.bind(this)(t6, s5);
          };
        };
      });
    }
  });

  // node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/plugin/utc.js
  var require_utc = __commonJS({
    "node_modules/.pnpm/dayjs@1.11.11/node_modules/dayjs/plugin/utc.js"(exports, module) {
      !function(t5, i4) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = i4() : "function" == typeof define && define.amd ? define(i4) : (t5 = "undefined" != typeof globalThis ? globalThis : t5 || self).dayjs_plugin_utc = i4();
      }(exports, function() {
        "use strict";
        var t5 = "minute", i4 = /[+-]\d\d(?::?\d\d)?/g, e4 = /([+-]|\d\d)/g;
        return function(s4, f3, n4) {
          var u4 = f3.prototype;
          n4.utc = function(t6) {
            var i5 = { date: t6, utc: true, args: arguments };
            return new f3(i5);
          }, u4.utc = function(i5) {
            var e5 = n4(this.toDate(), { locale: this.$L, utc: true });
            return i5 ? e5.add(this.utcOffset(), t5) : e5;
          }, u4.local = function() {
            return n4(this.toDate(), { locale: this.$L, utc: false });
          };
          var o4 = u4.parse;
          u4.parse = function(t6) {
            t6.utc && (this.$u = true), this.$utils().u(t6.$offset) || (this.$offset = t6.$offset), o4.call(this, t6);
          };
          var r3 = u4.init;
          u4.init = function() {
            if (this.$u) {
              var t6 = this.$d;
              this.$y = t6.getUTCFullYear(), this.$M = t6.getUTCMonth(), this.$D = t6.getUTCDate(), this.$W = t6.getUTCDay(), this.$H = t6.getUTCHours(), this.$m = t6.getUTCMinutes(), this.$s = t6.getUTCSeconds(), this.$ms = t6.getUTCMilliseconds();
            } else r3.call(this);
          };
          var a4 = u4.utcOffset;
          u4.utcOffset = function(s5, f4) {
            var n5 = this.$utils().u;
            if (n5(s5)) return this.$u ? 0 : n5(this.$offset) ? a4.call(this) : this.$offset;
            if ("string" == typeof s5 && (s5 = function(t6) {
              void 0 === t6 && (t6 = "");
              var s6 = t6.match(i4);
              if (!s6) return null;
              var f5 = ("" + s6[0]).match(e4) || ["-", 0, 0], n6 = f5[0], u6 = 60 * +f5[1] + +f5[2];
              return 0 === u6 ? 0 : "+" === n6 ? u6 : -u6;
            }(s5), null === s5)) return this;
            var u5 = Math.abs(s5) <= 16 ? 60 * s5 : s5, o5 = this;
            if (f4) return o5.$offset = u5, o5.$u = 0 === s5, o5;
            if (0 !== s5) {
              var r4 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
              (o5 = this.local().add(u5 + r4, t5)).$offset = u5, o5.$x.$localOffset = r4;
            } else o5 = this.utc();
            return o5;
          };
          var h4 = u4.format;
          u4.format = function(t6) {
            var i5 = t6 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
            return h4.call(this, i5);
          }, u4.valueOf = function() {
            var t6 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
            return this.$d.valueOf() - 6e4 * t6;
          }, u4.isUTC = function() {
            return !!this.$u;
          }, u4.toISOString = function() {
            return this.toDate().toISOString();
          }, u4.toString = function() {
            return this.toDate().toUTCString();
          };
          var l4 = u4.toDate;
          u4.toDate = function(t6) {
            return "s" === t6 && this.$offset ? n4(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l4.call(this);
          };
          var c4 = u4.diff;
          u4.diff = function(t6, i5, e5) {
            if (t6 && this.$u === t6.$u) return c4.call(this, t6, i5, e5);
            var s5 = this.local(), f4 = n4(t6).local();
            return c4.call(s5, f4, i5, e5);
          };
        };
      });
    }
  });

  // src/scripts/options.tsx
  var import_client = __toESM(require_client(), 1);

  // src/scripts/components/baseline.tsx
  var import_react4 = __toESM(require_react(), 1);

  // node_modules/.pnpm/goober@2.1.10_csstype@3.1.3/node_modules/goober/dist/goober.modern.js
  var e = { data: "" };
  var t = (t5) => "object" == typeof window ? ((t5 ? t5.querySelector("#_goober") : window._goober) || Object.assign((t5 || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : t5 || e;
  var l = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g;
  var a = /\/\*[^]*?\*\/|  +/g;
  var n = /\n+/g;
  var o = (e4, t5) => {
    let r3 = "", l4 = "", a4 = "";
    for (let n4 in e4) {
      let c4 = e4[n4];
      "@" == n4[0] ? "i" == n4[1] ? r3 = n4 + " " + c4 + ";" : l4 += "f" == n4[1] ? o(c4, n4) : n4 + "{" + o(c4, "k" == n4[1] ? "" : t5) + "}" : "object" == typeof c4 ? l4 += o(c4, t5 ? t5.replace(/([^,])+/g, (e5) => n4.replace(/(^:.*)|([^,])+/g, (t6) => /&/.test(t6) ? t6.replace(/&/g, e5) : e5 ? e5 + " " + t6 : t6)) : n4) : null != c4 && (n4 = /^--/.test(n4) ? n4 : n4.replace(/[A-Z]/g, "-$&").toLowerCase(), a4 += o.p ? o.p(n4, c4) : n4 + ":" + c4 + ";");
    }
    return r3 + (t5 && a4 ? t5 + "{" + a4 + "}" : a4) + l4;
  };
  var c = {};
  var s = (e4) => {
    if ("object" == typeof e4) {
      let t5 = "";
      for (let r3 in e4) t5 += r3 + s(e4[r3]);
      return t5;
    }
    return e4;
  };
  var i = (e4, t5, r3, i4, p4) => {
    let u4 = s(e4), d3 = c[u4] || (c[u4] = ((e5) => {
      let t6 = 0, r4 = 11;
      for (; t6 < e5.length; ) r4 = 101 * r4 + e5.charCodeAt(t6++) >>> 0;
      return "go" + r4;
    })(u4));
    if (!c[d3]) {
      let t6 = u4 !== e4 ? e4 : ((e5) => {
        let t7, r4, o4 = [{}];
        for (; t7 = l.exec(e5.replace(a, "")); ) t7[4] ? o4.shift() : t7[3] ? (r4 = t7[3].replace(n, " ").trim(), o4.unshift(o4[0][r4] = o4[0][r4] || {})) : o4[0][t7[1]] = t7[2].replace(n, " ").trim();
        return o4[0];
      })(e4);
      c[d3] = o(p4 ? { ["@keyframes " + d3]: t6 } : t6, r3 ? "" : "." + d3);
    }
    return ((e5, t6, r4) => {
      -1 == t6.data.indexOf(e5) && (t6.data = r4 ? e5 + t6.data : t6.data + e5);
    })(c[d3], t5, i4), d3;
  };
  var p = (e4, t5, r3) => e4.reduce((e5, l4, a4) => {
    let n4 = t5[a4];
    if (n4 && n4.call) {
      let e6 = n4(r3), t6 = e6 && e6.props && e6.props.className || /^go/.test(e6) && e6;
      n4 = t6 ? "." + t6 : e6 && "object" == typeof e6 ? e6.props ? "" : o(e6, "") : false === e6 ? "" : e6;
    }
    return e5 + l4 + (null == n4 ? "" : n4);
  }, "");
  function u(e4) {
    let r3 = this || {}, l4 = e4.call ? e4(r3.p) : e4;
    return i(l4.unshift ? l4.raw ? p(l4, [].slice.call(arguments, 1), r3.p) : l4.reduce((e5, t5) => Object.assign(e5, t5 && t5.call ? t5(r3.p) : t5), {}) : l4, t(r3.target), r3.g, r3.o, r3.k);
  }
  var b = u.bind({ g: 1 });
  var h = u.bind({ k: 1 });

  // src/scripts/components/styles.tsx
  var import_react = __toESM(require_react(), 1);
  var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
  var StylesContext = import_react.default.createContext({
    css: u,
    glob: b
  });
  function useCSS() {
    const { css } = (0, import_react.useContext)(StylesContext);
    return css;
  }
  function useGlob() {
    const { glob } = (0, import_react.useContext)(StylesContext);
    return glob;
  }

  // src/scripts/components/utilities.ts
  var import_react3 = __toESM(require_react(), 1);

  // src/scripts/components/theme.tsx
  var import_react2 = __toESM(require_react(), 1);
  var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
  var darkTheme = {
    name: "dark",
    background: "rgb(32, 33, 36)",
    button: {
      primary: {
        background: "rgb(138, 180, 248)",
        backgroundActive: "rgba(138, 180, 248, 0.8)",
        backgroundDisabled: "rgb(60, 64, 67)",
        backgroundHovered: "rgba(138, 180, 248, 0.9)",
        text: "rgb(32, 33, 36)",
        textDisabled: "rgb(128, 134, 139)"
      },
      secondary: {
        background: "transparent",
        backgroundActive: "rgba(138, 180, 248, 0.16)",
        backgroundDisabled: "transparent",
        backgroundHovered: "rgba(138, 180, 248, 0.08)",
        border: "rgb(95, 99, 104)",
        text: "rgb(138, 180, 248)",
        textDisabled: "rgb(128, 134, 139)"
      }
    },
    checkBox: {
      border: "rgb(154, 160, 166)",
      box: "rgb(138, 180, 248)",
      checkMark: "rgb(32, 33, 36)"
    },
    colorPicker: {
      border: "rgb(95, 99, 104)",
      popoverBackground: "rgb(41, 42, 45)"
    },
    dialog: {
      background: "rgb(41, 42, 45)"
    },
    editor: {
      border: "rgb(95, 99, 104)"
    },
    focus: {
      shadow: "rgba(138, 180, 248, 0.5)",
      circle: "rgba(138, 180, 248, 0.4)"
    },
    iconButton: "rgb(154, 160, 166)",
    input: {
      border: "rgb(95, 99, 104)"
    },
    link: {
      text: "rgb(138, 180, 248)"
    },
    menu: {
      itemBackgroundFocused: "rgba(95, 99, 104, 0.6)",
      itemBackgroundHovered: "rgba(95, 99, 104, 0.3)",
      itemListBackground: "rgb(41, 42, 45)"
    },
    radioButton: {
      unchecked: "rgb(154, 160, 166)",
      checked: "rgb(138, 180, 248)"
    },
    section: {
      background: "rgb(41, 42, 45)",
      shadow1: "rgba(0, 0, 0, 0.3)",
      shadow2: "rgba(0, 0, 0, 0.15)"
    },
    select: {
      arrow: "rgb(154, 160, 166)",
      border: "rgb(95, 99, 104)",
      optionBackground: "rgb(41, 42, 45)"
    },
    separator: "rgba(255, 255, 255, 0.1)",
    switch: {
      bar: "rgb(154, 160, 166)",
      barChecked: "rgba(138, 180, 248, 0.5)",
      knob: "rgb(218, 220, 224)",
      knobChecked: "rgb(138, 180, 248)"
    },
    text: {
      primary: "rgb(232, 234, 237)",
      secondary: "rgb(154, 160, 166)"
    },
    textArea: {
      border: "rgb(95, 99, 104)"
    }
  };
  var lightTheme = {
    name: "light",
    background: "rgb(248, 249, 250)",
    button: {
      primary: {
        background: "rgb(26, 115, 232)",
        backgroundActive: "rgba(26, 115, 232, 0.8)",
        backgroundDisabled: "rgb(241, 243, 244)",
        backgroundHovered: "rgba(26, 115, 232, 0.9)",
        text: "white",
        textDisabled: "rgb(128, 134, 139)"
      },
      secondary: {
        background: "transparent",
        backgroundActive: "rgba(66, 133, 244, 0.08)",
        backgroundDisabled: "transparent",
        backgroundHovered: "rgba(66, 133, 244, 0.04)",
        border: "rgb(218, 220, 224)",
        text: "rgb(26, 115, 232)",
        textDisabled: "rgb(128, 134, 139)"
      }
    },
    checkBox: {
      border: "rgb(95, 99, 104)",
      box: "rgb(26, 115, 232)",
      checkMark: "white"
    },
    colorPicker: {
      border: "rgb(218, 220, 224)",
      popoverBackground: "white"
    },
    dialog: {
      background: "white"
    },
    editor: {
      border: "rgb(218, 220, 224)"
    },
    focus: {
      shadow: "rgba(26, 115, 232, 0.4)",
      circle: "rgba(26, 115, 232, 0.2)"
    },
    iconButton: "rgb(95, 99, 104)",
    input: {
      border: "rgb(218, 220, 224)"
    },
    link: {
      text: "rgb(51, 103, 214)"
    },
    menu: {
      itemBackgroundFocused: "rgba(189, 193, 198, 0.3)",
      itemBackgroundHovered: "rgba(189, 193, 198, 0.15)",
      itemListBackground: "white"
    },
    radioButton: {
      unchecked: "rgb(95, 99, 104)",
      checked: "rgb(26, 115, 232)"
    },
    section: {
      background: "white",
      shadow1: "rgba(60, 64, 67, 0.3)",
      shadow2: "rgba(60, 64, 67, 0.15)"
    },
    select: {
      arrow: "rgb(95, 99, 104)",
      border: "rgb(218, 220, 224)",
      optionBackground: "white"
    },
    separator: "rgba(0, 0, 0, 0.06)",
    switch: {
      bar: "rgb(189, 193, 198)",
      barChecked: "rgba(26, 115, 232, 0.5)",
      knob: "white",
      knobBorder: "rgb(218, 220, 224)",
      knobChecked: "rgb(26, 115, 232)"
    },
    text: {
      primary: "rgb(32, 33, 36)",
      secondary: "rgb(95, 99, 104)"
    },
    textArea: {
      border: "rgb(218, 220, 224)"
    }
  };
  var ThemeContext = import_react2.default.createContext({
    theme: lightTheme
  });
  var ThemeProvider = ({
    children,
    theme: theme2
  }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(ThemeContext.Provider, { value: { theme: theme2 }, children });
  };
  function useTheme() {
    const { theme: theme2 } = (0, import_react2.useContext)(ThemeContext);
    return theme2;
  }
  var AutoThemeProvider = ({
    children
  }) => {
    const preferDark = (0, import_react2.useRef)(window.matchMedia("(prefers-color-scheme: dark)"));
    const [dark, setDark] = (0, import_react2.useState)(preferDark.current.matches);
    (0, import_react2.useEffect)(() => {
      preferDark.current.addEventListener("change", (e4) => {
        setDark(e4.matches);
      });
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(ThemeProvider, { theme: dark ? darkTheme : lightTheme, children });
  };

  // src/scripts/components/utilities.ts
  function useClassName(props, deps) {
    const css = useCSS();
    const theme2 = useTheme();
    const className = (0, import_react3.useMemo)(() => css(props(theme2)), [css, theme2, ...deps]);
    return className;
  }
  function usePrevious(value, defaultValue) {
    const previousRef = (0, import_react3.useRef)(defaultValue);
    const previous = previousRef.current;
    previousRef.current = value;
    return previous;
  }

  // src/scripts/components/baseline.tsx
  var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
  var fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif';
  var Baseline = ({
    children,
    fontSize = "13px"
  }) => {
    const rootClassName = useClassName(
      (theme2) => ({
        colorScheme: theme2.name
      }),
      []
    );
    const bodyClassName = useClassName(
      (theme2) => ({
        background: theme2.background,
        color: theme2.text.primary,
        margin: 0,
        fontFamily,
        fontSize,
        lineHeight: 1.5
      }),
      [fontSize]
    );
    (0, import_react4.useLayoutEffect)(() => {
      document.documentElement.classList.add(rootClassName);
      document.body.classList.add(bodyClassName);
      return () => {
        document.documentElement.classList.remove(rootClassName);
        document.body.classList.remove(bodyClassName);
      };
    }, [rootClassName, bodyClassName]);
    const glob = useGlob();
    (0, import_react4.useLayoutEffect)(() => {
      glob({
        "*, *::before, *::after": {
          boxSizing: "border-box"
        }
      });
    }, [glob]);
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children });
  };

  // src/scripts/components/container.tsx
  var import_react6 = __toESM(require_react(), 1);

  // src/scripts/components/helpers.tsx
  var import_react5 = __toESM(require_react(), 1);
  var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
  function applyClassName(props, className) {
    return {
      ...props,
      className: `${className}${props.className ? ` ${props.className}` : ""}`
    };
  }
  function useInnerRef(ref) {
    const innerRef = (0, import_react5.useRef)(null);
    (0, import_react5.useLayoutEffect)(() => {
      if (ref && typeof ref === "object" && innerRef.current != null) {
        ref.current = innerRef.current;
      }
    }, [ref]);
    return innerRef;
  }
  var FocusCircle = ({ depth = 0 }) => {
    const className = useClassName(
      (theme2) => ({
        borderRadius: "50%",
        height: "40px",
        left: "calc(50% - 20px)",
        pointerEvents: "none",
        position: "absolute",
        top: "calc(50% - 20px)",
        width: "40px",
        [`:focus + ${"* > ".repeat(depth)}&`]: {
          background: theme2.focus.circle
        },
        [`:focus:not(:focus-visible) + ${"* > ".repeat(depth)}&`]: {
          background: "transparent"
        },
        [`:focus:not(:-moz-focusring) + ${"* > ".repeat(depth)}&`]: {
          background: "transparent"
        }
      }),
      [depth]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className });
  };

  // src/scripts/components/container.tsx
  var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
  var Container = import_react6.default.forwardRef(
    function Container2({ width = "640px", ...props }, ref) {
      const wrapperClassName = useClassName(
        () => ({
          bottom: 0,
          left: 0,
          overflow: "auto",
          position: "fixed",
          right: 0,
          top: 0
        }),
        []
      );
      const containerClassName = useClassName(
        () => ({
          margin: "0 auto",
          maxWidth: "100%",
          padding: "2em 0",
          width
        }),
        [width]
      );
      return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: wrapperClassName, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { ...applyClassName(props, containerClassName), ref }) });
    }
  );

  // src/scripts/browser.ts
  var browser = false ? globalThis.chrome : globalThis.browser;

  // src/scripts/locales.ts
  function translate(messageName, ...substitutions) {
    return browser.i18n.getMessage(
      messageName,
      substitutions
    );
  }
  function getWebsiteURL(path) {
    const locale = translate("websiteLocale");
    return `https://iorate.github.io/ublacklist${locale === "en" ? "" : `/${locale}`}${path.startsWith("/") ? "" : "/"}${path}`;
  }

  // src/scripts/options/about-section.tsx
  var import_react13 = __toESM(require_react(), 1);

  // src/icons/icon.svg
  var icon_default = '<svg xmlns="http://www.w3.org/2000/svg" width="128" height="128"><circle cx="64" cy="64" r="64" fill="#fff"/><circle cx="64" cy="64" r="48" fill="none" stroke="#000" stroke-width="16"/><path stroke="#000" stroke-width="16" d="M96 32L32 96"/></svg>';

  // src/scripts/components/icon.tsx
  var import_react7 = __toESM(require_react(), 1);
  var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
  var Icon = import_react7.default.forwardRef(function Icon2({ iconSize = "24px", url, ...props }, ref) {
    const className = useClassName(
      () => ({
        background: `url("${url}") center / ${iconSize} no-repeat`,
        display: "block",
        height: iconSize,
        width: iconSize
      }),
      [iconSize, url]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { ...applyClassName(props, className), ref });
  });
  var TemplateIcon = import_react7.default.forwardRef(function TemplateIcon2({ color = "black", iconSize = "24px", url, ...props }, ref) {
    const className = useClassName(
      () => ({
        backgroundColor: color,
        display: "block",
        height: iconSize,
        mask: `url("${url}") center / ${iconSize} no-repeat`,
        WebkitMask: `url("${url}") center / ${iconSize} no-repeat`,
        width: iconSize
      }),
      [color, iconSize, url]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { ...applyClassName(props, className), ref });
  });

  // src/scripts/components/indent.tsx
  var import_react8 = __toESM(require_react(), 1);
  var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
  var Indent = import_react8.default.forwardRef(
    function Indent2({ depth = 1, ...props }, ref) {
      const className = useClassName(
        () => ({
          width: `${2.375 * depth}em`
        }),
        [depth]
      );
      return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { ...applyClassName(props, className), ref });
    }
  );

  // src/scripts/components/label.tsx
  var import_react9 = __toESM(require_react(), 1);

  // src/scripts/components/constants.ts
  var FOCUS_START_CLASS = "js-focus-start";
  var FOCUS_END_CLASS = "js-focus-end";
  var FOCUS_DEFAULT_CLASS = "js-focus-default";
  var MENU_ITEM_CLASS = "js-menu-item";
  var DISABLED_OPACITY = 0.38;
  var INPUT_Z_INDEX = 1;
  var COLOR_PICKER_Z_INDEX = 2;
  var MENU_Z_INDEX = 2;
  var DIALOG_Z_INDEX = 1e5;

  // src/scripts/components/label.tsx
  var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
  var LabelContext = import_react9.default.createContext(null);
  function useLabelContext() {
    const value = (0, import_react9.useContext)(LabelContext);
    if (!value) {
      throw new Error("useLabelContext: no matching provider");
    }
    return value;
  }
  var LabelWrapper = import_react9.default.forwardRef(
    function LabelWrapper2({ disabled = false, fullWidth = false, ...props }, ref) {
      const className = useClassName(
        () => ({
          marginBottom: fullWidth ? "0.5em" : 0,
          opacity: disabled ? DISABLED_OPACITY : 1
        }),
        [disabled, fullWidth]
      );
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(LabelContext.Provider, { value: { disabled }, children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { ...applyClassName(props, className), ref }) });
    }
  );
  var Label = import_react9.default.forwardRef(
    function Label2(props, ref) {
      const { disabled } = useLabelContext();
      const className = useClassName(
        (theme2) => ({
          color: theme2.text.primary,
          cursor: disabled ? "default" : "auto"
        }),
        [disabled]
      );
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { ...applyClassName(props, className), ref }) });
    }
  );
  var ControlLabel = import_react9.default.forwardRef(function ControlLabel2({ children, for: for_, ...props }, ref) {
    const { disabled } = useLabelContext();
    const className = useClassName(
      (theme2) => ({
        color: theme2.text.primary,
        cursor: disabled ? "default" : "pointer"
      }),
      [disabled]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("label", { ...applyClassName(props, className), htmlFor: for_, ref, children }) });
  });
  var SubLabel = import_react9.default.forwardRef(
    function SubLabel2(props, ref) {
      const { disabled } = useLabelContext();
      const className = useClassName(
        (theme2) => ({
          color: theme2.text.secondary,
          cursor: disabled ? "default" : "auto"
        }),
        [disabled]
      );
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { ...applyClassName(props, className), ref }) });
    }
  );

  // src/scripts/components/link.tsx
  var import_react10 = __toESM(require_react(), 1);
  var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
  var Link = import_react10.default.forwardRef(
    function Link2({ disabled = false, ...props }, ref) {
      const className = useClassName(
        (theme2) => ({
          color: theme2.link.text,
          outline: "none",
          textDecoration: "none",
          "&:focus": {
            boxShadow: `0 0 0 2px ${theme2.focus.shadow}`
          },
          "&:focus:not(:focus-visible)": {
            boxShadow: "none"
          },
          "&:focus:not(:-moz-focusring)": {
            boxShadow: "none"
          }
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        "a",
        {
          ...applyClassName(props, className),
          ...disabled ? {} : { href: props.href },
          ref,
          rel: "noopener noreferrer",
          target: "_blank"
        }
      );
    }
  );
  function expandLinks(text, disabled = false) {
    const children = [];
    const split = text.split(/\[([^\]]*)]\(([^)]*)\)/g);
    for (let i4 = 0; i4 < split.length; ++i4) {
      if (i4 % 3 === 0) {
        children.push(split[i4]);
      } else if (i4 % 3 === 1) {
        children.push(
          /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Link, { disabled, href: split[i4 + 1], children: split[i4] }, i4)
        );
        ++i4;
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(import_jsx_runtime9.Fragment, { children });
  }

  // src/scripts/components/row.tsx
  var import_react11 = __toESM(require_react(), 1);
  var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
  var Row = import_react11.default.forwardRef(function Row2({ multiline = false, right = false, ...props }, ref) {
    const className = useClassName(
      () => ({
        alignItems: "center",
        display: "flex",
        flexWrap: multiline ? "wrap" : "nowrap",
        justifyContent: right ? "flex-end" : "flex-start",
        "&:not(:first-child)": {
          marginTop: "1em"
        }
      }),
      [multiline, right]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { ...applyClassName(props, className), ref });
  });
  var RowItem = import_react11.default.forwardRef(
    function RowItem2({ expanded = false, ...props }, ref) {
      const className = useClassName(
        () => ({
          flexGrow: expanded ? 1 : 0,
          flexShrink: expanded ? 1 : 0,
          minWidth: 0,
          "&:not(:first-child)": {
            marginLeft: "0.625em"
          }
        }),
        [expanded]
      );
      return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { ...applyClassName(props, className), ref });
    }
  );

  // src/scripts/components/section.tsx
  var import_react12 = __toESM(require_react(), 1);
  var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
  var Section = import_react12.default.forwardRef(
    function Section2(props, ref) {
      const className = useClassName(
        () => ({
          "&:not(:first-child)": {
            marginTop: "2em"
          }
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("section", { ...applyClassName(props, className), ref });
    }
  );
  var SectionHeader = import_react12.default.forwardRef(function SectionHeader2({ maxWidth = "640px", ...props }, ref) {
    const className = useClassName(
      () => ({
        marginBottom: "1em",
        [`@media screen and (max-width: ${maxWidth})`]: {
          padding: "0 1.25em"
        }
      }),
      [maxWidth]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { ...applyClassName(props, className), ref });
  });
  var SectionTitle = import_react12.default.forwardRef(function SectionTitle2({ children, ...props }, ref) {
    const className = useClassName(
      () => ({
        fontSize: "1.125em",
        fontWeight: "normal",
        margin: 0
      }),
      []
    );
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("h1", { ...applyClassName(props, className), ref, children });
  });
  var SectionBody = import_react12.default.forwardRef(
    function SectionBody2(props, ref) {
      const className = useClassName(
        (theme2) => ({
          background: theme2.section.background,
          borderRadius: "4px",
          boxShadow: `0 1px 2px 0 ${theme2.section.shadow1}, 0 1px 3px 1px ${theme2.section.shadow2}`
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { ...applyClassName(props, className), ref });
    }
  );
  var SectionItem = import_react12.default.forwardRef(
    function SectionItem2(props, ref) {
      const className = useClassName(
        (theme2) => ({
          padding: "0.75em 1.25em",
          "&:not(:first-child)": {
            borderTop: `solid 1px ${theme2.separator}`
          }
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { ...applyClassName(props, className), ref });
    }
  );

  // src/scripts/utilities.ts
  var import_dayjs = __toESM(require_dayjs_min(), 1);

  // node_modules/.pnpm/@lezer+common@1.2.1/node_modules/@lezer/common/dist/index.js
  var DefaultBufferLength = 1024;
  var nextPropID = 0;
  var Range = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  var NodeProp = class {
    /**
    Create a new node prop type.
    */
    constructor(config = {}) {
      this.id = nextPropID++;
      this.perNode = !!config.perNode;
      this.deserialize = config.deserialize || (() => {
        throw new Error("This node type doesn't define a deserialize function");
      });
    }
    /**
    This is meant to be used with
    [`NodeSet.extend`](#common.NodeSet.extend) or
    [`LRParser.configure`](#lr.ParserConfig.props) to compute
    prop values for each node type in the set. Takes a [match
    object](#common.NodeType^match) or function that returns undefined
    if the node type doesn't get this prop, and the prop's value if
    it does.
    */
    add(match) {
      if (this.perNode)
        throw new RangeError("Can't add per-node props to node types");
      if (typeof match != "function")
        match = NodeType.match(match);
      return (type2) => {
        let result = match(type2);
        return result === void 0 ? null : [this, result];
      };
    }
  };
  NodeProp.closedBy = new NodeProp({ deserialize: (str2) => str2.split(" ") });
  NodeProp.openedBy = new NodeProp({ deserialize: (str2) => str2.split(" ") });
  NodeProp.group = new NodeProp({ deserialize: (str2) => str2.split(" ") });
  NodeProp.isolate = new NodeProp({ deserialize: (value) => {
    if (value && value != "rtl" && value != "ltr" && value != "auto")
      throw new RangeError("Invalid value for isolate: " + value);
    return value || "auto";
  } });
  NodeProp.contextHash = new NodeProp({ perNode: true });
  NodeProp.lookAhead = new NodeProp({ perNode: true });
  NodeProp.mounted = new NodeProp({ perNode: true });
  var MountedTree = class {
    constructor(tree, overlay, parser4) {
      this.tree = tree;
      this.overlay = overlay;
      this.parser = parser4;
    }
    /**
    @internal
    */
    static get(tree) {
      return tree && tree.props && tree.props[NodeProp.mounted.id];
    }
  };
  var noProps = /* @__PURE__ */ Object.create(null);
  var NodeType = class _NodeType {
    /**
    @internal
    */
    constructor(name2, props, id2, flags = 0) {
      this.name = name2;
      this.props = props;
      this.id = id2;
      this.flags = flags;
    }
    /**
    Define a node type.
    */
    static define(spec) {
      let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
      let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
      let type2 = new _NodeType(spec.name || "", props, spec.id, flags);
      if (spec.props)
        for (let src of spec.props) {
          if (!Array.isArray(src))
            src = src(type2);
          if (src) {
            if (src[0].perNode)
              throw new RangeError("Can't store a per-node prop on a node type");
            props[src[0].id] = src[1];
          }
        }
      return type2;
    }
    /**
    Retrieves a node prop for this type. Will return `undefined` if
    the prop isn't present on this node.
    */
    prop(prop) {
      return this.props[prop.id];
    }
    /**
    True when this is the top node of a grammar.
    */
    get isTop() {
      return (this.flags & 1) > 0;
    }
    /**
    True when this node is produced by a skip rule.
    */
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    /**
    Indicates whether this is an error node.
    */
    get isError() {
      return (this.flags & 4) > 0;
    }
    /**
    When true, this node type doesn't correspond to a user-declared
    named node, for example because it is used to cache repetition.
    */
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    /**
    Returns true when this node's name or one of its
    [groups](#common.NodeProp^group) matches the given string.
    */
    is(name2) {
      if (typeof name2 == "string") {
        if (this.name == name2)
          return true;
        let group = this.prop(NodeProp.group);
        return group ? group.indexOf(name2) > -1 : false;
      }
      return this.id == name2;
    }
    /**
    Create a function from node types to arbitrary values by
    specifying an object whose property names are node or
    [group](#common.NodeProp^group) names. Often useful with
    [`NodeProp.add`](#common.NodeProp.add). You can put multiple
    names, separated by spaces, in a single property name to map
    multiple node names to a single value.
    */
    static match(map2) {
      let direct = /* @__PURE__ */ Object.create(null);
      for (let prop in map2)
        for (let name2 of prop.split(" "))
          direct[name2] = map2[prop];
      return (node) => {
        for (let groups = node.prop(NodeProp.group), i4 = -1; i4 < (groups ? groups.length : 0); i4++) {
          let found = direct[i4 < 0 ? node.name : groups[i4]];
          if (found)
            return found;
        }
      };
    }
  };
  NodeType.none = new NodeType(
    "",
    /* @__PURE__ */ Object.create(null),
    0,
    8
    /* NodeFlag.Anonymous */
  );
  var NodeSet = class _NodeSet {
    /**
    Create a set with the given types. The `id` property of each
    type should correspond to its position within the array.
    */
    constructor(types2) {
      this.types = types2;
      for (let i4 = 0; i4 < types2.length; i4++)
        if (types2[i4].id != i4)
          throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /**
    Create a copy of this set with some node properties added. The
    arguments to this method can be created with
    [`NodeProp.add`](#common.NodeProp.add).
    */
    extend(...props) {
      let newTypes = [];
      for (let type2 of this.types) {
        let newProps = null;
        for (let source of props) {
          let add2 = source(type2);
          if (add2) {
            if (!newProps)
              newProps = Object.assign({}, type2.props);
            newProps[add2[0].id] = add2[1];
          }
        }
        newTypes.push(newProps ? new NodeType(type2.name, newProps, type2.id, type2.flags) : type2);
      }
      return new _NodeSet(newTypes);
    }
  };
  var CachedNode = /* @__PURE__ */ new WeakMap();
  var CachedInnerNode = /* @__PURE__ */ new WeakMap();
  var IterMode;
  (function(IterMode2) {
    IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
    IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
  })(IterMode || (IterMode = {}));
  var Tree = class _Tree {
    /**
    Construct a new tree. See also [`Tree.build`](#common.Tree^build).
    */
    constructor(type2, children, positions, length, props) {
      this.type = type2;
      this.children = children;
      this.positions = positions;
      this.length = length;
      this.props = null;
      if (props && props.length) {
        this.props = /* @__PURE__ */ Object.create(null);
        for (let [prop, value] of props)
          this.props[typeof prop == "number" ? prop : prop.id] = value;
      }
    }
    /**
    @internal
    */
    toString() {
      let mounted = MountedTree.get(this);
      if (mounted && !mounted.overlay)
        return mounted.tree.toString();
      let children = "";
      for (let ch of this.children) {
        let str2 = ch.toString();
        if (str2) {
          if (children)
            children += ",";
          children += str2;
        }
      }
      return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
    }
    /**
    Get a [tree cursor](#common.TreeCursor) positioned at the top of
    the tree. Mode can be used to [control](#common.IterMode) which
    nodes the cursor visits.
    */
    cursor(mode = 0) {
      return new TreeCursor(this.topNode, mode);
    }
    /**
    Get a [tree cursor](#common.TreeCursor) pointing into this tree
    at the given position and side (see
    [`moveTo`](#common.TreeCursor.moveTo).
    */
    cursorAt(pos, side = 0, mode = 0) {
      let scope = CachedNode.get(this) || this.topNode;
      let cursor = new TreeCursor(scope);
      cursor.moveTo(pos, side);
      CachedNode.set(this, cursor._tree);
      return cursor;
    }
    /**
    Get a [syntax node](#common.SyntaxNode) object for the top of the
    tree.
    */
    get topNode() {
      return new TreeNode(this, 0, 0, null);
    }
    /**
    Get the [syntax node](#common.SyntaxNode) at the given position.
    If `side` is -1, this will move into nodes that end at the
    position. If 1, it'll move into nodes that start at the
    position. With 0, it'll only enter nodes that cover the position
    from both sides.
    
    Note that this will not enter
    [overlays](#common.MountedTree.overlay), and you often want
    [`resolveInner`](#common.Tree.resolveInner) instead.
    */
    resolve(pos, side = 0) {
      let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
      CachedNode.set(this, node);
      return node;
    }
    /**
    Like [`resolve`](#common.Tree.resolve), but will enter
    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
    pointing into the innermost overlaid tree at the given position
    (with parent links going through all parent structure, including
    the host trees).
    */
    resolveInner(pos, side = 0) {
      let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
      CachedInnerNode.set(this, node);
      return node;
    }
    /**
    In some situations, it can be useful to iterate through all
    nodes around a position, including those in overlays that don't
    directly cover the position. This method gives you an iterator
    that will produce all nodes, from small to big, around the given
    position.
    */
    resolveStack(pos, side = 0) {
      return stackIterator(this, pos, side);
    }
    /**
    Iterate over the tree and its children, calling `enter` for any
    node that touches the `from`/`to` region (if given) before
    running over such a node's children, and `leave` (if given) when
    leaving the node. When `enter` returns `false`, that node will
    not have its children iterated over (or `leave` called).
    */
    iterate(spec) {
      let { enter, leave, from = 0, to = this.length } = spec;
      let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
      for (let c4 = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
        let entered = false;
        if (c4.from <= to && c4.to >= from && (!anon && c4.type.isAnonymous || enter(c4) !== false)) {
          if (c4.firstChild())
            continue;
          entered = true;
        }
        for (; ; ) {
          if (entered && leave && (anon || !c4.type.isAnonymous))
            leave(c4);
          if (c4.nextSibling())
            break;
          if (!c4.parent())
            return;
          entered = true;
        }
      }
    }
    /**
    Get the value of the given [node prop](#common.NodeProp) for this
    node. Works with both per-node and per-type props.
    */
    prop(prop) {
      return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
    }
    /**
    Returns the node's [per-node props](#common.NodeProp.perNode) in a
    format that can be passed to the [`Tree`](#common.Tree)
    constructor.
    */
    get propValues() {
      let result = [];
      if (this.props)
        for (let id2 in this.props)
          result.push([+id2, this.props[id2]]);
      return result;
    }
    /**
    Balance the direct children of this tree, producing a copy of
    which may have children grouped into subtrees with type
    [`NodeType.none`](#common.NodeType^none).
    */
    balance(config = {}) {
      return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new _Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new _Tree(NodeType.none, children, positions, length)));
    }
    /**
    Build a tree from a postfix-ordered buffer of node information,
    or a cursor over such a buffer.
    */
    static build(data) {
      return buildTree(data);
    }
  };
  Tree.empty = new Tree(NodeType.none, [], [], 0);
  var FlatBufferCursor = class _FlatBufferCursor {
    constructor(buffer, index) {
      this.buffer = buffer;
      this.index = index;
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new _FlatBufferCursor(this.buffer, this.index);
    }
  };
  var TreeBuffer = class _TreeBuffer {
    /**
    Create a tree buffer.
    */
    constructor(buffer, length, set2) {
      this.buffer = buffer;
      this.length = length;
      this.set = set2;
    }
    /**
    @internal
    */
    get type() {
      return NodeType.none;
    }
    /**
    @internal
    */
    toString() {
      let result = [];
      for (let index = 0; index < this.buffer.length; ) {
        result.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result.join(",");
    }
    /**
    @internal
    */
    childString(index) {
      let id2 = this.buffer[index], endIndex = this.buffer[index + 3];
      let type2 = this.set.types[id2], result = type2.name;
      if (/\W/.test(result) && !type2.isError)
        result = JSON.stringify(result);
      index += 4;
      if (endIndex == index)
        return result;
      let children = [];
      while (index < endIndex) {
        children.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result + "(" + children.join(",") + ")";
    }
    /**
    @internal
    */
    findChild(startIndex, endIndex, dir, pos, side) {
      let { buffer } = this, pick = -1;
      for (let i4 = startIndex; i4 != endIndex; i4 = buffer[i4 + 3]) {
        if (checkSide(side, pos, buffer[i4 + 1], buffer[i4 + 2])) {
          pick = i4;
          if (dir > 0)
            break;
        }
      }
      return pick;
    }
    /**
    @internal
    */
    slice(startI, endI, from) {
      let b4 = this.buffer;
      let copy = new Uint16Array(endI - startI), len = 0;
      for (let i4 = startI, j2 = 0; i4 < endI; ) {
        copy[j2++] = b4[i4++];
        copy[j2++] = b4[i4++] - from;
        let to = copy[j2++] = b4[i4++] - from;
        copy[j2++] = b4[i4++] - startI;
        len = Math.max(len, to);
      }
      return new _TreeBuffer(copy, len, this.set);
    }
  };
  function checkSide(side, pos, from, to) {
    switch (side) {
      case -2:
        return from < pos;
      case -1:
        return to >= pos && from < pos;
      case 0:
        return from < pos && to > pos;
      case 1:
        return from <= pos && to > pos;
      case 2:
        return to > pos;
      case 4:
        return true;
    }
  }
  function resolveNode(node, pos, side, overlays) {
    var _a2;
    while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
      let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
      if (!parent)
        return node;
      node = parent;
    }
    let mode = overlays ? 0 : IterMode.IgnoreOverlays;
    if (overlays)
      for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
        if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
          node = parent;
      }
    for (; ; ) {
      let inner = node.enter(pos, side, mode);
      if (!inner)
        return node;
      node = inner;
    }
  }
  var BaseNode = class {
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    getChild(type2, before = null, after = null) {
      let r3 = getChildren(this, type2, before, after);
      return r3.length ? r3[0] : null;
    }
    getChildren(type2, before = null, after = null) {
      return getChildren(this, type2, before, after);
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    matchContext(context) {
      return matchNodeContext(this, context);
    }
    enterUnfinishedNodesBefore(pos) {
      let scan = this.childBefore(pos), node = this;
      while (scan) {
        let last = scan.lastChild;
        if (!last || last.to != scan.to)
          break;
        if (last.type.isError && last.from == last.to) {
          node = scan;
          scan = last.prevSibling;
        } else {
          scan = last;
        }
      }
      return node;
    }
    get node() {
      return this;
    }
    get next() {
      return this.parent;
    }
  };
  var TreeNode = class _TreeNode extends BaseNode {
    constructor(_tree, from, index, _parent) {
      super();
      this._tree = _tree;
      this.from = from;
      this.index = index;
      this._parent = _parent;
    }
    get type() {
      return this._tree.type;
    }
    get name() {
      return this._tree.type.name;
    }
    get to() {
      return this.from + this._tree.length;
    }
    nextChild(i4, dir, pos, side, mode = 0) {
      for (let parent = this; ; ) {
        for (let { children, positions } = parent._tree, e4 = dir > 0 ? children.length : -1; i4 != e4; i4 += dir) {
          let next = children[i4], start = positions[i4] + parent.from;
          if (!checkSide(side, pos, start, start + next.length))
            continue;
          if (next instanceof TreeBuffer) {
            if (mode & IterMode.ExcludeBuffers)
              continue;
            let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
            if (index > -1)
              return new BufferNode(new BufferContext(parent, next, i4, start), null, index);
          } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
            let mounted;
            if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
              return new _TreeNode(mounted.tree, start, i4, parent);
            let inner = new _TreeNode(next, start, i4, parent);
            return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
          }
        }
        if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
          return null;
        if (parent.index >= 0)
          i4 = parent.index + dir;
        else
          i4 = dir < 0 ? -1 : parent._parent._tree.children.length;
        parent = parent._parent;
        if (!parent)
          return null;
      }
    }
    get firstChild() {
      return this.nextChild(
        0,
        1,
        0,
        4
        /* Side.DontCare */
      );
    }
    get lastChild() {
      return this.nextChild(
        this._tree.children.length - 1,
        -1,
        0,
        4
        /* Side.DontCare */
      );
    }
    childAfter(pos) {
      return this.nextChild(
        0,
        1,
        pos,
        2
        /* Side.After */
      );
    }
    childBefore(pos) {
      return this.nextChild(
        this._tree.children.length - 1,
        -1,
        pos,
        -2
        /* Side.Before */
      );
    }
    enter(pos, side, mode = 0) {
      let mounted;
      if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
        let rPos = pos - this.from;
        for (let { from, to } of mounted.overlay) {
          if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
            return new _TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
        }
      }
      return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
      let val = this;
      while (val.type.isAnonymous && val._parent)
        val = val._parent;
      return val;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(
        this.index + 1,
        1,
        0,
        4
        /* Side.DontCare */
      ) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(
        this.index - 1,
        -1,
        0,
        4
        /* Side.DontCare */
      ) : null;
    }
    get tree() {
      return this._tree;
    }
    toTree() {
      return this._tree;
    }
    /**
    @internal
    */
    toString() {
      return this._tree.toString();
    }
  };
  function getChildren(node, type2, before, after) {
    let cur = node.cursor(), result = [];
    if (!cur.firstChild())
      return result;
    if (before != null)
      for (let found = false; !found; ) {
        found = cur.type.is(before);
        if (!cur.nextSibling())
          return result;
      }
    for (; ; ) {
      if (after != null && cur.type.is(after))
        return result;
      if (cur.type.is(type2))
        result.push(cur.node);
      if (!cur.nextSibling())
        return after == null ? result : [];
    }
  }
  function matchNodeContext(node, context, i4 = context.length - 1) {
    for (let p4 = node.parent; i4 >= 0; p4 = p4.parent) {
      if (!p4)
        return false;
      if (!p4.type.isAnonymous) {
        if (context[i4] && context[i4] != p4.name)
          return false;
        i4--;
      }
    }
    return true;
  }
  var BufferContext = class {
    constructor(parent, buffer, index, start) {
      this.parent = parent;
      this.buffer = buffer;
      this.index = index;
      this.start = start;
    }
  };
  var BufferNode = class _BufferNode extends BaseNode {
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    constructor(context, _parent, index) {
      super();
      this.context = context;
      this._parent = _parent;
      this.index = index;
      this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    child(dir, pos, side) {
      let { buffer } = this.context;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
      return index < 0 ? null : new _BufferNode(this.context, this, index);
    }
    get firstChild() {
      return this.child(
        1,
        0,
        4
        /* Side.DontCare */
      );
    }
    get lastChild() {
      return this.child(
        -1,
        0,
        4
        /* Side.DontCare */
      );
    }
    childAfter(pos) {
      return this.child(
        1,
        pos,
        2
        /* Side.After */
      );
    }
    childBefore(pos) {
      return this.child(
        -1,
        pos,
        -2
        /* Side.Before */
      );
    }
    enter(pos, side, mode = 0) {
      if (mode & IterMode.ExcludeBuffers)
        return null;
      let { buffer } = this.context;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
      return index < 0 ? null : new _BufferNode(this.context, this, index);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
      return this._parent ? null : this.context.parent.nextChild(
        this.context.index + dir,
        dir,
        0,
        4
        /* Side.DontCare */
      );
    }
    get nextSibling() {
      let { buffer } = this.context;
      let after = buffer.buffer[this.index + 3];
      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
        return new _BufferNode(this.context, this._parent, after);
      return this.externalSibling(1);
    }
    get prevSibling() {
      let { buffer } = this.context;
      let parentStart = this._parent ? this._parent.index + 4 : 0;
      if (this.index == parentStart)
        return this.externalSibling(-1);
      return new _BufferNode(this.context, this._parent, buffer.findChild(
        parentStart,
        this.index,
        -1,
        0,
        4
        /* Side.DontCare */
      ));
    }
    get tree() {
      return null;
    }
    toTree() {
      let children = [], positions = [];
      let { buffer } = this.context;
      let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
      if (endI > startI) {
        let from = buffer.buffer[this.index + 1];
        children.push(buffer.slice(startI, endI, from));
        positions.push(0);
      }
      return new Tree(this.type, children, positions, this.to - this.from);
    }
    /**
    @internal
    */
    toString() {
      return this.context.buffer.childString(this.index);
    }
  };
  function iterStack(heads) {
    if (!heads.length)
      return null;
    let pick = 0, picked = heads[0];
    for (let i4 = 1; i4 < heads.length; i4++) {
      let node = heads[i4];
      if (node.from > picked.from || node.to < picked.to) {
        picked = node;
        pick = i4;
      }
    }
    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
    let newHeads = heads.slice();
    if (next)
      newHeads[pick] = next;
    else
      newHeads.splice(pick, 1);
    return new StackIterator(newHeads, picked);
  }
  var StackIterator = class {
    constructor(heads, node) {
      this.heads = heads;
      this.node = node;
    }
    get next() {
      return iterStack(this.heads);
    }
  };
  function stackIterator(tree, pos, side) {
    let inner = tree.resolveInner(pos, side), layers = null;
    for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
      if (scan.index < 0) {
        let parent = scan.parent;
        (layers || (layers = [inner])).push(parent.resolve(pos, side));
        scan = parent;
      } else {
        let mount = MountedTree.get(scan.tree);
        if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
          let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
          (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
        }
      }
    }
    return layers ? iterStack(layers) : inner;
  }
  var TreeCursor = class {
    /**
    Shorthand for `.type.name`.
    */
    get name() {
      return this.type.name;
    }
    /**
    @internal
    */
    constructor(node, mode = 0) {
      this.mode = mode;
      this.buffer = null;
      this.stack = [];
      this.index = 0;
      this.bufferNode = null;
      if (node instanceof TreeNode) {
        this.yieldNode(node);
      } else {
        this._tree = node.context.parent;
        this.buffer = node.context;
        for (let n4 = node._parent; n4; n4 = n4._parent)
          this.stack.unshift(n4.index);
        this.bufferNode = node;
        this.yieldBuf(node.index);
      }
    }
    yieldNode(node) {
      if (!node)
        return false;
      this._tree = node;
      this.type = node.type;
      this.from = node.from;
      this.to = node.to;
      return true;
    }
    yieldBuf(index, type2) {
      this.index = index;
      let { start, buffer } = this.buffer;
      this.type = type2 || buffer.set.types[buffer.buffer[index]];
      this.from = start + buffer.buffer[index + 1];
      this.to = start + buffer.buffer[index + 2];
      return true;
    }
    /**
    @internal
    */
    yield(node) {
      if (!node)
        return false;
      if (node instanceof TreeNode) {
        this.buffer = null;
        return this.yieldNode(node);
      }
      this.buffer = node.context;
      return this.yieldBuf(node.index, node.type);
    }
    /**
    @internal
    */
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /**
    @internal
    */
    enterChild(dir, pos, side) {
      if (!this.buffer)
        return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
      let { buffer } = this.buffer;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
      if (index < 0)
        return false;
      this.stack.push(this.index);
      return this.yieldBuf(index);
    }
    /**
    Move the cursor to this node's first child. When this returns
    false, the node has no child, and the cursor has not been moved.
    */
    firstChild() {
      return this.enterChild(
        1,
        0,
        4
        /* Side.DontCare */
      );
    }
    /**
    Move the cursor to this node's last child.
    */
    lastChild() {
      return this.enterChild(
        -1,
        0,
        4
        /* Side.DontCare */
      );
    }
    /**
    Move the cursor to the first child that ends after `pos`.
    */
    childAfter(pos) {
      return this.enterChild(
        1,
        pos,
        2
        /* Side.After */
      );
    }
    /**
    Move to the last child that starts before `pos`.
    */
    childBefore(pos) {
      return this.enterChild(
        -1,
        pos,
        -2
        /* Side.Before */
      );
    }
    /**
    Move the cursor to the child around `pos`. If side is -1 the
    child may end at that position, when 1 it may start there. This
    will also enter [overlaid](#common.MountedTree.overlay)
    [mounted](#common.NodeProp^mounted) trees unless `overlays` is
    set to false.
    */
    enter(pos, side, mode = this.mode) {
      if (!this.buffer)
        return this.yield(this._tree.enter(pos, side, mode));
      return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    /**
    Move to the node's parent node, if this isn't the top node.
    */
    parent() {
      if (!this.buffer)
        return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
      if (this.stack.length)
        return this.yieldBuf(this.stack.pop());
      let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      this.buffer = null;
      return this.yieldNode(parent);
    }
    /**
    @internal
    */
    sibling(dir) {
      if (!this.buffer)
        return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
      let { buffer } = this.buffer, d3 = this.stack.length - 1;
      if (dir < 0) {
        let parentStart = d3 < 0 ? 0 : this.stack[d3] + 4;
        if (this.index != parentStart)
          return this.yieldBuf(buffer.findChild(
            parentStart,
            this.index,
            -1,
            0,
            4
            /* Side.DontCare */
          ));
      } else {
        let after = buffer.buffer[this.index + 3];
        if (after < (d3 < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d3] + 3]))
          return this.yieldBuf(after);
      }
      return d3 < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
    }
    /**
    Move to this node's next sibling, if any.
    */
    nextSibling() {
      return this.sibling(1);
    }
    /**
    Move to this node's previous sibling, if any.
    */
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(dir) {
      let index, parent, { buffer } = this;
      if (buffer) {
        if (dir > 0) {
          if (this.index < buffer.buffer.buffer.length)
            return false;
        } else {
          for (let i4 = 0; i4 < this.index; i4++)
            if (buffer.buffer.buffer[i4 + 3] < this.index)
              return false;
        }
        ({ index, parent } = buffer);
      } else {
        ({ index, _parent: parent } = this._tree);
      }
      for (; parent; { index, _parent: parent } = parent) {
        if (index > -1)
          for (let i4 = index + dir, e4 = dir < 0 ? -1 : parent._tree.children.length; i4 != e4; i4 += dir) {
            let child = parent._tree.children[i4];
            if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
              return false;
          }
      }
      return true;
    }
    move(dir, enter) {
      if (enter && this.enterChild(
        dir,
        0,
        4
        /* Side.DontCare */
      ))
        return true;
      for (; ; ) {
        if (this.sibling(dir))
          return true;
        if (this.atLastNode(dir) || !this.parent())
          return false;
      }
    }
    /**
    Move to the next node in a
    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
    traversal, going from a node to its first child or, if the
    current node is empty or `enter` is false, its next sibling or
    the next sibling of the first parent node that has one.
    */
    next(enter = true) {
      return this.move(1, enter);
    }
    /**
    Move to the next node in a last-to-first pre-order traveral. A
    node is followed by its last child or, if it has none, its
    previous sibling or the previous sibling of the first parent
    node that has one.
    */
    prev(enter = true) {
      return this.move(-1, enter);
    }
    /**
    Move the cursor to the innermost node that covers `pos`. If
    `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    it will enter nodes that start at `pos`.
    */
    moveTo(pos, side = 0) {
      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
        if (!this.parent())
          break;
      while (this.enterChild(1, pos, side)) {
      }
      return this;
    }
    /**
    Get a [syntax node](#common.SyntaxNode) at the cursor's current
    position.
    */
    get node() {
      if (!this.buffer)
        return this._tree;
      let cache = this.bufferNode, result = null, depth = 0;
      if (cache && cache.context == this.buffer) {
        scan: for (let index = this.index, d3 = this.stack.length; d3 >= 0; ) {
          for (let c4 = cache; c4; c4 = c4._parent)
            if (c4.index == index) {
              if (index == this.index)
                return c4;
              result = c4;
              depth = d3 + 1;
              break scan;
            }
          index = this.stack[--d3];
        }
      }
      for (let i4 = depth; i4 < this.stack.length; i4++)
        result = new BufferNode(this.buffer, result, this.stack[i4]);
      return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /**
    Get the [tree](#common.Tree) that represents the current node, if
    any. Will return null when the node is in a [tree
    buffer](#common.TreeBuffer).
    */
    get tree() {
      return this.buffer ? null : this._tree._tree;
    }
    /**
    Iterate over the current node and all its descendants, calling
    `enter` when entering a node and `leave`, if given, when leaving
    one. When `enter` returns `false`, any children of that node are
    skipped, and `leave` isn't called for it.
    */
    iterate(enter, leave) {
      for (let depth = 0; ; ) {
        let mustLeave = false;
        if (this.type.isAnonymous || enter(this) !== false) {
          if (this.firstChild()) {
            depth++;
            continue;
          }
          if (!this.type.isAnonymous)
            mustLeave = true;
        }
        for (; ; ) {
          if (mustLeave && leave)
            leave(this);
          mustLeave = this.type.isAnonymous;
          if (this.nextSibling())
            break;
          if (!depth)
            return;
          this.parent();
          depth--;
          mustLeave = true;
        }
      }
    }
    /**
    Test whether the current node matches a given context—a sequence
    of direct parent node names. Empty strings in the context array
    are treated as wildcards.
    */
    matchContext(context) {
      if (!this.buffer)
        return matchNodeContext(this.node, context);
      let { buffer } = this.buffer, { types: types2 } = buffer.set;
      for (let i4 = context.length - 1, d3 = this.stack.length - 1; i4 >= 0; d3--) {
        if (d3 < 0)
          return matchNodeContext(this.node, context, i4);
        let type2 = types2[buffer.buffer[this.stack[d3]]];
        if (!type2.isAnonymous) {
          if (context[i4] && context[i4] != type2.name)
            return false;
          i4--;
        }
      }
      return true;
    }
  };
  function hasChild(tree) {
    return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
  }
  function buildTree(data) {
    var _a2;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types2 = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth) {
      let { id: id2, start, end, size } = cursor;
      let lookAheadAtStart = lookAhead;
      while (size < 0) {
        cursor.next();
        if (size == -1) {
          let node2 = reused[id2];
          children2.push(node2);
          positions2.push(start - parentStart);
          return;
        } else if (size == -3) {
          contextHash = id2;
          return;
        } else if (size == -4) {
          lookAhead = id2;
          return;
        } else {
          throw new RangeError(`Unrecognized record size: ${size}`);
        }
      }
      let type2 = types2[id2], node, buffer2;
      let startPos = start - parentStart;
      if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
        let data2 = new Uint16Array(buffer2.size - buffer2.skip);
        let endPos = cursor.pos - buffer2.size, index = data2.length;
        while (cursor.pos > endPos)
          index = copyToBuffer(buffer2.start, data2, index);
        node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
        startPos = buffer2.start - parentStart;
      } else {
        let endPos = cursor.pos - size;
        cursor.next();
        let localChildren = [], localPositions = [];
        let localInRepeat = id2 >= minRepeatType ? id2 : -1;
        let lastGroup = 0, lastEnd = end;
        while (cursor.pos > endPos) {
          if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
            if (cursor.end <= lastEnd - maxBufferLength) {
              makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
              lastGroup = localChildren.length;
              lastEnd = cursor.end;
            }
            cursor.next();
          } else if (depth > 2500) {
            takeFlatNode(start, endPos, localChildren, localPositions);
          } else {
            takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
          }
        }
        if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
          makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
        localChildren.reverse();
        localPositions.reverse();
        if (localInRepeat > -1 && lastGroup > 0) {
          let make = makeBalanced(type2);
          node = balanceRange(type2, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
        } else {
          node = makeTree(type2, localChildren, localPositions, end - start, lookAheadAtStart - end);
        }
      }
      children2.push(node);
      positions2.push(startPos);
    }
    function takeFlatNode(parentStart, minPos, children2, positions2) {
      let nodes = [];
      let nodeCount = 0, stopAt = -1;
      while (cursor.pos > minPos) {
        let { id: id2, start, end, size } = cursor;
        if (size > 4) {
          cursor.next();
        } else if (stopAt > -1 && start < stopAt) {
          break;
        } else {
          if (stopAt < 0)
            stopAt = end - maxBufferLength;
          nodes.push(id2, start, end);
          nodeCount++;
          cursor.next();
        }
      }
      if (nodeCount) {
        let buffer2 = new Uint16Array(nodeCount * 4);
        let start = nodes[nodes.length - 2];
        for (let i4 = nodes.length - 3, j2 = 0; i4 >= 0; i4 -= 3) {
          buffer2[j2++] = nodes[i4];
          buffer2[j2++] = nodes[i4 + 1] - start;
          buffer2[j2++] = nodes[i4 + 2] - start;
          buffer2[j2++] = j2;
        }
        children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet));
        positions2.push(start - parentStart);
      }
    }
    function makeBalanced(type2) {
      return (children2, positions2, length2) => {
        let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
        if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
          if (!lastI && last.type == type2 && last.length == length2)
            return last;
          if (lookAheadProp = last.prop(NodeProp.lookAhead))
            lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
        }
        return makeTree(type2, children2, positions2, length2, lookAhead2);
      };
    }
    function makeRepeatLeaf(children2, positions2, base2, i4, from, to, type2, lookAhead2) {
      let localChildren = [], localPositions = [];
      while (children2.length > i4) {
        localChildren.push(children2.pop());
        localPositions.push(positions2.pop() + base2 - from);
      }
      children2.push(makeTree(nodeSet.types[type2], localChildren, localPositions, to - from, lookAhead2 - to));
      positions2.push(from - base2);
    }
    function makeTree(type2, children2, positions2, length2, lookAhead2 = 0, props) {
      if (contextHash) {
        let pair2 = [NodeProp.contextHash, contextHash];
        props = props ? [pair2].concat(props) : [pair2];
      }
      if (lookAhead2 > 25) {
        let pair2 = [NodeProp.lookAhead, lookAhead2];
        props = props ? [pair2].concat(props) : [pair2];
      }
      return new Tree(type2, children2, positions2, length2, props);
    }
    function findBufferSize(maxSize, inRepeat) {
      let fork = cursor.fork();
      let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
      let result = { size: 0, start: 0, skip: 0 };
      scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
        let nodeSize2 = fork.size;
        if (fork.id == inRepeat && nodeSize2 >= 0) {
          result.size = size;
          result.start = start;
          result.skip = skip;
          skip += 4;
          size += 4;
          fork.next();
          continue;
        }
        let startPos = fork.pos - nodeSize2;
        if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
          break;
        let localSkipped = fork.id >= minRepeatType ? 4 : 0;
        let nodeStart = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0) {
            if (fork.size == -3)
              localSkipped += 4;
            else
              break scan;
          } else if (fork.id >= minRepeatType) {
            localSkipped += 4;
          }
          fork.next();
        }
        start = nodeStart;
        size += nodeSize2;
        skip += localSkipped;
      }
      if (inRepeat < 0 || size == maxSize) {
        result.size = size;
        result.start = start;
        result.skip = skip;
      }
      return result.size > 4 ? result : void 0;
    }
    function copyToBuffer(bufferStart, buffer2, index) {
      let { id: id2, start, end, size } = cursor;
      cursor.next();
      if (size >= 0 && id2 < minRepeatType) {
        let startIndex = index;
        if (size > 4) {
          let endPos = cursor.pos - (size - 4);
          while (cursor.pos > endPos)
            index = copyToBuffer(bufferStart, buffer2, index);
        }
        buffer2[--index] = startIndex;
        buffer2[--index] = end - bufferStart;
        buffer2[--index] = start - bufferStart;
        buffer2[--index] = id2;
      } else if (size == -3) {
        contextHash = id2;
      } else if (size == -4) {
        lookAhead = id2;
      }
      return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
      takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
    let length = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
    return new Tree(types2[data.topID], children.reverse(), positions.reverse(), length);
  }
  var nodeSizeCache = /* @__PURE__ */ new WeakMap();
  function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
      return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
      size = 1;
      for (let child of node.children) {
        if (child.type != balanceType || !(child instanceof Tree)) {
          size = 1;
          break;
        }
        size += nodeSize(balanceType, child);
      }
      nodeSizeCache.set(node, size);
    }
    return size;
  }
  function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
    let total = 0;
    for (let i4 = from; i4 < to; i4++)
      total += nodeSize(balanceType, children[i4]);
    let maxChild = Math.ceil(
      total * 1.5 / 8
      /* Balance.BranchFactor */
    );
    let localChildren = [], localPositions = [];
    function divide(children2, positions2, from2, to2, offset) {
      for (let i4 = from2; i4 < to2; ) {
        let groupFrom = i4, groupStart = positions2[i4], groupSize = nodeSize(balanceType, children2[i4]);
        i4++;
        for (; i4 < to2; i4++) {
          let nextSize = nodeSize(balanceType, children2[i4]);
          if (groupSize + nextSize >= maxChild)
            break;
          groupSize += nextSize;
        }
        if (i4 == groupFrom + 1) {
          if (groupSize > maxChild) {
            let only = children2[groupFrom];
            divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
            continue;
          }
          localChildren.push(children2[groupFrom]);
        } else {
          let length2 = positions2[i4 - 1] + children2[i4 - 1].length - groupStart;
          localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i4, groupStart, length2, null, mkTree));
        }
        localPositions.push(groupStart + offset - start);
      }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
  }
  var TreeFragment = class _TreeFragment {
    /**
    Construct a tree fragment. You'll usually want to use
    [`addTree`](#common.TreeFragment^addTree) and
    [`applyChanges`](#common.TreeFragment^applyChanges) instead of
    calling this directly.
    */
    constructor(from, to, tree, offset, openStart = false, openEnd = false) {
      this.from = from;
      this.to = to;
      this.tree = tree;
      this.offset = offset;
      this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
    }
    /**
    Whether the start of the fragment represents the start of a
    parse, or the end of a change. (In the second case, it may not
    be safe to reuse some nodes at the start, depending on the
    parsing algorithm.)
    */
    get openStart() {
      return (this.open & 1) > 0;
    }
    /**
    Whether the end of the fragment represents the end of a
    full-document parse, or the start of a change.
    */
    get openEnd() {
      return (this.open & 2) > 0;
    }
    /**
    Create a set of fragments from a freshly parsed tree, or update
    an existing set of fragments by replacing the ones that overlap
    with a tree with content from the new tree. When `partial` is
    true, the parse is treated as incomplete, and the resulting
    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
    true.
    */
    static addTree(tree, fragments = [], partial = false) {
      let result = [new _TreeFragment(0, tree.length, tree, 0, false, partial)];
      for (let f3 of fragments)
        if (f3.to > tree.length)
          result.push(f3);
      return result;
    }
    /**
    Apply a set of edits to an array of fragments, removing or
    splitting fragments as necessary to remove edited ranges, and
    adjusting offsets for fragments that moved.
    */
    static applyChanges(fragments, changes, minGap = 128) {
      if (!changes.length)
        return fragments;
      let result = [];
      let fI = 1, nextF = fragments.length ? fragments[0] : null;
      for (let cI = 0, pos = 0, off = 0; ; cI++) {
        let nextC = cI < changes.length ? changes[cI] : null;
        let nextPos = nextC ? nextC.fromA : 1e9;
        if (nextPos - pos >= minGap)
          while (nextF && nextF.from < nextPos) {
            let cut = nextF;
            if (pos >= cut.from || nextPos <= cut.to || off) {
              let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
              cut = fFrom >= fTo ? null : new _TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
            }
            if (cut)
              result.push(cut);
            if (nextF.to > nextPos)
              break;
            nextF = fI < fragments.length ? fragments[fI++] : null;
          }
        if (!nextC)
          break;
        pos = nextC.toA;
        off = nextC.toA - nextC.toB;
      }
      return result;
    }
  };
  var Parser = class {
    /**
    Start a parse, returning a [partial parse](#common.PartialParse)
    object. [`fragments`](#common.TreeFragment) can be passed in to
    make the parse incremental.
    
    By default, the entire input is parsed. You can pass `ranges`,
    which should be a sorted array of non-empty, non-overlapping
    ranges, to parse only those ranges. The tree returned in that
    case will start at `ranges[0].from`.
    */
    startParse(input, fragments, ranges) {
      if (typeof input == "string")
        input = new StringInput(input);
      ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map((r3) => new Range(r3.from, r3.to)) : [new Range(0, 0)];
      return this.createParse(input, fragments || [], ranges);
    }
    /**
    Run a full parse, returning the resulting tree.
    */
    parse(input, fragments, ranges) {
      let parse = this.startParse(input, fragments, ranges);
      for (; ; ) {
        let done = parse.advance();
        if (done)
          return done;
      }
    }
  };
  var StringInput = class {
    constructor(string2) {
      this.string = string2;
    }
    get length() {
      return this.string.length;
    }
    chunk(from) {
      return this.string.slice(from);
    }
    get lineChunks() {
      return false;
    }
    read(from, to) {
      return this.string.slice(from, to);
    }
  };
  function parseMixed(nest) {
    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
  }
  var InnerParse = class {
    constructor(parser4, parse, overlay, target, from) {
      this.parser = parser4;
      this.parse = parse;
      this.overlay = overlay;
      this.target = target;
      this.from = from;
    }
  };
  function checkRanges(ranges) {
    if (!ranges.length || ranges.some((r3) => r3.from >= r3.to))
      throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(ranges));
  }
  var ActiveOverlay = class {
    constructor(parser4, predicate, mounts, index, start, target, prev) {
      this.parser = parser4;
      this.predicate = predicate;
      this.mounts = mounts;
      this.index = index;
      this.start = start;
      this.target = target;
      this.prev = prev;
      this.depth = 0;
      this.ranges = [];
    }
  };
  var stoppedInner = new NodeProp({ perNode: true });
  var MixedParse = class {
    constructor(base2, nest, input, fragments, ranges) {
      this.nest = nest;
      this.input = input;
      this.fragments = fragments;
      this.ranges = ranges;
      this.inner = [];
      this.innerDone = 0;
      this.baseTree = null;
      this.stoppedAt = null;
      this.baseParse = base2;
    }
    advance() {
      if (this.baseParse) {
        let done2 = this.baseParse.advance();
        if (!done2)
          return null;
        this.baseParse = null;
        this.baseTree = done2;
        this.startInner();
        if (this.stoppedAt != null)
          for (let inner2 of this.inner)
            inner2.parse.stopAt(this.stoppedAt);
      }
      if (this.innerDone == this.inner.length) {
        let result = this.baseTree;
        if (this.stoppedAt != null)
          result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
        return result;
      }
      let inner = this.inner[this.innerDone], done = inner.parse.advance();
      if (done) {
        this.innerDone++;
        let props = Object.assign(/* @__PURE__ */ Object.create(null), inner.target.props);
        props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
        inner.target.props = props;
      }
      return null;
    }
    get parsedPos() {
      if (this.baseParse)
        return 0;
      let pos = this.input.length;
      for (let i4 = this.innerDone; i4 < this.inner.length; i4++) {
        if (this.inner[i4].from < pos)
          pos = Math.min(pos, this.inner[i4].parse.parsedPos);
      }
      return pos;
    }
    stopAt(pos) {
      this.stoppedAt = pos;
      if (this.baseParse)
        this.baseParse.stopAt(pos);
      else
        for (let i4 = this.innerDone; i4 < this.inner.length; i4++)
          this.inner[i4].parse.stopAt(pos);
    }
    startInner() {
      let fragmentCursor = new FragmentCursor(this.fragments);
      let overlay = null;
      let covered = null;
      let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
      scan: for (let nest, isCovered; ; ) {
        let enter = true, range;
        if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {
          enter = false;
        } else if (fragmentCursor.hasNode(cursor)) {
          if (overlay) {
            let match = overlay.mounts.find((m3) => m3.frag.from <= cursor.from && m3.frag.to >= cursor.to && m3.mount.overlay);
            if (match)
              for (let r3 of match.mount.overlay) {
                let from = r3.from + match.pos, to = r3.to + match.pos;
                if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some((r4) => r4.from < to && r4.to > from))
                  overlay.ranges.push({ from, to });
              }
          }
          enter = false;
        } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
          enter = isCovered != 2;
        } else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) && (cursor.from < cursor.to || !nest.overlay)) {
          if (!cursor.tree)
            materialize(cursor);
          let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
          if (typeof nest.overlay == "function") {
            overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
          } else {
            let ranges = punchRanges(this.ranges, nest.overlay || (cursor.from < cursor.to ? [new Range(cursor.from, cursor.to)] : []));
            if (ranges.length)
              checkRanges(ranges);
            if (ranges.length || !nest.overlay)
              this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges) : nest.parser.startParse(""), nest.overlay ? nest.overlay.map((r3) => new Range(r3.from - cursor.from, r3.to - cursor.from)) : null, cursor.tree, ranges.length ? ranges[0].from : cursor.from));
            if (!nest.overlay)
              enter = false;
            else if (ranges.length)
              covered = { ranges, depth: 0, prev: covered };
          }
        } else if (overlay && (range = overlay.predicate(cursor))) {
          if (range === true)
            range = new Range(cursor.from, cursor.to);
          if (range.from < range.to)
            overlay.ranges.push(range);
        }
        if (enter && cursor.firstChild()) {
          if (overlay)
            overlay.depth++;
          if (covered)
            covered.depth++;
        } else {
          for (; ; ) {
            if (cursor.nextSibling())
              break;
            if (!cursor.parent())
              break scan;
            if (overlay && !--overlay.depth) {
              let ranges = punchRanges(this.ranges, overlay.ranges);
              if (ranges.length) {
                checkRanges(ranges);
                this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r3) => new Range(r3.from - overlay.start, r3.to - overlay.start)), overlay.target, ranges[0].from));
              }
              overlay = overlay.prev;
            }
            if (covered && !--covered.depth)
              covered = covered.prev;
          }
        }
      }
    }
  };
  function checkCover(covered, from, to) {
    for (let range of covered) {
      if (range.from >= to)
        break;
      if (range.to > from)
        return range.from <= from && range.to >= to ? 2 : 1;
    }
    return 0;
  }
  function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
      let from = buf.buffer[startI + 1];
      nodes.push(buf.slice(startI, endI, from));
      positions.push(from - off);
    }
  }
  function materialize(cursor) {
    let { node } = cursor, stack = [];
    let buffer = node.context.buffer;
    do {
      stack.push(cursor.index);
      cursor.parent();
    } while (!cursor.tree);
    let base2 = cursor.tree, i4 = base2.children.indexOf(buffer);
    let buf = base2.children[i4], b4 = buf.buffer, newStack = [i4];
    function split(startI, endI, type2, innerOffset, length, stackPos) {
      let targetI = stack[stackPos];
      let children = [], positions = [];
      sliceBuf(buf, startI, targetI, children, positions, innerOffset);
      let from = b4[targetI + 1], to = b4[targetI + 2];
      newStack.push(children.length);
      let child = stackPos ? split(targetI + 4, b4[targetI + 3], buf.set.types[b4[targetI]], from, to - from, stackPos - 1) : node.toTree();
      children.push(child);
      positions.push(from - innerOffset);
      sliceBuf(buf, b4[targetI + 3], endI, children, positions, innerOffset);
      return new Tree(type2, children, positions, length);
    }
    base2.children[i4] = split(0, b4.length, NodeType.none, 0, buf.length, stack.length - 1);
    for (let index of newStack) {
      let tree = cursor.tree.children[index], pos = cursor.tree.positions[index];
      cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));
    }
  }
  var StructureCursor = class {
    constructor(root, offset) {
      this.offset = offset;
      this.done = false;
      this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
    }
    // Move to the first node (in pre-order) that starts at or after `pos`.
    moveTo(pos) {
      let { cursor } = this, p4 = pos - this.offset;
      while (!this.done && cursor.from < p4) {
        if (cursor.to >= pos && cursor.enter(p4, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;
        else if (!cursor.next(false))
          this.done = true;
      }
    }
    hasNode(cursor) {
      this.moveTo(cursor.from);
      if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
        for (let tree = this.cursor.tree; ; ) {
          if (tree == cursor.tree)
            return true;
          if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
            tree = tree.children[0];
          else
            break;
        }
      }
      return false;
    }
  };
  var FragmentCursor = class {
    constructor(fragments) {
      var _a2;
      this.fragments = fragments;
      this.curTo = 0;
      this.fragI = 0;
      if (fragments.length) {
        let first = this.curFrag = fragments[0];
        this.curTo = (_a2 = first.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : first.to;
        this.inner = new StructureCursor(first.tree, -first.offset);
      } else {
        this.curFrag = this.inner = null;
      }
    }
    hasNode(node) {
      while (this.curFrag && node.from >= this.curTo)
        this.nextFrag();
      return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
      var _a2;
      this.fragI++;
      if (this.fragI == this.fragments.length) {
        this.curFrag = this.inner = null;
      } else {
        let frag = this.curFrag = this.fragments[this.fragI];
        this.curTo = (_a2 = frag.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : frag.to;
        this.inner = new StructureCursor(frag.tree, -frag.offset);
      }
    }
    findMounts(pos, parser4) {
      var _a2;
      let result = [];
      if (this.inner) {
        this.inner.cursor.moveTo(pos, 1);
        for (let pos2 = this.inner.cursor.node; pos2; pos2 = pos2.parent) {
          let mount = (_a2 = pos2.tree) === null || _a2 === void 0 ? void 0 : _a2.prop(NodeProp.mounted);
          if (mount && mount.parser == parser4) {
            for (let i4 = this.fragI; i4 < this.fragments.length; i4++) {
              let frag = this.fragments[i4];
              if (frag.from >= pos2.to)
                break;
              if (frag.tree == this.curFrag.tree)
                result.push({
                  frag,
                  pos: pos2.from - frag.offset,
                  mount
                });
            }
          }
        }
      }
      return result;
    }
  };
  function punchRanges(outer, ranges) {
    let copy = null, current = ranges;
    for (let i4 = 1, j2 = 0; i4 < outer.length; i4++) {
      let gapFrom = outer[i4 - 1].to, gapTo = outer[i4].from;
      for (; j2 < current.length; j2++) {
        let r3 = current[j2];
        if (r3.from >= gapTo)
          break;
        if (r3.to <= gapFrom)
          continue;
        if (!copy)
          current = copy = ranges.slice();
        if (r3.from < gapFrom) {
          copy[j2] = new Range(r3.from, gapFrom);
          if (r3.to > gapTo)
            copy.splice(j2 + 1, 0, new Range(gapTo, r3.to));
        } else if (r3.to > gapTo) {
          copy[j2--] = new Range(gapTo, r3.to);
        } else {
          copy.splice(j2--, 1);
        }
      }
    }
    return current;
  }
  function findCoverChanges(a4, b4, from, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
    let result = [];
    for (; ; ) {
      let nextA = iA == a4.length ? 1e9 : inA ? a4[iA].to : a4[iA].from;
      let nextB = iB == b4.length ? 1e9 : inB ? b4[iB].to : b4[iB].from;
      if (inA != inB) {
        let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
        if (start < end)
          result.push(new Range(start, end));
      }
      pos = Math.min(nextA, nextB);
      if (pos == 1e9)
        break;
      if (nextA == pos) {
        if (!inA)
          inA = true;
        else {
          inA = false;
          iA++;
        }
      }
      if (nextB == pos) {
        if (!inB)
          inB = true;
        else {
          inB = false;
          iB++;
        }
      }
    }
    return result;
  }
  function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos, mount, frag } of mounts) {
      let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
      let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
      if (mount.overlay) {
        let overlay = mount.overlay.map((r3) => new Range(r3.from + pos, r3.to + pos));
        let changes = findCoverChanges(ranges, overlay, from, to);
        for (let i4 = 0, pos2 = from; ; i4++) {
          let last = i4 == changes.length, end = last ? to : changes[i4].from;
          if (end > pos2)
            result.push(new TreeFragment(pos2, end, mount.tree, -startPos, frag.from >= pos2 || frag.openStart, frag.to <= end || frag.openEnd));
          if (last)
            break;
          pos2 = changes[i4].to;
        }
      } else {
        result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));
      }
    }
    return result;
  }

  // node_modules/.pnpm/@codemirror+state@6.4.1/node_modules/@codemirror/state/dist/index.js
  var Text = class _Text {
    /**
    Get the line description around the given position.
    */
    lineAt(pos) {
      if (pos < 0 || pos > this.length)
        throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
      return this.lineInner(pos, false, 1, 0);
    }
    /**
    Get the description for the given (1-based) line number.
    */
    line(n4) {
      if (n4 < 1 || n4 > this.lines)
        throw new RangeError(`Invalid line number ${n4} in ${this.lines}-line document`);
      return this.lineInner(n4, true, 1, 0);
    }
    /**
    Replace a range of the text with the given content.
    */
    replace(from, to, text) {
      [from, to] = clip(this, from, to);
      let parts = [];
      this.decompose(
        0,
        from,
        parts,
        2
        /* Open.To */
      );
      if (text.length)
        text.decompose(
          0,
          text.length,
          parts,
          1 | 2
          /* Open.To */
        );
      this.decompose(
        to,
        this.length,
        parts,
        1
        /* Open.From */
      );
      return TextNode.from(parts, this.length - (to - from) + text.length);
    }
    /**
    Append another document to this one.
    */
    append(other) {
      return this.replace(this.length, this.length, other);
    }
    /**
    Retrieve the text between the given points.
    */
    slice(from, to = this.length) {
      [from, to] = clip(this, from, to);
      let parts = [];
      this.decompose(from, to, parts, 0);
      return TextNode.from(parts, to - from);
    }
    /**
    Test whether this text is equal to another instance.
    */
    eq(other) {
      if (other == this)
        return true;
      if (other.length != this.length || other.lines != this.lines)
        return false;
      let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
      let a4 = new RawTextCursor(this), b4 = new RawTextCursor(other);
      for (let skip = start, pos = start; ; ) {
        a4.next(skip);
        b4.next(skip);
        skip = 0;
        if (a4.lineBreak != b4.lineBreak || a4.done != b4.done || a4.value != b4.value)
          return false;
        pos += a4.value.length;
        if (a4.done || pos >= end)
          return true;
      }
    }
    /**
    Iterate over the text. When `dir` is `-1`, iteration happens
    from end to start. This will return lines and the breaks between
    them as separate strings.
    */
    iter(dir = 1) {
      return new RawTextCursor(this, dir);
    }
    /**
    Iterate over a range of the text. When `from` > `to`, the
    iterator will run in reverse.
    */
    iterRange(from, to = this.length) {
      return new PartialTextCursor(this, from, to);
    }
    /**
    Return a cursor that iterates over the given range of lines,
    _without_ returning the line breaks between, and yielding empty
    strings for empty lines.
    
    When `from` and `to` are given, they should be 1-based line numbers.
    */
    iterLines(from, to) {
      let inner;
      if (from == null) {
        inner = this.iter();
      } else {
        if (to == null)
          to = this.lines + 1;
        let start = this.line(from).from;
        inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
      }
      return new LineCursor(inner);
    }
    /**
    Return the document as a string, using newline characters to
    separate lines.
    */
    toString() {
      return this.sliceString(0);
    }
    /**
    Convert the document to an array of lines (which can be
    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
    */
    toJSON() {
      let lines2 = [];
      this.flatten(lines2);
      return lines2;
    }
    /**
    @internal
    */
    constructor() {
    }
    /**
    Create a `Text` instance for the given array of lines.
    */
    static of(text) {
      if (text.length == 0)
        throw new RangeError("A document must have at least one line");
      if (text.length == 1 && !text[0])
        return _Text.empty;
      return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
    }
  };
  var TextLeaf = class _TextLeaf extends Text {
    constructor(text, length = textLength(text)) {
      super();
      this.text = text;
      this.length = length;
    }
    get lines() {
      return this.text.length;
    }
    get children() {
      return null;
    }
    lineInner(target, isLine, line, offset) {
      for (let i4 = 0; ; i4++) {
        let string2 = this.text[i4], end = offset + string2.length;
        if ((isLine ? line : end) >= target)
          return new Line(offset, end, line, string2);
        offset = end + 1;
        line++;
      }
    }
    decompose(from, to, target, open) {
      let text = from <= 0 && to >= this.length ? this : new _TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
      if (open & 1) {
        let prev = target.pop();
        let joined = appendText(text.text, prev.text.slice(), 0, text.length);
        if (joined.length <= 32) {
          target.push(new _TextLeaf(joined, prev.length + text.length));
        } else {
          let mid = joined.length >> 1;
          target.push(new _TextLeaf(joined.slice(0, mid)), new _TextLeaf(joined.slice(mid)));
        }
      } else {
        target.push(text);
      }
    }
    replace(from, to, text) {
      if (!(text instanceof _TextLeaf))
        return super.replace(from, to, text);
      [from, to] = clip(this, from, to);
      let lines2 = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
      let newLen = this.length + text.length - (to - from);
      if (lines2.length <= 32)
        return new _TextLeaf(lines2, newLen);
      return TextNode.from(_TextLeaf.split(lines2, []), newLen);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      [from, to] = clip(this, from, to);
      let result = "";
      for (let pos = 0, i4 = 0; pos <= to && i4 < this.text.length; i4++) {
        let line = this.text[i4], end = pos + line.length;
        if (pos > from && i4)
          result += lineSep;
        if (from < end && to > pos)
          result += line.slice(Math.max(0, from - pos), to - pos);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let line of this.text)
        target.push(line);
    }
    scanIdentical() {
      return 0;
    }
    static split(text, target) {
      let part = [], len = -1;
      for (let line of text) {
        part.push(line);
        len += line.length + 1;
        if (part.length == 32) {
          target.push(new _TextLeaf(part, len));
          part = [];
          len = -1;
        }
      }
      if (len > -1)
        target.push(new _TextLeaf(part, len));
      return target;
    }
  };
  var TextNode = class _TextNode extends Text {
    constructor(children, length) {
      super();
      this.children = children;
      this.length = length;
      this.lines = 0;
      for (let child of children)
        this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
      for (let i4 = 0; ; i4++) {
        let child = this.children[i4], end = offset + child.length, endLine = line + child.lines - 1;
        if ((isLine ? endLine : end) >= target)
          return child.lineInner(target, isLine, line, offset);
        offset = end + 1;
        line = endLine + 1;
      }
    }
    decompose(from, to, target, open) {
      for (let i4 = 0, pos = 0; pos <= to && i4 < this.children.length; i4++) {
        let child = this.children[i4], end = pos + child.length;
        if (from <= end && to >= pos) {
          let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
          if (pos >= from && end <= to && !childOpen)
            target.push(child);
          else
            child.decompose(from - pos, to - pos, target, childOpen);
        }
        pos = end + 1;
      }
    }
    replace(from, to, text) {
      [from, to] = clip(this, from, to);
      if (text.lines < this.lines)
        for (let i4 = 0, pos = 0; i4 < this.children.length; i4++) {
          let child = this.children[i4], end = pos + child.length;
          if (from >= pos && to <= end) {
            let updated = child.replace(from - pos, to - pos, text);
            let totalLines = this.lines - child.lines + updated.lines;
            if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
              let copy = this.children.slice();
              copy[i4] = updated;
              return new _TextNode(copy, this.length - (to - from) + text.length);
            }
            return super.replace(pos, end, updated);
          }
          pos = end + 1;
        }
      return super.replace(from, to, text);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      [from, to] = clip(this, from, to);
      let result = "";
      for (let i4 = 0, pos = 0; i4 < this.children.length && pos <= to; i4++) {
        let child = this.children[i4], end = pos + child.length;
        if (pos > from && i4)
          result += lineSep;
        if (from < end && to > pos)
          result += child.sliceString(from - pos, to - pos, lineSep);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let child of this.children)
        child.flatten(target);
    }
    scanIdentical(other, dir) {
      if (!(other instanceof _TextNode))
        return 0;
      let length = 0;
      let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
      for (; ; iA += dir, iB += dir) {
        if (iA == eA || iB == eB)
          return length;
        let chA = this.children[iA], chB = other.children[iB];
        if (chA != chB)
          return length + chA.scanIdentical(chB, dir);
        length += chA.length + 1;
      }
    }
    static from(children, length = children.reduce((l4, ch) => l4 + ch.length + 1, -1)) {
      let lines2 = 0;
      for (let ch of children)
        lines2 += ch.lines;
      if (lines2 < 32) {
        let flat = [];
        for (let ch of children)
          ch.flatten(flat);
        return new TextLeaf(flat, length);
      }
      let chunk = Math.max(
        32,
        lines2 >> 5
        /* Tree.BranchShift */
      ), maxChunk = chunk << 1, minChunk = chunk >> 1;
      let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
      function add2(child) {
        let last;
        if (child.lines > maxChunk && child instanceof _TextNode) {
          for (let node of child.children)
            add2(node);
        } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
          flush();
          chunked.push(child);
        } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
        } else {
          if (currentLines + child.lines > chunk)
            flush();
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk.push(child);
        }
      }
      function flush() {
        if (currentLines == 0)
          return;
        chunked.push(currentChunk.length == 1 ? currentChunk[0] : _TextNode.from(currentChunk, currentLen));
        currentLen = -1;
        currentLines = currentChunk.length = 0;
      }
      for (let child of children)
        add2(child);
      flush();
      return chunked.length == 1 ? chunked[0] : new _TextNode(chunked, length);
    }
  };
  Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
  function textLength(text) {
    let length = -1;
    for (let line of text)
      length += line.length + 1;
    return length;
  }
  function appendText(text, target, from = 0, to = 1e9) {
    for (let pos = 0, i4 = 0, first = true; i4 < text.length && pos <= to; i4++) {
      let line = text[i4], end = pos + line.length;
      if (end >= from) {
        if (end > to)
          line = line.slice(0, to - pos);
        if (pos < from)
          line = line.slice(from - pos);
        if (first) {
          target[target.length - 1] += line;
          first = false;
        } else
          target.push(line);
      }
      pos = end + 1;
    }
    return target;
  }
  function sliceText(text, from, to) {
    return appendText(text, [""], from, to);
  }
  var RawTextCursor = class {
    constructor(text, dir = 1) {
      this.dir = dir;
      this.done = false;
      this.lineBreak = false;
      this.value = "";
      this.nodes = [text];
      this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
    }
    nextInner(skip, dir) {
      this.done = this.lineBreak = false;
      for (; ; ) {
        let last = this.nodes.length - 1;
        let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
        let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
        if (offset == (dir > 0 ? size : 0)) {
          if (last == 0) {
            this.done = true;
            this.value = "";
            return this;
          }
          if (dir > 0)
            this.offsets[last - 1]++;
          this.nodes.pop();
          this.offsets.pop();
        } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
          this.offsets[last] += dir;
          if (skip == 0) {
            this.lineBreak = true;
            this.value = "\n";
            return this;
          }
          skip--;
        } else if (top2 instanceof TextLeaf) {
          let next = top2.text[offset + (dir < 0 ? -1 : 0)];
          this.offsets[last] += dir;
          if (next.length > Math.max(0, skip)) {
            this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
            return this;
          }
          skip -= next.length;
        } else {
          let next = top2.children[offset + (dir < 0 ? -1 : 0)];
          if (skip > next.length) {
            skip -= next.length;
            this.offsets[last] += dir;
          } else {
            if (dir < 0)
              this.offsets[last]--;
            this.nodes.push(next);
            this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
          }
        }
      }
    }
    next(skip = 0) {
      if (skip < 0) {
        this.nextInner(-skip, -this.dir);
        skip = this.value.length;
      }
      return this.nextInner(skip, this.dir);
    }
  };
  var PartialTextCursor = class {
    constructor(text, start, end) {
      this.value = "";
      this.done = false;
      this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
      this.pos = start > end ? text.length : 0;
      this.from = Math.min(start, end);
      this.to = Math.max(start, end);
    }
    nextInner(skip, dir) {
      if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
        this.value = "";
        this.done = true;
        return this;
      }
      skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
      let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
      if (skip > limit)
        skip = limit;
      limit -= skip;
      let { value } = this.cursor.next(skip);
      this.pos += (value.length + skip) * dir;
      this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
      this.done = !this.value;
      return this;
    }
    next(skip = 0) {
      if (skip < 0)
        skip = Math.max(skip, this.from - this.pos);
      else if (skip > 0)
        skip = Math.min(skip, this.to - this.pos);
      return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() {
      return this.cursor.lineBreak && this.value != "";
    }
  };
  var LineCursor = class {
    constructor(inner) {
      this.inner = inner;
      this.afterBreak = true;
      this.value = "";
      this.done = false;
    }
    next(skip = 0) {
      let { done, lineBreak, value } = this.inner.next(skip);
      if (done && this.afterBreak) {
        this.value = "";
        this.afterBreak = false;
      } else if (done) {
        this.done = true;
        this.value = "";
      } else if (lineBreak) {
        if (this.afterBreak) {
          this.value = "";
        } else {
          this.afterBreak = true;
          this.next();
        }
      } else {
        this.value = value;
        this.afterBreak = false;
      }
      return this;
    }
    get lineBreak() {
      return false;
    }
  };
  if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function() {
      return this.iter();
    };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  var Line = class {
    /**
    @internal
    */
    constructor(from, to, number2, text) {
      this.from = from;
      this.to = to;
      this.number = number2;
      this.text = text;
    }
    /**
    The length of the line (not including any line break after it).
    */
    get length() {
      return this.to - this.from;
    }
  };
  function clip(text, from, to) {
    from = Math.max(0, Math.min(text.length, from));
    return [from, Math.max(from, Math.min(text.length, to))];
  }
  var extend = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s4) => s4 ? parseInt(s4, 36) : 1);
  for (let i4 = 1; i4 < extend.length; i4++)
    extend[i4] += extend[i4 - 1];
  function isExtendingChar(code) {
    for (let i4 = 1; i4 < extend.length; i4 += 2)
      if (extend[i4] > code)
        return extend[i4 - 1] <= code;
    return false;
  }
  function isRegionalIndicator(code) {
    return code >= 127462 && code <= 127487;
  }
  var ZWJ = 8205;
  function findClusterBreak(str2, pos, forward = true, includeExtending = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str2, pos, includeExtending);
  }
  function nextClusterBreak(str2, pos, includeExtending) {
    if (pos == str2.length)
      return pos;
    if (pos && surrogateLow(str2.charCodeAt(pos)) && surrogateHigh(str2.charCodeAt(pos - 1)))
      pos--;
    let prev = codePointAt(str2, pos);
    pos += codePointSize(prev);
    while (pos < str2.length) {
      let next = codePointAt(str2, pos);
      if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
        pos += codePointSize(next);
        prev = next;
      } else if (isRegionalIndicator(next)) {
        let countBefore = 0, i4 = pos - 2;
        while (i4 >= 0 && isRegionalIndicator(codePointAt(str2, i4))) {
          countBefore++;
          i4 -= 2;
        }
        if (countBefore % 2 == 0)
          break;
        else
          pos += 2;
      } else {
        break;
      }
    }
    return pos;
  }
  function prevClusterBreak(str2, pos, includeExtending) {
    while (pos > 0) {
      let found = nextClusterBreak(str2, pos - 2, includeExtending);
      if (found < pos)
        return found;
      pos--;
    }
    return 0;
  }
  function surrogateLow(ch) {
    return ch >= 56320 && ch < 57344;
  }
  function surrogateHigh(ch) {
    return ch >= 55296 && ch < 56320;
  }
  function codePointAt(str2, pos) {
    let code0 = str2.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str2.length)
      return code0;
    let code1 = str2.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
      return code0;
    return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
  }
  function codePointSize(code) {
    return code < 65536 ? 1 : 2;
  }
  var DefaultSplit = /\r\n?|\n/;
  var MapMode = /* @__PURE__ */ function(MapMode2) {
    MapMode2[MapMode2["Simple"] = 0] = "Simple";
    MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
    MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
    MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
    return MapMode2;
  }(MapMode || (MapMode = {}));
  var ChangeDesc = class _ChangeDesc {
    // Sections are encoded as pairs of integers. The first is the
    // length in the current document, and the second is -1 for
    // unaffected sections, and the length of the replacement content
    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
    // 0), and a replacement two positive numbers.
    /**
    @internal
    */
    constructor(sections) {
      this.sections = sections;
    }
    /**
    The length of the document before the change.
    */
    get length() {
      let result = 0;
      for (let i4 = 0; i4 < this.sections.length; i4 += 2)
        result += this.sections[i4];
      return result;
    }
    /**
    The length of the document after the change.
    */
    get newLength() {
      let result = 0;
      for (let i4 = 0; i4 < this.sections.length; i4 += 2) {
        let ins = this.sections[i4 + 1];
        result += ins < 0 ? this.sections[i4] : ins;
      }
      return result;
    }
    /**
    False when there are actual changes in this set.
    */
    get empty() {
      return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
    }
    /**
    Iterate over the unchanged parts left by these changes. `posA`
    provides the position of the range in the old document, `posB`
    the new position in the changed document.
    */
    iterGaps(f3) {
      for (let i4 = 0, posA = 0, posB = 0; i4 < this.sections.length; ) {
        let len = this.sections[i4++], ins = this.sections[i4++];
        if (ins < 0) {
          f3(posA, posB, len);
          posB += len;
        } else {
          posB += ins;
        }
        posA += len;
      }
    }
    /**
    Iterate over the ranges changed by these changes. (See
    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
    variant that also provides you with the inserted text.)
    `fromA`/`toA` provides the extent of the change in the starting
    document, `fromB`/`toB` the extent of the replacement in the
    changed document.
    
    When `individual` is true, adjacent changes (which are kept
    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
    reported separately.
    */
    iterChangedRanges(f3, individual = false) {
      iterChanges(this, f3, individual);
    }
    /**
    Get a description of the inverted form of these changes.
    */
    get invertedDesc() {
      let sections = [];
      for (let i4 = 0; i4 < this.sections.length; ) {
        let len = this.sections[i4++], ins = this.sections[i4++];
        if (ins < 0)
          sections.push(len, ins);
        else
          sections.push(ins, len);
      }
      return new _ChangeDesc(sections);
    }
    /**
    Compute the combined effect of applying another set of changes
    after this one. The length of the document after this set should
    match the length before `other`.
    */
    composeDesc(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other);
    }
    /**
    Map this description, which should start with the same document
    as `other`, over another set of changes, so that it can be
    applied after it. When `before` is true, map as if the changes
    in `other` happened before the ones in `this`.
    */
    mapDesc(other, before = false) {
      return other.empty ? this : mapSet(this, other, before);
    }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
      let posA = 0, posB = 0;
      for (let i4 = 0; i4 < this.sections.length; ) {
        let len = this.sections[i4++], ins = this.sections[i4++], endA = posA + len;
        if (ins < 0) {
          if (endA > pos)
            return posB + (pos - posA);
          posB += len;
        } else {
          if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
            return null;
          if (endA > pos || endA == pos && assoc < 0 && !len)
            return pos == posA || assoc < 0 ? posB : posB + ins;
          posB += ins;
        }
        posA = endA;
      }
      if (pos > posA)
        throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
      return posB;
    }
    /**
    Check whether these changes touch a given range. When one of the
    changes entirely covers the range, the string `"cover"` is
    returned.
    */
    touchesRange(from, to = from) {
      for (let i4 = 0, pos = 0; i4 < this.sections.length && pos <= to; ) {
        let len = this.sections[i4++], ins = this.sections[i4++], end = pos + len;
        if (ins >= 0 && pos <= to && end >= from)
          return pos < from && end > to ? "cover" : true;
        pos = end;
      }
      return false;
    }
    /**
    @internal
    */
    toString() {
      let result = "";
      for (let i4 = 0; i4 < this.sections.length; ) {
        let len = this.sections[i4++], ins = this.sections[i4++];
        result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
      }
      return result;
    }
    /**
    Serialize this change desc to a JSON-representable value.
    */
    toJSON() {
      return this.sections;
    }
    /**
    Create a change desc from its JSON representation (as produced
    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
    */
    static fromJSON(json2) {
      if (!Array.isArray(json2) || json2.length % 2 || json2.some((a4) => typeof a4 != "number"))
        throw new RangeError("Invalid JSON representation of ChangeDesc");
      return new _ChangeDesc(json2);
    }
    /**
    @internal
    */
    static create(sections) {
      return new _ChangeDesc(sections);
    }
  };
  var ChangeSet = class _ChangeSet extends ChangeDesc {
    constructor(sections, inserted) {
      super(sections);
      this.inserted = inserted;
    }
    /**
    Apply the changes to a document, returning the modified
    document.
    */
    apply(doc2) {
      if (this.length != doc2.length)
        throw new RangeError("Applying change set to a document with the wrong length");
      iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
      return doc2;
    }
    mapDesc(other, before = false) {
      return mapSet(this, other, before, true);
    }
    /**
    Given the document as it existed _before_ the changes, return a
    change set that represents the inverse of this set, which could
    be used to go from the document created by the changes back to
    the document as it existed before the changes.
    */
    invert(doc2) {
      let sections = this.sections.slice(), inserted = [];
      for (let i4 = 0, pos = 0; i4 < sections.length; i4 += 2) {
        let len = sections[i4], ins = sections[i4 + 1];
        if (ins >= 0) {
          sections[i4] = ins;
          sections[i4 + 1] = len;
          let index = i4 >> 1;
          while (inserted.length < index)
            inserted.push(Text.empty);
          inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
        }
        pos += len;
      }
      return new _ChangeSet(sections, inserted);
    }
    /**
    Combine two subsequent change sets into a single set. `other`
    must start in the document produced by `this`. If `this` goes
    `docA` → `docB` and `other` represents `docB` → `docC`, the
    returned value will represent the change `docA` → `docC`.
    */
    compose(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other, true);
    }
    /**
    Given another change set starting in the same document, maps this
    change set over the other, producing a new change set that can be
    applied to the document produced by applying `other`. When
    `before` is `true`, order changes as if `this` comes before
    `other`, otherwise (the default) treat `other` as coming first.
    
    Given two changes `A` and `B`, `A.compose(B.map(A))` and
    `B.compose(A.map(B, true))` will produce the same document. This
    provides a basic form of [operational
    transformation](https://en.wikipedia.org/wiki/Operational_transformation),
    and can be used for collaborative editing.
    */
    map(other, before = false) {
      return other.empty ? this : mapSet(this, other, before, true);
    }
    /**
    Iterate over the changed ranges in the document, calling `f` for
    each, with the range in the original document (`fromA`-`toA`)
    and the range that replaces it in the new document
    (`fromB`-`toB`).
    
    When `individual` is true, adjacent changes are reported
    separately.
    */
    iterChanges(f3, individual = false) {
      iterChanges(this, f3, individual);
    }
    /**
    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
    set.
    */
    get desc() {
      return ChangeDesc.create(this.sections);
    }
    /**
    @internal
    */
    filter(ranges) {
      let resultSections = [], resultInserted = [], filteredSections = [];
      let iter = new SectionIter(this);
      done: for (let i4 = 0, pos = 0; ; ) {
        let next = i4 == ranges.length ? 1e9 : ranges[i4++];
        while (pos < next || pos == next && iter.len == 0) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, next - pos);
          addSection(filteredSections, len, -1);
          let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
          addSection(resultSections, len, ins);
          if (ins > 0)
            addInsert(resultInserted, resultSections, iter.text);
          iter.forward(len);
          pos += len;
        }
        let end = ranges[i4++];
        while (pos < end) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, end - pos);
          addSection(resultSections, len, -1);
          addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
          iter.forward(len);
          pos += len;
        }
      }
      return {
        changes: new _ChangeSet(resultSections, resultInserted),
        filtered: ChangeDesc.create(filteredSections)
      };
    }
    /**
    Serialize this change set to a JSON-representable value.
    */
    toJSON() {
      let parts = [];
      for (let i4 = 0; i4 < this.sections.length; i4 += 2) {
        let len = this.sections[i4], ins = this.sections[i4 + 1];
        if (ins < 0)
          parts.push(len);
        else if (ins == 0)
          parts.push([len]);
        else
          parts.push([len].concat(this.inserted[i4 >> 1].toJSON()));
      }
      return parts;
    }
    /**
    Create a change set for the given changes, for a document of the
    given length, using `lineSep` as line separator.
    */
    static of(changes, length, lineSep) {
      let sections = [], inserted = [], pos = 0;
      let total = null;
      function flush(force = false) {
        if (!force && !sections.length)
          return;
        if (pos < length)
          addSection(sections, length - pos, -1);
        let set2 = new _ChangeSet(sections, inserted);
        total = total ? total.compose(set2.map(total)) : set2;
        sections = [];
        inserted = [];
        pos = 0;
      }
      function process2(spec) {
        if (Array.isArray(spec)) {
          for (let sub of spec)
            process2(sub);
        } else if (spec instanceof _ChangeSet) {
          if (spec.length != length)
            throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
          flush();
          total = total ? total.compose(spec.map(total)) : spec;
        } else {
          let { from, to = from, insert: insert2 } = spec;
          if (from > to || from < 0 || to > length)
            throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
          let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
          let insLen = insText.length;
          if (from == to && insLen == 0)
            return;
          if (from < pos)
            flush();
          if (from > pos)
            addSection(sections, from - pos, -1);
          addSection(sections, to - from, insLen);
          addInsert(inserted, sections, insText);
          pos = to;
        }
      }
      process2(changes);
      flush(!total);
      return total;
    }
    /**
    Create an empty changeset of the given length.
    */
    static empty(length) {
      return new _ChangeSet(length ? [length, -1] : [], []);
    }
    /**
    Create a changeset from its JSON representation (as produced by
    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
    */
    static fromJSON(json2) {
      if (!Array.isArray(json2))
        throw new RangeError("Invalid JSON representation of ChangeSet");
      let sections = [], inserted = [];
      for (let i4 = 0; i4 < json2.length; i4++) {
        let part = json2[i4];
        if (typeof part == "number") {
          sections.push(part, -1);
        } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e4, i5) => i5 && typeof e4 != "string")) {
          throw new RangeError("Invalid JSON representation of ChangeSet");
        } else if (part.length == 1) {
          sections.push(part[0], 0);
        } else {
          while (inserted.length < i4)
            inserted.push(Text.empty);
          inserted[i4] = Text.of(part.slice(1));
          sections.push(part[0], inserted[i4].length);
        }
      }
      return new _ChangeSet(sections, inserted);
    }
    /**
    @internal
    */
    static createSet(sections, inserted) {
      return new _ChangeSet(sections, inserted);
    }
  };
  function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
      return;
    let last = sections.length - 2;
    if (last >= 0 && ins <= 0 && ins == sections[last + 1])
      sections[last] += len;
    else if (len == 0 && sections[last] == 0)
      sections[last + 1] += ins;
    else if (forceJoin) {
      sections[last] += len;
      sections[last + 1] += ins;
    } else
      sections.push(len, ins);
  }
  function addInsert(values, sections, value) {
    if (value.length == 0)
      return;
    let index = sections.length - 2 >> 1;
    if (index < values.length) {
      values[values.length - 1] = values[values.length - 1].append(value);
    } else {
      while (values.length < index)
        values.push(Text.empty);
      values.push(value);
    }
  }
  function iterChanges(desc, f3, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i4 = 0; i4 < desc.sections.length; ) {
      let len = desc.sections[i4++], ins = desc.sections[i4++];
      if (ins < 0) {
        posA += len;
        posB += len;
      } else {
        let endA = posA, endB = posB, text = Text.empty;
        for (; ; ) {
          endA += len;
          endB += ins;
          if (ins && inserted)
            text = text.append(inserted[i4 - 2 >> 1]);
          if (individual || i4 == desc.sections.length || desc.sections[i4 + 1] < 0)
            break;
          len = desc.sections[i4++];
          ins = desc.sections[i4++];
        }
        f3(posA, endA, posB, endB, text);
        posA = endA;
        posB = endB;
      }
    }
  }
  function mapSet(setA, setB, before, mkSet = false) {
    let sections = [], insert2 = mkSet ? [] : null;
    let a4 = new SectionIter(setA), b4 = new SectionIter(setB);
    for (let inserted = -1; ; ) {
      if (a4.ins == -1 && b4.ins == -1) {
        let len = Math.min(a4.len, b4.len);
        addSection(sections, len, -1);
        a4.forward(len);
        b4.forward(len);
      } else if (b4.ins >= 0 && (a4.ins < 0 || inserted == a4.i || a4.off == 0 && (b4.len < a4.len || b4.len == a4.len && !before))) {
        let len = b4.len;
        addSection(sections, b4.ins, -1);
        while (len) {
          let piece = Math.min(a4.len, len);
          if (a4.ins >= 0 && inserted < a4.i && a4.len <= piece) {
            addSection(sections, 0, a4.ins);
            if (insert2)
              addInsert(insert2, sections, a4.text);
            inserted = a4.i;
          }
          a4.forward(piece);
          len -= piece;
        }
        b4.next();
      } else if (a4.ins >= 0) {
        let len = 0, left = a4.len;
        while (left) {
          if (b4.ins == -1) {
            let piece = Math.min(left, b4.len);
            len += piece;
            left -= piece;
            b4.forward(piece);
          } else if (b4.ins == 0 && b4.len < left) {
            left -= b4.len;
            b4.next();
          } else {
            break;
          }
        }
        addSection(sections, len, inserted < a4.i ? a4.ins : 0);
        if (insert2 && inserted < a4.i)
          addInsert(insert2, sections, a4.text);
        inserted = a4.i;
        a4.forward(a4.len - left);
      } else if (a4.done && b4.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else {
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert2 = mkSet ? [] : null;
    let a4 = new SectionIter(setA), b4 = new SectionIter(setB);
    for (let open = false; ; ) {
      if (a4.done && b4.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else if (a4.ins == 0) {
        addSection(sections, a4.len, 0, open);
        a4.next();
      } else if (b4.len == 0 && !b4.done) {
        addSection(sections, 0, b4.ins, open);
        if (insert2)
          addInsert(insert2, sections, b4.text);
        b4.next();
      } else if (a4.done || b4.done) {
        throw new Error("Mismatched change set lengths");
      } else {
        let len = Math.min(a4.len2, b4.len), sectionLen = sections.length;
        if (a4.ins == -1) {
          let insB = b4.ins == -1 ? -1 : b4.off ? 0 : b4.ins;
          addSection(sections, len, insB, open);
          if (insert2 && insB)
            addInsert(insert2, sections, b4.text);
        } else if (b4.ins == -1) {
          addSection(sections, a4.off ? 0 : a4.len, len, open);
          if (insert2)
            addInsert(insert2, sections, a4.textBit(len));
        } else {
          addSection(sections, a4.off ? 0 : a4.len, b4.off ? 0 : b4.ins, open);
          if (insert2 && !b4.off)
            addInsert(insert2, sections, b4.text);
        }
        open = (a4.ins > len || b4.ins >= 0 && b4.len > len) && (open || sections.length > sectionLen);
        a4.forward2(len);
        b4.forward(len);
      }
    }
  }
  var SectionIter = class {
    constructor(set2) {
      this.set = set2;
      this.i = 0;
      this.next();
    }
    next() {
      let { sections } = this.set;
      if (this.i < sections.length) {
        this.len = sections[this.i++];
        this.ins = sections[this.i++];
      } else {
        this.len = 0;
        this.ins = -2;
      }
      this.off = 0;
    }
    get done() {
      return this.ins == -2;
    }
    get len2() {
      return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
      let { inserted } = this.set, index = this.i - 2 >> 1;
      return index >= inserted.length ? Text.empty : inserted[index];
    }
    textBit(len) {
      let { inserted } = this.set, index = this.i - 2 >> 1;
      return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
    }
    forward(len) {
      if (len == this.len)
        this.next();
      else {
        this.len -= len;
        this.off += len;
      }
    }
    forward2(len) {
      if (this.ins == -1)
        this.forward(len);
      else if (len == this.ins)
        this.next();
      else {
        this.ins -= len;
        this.off += len;
      }
    }
  };
  var SelectionRange = class _SelectionRange {
    constructor(from, to, flags) {
      this.from = from;
      this.to = to;
      this.flags = flags;
    }
    /**
    The anchor of the range—the side that doesn't move when you
    extend it.
    */
    get anchor() {
      return this.flags & 32 ? this.to : this.from;
    }
    /**
    The head of the range, which is moved when the range is
    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
    */
    get head() {
      return this.flags & 32 ? this.from : this.to;
    }
    /**
    True when `anchor` and `head` are at the same position.
    */
    get empty() {
      return this.from == this.to;
    }
    /**
    If this is a cursor that is explicitly associated with the
    character on one of its sides, this returns the side. -1 means
    the character before its position, 1 the character after, and 0
    means no association.
    */
    get assoc() {
      return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
    }
    /**
    The bidirectional text level associated with this cursor, if
    any.
    */
    get bidiLevel() {
      let level = this.flags & 7;
      return level == 7 ? null : level;
    }
    /**
    The goal column (stored vertical offset) associated with a
    cursor. This is used to preserve the vertical position when
    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
    lines of different length.
    */
    get goalColumn() {
      let value = this.flags >> 6;
      return value == 16777215 ? void 0 : value;
    }
    /**
    Map this range through a change, producing a valid range in the
    updated document.
    */
    map(change, assoc = -1) {
      let from, to;
      if (this.empty) {
        from = to = change.mapPos(this.from, assoc);
      } else {
        from = change.mapPos(this.from, 1);
        to = change.mapPos(this.to, -1);
      }
      return from == this.from && to == this.to ? this : new _SelectionRange(from, to, this.flags);
    }
    /**
    Extend this range to cover at least `from` to `to`.
    */
    extend(from, to = from) {
      if (from <= this.anchor && to >= this.anchor)
        return EditorSelection.range(from, to);
      let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
      return EditorSelection.range(this.anchor, head);
    }
    /**
    Compare this range to another range.
    */
    eq(other, includeAssoc = false) {
      return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
    }
    /**
    Return a JSON-serializable object representing the range.
    */
    toJSON() {
      return { anchor: this.anchor, head: this.head };
    }
    /**
    Convert a JSON representation of a range to a `SelectionRange`
    instance.
    */
    static fromJSON(json2) {
      if (!json2 || typeof json2.anchor != "number" || typeof json2.head != "number")
        throw new RangeError("Invalid JSON representation for SelectionRange");
      return EditorSelection.range(json2.anchor, json2.head);
    }
    /**
    @internal
    */
    static create(from, to, flags) {
      return new _SelectionRange(from, to, flags);
    }
  };
  var EditorSelection = class _EditorSelection {
    constructor(ranges, mainIndex) {
      this.ranges = ranges;
      this.mainIndex = mainIndex;
    }
    /**
    Map a selection through a change. Used to adjust the selection
    position for changes.
    */
    map(change, assoc = -1) {
      if (change.empty)
        return this;
      return _EditorSelection.create(this.ranges.map((r3) => r3.map(change, assoc)), this.mainIndex);
    }
    /**
    Compare this selection to another selection. By default, ranges
    are compared only by position. When `includeAssoc` is true,
    cursor ranges must also have the same
    [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
    */
    eq(other, includeAssoc = false) {
      if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
        return false;
      for (let i4 = 0; i4 < this.ranges.length; i4++)
        if (!this.ranges[i4].eq(other.ranges[i4], includeAssoc))
          return false;
      return true;
    }
    /**
    Get the primary selection range. Usually, you should make sure
    your code applies to _all_ ranges, by using methods like
    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
    */
    get main() {
      return this.ranges[this.mainIndex];
    }
    /**
    Make sure the selection only has one range. Returns a selection
    holding only the main range from this selection.
    */
    asSingle() {
      return this.ranges.length == 1 ? this : new _EditorSelection([this.main], 0);
    }
    /**
    Extend this selection with an extra range.
    */
    addRange(range, main2 = true) {
      return _EditorSelection.create([range].concat(this.ranges), main2 ? 0 : this.mainIndex + 1);
    }
    /**
    Replace a given range with another range, and then normalize the
    selection to merge and sort ranges if necessary.
    */
    replaceRange(range, which = this.mainIndex) {
      let ranges = this.ranges.slice();
      ranges[which] = range;
      return _EditorSelection.create(ranges, this.mainIndex);
    }
    /**
    Convert this selection to an object that can be serialized to
    JSON.
    */
    toJSON() {
      return { ranges: this.ranges.map((r3) => r3.toJSON()), main: this.mainIndex };
    }
    /**
    Create a selection from a JSON representation.
    */
    static fromJSON(json2) {
      if (!json2 || !Array.isArray(json2.ranges) || typeof json2.main != "number" || json2.main >= json2.ranges.length)
        throw new RangeError("Invalid JSON representation for EditorSelection");
      return new _EditorSelection(json2.ranges.map((r3) => SelectionRange.fromJSON(r3)), json2.main);
    }
    /**
    Create a selection holding a single range.
    */
    static single(anchor, head = anchor) {
      return new _EditorSelection([_EditorSelection.range(anchor, head)], 0);
    }
    /**
    Sort and merge the given set of ranges, creating a valid
    selection.
    */
    static create(ranges, mainIndex = 0) {
      if (ranges.length == 0)
        throw new RangeError("A selection needs at least one range");
      for (let pos = 0, i4 = 0; i4 < ranges.length; i4++) {
        let range = ranges[i4];
        if (range.empty ? range.from <= pos : range.from < pos)
          return _EditorSelection.normalized(ranges.slice(), mainIndex);
        pos = range.to;
      }
      return new _EditorSelection(ranges, mainIndex);
    }
    /**
    Create a cursor selection range at the given position. You can
    safely ignore the optional arguments in most situations.
    */
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
      return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
    }
    /**
    Create a selection range.
    */
    static range(anchor, head, goalColumn, bidiLevel) {
      let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
      return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
    }
    /**
    @internal
    */
    static normalized(ranges, mainIndex = 0) {
      let main2 = ranges[mainIndex];
      ranges.sort((a4, b4) => a4.from - b4.from);
      mainIndex = ranges.indexOf(main2);
      for (let i4 = 1; i4 < ranges.length; i4++) {
        let range = ranges[i4], prev = ranges[i4 - 1];
        if (range.empty ? range.from <= prev.to : range.from < prev.to) {
          let from = prev.from, to = Math.max(range.to, prev.to);
          if (i4 <= mainIndex)
            mainIndex--;
          ranges.splice(--i4, 2, range.anchor > range.head ? _EditorSelection.range(to, from) : _EditorSelection.range(from, to));
        }
      }
      return new _EditorSelection(ranges, mainIndex);
    }
  };
  function checkSelection(selection, docLength) {
    for (let range of selection.ranges)
      if (range.to > docLength)
        throw new RangeError("Selection points outside of document");
  }
  var nextID = 0;
  var Facet = class _Facet {
    constructor(combine, compareInput, compare2, isStatic, enables) {
      this.combine = combine;
      this.compareInput = compareInput;
      this.compare = compare2;
      this.isStatic = isStatic;
      this.id = nextID++;
      this.default = combine([]);
      this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
    /**
    Returns a facet reader for this facet, which can be used to
    [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
    */
    get reader() {
      return this;
    }
    /**
    Define a new facet.
    */
    static define(config = {}) {
      return new _Facet(config.combine || ((a4) => a4), config.compareInput || ((a4, b4) => a4 === b4), config.compare || (!config.combine ? sameArray : (a4, b4) => a4 === b4), !!config.static, config.enables);
    }
    /**
    Returns an extension that adds the given value to this facet.
    */
    of(value) {
      return new FacetProvider([], this, 0, value);
    }
    /**
    Create an extension that computes a value for the facet from a
    state. You must take care to declare the parts of the state that
    this value depends on, since your function is only called again
    for a new state when one of those parts changed.
    
    In cases where your value depends only on a single field, you'll
    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
    */
    compute(deps, get) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 1, get);
    }
    /**
    Create an extension that computes zero or more values for this
    facet from a state.
    */
    computeN(deps, get) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 2, get);
    }
    from(field, get) {
      if (!get)
        get = (x2) => x2;
      return this.compute([field], (state) => get(state.field(field)));
    }
  };
  function sameArray(a4, b4) {
    return a4 == b4 || a4.length == b4.length && a4.every((e4, i4) => e4 === b4[i4]);
  }
  var FacetProvider = class {
    constructor(dependencies, facet, type2, value) {
      this.dependencies = dependencies;
      this.facet = facet;
      this.type = type2;
      this.value = value;
      this.id = nextID++;
    }
    dynamicSlot(addresses) {
      var _a2;
      let getter = this.value;
      let compare2 = this.facet.compareInput;
      let id2 = this.id, idx = addresses[id2] >> 1, multi = this.type == 2;
      let depDoc = false, depSel = false, depAddrs = [];
      for (let dep of this.dependencies) {
        if (dep == "doc")
          depDoc = true;
        else if (dep == "selection")
          depSel = true;
        else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
          depAddrs.push(addresses[dep.id]);
      }
      return {
        create(state) {
          state.values[idx] = getter(state);
          return 1;
        },
        update(state, tr) {
          if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
            let newVal = getter(state);
            if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
              state.values[idx] = newVal;
              return 1;
            }
          }
          return 0;
        },
        reconfigure: (state, oldState) => {
          let newVal, oldAddr = oldState.config.address[id2];
          if (oldAddr != null) {
            let oldVal = getAddr(oldState, oldAddr);
            if (this.dependencies.every((dep) => {
              return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
            }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
              state.values[idx] = oldVal;
              return 0;
            }
          } else {
            newVal = getter(state);
          }
          state.values[idx] = newVal;
          return 1;
        }
      };
    }
  };
  function compareArray(a4, b4, compare2) {
    if (a4.length != b4.length)
      return false;
    for (let i4 = 0; i4 < a4.length; i4++)
      if (!compare2(a4[i4], b4[i4]))
        return false;
    return true;
  }
  function ensureAll(state, addrs) {
    let changed = false;
    for (let addr of addrs)
      if (ensureAddr(state, addr) & 1)
        changed = true;
    return changed;
  }
  function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map((p4) => addresses[p4.id]);
    let providerTypes = providers.map((p4) => p4.type);
    let dynamic = providerAddrs.filter((p4) => !(p4 & 1));
    let idx = addresses[facet.id] >> 1;
    function get(state) {
      let values = [];
      for (let i4 = 0; i4 < providerAddrs.length; i4++) {
        let value = getAddr(state, providerAddrs[i4]);
        if (providerTypes[i4] == 2)
          for (let val of value)
            values.push(val);
        else
          values.push(value);
      }
      return facet.combine(values);
    }
    return {
      create(state) {
        for (let addr of providerAddrs)
          ensureAddr(state, addr);
        state.values[idx] = get(state);
        return 1;
      },
      update(state, tr) {
        if (!ensureAll(state, dynamic))
          return 0;
        let value = get(state);
        if (facet.compare(value, state.values[idx]))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure(state, oldState) {
        let depChanged = ensureAll(state, providerAddrs);
        let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
        if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
          state.values[idx] = oldValue;
          return 0;
        }
        let value = get(state);
        if (facet.compare(value, oldValue)) {
          state.values[idx] = oldValue;
          return 0;
        }
        state.values[idx] = value;
        return 1;
      }
    };
  }
  var initField = /* @__PURE__ */ Facet.define({ static: true });
  var StateField = class _StateField {
    constructor(id2, createF, updateF, compareF, spec) {
      this.id = id2;
      this.createF = createF;
      this.updateF = updateF;
      this.compareF = compareF;
      this.spec = spec;
      this.provides = void 0;
    }
    /**
    Define a state field.
    */
    static define(config) {
      let field = new _StateField(nextID++, config.create, config.update, config.compare || ((a4, b4) => a4 === b4), config);
      if (config.provide)
        field.provides = config.provide(field);
      return field;
    }
    create(state) {
      let init = state.facet(initField).find((i4) => i4.field == this);
      return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
    }
    /**
    @internal
    */
    slot(addresses) {
      let idx = addresses[this.id] >> 1;
      return {
        create: (state) => {
          state.values[idx] = this.create(state);
          return 1;
        },
        update: (state, tr) => {
          let oldVal = state.values[idx];
          let value = this.updateF(oldVal, tr);
          if (this.compareF(oldVal, value))
            return 0;
          state.values[idx] = value;
          return 1;
        },
        reconfigure: (state, oldState) => {
          if (oldState.config.address[this.id] != null) {
            state.values[idx] = oldState.field(this);
            return 0;
          }
          state.values[idx] = this.create(state);
          return 1;
        }
      };
    }
    /**
    Returns an extension that enables this field and overrides the
    way it is initialized. Can be useful when you need to provide a
    non-default starting value for the field.
    */
    init(create) {
      return [this, initField.of({ field: this, create })];
    }
    /**
    State field instances can be used as
    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
    given state.
    */
    get extension() {
      return this;
    }
  };
  var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
  function prec(value) {
    return (ext) => new PrecExtension(ext, value);
  }
  var Prec = {
    /**
    The highest precedence level, for extensions that should end up
    near the start of the precedence ordering.
    */
    highest: /* @__PURE__ */ prec(Prec_.highest),
    /**
    A higher-than-default precedence, for extensions that should
    come before those with default precedence.
    */
    high: /* @__PURE__ */ prec(Prec_.high),
    /**
    The default precedence, which is also used for extensions
    without an explicit precedence.
    */
    default: /* @__PURE__ */ prec(Prec_.default),
    /**
    A lower-than-default precedence.
    */
    low: /* @__PURE__ */ prec(Prec_.low),
    /**
    The lowest precedence level. Meant for things that should end up
    near the end of the extension order.
    */
    lowest: /* @__PURE__ */ prec(Prec_.lowest)
  };
  var PrecExtension = class {
    constructor(inner, prec2) {
      this.inner = inner;
      this.prec = prec2;
    }
  };
  var Compartment = class _Compartment {
    /**
    Create an instance of this compartment to add to your [state
    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
    */
    of(ext) {
      return new CompartmentInstance(this, ext);
    }
    /**
    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
    reconfigures this compartment.
    */
    reconfigure(content2) {
      return _Compartment.reconfigure.of({ compartment: this, extension: content2 });
    }
    /**
    Get the current content of the compartment in the state, or
    `undefined` if it isn't present.
    */
    get(state) {
      return state.config.compartments.get(this);
    }
  };
  var CompartmentInstance = class {
    constructor(compartment, inner) {
      this.compartment = compartment;
      this.inner = inner;
    }
  };
  var Configuration = class _Configuration {
    constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
      this.base = base2;
      this.compartments = compartments;
      this.dynamicSlots = dynamicSlots;
      this.address = address;
      this.staticValues = staticValues;
      this.facets = facets;
      this.statusTemplate = [];
      while (this.statusTemplate.length < dynamicSlots.length)
        this.statusTemplate.push(
          0
          /* SlotStatus.Unresolved */
        );
    }
    staticFacet(facet) {
      let addr = this.address[facet.id];
      return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base2, compartments, oldState) {
      let fields = [];
      let facets = /* @__PURE__ */ Object.create(null);
      let newCompartments = /* @__PURE__ */ new Map();
      for (let ext of flatten(base2, compartments, newCompartments)) {
        if (ext instanceof StateField)
          fields.push(ext);
        else
          (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
      }
      let address = /* @__PURE__ */ Object.create(null);
      let staticValues = [];
      let dynamicSlots = [];
      for (let field of fields) {
        address[field.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a4) => field.slot(a4));
      }
      let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
      for (let id2 in facets) {
        let providers = facets[id2], facet = providers[0].facet;
        let oldProviders = oldFacets && oldFacets[id2] || [];
        if (providers.every(
          (p4) => p4.type == 0
          /* Provider.Static */
        )) {
          address[facet.id] = staticValues.length << 1 | 1;
          if (sameArray(oldProviders, providers)) {
            staticValues.push(oldState.facet(facet));
          } else {
            let value = facet.combine(providers.map((p4) => p4.value));
            staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
          }
        } else {
          for (let p4 of providers) {
            if (p4.type == 0) {
              address[p4.id] = staticValues.length << 1 | 1;
              staticValues.push(p4.value);
            } else {
              address[p4.id] = dynamicSlots.length << 1;
              dynamicSlots.push((a4) => p4.dynamicSlot(a4));
            }
          }
          address[facet.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a4) => dynamicFacetSlot(a4, facet, providers));
        }
      }
      let dynamic = dynamicSlots.map((f3) => f3(address));
      return new _Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
    }
  };
  function flatten(extension, compartments, newCompartments) {
    let result = [[], [], [], [], []];
    let seen = /* @__PURE__ */ new Map();
    function inner(ext, prec2) {
      let known = seen.get(ext);
      if (known != null) {
        if (known <= prec2)
          return;
        let found = result[known].indexOf(ext);
        if (found > -1)
          result[known].splice(found, 1);
        if (ext instanceof CompartmentInstance)
          newCompartments.delete(ext.compartment);
      }
      seen.set(ext, prec2);
      if (Array.isArray(ext)) {
        for (let e4 of ext)
          inner(e4, prec2);
      } else if (ext instanceof CompartmentInstance) {
        if (newCompartments.has(ext.compartment))
          throw new RangeError(`Duplicate use of compartment in extensions`);
        let content2 = compartments.get(ext.compartment) || ext.inner;
        newCompartments.set(ext.compartment, content2);
        inner(content2, prec2);
      } else if (ext instanceof PrecExtension) {
        inner(ext.inner, ext.prec);
      } else if (ext instanceof StateField) {
        result[prec2].push(ext);
        if (ext.provides)
          inner(ext.provides, prec2);
      } else if (ext instanceof FacetProvider) {
        result[prec2].push(ext);
        if (ext.facet.extensions)
          inner(ext.facet.extensions, Prec_.default);
      } else {
        let content2 = ext.extension;
        if (!content2)
          throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
        inner(content2, prec2);
      }
    }
    inner(extension, Prec_.default);
    return result.reduce((a4, b4) => a4.concat(b4));
  }
  function ensureAddr(state, addr) {
    if (addr & 1)
      return 2;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4)
      throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2)
      return status;
    state.status[idx] = 4;
    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
    return state.status[idx] = 2 | changed;
  }
  function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
  }
  var languageData = /* @__PURE__ */ Facet.define();
  var allowMultipleSelections = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((v3) => v3),
    static: true
  });
  var lineSeparator = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : void 0,
    static: true
  });
  var changeFilter = /* @__PURE__ */ Facet.define();
  var transactionFilter = /* @__PURE__ */ Facet.define();
  var transactionExtender = /* @__PURE__ */ Facet.define();
  var readOnly = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : false
  });
  var Annotation = class {
    /**
    @internal
    */
    constructor(type2, value) {
      this.type = type2;
      this.value = value;
    }
    /**
    Define a new type of annotation.
    */
    static define() {
      return new AnnotationType();
    }
  };
  var AnnotationType = class {
    /**
    Create an instance of this annotation.
    */
    of(value) {
      return new Annotation(this, value);
    }
  };
  var StateEffectType = class {
    /**
    @internal
    */
    constructor(map2) {
      this.map = map2;
    }
    /**
    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
    type.
    */
    of(value) {
      return new StateEffect(this, value);
    }
  };
  var StateEffect = class _StateEffect {
    /**
    @internal
    */
    constructor(type2, value) {
      this.type = type2;
      this.value = value;
    }
    /**
    Map this effect through a position mapping. Will return
    `undefined` when that ends up deleting the effect.
    */
    map(mapping) {
      let mapped = this.type.map(this.value, mapping);
      return mapped === void 0 ? void 0 : mapped == this.value ? this : new _StateEffect(this.type, mapped);
    }
    /**
    Tells you whether this effect object is of a given
    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
    */
    is(type2) {
      return this.type == type2;
    }
    /**
    Define a new effect type. The type parameter indicates the type
    of values that his effect holds. It should be a type that
    doesn't include `undefined`, since that is used in
    [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
    removed.
    */
    static define(spec = {}) {
      return new StateEffectType(spec.map || ((v3) => v3));
    }
    /**
    Map an array of effects through a change set.
    */
    static mapEffects(effects, mapping) {
      if (!effects.length)
        return effects;
      let result = [];
      for (let effect of effects) {
        let mapped = effect.map(mapping);
        if (mapped)
          result.push(mapped);
      }
      return result;
    }
  };
  StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
  StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
  var Transaction = class _Transaction {
    constructor(startState, changes, selection, effects, annotations, scrollIntoView2) {
      this.startState = startState;
      this.changes = changes;
      this.selection = selection;
      this.effects = effects;
      this.annotations = annotations;
      this.scrollIntoView = scrollIntoView2;
      this._doc = null;
      this._state = null;
      if (selection)
        checkSelection(selection, changes.newLength);
      if (!annotations.some((a4) => a4.type == _Transaction.time))
        this.annotations = annotations.concat(_Transaction.time.of(Date.now()));
    }
    /**
    @internal
    */
    static create(startState, changes, selection, effects, annotations, scrollIntoView2) {
      return new _Transaction(startState, changes, selection, effects, annotations, scrollIntoView2);
    }
    /**
    The new document produced by the transaction. Contrary to
    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
    force the entire new state to be computed right away, so it is
    recommended that [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
    when they need to look at the new document.
    */
    get newDoc() {
      return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    /**
    The new selection produced by the transaction. If
    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
    current selection through the changes made by the transaction.
    */
    get newSelection() {
      return this.selection || this.startState.selection.map(this.changes);
    }
    /**
    The new state created by the transaction. Computed on demand
    (but retained for subsequent access), so it is recommended not to
    access it in [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
    */
    get state() {
      if (!this._state)
        this.startState.applyTransaction(this);
      return this._state;
    }
    /**
    Get the value of the given annotation type, if any.
    */
    annotation(type2) {
      for (let ann of this.annotations)
        if (ann.type == type2)
          return ann.value;
      return void 0;
    }
    /**
    Indicates whether the transaction changed the document.
    */
    get docChanged() {
      return !this.changes.empty;
    }
    /**
    Indicates whether this transaction reconfigures the state
    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
    with a top-level configuration
    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
    */
    get reconfigured() {
      return this.startState.config != this.state.config;
    }
    /**
    Returns true if the transaction has a [user
    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
    or more specific than `event`. For example, if the transaction
    has `"select.pointer"` as user event, `"select"` and
    `"select.pointer"` will match it.
    */
    isUserEvent(event) {
      let e4 = this.annotation(_Transaction.userEvent);
      return !!(e4 && (e4 == event || e4.length > event.length && e4.slice(0, event.length) == event && e4[event.length] == "."));
    }
  };
  Transaction.time = /* @__PURE__ */ Annotation.define();
  Transaction.userEvent = /* @__PURE__ */ Annotation.define();
  Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
  Transaction.remote = /* @__PURE__ */ Annotation.define();
  function joinRanges(a4, b4) {
    let result = [];
    for (let iA = 0, iB = 0; ; ) {
      let from, to;
      if (iA < a4.length && (iB == b4.length || b4[iB] >= a4[iA])) {
        from = a4[iA++];
        to = a4[iA++];
      } else if (iB < b4.length) {
        from = b4[iB++];
        to = b4[iB++];
      } else
        return result;
      if (!result.length || result[result.length - 1] < from)
        result.push(from, to);
      else if (result[result.length - 1] < to)
        result[result.length - 1] = to;
    }
  }
  function mergeTransaction(a4, b4, sequential) {
    var _a2;
    let mapForA, mapForB, changes;
    if (sequential) {
      mapForA = b4.changes;
      mapForB = ChangeSet.empty(b4.changes.length);
      changes = a4.changes.compose(b4.changes);
    } else {
      mapForA = b4.changes.map(a4.changes);
      mapForB = a4.changes.mapDesc(b4.changes, true);
      changes = a4.changes.compose(mapForA);
    }
    return {
      changes,
      selection: b4.selection ? b4.selection.map(mapForB) : (_a2 = a4.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
      effects: StateEffect.mapEffects(a4.effects, mapForA).concat(StateEffect.mapEffects(b4.effects, mapForB)),
      annotations: a4.annotations.length ? a4.annotations.concat(b4.annotations) : b4.annotations,
      scrollIntoView: a4.scrollIntoView || b4.scrollIntoView
    };
  }
  function resolveTransactionInner(state, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
      annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
      changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
      selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
      effects: asArray(spec.effects),
      annotations,
      scrollIntoView: !!spec.scrollIntoView
    };
  }
  function resolveTransaction(state, specs, filter) {
    let s4 = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false)
      filter = false;
    for (let i4 = 1; i4 < specs.length; i4++) {
      if (specs[i4].filter === false)
        filter = false;
      let seq2 = !!specs[i4].sequential;
      s4 = mergeTransaction(s4, resolveTransactionInner(state, specs[i4], seq2 ? s4.changes.newLength : state.doc.length), seq2);
    }
    let tr = Transaction.create(state, s4.changes, s4.selection, s4.effects, s4.annotations, s4.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
  }
  function filterTransaction(tr) {
    let state = tr.startState;
    let result = true;
    for (let filter of state.facet(changeFilter)) {
      let value = filter(tr);
      if (value === false) {
        result = false;
        break;
      }
      if (Array.isArray(value))
        result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
      let changes, back;
      if (result === false) {
        back = tr.changes.invertedDesc;
        changes = ChangeSet.empty(state.doc.length);
      } else {
        let filtered = tr.changes.filter(result);
        changes = filtered.changes;
        back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
      }
      tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    let filters = state.facet(transactionFilter);
    for (let i4 = filters.length - 1; i4 >= 0; i4--) {
      let filtered = filters[i4](tr);
      if (filtered instanceof Transaction)
        tr = filtered;
      else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
        tr = filtered[0];
      else
        tr = resolveTransaction(state, asArray(filtered), false);
    }
    return tr;
  }
  function extendTransaction(tr) {
    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
    for (let i4 = extenders.length - 1; i4 >= 0; i4--) {
      let extension = extenders[i4](tr);
      if (extension && Object.keys(extension).length)
        spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
  }
  var none = [];
  function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [value];
  }
  var CharCategory = /* @__PURE__ */ function(CharCategory2) {
    CharCategory2[CharCategory2["Word"] = 0] = "Word";
    CharCategory2[CharCategory2["Space"] = 1] = "Space";
    CharCategory2[CharCategory2["Other"] = 2] = "Other";
    return CharCategory2;
  }(CharCategory || (CharCategory = {}));
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var wordChar;
  try {
    wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch (_2) {
  }
  function hasWordChar(str2) {
    if (wordChar)
      return wordChar.test(str2);
    for (let i4 = 0; i4 < str2.length; i4++) {
      let ch = str2[i4];
      if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
        return true;
    }
    return false;
  }
  function makeCategorizer(wordChars) {
    return (char) => {
      if (!/\S/.test(char))
        return CharCategory.Space;
      if (hasWordChar(char))
        return CharCategory.Word;
      for (let i4 = 0; i4 < wordChars.length; i4++)
        if (char.indexOf(wordChars[i4]) > -1)
          return CharCategory.Word;
      return CharCategory.Other;
    };
  }
  var EditorState = class _EditorState {
    constructor(config, doc2, selection, values, computeSlot, tr) {
      this.config = config;
      this.doc = doc2;
      this.selection = selection;
      this.values = values;
      this.status = config.statusTemplate.slice();
      this.computeSlot = computeSlot;
      if (tr)
        tr._state = this;
      for (let i4 = 0; i4 < this.config.dynamicSlots.length; i4++)
        ensureAddr(this, i4 << 1);
      this.computeSlot = null;
    }
    field(field, require2 = true) {
      let addr = this.config.address[field.id];
      if (addr == null) {
        if (require2)
          throw new RangeError("Field is not present in this state");
        return void 0;
      }
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    /**
    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
    can be passed. Unless
    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
    are assumed to start in the _current_ document (not the document
    produced by previous specs), and its
    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
    to the document created by its _own_ changes. The resulting
    transaction contains the combined effect of all the different
    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
    specs take precedence over earlier ones.
    */
    update(...specs) {
      return resolveTransaction(this, specs, true);
    }
    /**
    @internal
    */
    applyTransaction(tr) {
      let conf = this.config, { base: base2, compartments } = conf;
      for (let effect of tr.effects) {
        if (effect.is(Compartment.reconfigure)) {
          if (conf) {
            compartments = /* @__PURE__ */ new Map();
            conf.compartments.forEach((val, key) => compartments.set(key, val));
            conf = null;
          }
          compartments.set(effect.value.compartment, effect.value.extension);
        } else if (effect.is(StateEffect.reconfigure)) {
          conf = null;
          base2 = effect.value;
        } else if (effect.is(StateEffect.appendConfig)) {
          conf = null;
          base2 = asArray(base2).concat(effect.value);
        }
      }
      let startValues;
      if (!conf) {
        conf = Configuration.resolve(base2, compartments, this);
        let intermediateState = new _EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
        startValues = intermediateState.values;
      } else {
        startValues = tr.startState.values.slice();
      }
      let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
      new _EditorState(conf, tr.newDoc, selection, startValues, (state, slot) => slot.update(state, tr), tr);
    }
    /**
    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
    replaces every selection range with the given content.
    */
    replaceSelection(text) {
      if (typeof text == "string")
        text = this.toText(text);
      return this.changeByRange((range) => ({
        changes: { from: range.from, to: range.to, insert: text },
        range: EditorSelection.cursor(range.from + text.length)
      }));
    }
    /**
    Create a set of changes and a new selection by running the given
    function for each range in the active selection. The function
    can return an optional set of changes (in the coordinate space
    of the start document), plus an updated range (in the coordinate
    space of the document produced by the call's own changes). This
    method will merge all the changes and ranges into a single
    changeset and selection, and return it as a [transaction
    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
    */
    changeByRange(f3) {
      let sel = this.selection;
      let result1 = f3(sel.ranges[0]);
      let changes = this.changes(result1.changes), ranges = [result1.range];
      let effects = asArray(result1.effects);
      for (let i4 = 1; i4 < sel.ranges.length; i4++) {
        let result = f3(sel.ranges[i4]);
        let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
        for (let j2 = 0; j2 < i4; j2++)
          ranges[j2] = ranges[j2].map(newMapped);
        let mapBy = changes.mapDesc(newChanges, true);
        ranges.push(result.range.map(mapBy));
        changes = changes.compose(newMapped);
        effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
      }
      return {
        changes,
        selection: EditorSelection.create(ranges, sel.mainIndex),
        effects
      };
    }
    /**
    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
    description, taking the state's document length and line
    separator into account.
    */
    changes(spec = []) {
      if (spec instanceof ChangeSet)
        return spec;
      return ChangeSet.of(spec, this.doc.length, this.facet(_EditorState.lineSeparator));
    }
    /**
    Using the state's [line
    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
    */
    toText(string2) {
      return Text.of(string2.split(this.facet(_EditorState.lineSeparator) || DefaultSplit));
    }
    /**
    Return the given range of the document as a string.
    */
    sliceDoc(from = 0, to = this.doc.length) {
      return this.doc.sliceString(from, to, this.lineBreak);
    }
    /**
    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
    */
    facet(facet) {
      let addr = this.config.address[facet.id];
      if (addr == null)
        return facet.default;
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    /**
    Convert this state to a JSON-serializable object. When custom
    fields should be serialized, you can pass them in as an object
    mapping property names (in the resulting object, which should
    not use `doc` or `selection`) to fields.
    */
    toJSON(fields) {
      let result = {
        doc: this.sliceDoc(),
        selection: this.selection.toJSON()
      };
      if (fields)
        for (let prop in fields) {
          let value = fields[prop];
          if (value instanceof StateField && this.config.address[value.id] != null)
            result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
        }
      return result;
    }
    /**
    Deserialize a state from its JSON representation. When custom
    fields should be deserialized, pass the same object you passed
    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
    third argument.
    */
    static fromJSON(json2, config = {}, fields) {
      if (!json2 || typeof json2.doc != "string")
        throw new RangeError("Invalid JSON representation for EditorState");
      let fieldInit = [];
      if (fields)
        for (let prop in fields) {
          if (Object.prototype.hasOwnProperty.call(json2, prop)) {
            let field = fields[prop], value = json2[prop];
            fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
          }
        }
      return _EditorState.create({
        doc: json2.doc,
        selection: EditorSelection.fromJSON(json2.selection),
        extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
      });
    }
    /**
    Create a new state. You'll usually only need this when
    initializing an editor—updated states are created by applying
    transactions.
    */
    static create(config = {}) {
      let configuration = Configuration.resolve(config.extensions || [], /* @__PURE__ */ new Map());
      let doc2 = config.doc instanceof Text ? config.doc : Text.of((config.doc || "").split(configuration.staticFacet(_EditorState.lineSeparator) || DefaultSplit));
      let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);
      checkSelection(selection, doc2.length);
      if (!configuration.staticFacet(allowMultipleSelections))
        selection = selection.asSingle();
      return new _EditorState(configuration, doc2, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
    }
    /**
    The size (in columns) of a tab in the document, determined by
    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
    */
    get tabSize() {
      return this.facet(_EditorState.tabSize);
    }
    /**
    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
    string for this state.
    */
    get lineBreak() {
      return this.facet(_EditorState.lineSeparator) || "\n";
    }
    /**
    Returns true when the editor is
    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
    */
    get readOnly() {
      return this.facet(readOnly);
    }
    /**
    Look up a translation for the given phrase (via the
    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
    original string if no translation is found.
    
    If additional arguments are passed, they will be inserted in
    place of markers like `$1` (for the first value) and `$2`, etc.
    A single `$` is equivalent to `$1`, and `$$` will produce a
    literal dollar sign.
    */
    phrase(phrase, ...insert2) {
      for (let map2 of this.facet(_EditorState.phrases))
        if (Object.prototype.hasOwnProperty.call(map2, phrase)) {
          phrase = map2[phrase];
          break;
        }
      if (insert2.length)
        phrase = phrase.replace(/\$(\$|\d*)/g, (m3, i4) => {
          if (i4 == "$")
            return "$";
          let n4 = +(i4 || 1);
          return !n4 || n4 > insert2.length ? m3 : insert2[n4 - 1];
        });
      return phrase;
    }
    /**
    Find the values for a given language data field, provided by the
    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
    
    Examples of language data fields are...
    
    - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
      comment syntax.
    - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
      for providing language-specific completion sources.
    - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
      characters that should be considered part of words in this
      language.
    - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
      bracket closing behavior.
    */
    languageDataAt(name2, pos, side = -1) {
      let values = [];
      for (let provider of this.facet(languageData)) {
        for (let result of provider(this, pos, side)) {
          if (Object.prototype.hasOwnProperty.call(result, name2))
            values.push(result[name2]);
        }
      }
      return values;
    }
    /**
    Return a function that can categorize strings (expected to
    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
    into one of:
    
     - Word (contains an alphanumeric character or a character
       explicitly listed in the local language's `"wordChars"`
       language data, which should be a string)
     - Space (contains only whitespace)
     - Other (anything else)
    */
    charCategorizer(at) {
      return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    /**
    Find the word at the given position, meaning the range
    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
    around it. If no word characters are adjacent to the position,
    this returns null.
    */
    wordAt(pos) {
      let { text, from, length } = this.doc.lineAt(pos);
      let cat = this.charCategorizer(pos);
      let start = pos - from, end = pos - from;
      while (start > 0) {
        let prev = findClusterBreak(text, start, false);
        if (cat(text.slice(prev, start)) != CharCategory.Word)
          break;
        start = prev;
      }
      while (end < length) {
        let next = findClusterBreak(text, end);
        if (cat(text.slice(end, next)) != CharCategory.Word)
          break;
        end = next;
      }
      return start == end ? null : EditorSelection.range(start + from, end + from);
    }
  };
  EditorState.allowMultipleSelections = allowMultipleSelections;
  EditorState.tabSize = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : 4
  });
  EditorState.lineSeparator = lineSeparator;
  EditorState.readOnly = readOnly;
  EditorState.phrases = /* @__PURE__ */ Facet.define({
    compare(a4, b4) {
      let kA = Object.keys(a4), kB = Object.keys(b4);
      return kA.length == kB.length && kA.every((k2) => a4[k2] == b4[k2]);
    }
  });
  EditorState.languageData = languageData;
  EditorState.changeFilter = changeFilter;
  EditorState.transactionFilter = transactionFilter;
  EditorState.transactionExtender = transactionExtender;
  Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
  function combineConfig(configs, defaults2, combine = {}) {
    let result = {};
    for (let config of configs)
      for (let key of Object.keys(config)) {
        let value = config[key], current = result[key];
        if (current === void 0)
          result[key] = value;
        else if (current === value || value === void 0) ;
        else if (Object.hasOwnProperty.call(combine, key))
          result[key] = combine[key](current, value);
        else
          throw new Error("Config merge conflict for field " + key);
      }
    for (let key in defaults2)
      if (result[key] === void 0)
        result[key] = defaults2[key];
    return result;
  }
  var RangeValue = class {
    /**
    Compare this value with another value. Used when comparing
    rangesets. The default implementation compares by identity.
    Unless you are only creating a fixed number of unique instances
    of your value type, it is a good idea to implement this
    properly.
    */
    eq(other) {
      return this == other;
    }
    /**
    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
    */
    range(from, to = from) {
      return Range2.create(from, to, this);
    }
  };
  RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
  RangeValue.prototype.point = false;
  RangeValue.prototype.mapMode = MapMode.TrackDel;
  var Range2 = class _Range {
    constructor(from, to, value) {
      this.from = from;
      this.to = to;
      this.value = value;
    }
    /**
    @internal
    */
    static create(from, to, value) {
      return new _Range(from, to, value);
    }
  };
  function cmpRange(a4, b4) {
    return a4.from - b4.from || a4.value.startSide - b4.value.startSide;
  }
  var Chunk = class _Chunk {
    constructor(from, to, value, maxPoint) {
      this.from = from;
      this.to = to;
      this.value = value;
      this.maxPoint = maxPoint;
    }
    get length() {
      return this.to[this.to.length - 1];
    }
    // Find the index of the given position and side. Use the ranges'
    // `from` pos when `end == false`, `to` when `end == true`.
    findIndex(pos, side, end, startAt = 0) {
      let arr = end ? this.to : this.from;
      for (let lo = startAt, hi = arr.length; ; ) {
        if (lo == hi)
          return lo;
        let mid = lo + hi >> 1;
        let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
        if (mid == lo)
          return diff >= 0 ? lo : hi;
        if (diff >= 0)
          hi = mid;
        else
          lo = mid + 1;
      }
    }
    between(offset, from, to, f3) {
      for (let i4 = this.findIndex(from, -1e9, true), e4 = this.findIndex(to, 1e9, false, i4); i4 < e4; i4++)
        if (f3(this.from[i4] + offset, this.to[i4] + offset, this.value[i4]) === false)
          return false;
    }
    map(offset, changes) {
      let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
      for (let i4 = 0; i4 < this.value.length; i4++) {
        let val = this.value[i4], curFrom = this.from[i4] + offset, curTo = this.to[i4] + offset, newFrom, newTo;
        if (curFrom == curTo) {
          let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
          if (mapped == null)
            continue;
          newFrom = newTo = mapped;
          if (val.startSide != val.endSide) {
            newTo = changes.mapPos(curFrom, val.endSide);
            if (newTo < newFrom)
              continue;
          }
        } else {
          newFrom = changes.mapPos(curFrom, val.startSide);
          newTo = changes.mapPos(curTo, val.endSide);
          if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
            continue;
        }
        if ((newTo - newFrom || val.endSide - val.startSide) < 0)
          continue;
        if (newPos < 0)
          newPos = newFrom;
        if (val.point)
          maxPoint = Math.max(maxPoint, newTo - newFrom);
        value.push(val);
        from.push(newFrom - newPos);
        to.push(newTo - newPos);
      }
      return { mapped: value.length ? new _Chunk(from, to, value, maxPoint) : null, pos: newPos };
    }
  };
  var RangeSet = class _RangeSet {
    constructor(chunkPos, chunk, nextLayer, maxPoint) {
      this.chunkPos = chunkPos;
      this.chunk = chunk;
      this.nextLayer = nextLayer;
      this.maxPoint = maxPoint;
    }
    /**
    @internal
    */
    static create(chunkPos, chunk, nextLayer, maxPoint) {
      return new _RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    /**
    @internal
    */
    get length() {
      let last = this.chunk.length - 1;
      return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
    }
    /**
    The number of ranges in the set.
    */
    get size() {
      if (this.isEmpty)
        return 0;
      let size = this.nextLayer.size;
      for (let chunk of this.chunk)
        size += chunk.value.length;
      return size;
    }
    /**
    @internal
    */
    chunkEnd(index) {
      return this.chunkPos[index] + this.chunk[index].length;
    }
    /**
    Update the range set, optionally adding new ranges or filtering
    out existing ones.
    
    (Note: The type parameter is just there as a kludge to work
    around TypeScript variance issues that prevented `RangeSet<X>`
    from being a subtype of `RangeSet<Y>` when `X` is a subtype of
    `Y`.)
    */
    update(updateSpec) {
      let { add: add2 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
      let filter = updateSpec.filter;
      if (add2.length == 0 && !filter)
        return this;
      if (sort)
        add2 = add2.slice().sort(cmpRange);
      if (this.isEmpty)
        return add2.length ? _RangeSet.of(add2) : this;
      let cur = new LayerCursor(this, null, -1).goto(0), i4 = 0, spill = [];
      let builder = new RangeSetBuilder();
      while (cur.value || i4 < add2.length) {
        if (i4 < add2.length && (cur.from - add2[i4].from || cur.startSide - add2[i4].value.startSide) >= 0) {
          let range = add2[i4++];
          if (!builder.addInner(range.from, range.to, range.value))
            spill.push(range);
        } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i4 == add2.length || this.chunkEnd(cur.chunkIndex) < add2[i4].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
          cur.nextChunk();
        } else {
          if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
            if (!builder.addInner(cur.from, cur.to, cur.value))
              spill.push(Range2.create(cur.from, cur.to, cur.value));
          }
          cur.next();
        }
      }
      return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? _RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
    }
    /**
    Map this range set through a set of changes, return the new set.
    */
    map(changes) {
      if (changes.empty || this.isEmpty)
        return this;
      let chunks = [], chunkPos = [], maxPoint = -1;
      for (let i4 = 0; i4 < this.chunk.length; i4++) {
        let start = this.chunkPos[i4], chunk = this.chunk[i4];
        let touch = changes.touchesRange(start, start + chunk.length);
        if (touch === false) {
          maxPoint = Math.max(maxPoint, chunk.maxPoint);
          chunks.push(chunk);
          chunkPos.push(changes.mapPos(start));
        } else if (touch === true) {
          let { mapped, pos } = chunk.map(start, changes);
          if (mapped) {
            maxPoint = Math.max(maxPoint, mapped.maxPoint);
            chunks.push(mapped);
            chunkPos.push(pos);
          }
        }
      }
      let next = this.nextLayer.map(changes);
      return chunks.length == 0 ? next : new _RangeSet(chunkPos, chunks, next || _RangeSet.empty, maxPoint);
    }
    /**
    Iterate over the ranges that touch the region `from` to `to`,
    calling `f` for each. There is no guarantee that the ranges will
    be reported in any specific order. When the callback returns
    `false`, iteration stops.
    */
    between(from, to, f3) {
      if (this.isEmpty)
        return;
      for (let i4 = 0; i4 < this.chunk.length; i4++) {
        let start = this.chunkPos[i4], chunk = this.chunk[i4];
        if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f3) === false)
          return;
      }
      this.nextLayer.between(from, to, f3);
    }
    /**
    Iterate over the ranges in this set, in order, including all
    ranges that end at or after `from`.
    */
    iter(from = 0) {
      return HeapCursor.from([this]).goto(from);
    }
    /**
    @internal
    */
    get isEmpty() {
      return this.nextLayer == this;
    }
    /**
    Iterate over the ranges in a collection of sets, in order,
    starting from `from`.
    */
    static iter(sets, from = 0) {
      return HeapCursor.from(sets).goto(from);
    }
    /**
    Iterate over two groups of sets, calling methods on `comparator`
    to notify it of possible differences.
    */
    static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
      let a4 = oldSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
      let b4 = newSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
      let sharedChunks = findSharedChunks(a4, b4, textDiff);
      let sideA = new SpanCursor(a4, sharedChunks, minPointSize);
      let sideB = new SpanCursor(b4, sharedChunks, minPointSize);
      textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
      if (textDiff.empty && textDiff.length == 0)
        compare(sideA, 0, sideB, 0, 0, comparator);
    }
    /**
    Compare the contents of two groups of range sets, returning true
    if they are equivalent in the given range.
    */
    static eq(oldSets, newSets, from = 0, to) {
      if (to == null)
        to = 1e9 - 1;
      let a4 = oldSets.filter((set2) => !set2.isEmpty && newSets.indexOf(set2) < 0);
      let b4 = newSets.filter((set2) => !set2.isEmpty && oldSets.indexOf(set2) < 0);
      if (a4.length != b4.length)
        return false;
      if (!a4.length)
        return true;
      let sharedChunks = findSharedChunks(a4, b4);
      let sideA = new SpanCursor(a4, sharedChunks, 0).goto(from), sideB = new SpanCursor(b4, sharedChunks, 0).goto(from);
      for (; ; ) {
        if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
          return false;
        if (sideA.to > to)
          return true;
        sideA.next();
        sideB.next();
      }
    }
    /**
    Iterate over a group of range sets at the same time, notifying
    the iterator about the ranges covering every given piece of
    content. Returns the open count (see
    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
    of the iteration.
    */
    static spans(sets, from, to, iterator, minPointSize = -1) {
      let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
      let openRanges = cursor.openStart;
      for (; ; ) {
        let curTo = Math.min(cursor.to, to);
        if (cursor.point) {
          let active = cursor.activeForPoint(cursor.to);
          let openCount = cursor.pointFrom < from ? active.length + 1 : cursor.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
          iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
          openRanges = Math.min(cursor.openEnd(curTo), active.length);
        } else if (curTo > pos) {
          iterator.span(pos, curTo, cursor.active, openRanges);
          openRanges = cursor.openEnd(curTo);
        }
        if (cursor.to > to)
          return openRanges + (cursor.point && cursor.to > to ? 1 : 0);
        pos = cursor.to;
        cursor.next();
      }
    }
    /**
    Create a range set for the given range or array of ranges. By
    default, this expects the ranges to be _sorted_ (by start
    position and, if two start at the same position,
    `value.startSide`). You can pass `true` as second argument to
    cause the method to sort them.
    */
    static of(ranges, sort = false) {
      let build = new RangeSetBuilder();
      for (let range of ranges instanceof Range2 ? [ranges] : sort ? lazySort(ranges) : ranges)
        build.add(range.from, range.to, range.value);
      return build.finish();
    }
    /**
    Join an array of range sets into a single set.
    */
    static join(sets) {
      if (!sets.length)
        return _RangeSet.empty;
      let result = sets[sets.length - 1];
      for (let i4 = sets.length - 2; i4 >= 0; i4--) {
        for (let layer = sets[i4]; layer != _RangeSet.empty; layer = layer.nextLayer)
          result = new _RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));
      }
      return result;
    }
  };
  RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
  function lazySort(ranges) {
    if (ranges.length > 1)
      for (let prev = ranges[0], i4 = 1; i4 < ranges.length; i4++) {
        let cur = ranges[i4];
        if (cmpRange(prev, cur) > 0)
          return ranges.slice().sort(cmpRange);
        prev = cur;
      }
    return ranges;
  }
  RangeSet.empty.nextLayer = RangeSet.empty;
  var RangeSetBuilder = class _RangeSetBuilder {
    finishChunk(newArrays) {
      this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
      this.chunkPos.push(this.chunkStart);
      this.chunkStart = -1;
      this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
      this.maxPoint = -1;
      if (newArrays) {
        this.from = [];
        this.to = [];
        this.value = [];
      }
    }
    /**
    Create an empty builder.
    */
    constructor() {
      this.chunks = [];
      this.chunkPos = [];
      this.chunkStart = -1;
      this.last = null;
      this.lastFrom = -1e9;
      this.lastTo = -1e9;
      this.from = [];
      this.to = [];
      this.value = [];
      this.maxPoint = -1;
      this.setMaxPoint = -1;
      this.nextLayer = null;
    }
    /**
    Add a range. Ranges should be added in sorted (by `from` and
    `value.startSide`) order.
    */
    add(from, to, value) {
      if (!this.addInner(from, to, value))
        (this.nextLayer || (this.nextLayer = new _RangeSetBuilder())).add(from, to, value);
    }
    /**
    @internal
    */
    addInner(from, to, value) {
      let diff = from - this.lastTo || value.startSide - this.last.endSide;
      if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
        throw new Error("Ranges must be added sorted by `from` position and `startSide`");
      if (diff < 0)
        return false;
      if (this.from.length == 250)
        this.finishChunk(true);
      if (this.chunkStart < 0)
        this.chunkStart = from;
      this.from.push(from - this.chunkStart);
      this.to.push(to - this.chunkStart);
      this.last = value;
      this.lastFrom = from;
      this.lastTo = to;
      this.value.push(value);
      if (value.point)
        this.maxPoint = Math.max(this.maxPoint, to - from);
      return true;
    }
    /**
    @internal
    */
    addChunk(from, chunk) {
      if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
        return false;
      if (this.from.length)
        this.finishChunk(true);
      this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
      this.chunks.push(chunk);
      this.chunkPos.push(from);
      let last = chunk.value.length - 1;
      this.last = chunk.value[last];
      this.lastFrom = chunk.from[last] + from;
      this.lastTo = chunk.to[last] + from;
      return true;
    }
    /**
    Finish the range set. Returns the new set. The builder can't be
    used anymore after this has been called.
    */
    finish() {
      return this.finishInner(RangeSet.empty);
    }
    /**
    @internal
    */
    finishInner(next) {
      if (this.from.length)
        this.finishChunk(false);
      if (this.chunks.length == 0)
        return next;
      let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
      this.from = null;
      return result;
    }
  };
  function findSharedChunks(a4, b4, textDiff) {
    let inA = /* @__PURE__ */ new Map();
    for (let set2 of a4)
      for (let i4 = 0; i4 < set2.chunk.length; i4++)
        if (set2.chunk[i4].maxPoint <= 0)
          inA.set(set2.chunk[i4], set2.chunkPos[i4]);
    let shared = /* @__PURE__ */ new Set();
    for (let set2 of b4)
      for (let i4 = 0; i4 < set2.chunk.length; i4++) {
        let known = inA.get(set2.chunk[i4]);
        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set2.chunkPos[i4] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set2.chunk[i4].length)))
          shared.add(set2.chunk[i4]);
      }
    return shared;
  }
  var LayerCursor = class {
    constructor(layer, skip, minPoint, rank = 0) {
      this.layer = layer;
      this.skip = skip;
      this.minPoint = minPoint;
      this.rank = rank;
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    get endSide() {
      return this.value ? this.value.endSide : 0;
    }
    goto(pos, side = -1e9) {
      this.chunkIndex = this.rangeIndex = 0;
      this.gotoInner(pos, side, false);
      return this;
    }
    gotoInner(pos, side, forward) {
      while (this.chunkIndex < this.layer.chunk.length) {
        let next = this.layer.chunk[this.chunkIndex];
        if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
          break;
        this.chunkIndex++;
        forward = false;
      }
      if (this.chunkIndex < this.layer.chunk.length) {
        let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
        if (!forward || this.rangeIndex < rangeIndex)
          this.setRangeIndex(rangeIndex);
      }
      this.next();
    }
    forward(pos, side) {
      if ((this.to - pos || this.endSide - side) < 0)
        this.gotoInner(pos, side, true);
    }
    next() {
      for (; ; ) {
        if (this.chunkIndex == this.layer.chunk.length) {
          this.from = this.to = 1e9;
          this.value = null;
          break;
        } else {
          let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
          let from = chunkPos + chunk.from[this.rangeIndex];
          this.from = from;
          this.to = chunkPos + chunk.to[this.rangeIndex];
          this.value = chunk.value[this.rangeIndex];
          this.setRangeIndex(this.rangeIndex + 1);
          if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
            break;
        }
      }
    }
    setRangeIndex(index) {
      if (index == this.layer.chunk[this.chunkIndex].value.length) {
        this.chunkIndex++;
        if (this.skip) {
          while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
            this.chunkIndex++;
        }
        this.rangeIndex = 0;
      } else {
        this.rangeIndex = index;
      }
    }
    nextChunk() {
      this.chunkIndex++;
      this.rangeIndex = 0;
      this.next();
    }
    compare(other) {
      return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
    }
  };
  var HeapCursor = class _HeapCursor {
    constructor(heap) {
      this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
      let heap = [];
      for (let i4 = 0; i4 < sets.length; i4++) {
        for (let cur = sets[i4]; !cur.isEmpty; cur = cur.nextLayer) {
          if (cur.maxPoint >= minPoint)
            heap.push(new LayerCursor(cur, skip, minPoint, i4));
        }
      }
      return heap.length == 1 ? heap[0] : new _HeapCursor(heap);
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    goto(pos, side = -1e9) {
      for (let cur of this.heap)
        cur.goto(pos, side);
      for (let i4 = this.heap.length >> 1; i4 >= 0; i4--)
        heapBubble(this.heap, i4);
      this.next();
      return this;
    }
    forward(pos, side) {
      for (let cur of this.heap)
        cur.forward(pos, side);
      for (let i4 = this.heap.length >> 1; i4 >= 0; i4--)
        heapBubble(this.heap, i4);
      if ((this.to - pos || this.value.endSide - side) < 0)
        this.next();
    }
    next() {
      if (this.heap.length == 0) {
        this.from = this.to = 1e9;
        this.value = null;
        this.rank = -1;
      } else {
        let top2 = this.heap[0];
        this.from = top2.from;
        this.to = top2.to;
        this.value = top2.value;
        this.rank = top2.rank;
        if (top2.value)
          top2.next();
        heapBubble(this.heap, 0);
      }
    }
  };
  function heapBubble(heap, index) {
    for (let cur = heap[index]; ; ) {
      let childIndex = (index << 1) + 1;
      if (childIndex >= heap.length)
        break;
      let child = heap[childIndex];
      if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
        child = heap[childIndex + 1];
        childIndex++;
      }
      if (cur.compare(child) < 0)
        break;
      heap[childIndex] = cur;
      heap[index] = child;
      index = childIndex;
    }
  }
  var SpanCursor = class {
    constructor(sets, skip, minPoint) {
      this.minPoint = minPoint;
      this.active = [];
      this.activeTo = [];
      this.activeRank = [];
      this.minActive = -1;
      this.point = null;
      this.pointFrom = 0;
      this.pointRank = 0;
      this.to = -1e9;
      this.endSide = 0;
      this.openStart = -1;
      this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1e9) {
      this.cursor.goto(pos, side);
      this.active.length = this.activeTo.length = this.activeRank.length = 0;
      this.minActive = -1;
      this.to = pos;
      this.endSide = side;
      this.openStart = -1;
      this.next();
      return this;
    }
    forward(pos, side) {
      while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
        this.removeActive(this.minActive);
      this.cursor.forward(pos, side);
    }
    removeActive(index) {
      remove(this.active, index);
      remove(this.activeTo, index);
      remove(this.activeRank, index);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
      let i4 = 0, { value, to, rank } = this.cursor;
      while (i4 < this.activeRank.length && (rank - this.activeRank[i4] || to - this.activeTo[i4]) > 0)
        i4++;
      insert(this.active, i4, value);
      insert(this.activeTo, i4, to);
      insert(this.activeRank, i4, rank);
      if (trackOpen)
        insert(trackOpen, i4, this.cursor.from);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    // After calling this, if `this.point` != null, the next range is a
    // point. Otherwise, it's a regular range, covered by `this.active`.
    next() {
      let from = this.to, wasPoint = this.point;
      this.point = null;
      let trackOpen = this.openStart < 0 ? [] : null;
      for (; ; ) {
        let a4 = this.minActive;
        if (a4 > -1 && (this.activeTo[a4] - this.cursor.from || this.active[a4].endSide - this.cursor.startSide) < 0) {
          if (this.activeTo[a4] > from) {
            this.to = this.activeTo[a4];
            this.endSide = this.active[a4].endSide;
            break;
          }
          this.removeActive(a4);
          if (trackOpen)
            remove(trackOpen, a4);
        } else if (!this.cursor.value) {
          this.to = this.endSide = 1e9;
          break;
        } else if (this.cursor.from > from) {
          this.to = this.cursor.from;
          this.endSide = this.cursor.startSide;
          break;
        } else {
          let nextVal = this.cursor.value;
          if (!nextVal.point) {
            this.addActive(trackOpen);
            this.cursor.next();
          } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
            this.cursor.next();
          } else {
            this.point = nextVal;
            this.pointFrom = this.cursor.from;
            this.pointRank = this.cursor.rank;
            this.to = this.cursor.to;
            this.endSide = nextVal.endSide;
            this.cursor.next();
            this.forward(this.to, this.endSide);
            break;
          }
        }
      }
      if (trackOpen) {
        this.openStart = 0;
        for (let i4 = trackOpen.length - 1; i4 >= 0 && trackOpen[i4] < from; i4--)
          this.openStart++;
      }
    }
    activeForPoint(to) {
      if (!this.active.length)
        return this.active;
      let active = [];
      for (let i4 = this.active.length - 1; i4 >= 0; i4--) {
        if (this.activeRank[i4] < this.pointRank)
          break;
        if (this.activeTo[i4] > to || this.activeTo[i4] == to && this.active[i4].endSide >= this.point.endSide)
          active.push(this.active[i4]);
      }
      return active.reverse();
    }
    openEnd(to) {
      let open = 0;
      for (let i4 = this.activeTo.length - 1; i4 >= 0 && this.activeTo[i4] > to; i4--)
        open++;
      return open;
    }
  };
  function compare(a4, startA, b4, startB, length, comparator) {
    a4.goto(startA);
    b4.goto(startB);
    let endB = startB + length;
    let pos = startB, dPos = startB - startA;
    for (; ; ) {
      let diff = a4.to + dPos - b4.to || a4.endSide - b4.endSide;
      let end = diff < 0 ? a4.to + dPos : b4.to, clipEnd = Math.min(end, endB);
      if (a4.point || b4.point) {
        if (!(a4.point && b4.point && (a4.point == b4.point || a4.point.eq(b4.point)) && sameValues(a4.activeForPoint(a4.to), b4.activeForPoint(b4.to))))
          comparator.comparePoint(pos, clipEnd, a4.point, b4.point);
      } else {
        if (clipEnd > pos && !sameValues(a4.active, b4.active))
          comparator.compareRange(pos, clipEnd, a4.active, b4.active);
      }
      if (end > endB)
        break;
      pos = end;
      if (diff <= 0)
        a4.next();
      if (diff >= 0)
        b4.next();
    }
  }
  function sameValues(a4, b4) {
    if (a4.length != b4.length)
      return false;
    for (let i4 = 0; i4 < a4.length; i4++)
      if (a4[i4] != b4[i4] && !a4[i4].eq(b4[i4]))
        return false;
    return true;
  }
  function remove(array, index) {
    for (let i4 = index, e4 = array.length - 1; i4 < e4; i4++)
      array[i4] = array[i4 + 1];
    array.pop();
  }
  function insert(array, index, value) {
    for (let i4 = array.length - 1; i4 >= index; i4--)
      array[i4 + 1] = array[i4];
    array[index] = value;
  }
  function findMinIndex(value, array) {
    let found = -1, foundPos = 1e9;
    for (let i4 = 0; i4 < array.length; i4++)
      if ((array[i4] - foundPos || value[i4].endSide - value[found].endSide) < 0) {
        found = i4;
        foundPos = array[i4];
      }
    return found;
  }
  function countColumn(string2, tabSize, to = string2.length) {
    let n4 = 0;
    for (let i4 = 0; i4 < to; ) {
      if (string2.charCodeAt(i4) == 9) {
        n4 += tabSize - n4 % tabSize;
        i4++;
      } else {
        n4++;
        i4 = findClusterBreak(string2, i4);
      }
    }
    return n4;
  }
  function findColumn(string2, col, tabSize, strict) {
    for (let i4 = 0, n4 = 0; ; ) {
      if (n4 >= col)
        return i4;
      if (i4 == string2.length)
        break;
      n4 += string2.charCodeAt(i4) == 9 ? tabSize - n4 % tabSize : 1;
      i4 = findClusterBreak(string2, i4);
    }
    return strict === true ? -1 : string2.length;
  }

  // node_modules/.pnpm/style-mod@4.1.2/node_modules/style-mod/src/style-mod.js
  var C = "\u037C";
  var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
  var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
  var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
  var StyleModule = class {
    // :: (Object<Style>, ?{finish: ?(string) → string})
    // Create a style module from the given spec.
    //
    // When `finish` is given, it is called on regular (non-`@`)
    // selectors (after `&` expansion) to compute the final selector.
    constructor(spec, options) {
      this.rules = [];
      let { finish } = options || {};
      function splitSelector(selector) {
        return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
      }
      function render(selectors, spec2, target, isKeyframes) {
        let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
        if (isAt && spec2 == null) return target.push(selectors[0] + ";");
        for (let prop in spec2) {
          let value = spec2[prop];
          if (/&/.test(prop)) {
            render(
              prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a4, b4) => a4.concat(b4)),
              value,
              target
            );
          } else if (value && typeof value == "object") {
            if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
            render(splitSelector(prop), value, local, keyframes);
          } else if (value != null) {
            local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l4) => "-" + l4.toLowerCase()) + ": " + value + ";");
          }
        }
        if (local.length || keyframes) {
          target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
        }
      }
      for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);
    }
    // :: () → string
    // Returns a string containing the module's CSS rules.
    getRules() {
      return this.rules.join("\n");
    }
    // :: () → string
    // Generate a new unique CSS class name.
    static newName() {
      let id2 = top[COUNT] || 1;
      top[COUNT] = id2 + 1;
      return C + id2.toString(36);
    }
    // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
    //
    // Mount the given set of modules in the given DOM root, which ensures
    // that the CSS rules defined by the module are available in that
    // context.
    //
    // Rules are only added to the document once per root.
    //
    // Rule order will follow the order of the modules, so that rules from
    // modules later in the array take precedence of those from earlier
    // modules. If you call this function multiple times for the same root
    // in a way that changes the order of already mounted modules, the old
    // order will be changed.
    //
    // If a Content Security Policy nonce is provided, it is added to
    // the `<style>` tag generated by the library.
    static mount(root, modules, options) {
      let set2 = root[SET], nonce = options && options.nonce;
      if (!set2) set2 = new StyleSet(root, nonce);
      else if (nonce) set2.setNonce(nonce);
      set2.mount(Array.isArray(modules) ? modules : [modules], root);
    }
  };
  var adoptedSet = /* @__PURE__ */ new Map();
  var StyleSet = class {
    constructor(root, nonce) {
      let doc2 = root.ownerDocument || root, win = doc2.defaultView;
      if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
        let adopted = adoptedSet.get(doc2);
        if (adopted) return root[SET] = adopted;
        this.sheet = new win.CSSStyleSheet();
        adoptedSet.set(doc2, this);
      } else {
        this.styleTag = doc2.createElement("style");
        if (nonce) this.styleTag.setAttribute("nonce", nonce);
      }
      this.modules = [];
      root[SET] = this;
    }
    mount(modules, root) {
      let sheet = this.sheet;
      let pos = 0, j2 = 0;
      for (let i4 = 0; i4 < modules.length; i4++) {
        let mod = modules[i4], index = this.modules.indexOf(mod);
        if (index < j2 && index > -1) {
          this.modules.splice(index, 1);
          j2--;
          index = -1;
        }
        if (index == -1) {
          this.modules.splice(j2++, 0, mod);
          if (sheet) for (let k2 = 0; k2 < mod.rules.length; k2++)
            sheet.insertRule(mod.rules[k2], pos++);
        } else {
          while (j2 < index) pos += this.modules[j2++].rules.length;
          pos += mod.rules.length;
          j2++;
        }
      }
      if (sheet) {
        if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)
          root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];
      } else {
        let text = "";
        for (let i4 = 0; i4 < this.modules.length; i4++)
          text += this.modules[i4].getRules() + "\n";
        this.styleTag.textContent = text;
        let target = root.head || root;
        if (this.styleTag.parentNode != target)
          target.insertBefore(this.styleTag, target.firstChild);
      }
    }
    setNonce(nonce) {
      if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
        this.styleTag.setAttribute("nonce", nonce);
    }
  };

  // node_modules/.pnpm/w3c-keyname@2.2.8/node_modules/w3c-keyname/index.js
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  for (i4 = 0; i4 < 10; i4++) base[48 + i4] = base[96 + i4] = String(i4);
  var i4;
  for (i4 = 1; i4 <= 24; i4++) base[i4 + 111] = "F" + i4;
  var i4;
  for (i4 = 65; i4 <= 90; i4++) {
    base[i4] = String.fromCharCode(i4 + 32);
    shift[i4] = String.fromCharCode(i4);
  }
  var i4;
  for (code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
  var code;
  function keyName(event) {
    var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name2 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    if (name2 == "Esc") name2 = "Escape";
    if (name2 == "Del") name2 = "Delete";
    if (name2 == "Left") name2 = "ArrowLeft";
    if (name2 == "Up") name2 = "ArrowUp";
    if (name2 == "Right") name2 = "ArrowRight";
    if (name2 == "Down") name2 = "ArrowDown";
    return name2;
  }

  // node_modules/.pnpm/@codemirror+view@6.28.1/node_modules/@codemirror/view/dist/index.js
  function getSelection(root) {
    let target;
    if (root.nodeType == 11) {
      target = root.getSelection ? root : root.ownerDocument;
    } else {
      target = root;
    }
    return target.getSelection();
  }
  function contains(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
  }
  function deepActiveElement(doc2) {
    let elt = doc2.activeElement;
    while (elt && elt.shadowRoot)
      elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function hasSelection(dom, selection) {
    if (!selection.anchorNode)
      return false;
    try {
      return contains(dom, selection.anchorNode);
    } catch (_2) {
      return false;
    }
  }
  function clientRectsFor(dom) {
    if (dom.nodeType == 3)
      return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
      return dom.getClientRects();
    else
      return [];
  }
  function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
  }
  function domIndex(node) {
    for (var index = 0; ; index++) {
      node = node.previousSibling;
      if (!node)
        return index;
    }
  }
  function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
  }
  function scanFor(node, off, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node == targetNode && off == targetOff)
        return true;
      if (off == (dir < 0 ? 0 : maxOffset(node))) {
        if (node.nodeName == "DIV")
          return false;
        let parent = node.parentNode;
        if (!parent || parent.nodeType != 1)
          return false;
        off = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node.nodeType == 1 && node.contentEditable == "false")
          return false;
        off = dir < 0 ? maxOffset(node) : 0;
      } else {
        return false;
      }
    }
  }
  function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  function flattenRect(rect, left) {
    let x2 = left ? rect.left : rect.right;
    return { left: x2, right: x2, top: rect.top, bottom: rect.bottom };
  }
  function windowRect(win) {
    let vp = win.visualViewport;
    if (vp)
      return {
        left: 0,
        right: vp.width,
        top: 0,
        bottom: vp.height
      };
    return {
      left: 0,
      right: win.innerWidth,
      top: 0,
      bottom: win.innerHeight
    };
  }
  function getScale(elt, rect) {
    let scaleX = rect.width / elt.offsetWidth;
    let scaleY = rect.height / elt.offsetHeight;
    if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1)
      scaleX = 1;
    if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1)
      scaleY = 1;
    return { scaleX, scaleY };
  }
  function scrollRectIntoView(dom, rect, side, x2, y3, xMargin, yMargin, ltr) {
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    for (let cur = dom, stop = false; cur && !stop; ) {
      if (cur.nodeType == 1) {
        let bounding, top2 = cur == doc2.body;
        let scaleX = 1, scaleY = 1;
        if (top2) {
          bounding = windowRect(win);
        } else {
          if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position))
            stop = true;
          if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
            cur = cur.assignedSlot || cur.parentNode;
            continue;
          }
          let rect2 = cur.getBoundingClientRect();
          ({ scaleX, scaleY } = getScale(cur, rect2));
          bounding = {
            left: rect2.left,
            right: rect2.left + cur.clientWidth * scaleX,
            top: rect2.top,
            bottom: rect2.top + cur.clientHeight * scaleY
          };
        }
        let moveX = 0, moveY = 0;
        if (y3 == "nearest") {
          if (rect.top < bounding.top) {
            moveY = -(bounding.top - rect.top + yMargin);
            if (side > 0 && rect.bottom > bounding.bottom + moveY)
              moveY = rect.bottom - bounding.bottom + moveY + yMargin;
          } else if (rect.bottom > bounding.bottom) {
            moveY = rect.bottom - bounding.bottom + yMargin;
            if (side < 0 && rect.top - moveY < bounding.top)
              moveY = -(bounding.top + moveY - rect.top + yMargin);
          }
        } else {
          let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
          let targetTop = y3 == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y3 == "start" || y3 == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
          moveY = targetTop - bounding.top;
        }
        if (x2 == "nearest") {
          if (rect.left < bounding.left) {
            moveX = -(bounding.left - rect.left + xMargin);
            if (side > 0 && rect.right > bounding.right + moveX)
              moveX = rect.right - bounding.right + moveX + xMargin;
          } else if (rect.right > bounding.right) {
            moveX = rect.right - bounding.right + xMargin;
            if (side < 0 && rect.left < bounding.left + moveX)
              moveX = -(bounding.left + moveX - rect.left + xMargin);
          }
        } else {
          let targetLeft = x2 == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x2 == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
          moveX = targetLeft - bounding.left;
        }
        if (moveX || moveY) {
          if (top2) {
            win.scrollBy(moveX, moveY);
          } else {
            let movedX = 0, movedY = 0;
            if (moveY) {
              let start = cur.scrollTop;
              cur.scrollTop += moveY / scaleY;
              movedY = (cur.scrollTop - start) * scaleY;
            }
            if (moveX) {
              let start = cur.scrollLeft;
              cur.scrollLeft += moveX / scaleX;
              movedX = (cur.scrollLeft - start) * scaleX;
            }
            rect = {
              left: rect.left - movedX,
              top: rect.top - movedY,
              right: rect.right - movedX,
              bottom: rect.bottom - movedY
            };
            if (movedX && Math.abs(movedX - moveX) < 1)
              x2 = "nearest";
            if (movedY && Math.abs(movedY - moveY) < 1)
              y3 = "nearest";
          }
        }
        if (top2)
          break;
        cur = cur.assignedSlot || cur.parentNode;
      } else if (cur.nodeType == 11) {
        cur = cur.host;
      } else {
        break;
      }
    }
  }
  function scrollableParent(dom) {
    let doc2 = dom.ownerDocument;
    for (let cur = dom.parentNode; cur; ) {
      if (cur == doc2.body) {
        break;
      } else if (cur.nodeType == 1) {
        if (cur.scrollHeight > cur.clientHeight || cur.scrollWidth > cur.clientWidth)
          return cur;
        cur = cur.assignedSlot || cur.parentNode;
      } else if (cur.nodeType == 11) {
        cur = cur.host;
      } else {
        break;
      }
    }
    return null;
  }
  var DOMSelectionState = class {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    eq(domSel) {
      return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range) {
      let { anchorNode, focusNode } = range;
      this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
      this.anchorNode = anchorNode;
      this.anchorOffset = anchorOffset;
      this.focusNode = focusNode;
      this.focusOffset = focusOffset;
    }
  };
  var preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive)
      return dom.setActive();
    if (preventScrollSupported)
      return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur = dom; cur; cur = cur.parentNode) {
      stack.push(cur, cur.scrollTop, cur.scrollLeft);
      if (cur == cur.ownerDocument)
        break;
    }
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      for (let i4 = 0; i4 < stack.length; ) {
        let elt = stack[i4++], top2 = stack[i4++], left = stack[i4++];
        if (elt.scrollTop != top2)
          elt.scrollTop = top2;
        if (elt.scrollLeft != left)
          elt.scrollLeft = left;
      }
    }
  }
  var scratchRange;
  function textRange(node, from, to = from) {
    let range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
  }
  function dispatchKey(elt, name2, code, mods) {
    let options = { key: name2, code: name2, keyCode: code, which: code, cancelable: true };
    if (mods)
      ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
  }
  function getRoot(node) {
    while (node) {
      if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
        return node;
      node = node.assignedSlot || node.parentNode;
    }
    return null;
  }
  function clearAttributes(node) {
    while (node.attributes.length)
      node.removeAttributeNode(node.attributes[0]);
  }
  function atElementStart(doc2, selection) {
    let node = selection.focusNode, offset = selection.focusOffset;
    if (!node || selection.anchorNode != node || selection.anchorOffset != offset)
      return false;
    offset = Math.min(offset, maxOffset(node));
    for (; ; ) {
      if (offset) {
        if (node.nodeType != 1)
          return false;
        let prev = node.childNodes[offset - 1];
        if (prev.contentEditable == "false")
          offset--;
        else {
          node = prev;
          offset = maxOffset(node);
        }
      } else if (node == doc2) {
        return true;
      } else {
        offset = domIndex(node);
        node = node.parentNode;
      }
    }
  }
  function isScrolledToBottom(elt) {
    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
  }
  function textNodeBefore(startNode, startOffset) {
    for (let node = startNode, offset = startOffset; ; ) {
      if (node.nodeType == 3 && offset > 0) {
        return { node, offset };
      } else if (node.nodeType == 1 && offset > 0) {
        if (node.contentEditable == "false")
          return null;
        node = node.childNodes[offset - 1];
        offset = maxOffset(node);
      } else if (node.parentNode && !isBlockElement(node)) {
        offset = domIndex(node);
        node = node.parentNode;
      } else {
        return null;
      }
    }
  }
  function textNodeAfter(startNode, startOffset) {
    for (let node = startNode, offset = startOffset; ; ) {
      if (node.nodeType == 3 && offset < node.nodeValue.length) {
        return { node, offset };
      } else if (node.nodeType == 1 && offset < node.childNodes.length) {
        if (node.contentEditable == "false")
          return null;
        node = node.childNodes[offset];
        offset = 0;
      } else if (node.parentNode && !isBlockElement(node)) {
        offset = domIndex(node) + 1;
        node = node.parentNode;
      } else {
        return null;
      }
    }
  }
  var DOMPos = class _DOMPos {
    constructor(node, offset, precise = true) {
      this.node = node;
      this.offset = offset;
      this.precise = precise;
    }
    static before(dom, precise) {
      return new _DOMPos(dom.parentNode, domIndex(dom), precise);
    }
    static after(dom, precise) {
      return new _DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
    }
  };
  var noChildren = [];
  var ContentView = class _ContentView {
    constructor() {
      this.parent = null;
      this.dom = null;
      this.flags = 2;
    }
    get overrideDOMText() {
      return null;
    }
    get posAtStart() {
      return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
      return this.posAtStart + this.length;
    }
    posBefore(view) {
      let pos = this.posAtStart;
      for (let child of this.children) {
        if (child == view)
          return pos;
        pos += child.length + child.breakAfter;
      }
      throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
      return this.posBefore(view) + view.length;
    }
    sync(view, track) {
      if (this.flags & 2) {
        let parent = this.dom;
        let prev = null, next;
        for (let child of this.children) {
          if (child.flags & 7) {
            if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
              let contentView = _ContentView.get(next);
              if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                child.reuseDOM(next);
            }
            child.sync(view, track);
            child.flags &= ~7;
          }
          next = prev ? prev.nextSibling : parent.firstChild;
          if (track && !track.written && track.node == parent && next != child.dom)
            track.written = true;
          if (child.dom.parentNode == parent) {
            while (next && next != child.dom)
              next = rm$1(next);
          } else {
            parent.insertBefore(child.dom, next);
          }
          prev = child.dom;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (next && track && track.node == parent)
          track.written = true;
        while (next)
          next = rm$1(next);
      } else if (this.flags & 1) {
        for (let child of this.children)
          if (child.flags & 7) {
            child.sync(view, track);
            child.flags &= ~7;
          }
      }
    }
    reuseDOM(_dom) {
    }
    localPosFromDOM(node, offset) {
      let after;
      if (node == this.dom) {
        after = this.dom.childNodes[offset];
      } else {
        let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
        for (; ; ) {
          let parent = node.parentNode;
          if (parent == this.dom)
            break;
          if (bias == 0 && parent.firstChild != parent.lastChild) {
            if (node == parent.firstChild)
              bias = -1;
            else
              bias = 1;
          }
          node = parent;
        }
        if (bias < 0)
          after = node;
        else
          after = node.nextSibling;
      }
      if (after == this.dom.firstChild)
        return 0;
      while (after && !_ContentView.get(after))
        after = after.nextSibling;
      if (!after)
        return this.length;
      for (let i4 = 0, pos = 0; ; i4++) {
        let child = this.children[i4];
        if (child.dom == after)
          return pos;
        pos += child.length + child.breakAfter;
      }
    }
    domBoundsAround(from, to, offset = 0) {
      let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
      for (let i4 = 0, pos = offset, prevEnd = offset; i4 < this.children.length; i4++) {
        let child = this.children[i4], end = pos + child.length;
        if (pos < from && end > to)
          return child.domBoundsAround(from, to, pos);
        if (end >= from && fromI == -1) {
          fromI = i4;
          fromStart = pos;
        }
        if (pos > to && child.dom.parentNode == this.dom) {
          toI = i4;
          toEnd = prevEnd;
          break;
        }
        prevEnd = end;
        pos = end + child.breakAfter;
      }
      return {
        from: fromStart,
        to: toEnd < 0 ? offset + this.length : toEnd,
        startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
        endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
      };
    }
    markDirty(andParent = false) {
      this.flags |= 2;
      this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
      for (let parent = this.parent; parent; parent = parent.parent) {
        if (childList)
          parent.flags |= 2;
        if (parent.flags & 1)
          return;
        parent.flags |= 1;
        childList = false;
      }
    }
    setParent(parent) {
      if (this.parent != parent) {
        this.parent = parent;
        if (this.flags & 7)
          this.markParentsDirty(true);
      }
    }
    setDOM(dom) {
      if (this.dom == dom)
        return;
      if (this.dom)
        this.dom.cmView = null;
      this.dom = dom;
      dom.cmView = this;
    }
    get rootView() {
      for (let v3 = this; ; ) {
        let parent = v3.parent;
        if (!parent)
          return v3;
        v3 = parent;
      }
    }
    replaceChildren(from, to, children = noChildren) {
      this.markDirty();
      for (let i4 = from; i4 < to; i4++) {
        let child = this.children[i4];
        if (child.parent == this && children.indexOf(child) < 0)
          child.destroy();
      }
      this.children.splice(from, to - from, ...children);
      for (let i4 = 0; i4 < children.length; i4++)
        children[i4].setParent(this);
    }
    ignoreMutation(_rec) {
      return false;
    }
    ignoreEvent(_event) {
      return false;
    }
    childCursor(pos = this.length) {
      return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
      return this.childCursor().findPos(pos, bias);
    }
    toString() {
      let name2 = this.constructor.name.replace("View", "");
      return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
    }
    static get(node) {
      return node.cmView;
    }
    get isEditable() {
      return true;
    }
    get isWidget() {
      return false;
    }
    get isHidden() {
      return false;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
      return false;
    }
    become(other) {
      return false;
    }
    canReuseDOM(other) {
      return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
    }
    // When this is a zero-length view with a side, this should return a
    // number <= 0 to indicate it is before its position, or a
    // number > 0 when after its position.
    getSide() {
      return 0;
    }
    destroy() {
      for (let child of this.children)
        if (child.parent == this)
          child.destroy();
      this.parent = null;
    }
  };
  ContentView.prototype.breakAfter = 0;
  function rm$1(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  var ChildCursor = class {
    constructor(children, pos, i4) {
      this.children = children;
      this.pos = pos;
      this.i = i4;
      this.off = 0;
    }
    findPos(pos, bias = 1) {
      for (; ; ) {
        if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
          this.off = pos - this.pos;
          return this;
        }
        let next = this.children[--this.i];
        this.pos -= next.length + next.breakAfter;
      }
    }
  };
  function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
    let { children } = parent;
    let before = children.length ? children[fromI] : null;
    let last = insert2.length ? insert2[insert2.length - 1] : null;
    let breakAtEnd = last ? last.breakAfter : breakAtStart;
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last : null, fromOff == 0, openStart, openEnd))
      return;
    if (toI < children.length) {
      let after = children[toI];
      if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {
        if (fromI == toI) {
          after = after.split(toOff);
          toOff = 0;
        }
        if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
          insert2[insert2.length - 1] = after;
        } else {
          if (toOff || after.children.length && !after.children[0].length)
            after.merge(0, toOff, null, false, 0, openEnd);
          insert2.push(after);
        }
      } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
        if (last)
          last.breakAfter = 1;
        else
          breakAtStart = 1;
      }
      toI++;
    }
    if (before) {
      before.breakAfter = breakAtStart;
      if (fromOff > 0) {
        if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
          before.breakAfter = insert2.shift().breakAfter;
        } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
          before.merge(fromOff, before.length, null, false, openStart, 0);
        }
        fromI++;
      }
    }
    while (fromI < toI && insert2.length) {
      if (children[toI - 1].become(insert2[insert2.length - 1])) {
        toI--;
        insert2.pop();
        openEnd = insert2.length ? 0 : openStart;
      } else if (children[fromI].become(insert2[0])) {
        fromI++;
        insert2.shift();
        openStart = insert2.length ? 0 : openEnd;
      } else {
        break;
      }
    }
    if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
      fromI--;
    if (fromI < toI || insert2.length)
      parent.replaceChildren(fromI, toI, insert2);
  }
  function mergeChildrenInto(parent, from, to, insert2, openStart, openEnd) {
    let cur = parent.childCursor();
    let { i: toI, off: toOff } = cur.findPos(to, 1);
    let { i: fromI, off: fromOff } = cur.findPos(from, -1);
    let dLen = from - to;
    for (let view of insert2)
      dLen += view.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
  }
  var nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
  var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
  var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
  var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
  var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
  var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
  var gecko = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
  var chrome = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
  var webkit = "webkitFontSmoothing" in doc.documentElement.style;
  var safari = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
  var ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
  var browser2 = {
    mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
    windows: /* @__PURE__ */ /Win/.test(nav.platform),
    linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
    ie: ie2,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko,
    gecko_version: gecko ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome,
    chrome_version: chrome ? +chrome[1] : 0,
    ios,
    android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
  };
  var MaxJoinLen = 256;
  var TextView = class _TextView extends ContentView {
    constructor(text) {
      super();
      this.text = text;
    }
    get length() {
      return this.text.length;
    }
    createDOM(textDOM) {
      this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(view, track) {
      if (!this.dom)
        this.createDOM();
      if (this.dom.nodeValue != this.text) {
        if (track && track.node == this.dom)
          track.written = true;
        this.dom.nodeValue = this.text;
      }
    }
    reuseDOM(dom) {
      if (dom.nodeType == 3)
        this.createDOM(dom);
    }
    merge(from, to, source) {
      if (this.flags & 8 || source && (!(source instanceof _TextView) || this.length - (to - from) + source.length > MaxJoinLen || source.flags & 8))
        return false;
      this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = new _TextView(this.text.slice(from));
      this.text = this.text.slice(0, from);
      this.markDirty();
      result.flags |= this.flags & 8;
      return result;
    }
    localPosFromDOM(node, offset) {
      return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) {
      return new DOMPos(this.dom, pos);
    }
    domBoundsAround(_from, _to, offset) {
      return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
      return textCoords(this.dom, pos, side);
    }
  };
  var MarkView = class _MarkView extends ContentView {
    constructor(mark, children = [], length = 0) {
      super();
      this.mark = mark;
      this.children = children;
      this.length = length;
      for (let ch of children)
        ch.setParent(this);
    }
    setAttrs(dom) {
      clearAttributes(dom);
      if (this.mark.class)
        dom.className = this.mark.class;
      if (this.mark.attrs)
        for (let name2 in this.mark.attrs)
          dom.setAttribute(name2, this.mark.attrs[name2]);
      return dom;
    }
    canReuseDOM(other) {
      return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
    }
    reuseDOM(node) {
      if (node.nodeName == this.mark.tagName.toUpperCase()) {
        this.setDOM(node);
        this.flags |= 4 | 2;
      }
    }
    sync(view, track) {
      if (!this.dom)
        this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
      else if (this.flags & 4)
        this.setAttrs(this.dom);
      super.sync(view, track);
    }
    merge(from, to, source, _hasStart, openStart, openEnd) {
      if (source && (!(source instanceof _MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = [], off = 0, detachFrom = -1, i4 = 0;
      for (let elt of this.children) {
        let end = off + elt.length;
        if (end > from)
          result.push(off < from ? elt.split(from - off) : elt);
        if (detachFrom < 0 && off >= from)
          detachFrom = i4;
        off = end;
        i4++;
      }
      let length = this.length - from;
      this.length = from;
      if (detachFrom > -1) {
        this.children.length = detachFrom;
        this.markDirty();
      }
      return new _MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
  };
  function textCoords(text, pos, side) {
    let length = text.nodeValue.length;
    if (pos > length)
      pos = length;
    let from = pos, to = pos, flatten2 = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
      if (!(browser2.chrome || browser2.gecko)) {
        if (pos) {
          from--;
          flatten2 = 1;
        } else if (to < length) {
          to++;
          flatten2 = -1;
        }
      }
    } else {
      if (side < 0)
        from--;
      else if (to < length)
        to++;
    }
    let rects = textRange(text, from, to).getClientRects();
    if (!rects.length)
      return null;
    let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser2.safari && !flatten2 && rect.width == 0)
      rect = Array.prototype.find.call(rects, (r3) => r3.width) || rect;
    return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
  }
  var WidgetView = class _WidgetView extends ContentView {
    static create(widget, length, side) {
      return new _WidgetView(widget, length, side);
    }
    constructor(widget, length, side) {
      super();
      this.widget = widget;
      this.length = length;
      this.side = side;
      this.prevWidget = null;
    }
    split(from) {
      let result = _WidgetView.create(this.widget, this.length - from, this.side);
      this.length -= from;
      return result;
    }
    sync(view) {
      if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(view));
        if (!this.widget.editable)
          this.dom.contentEditable = "false";
      }
    }
    getSide() {
      return this.side;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
      if (source && (!(source instanceof _WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from + (source ? source.length : 0) + (this.length - to);
      return true;
    }
    become(other) {
      if (other instanceof _WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
        if (!this.widget.compare(other.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    get overrideDOMText() {
      if (this.length == 0)
        return Text.empty;
      let top2 = this;
      while (top2.parent)
        top2 = top2.parent;
      let { view } = top2, text = view && view.state.doc, start = this.posAtStart;
      return text ? text.slice(start, start + this.length) : Text.empty;
    }
    domAtPos(pos) {
      return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos, side) {
      let custom2 = this.widget.coordsAt(this.dom, pos, side);
      if (custom2)
        return custom2;
      let rects = this.dom.getClientRects(), rect = null;
      if (!rects.length)
        return null;
      let fromBack = this.side ? this.side < 0 : pos > 0;
      for (let i4 = fromBack ? rects.length - 1 : 0; ; i4 += fromBack ? -1 : 1) {
        rect = rects[i4];
        if (pos > 0 ? i4 == 0 : i4 == rects.length - 1 || rect.top < rect.bottom)
          break;
      }
      return flattenRect(rect, !fromBack);
    }
    get isEditable() {
      return false;
    }
    get isWidget() {
      return true;
    }
    get isHidden() {
      return this.widget.isHidden;
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var WidgetBufferView = class _WidgetBufferView extends ContentView {
    constructor(side) {
      super();
      this.side = side;
    }
    get length() {
      return 0;
    }
    merge() {
      return false;
    }
    become(other) {
      return other instanceof _WidgetBufferView && other.side == this.side;
    }
    split() {
      return new _WidgetBufferView(this.side);
    }
    sync() {
      if (!this.dom) {
        let dom = document.createElement("img");
        dom.className = "cm-widgetBuffer";
        dom.setAttribute("aria-hidden", "true");
        this.setDOM(dom);
      }
    }
    getSide() {
      return this.side;
    }
    domAtPos(pos) {
      return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
    }
    localPosFromDOM() {
      return 0;
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos) {
      return this.dom.getBoundingClientRect();
    }
    get overrideDOMText() {
      return Text.empty;
    }
    get isHidden() {
      return true;
    }
  };
  TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
  function inlineDOMAtPos(parent, pos) {
    let dom = parent.dom, { children } = parent, i4 = 0;
    for (let off = 0; i4 < children.length; i4++) {
      let child = children[i4], end = off + child.length;
      if (end == off && child.getSide() <= 0)
        continue;
      if (pos > off && pos < end && child.dom.parentNode == dom)
        return child.domAtPos(pos - off);
      if (pos <= off)
        break;
      off = end;
    }
    for (let j2 = i4; j2 > 0; j2--) {
      let prev = children[j2 - 1];
      if (prev.dom.parentNode == dom)
        return prev.domAtPos(prev.length);
    }
    for (let j2 = i4; j2 < children.length; j2++) {
      let next = children[j2];
      if (next.dom.parentNode == dom)
        return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
  }
  function joinInlineInto(parent, view, open) {
    let last, { children } = parent;
    if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
      joinInlineInto(last, view.children[0], open - 1);
    } else {
      children.push(view);
      view.setParent(parent);
    }
    parent.length += view.length;
  }
  function coordsInChildren(view, pos, side) {
    let before = null, beforePos = -1, after = null, afterPos = -1;
    function scan(view2, pos2) {
      for (let i4 = 0, off = 0; i4 < view2.children.length && off <= pos2; i4++) {
        let child = view2.children[i4], end = off + child.length;
        if (end >= pos2) {
          if (child.children.length) {
            scan(child, pos2 - off);
          } else if ((!after || after.isHidden && side > 0) && (end > pos2 || off == end && child.getSide() > 0)) {
            after = child;
            afterPos = pos2 - off;
          } else if (off < pos2 || off == end && child.getSide() < 0 && !child.isHidden) {
            before = child;
            beforePos = pos2 - off;
          }
        }
        off = end;
      }
    }
    scan(view, pos);
    let target = (side < 0 ? before : after) || before || after;
    if (target)
      return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
    return fallbackRect(view);
  }
  function fallbackRect(view) {
    let last = view.dom.lastChild;
    if (!last)
      return view.dom.getBoundingClientRect();
    let rects = clientRectsFor(last);
    return rects[rects.length - 1] || null;
  }
  function combineAttrs(source, target) {
    for (let name2 in source) {
      if (name2 == "class" && target.class)
        target.class += " " + source.class;
      else if (name2 == "style" && target.style)
        target.style += ";" + source.style;
      else
        target[name2] = source[name2];
    }
    return target;
  }
  var noAttrs = /* @__PURE__ */ Object.create(null);
  function attrsEq(a4, b4, ignore) {
    if (a4 == b4)
      return true;
    if (!a4)
      a4 = noAttrs;
    if (!b4)
      b4 = noAttrs;
    let keysA = Object.keys(a4), keysB = Object.keys(b4);
    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
      return false;
    for (let key of keysA) {
      if (key != ignore && (keysB.indexOf(key) == -1 || a4[key] !== b4[key]))
        return false;
    }
    return true;
  }
  function updateAttrs(dom, prev, attrs) {
    let changed = false;
    if (prev) {
      for (let name2 in prev)
        if (!(attrs && name2 in attrs)) {
          changed = true;
          if (name2 == "style")
            dom.style.cssText = "";
          else
            dom.removeAttribute(name2);
        }
    }
    if (attrs) {
      for (let name2 in attrs)
        if (!(prev && prev[name2] == attrs[name2])) {
          changed = true;
          if (name2 == "style")
            dom.style.cssText = attrs[name2];
          else
            dom.setAttribute(name2, attrs[name2]);
        }
    }
    return changed;
  }
  function getAttrs(dom) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let i4 = 0; i4 < dom.attributes.length; i4++) {
      let attr = dom.attributes[i4];
      attrs[attr.name] = attr.value;
    }
    return attrs;
  }
  var LineView = class _LineView extends ContentView {
    constructor() {
      super(...arguments);
      this.children = [];
      this.length = 0;
      this.prevAttrs = void 0;
      this.attrs = null;
      this.breakAfter = 0;
    }
    // Consumes source
    merge(from, to, source, hasStart, openStart, openEnd) {
      if (source) {
        if (!(source instanceof _LineView))
          return false;
        if (!this.dom)
          source.transferDOM(this);
      }
      if (hasStart)
        this.setDeco(source ? source.attrs : null);
      mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);
      return true;
    }
    split(at) {
      let end = new _LineView();
      end.breakAfter = this.breakAfter;
      if (this.length == 0)
        return end;
      let { i: i4, off } = this.childPos(at);
      if (off) {
        end.append(this.children[i4].split(off), 0);
        this.children[i4].merge(off, this.children[i4].length, null, false, 0, 0);
        i4++;
      }
      for (let j2 = i4; j2 < this.children.length; j2++)
        end.append(this.children[j2], 0);
      while (i4 > 0 && this.children[i4 - 1].length == 0)
        this.children[--i4].destroy();
      this.children.length = i4;
      this.markDirty();
      this.length = at;
      return end;
    }
    transferDOM(other) {
      if (!this.dom)
        return;
      this.markDirty();
      other.setDOM(this.dom);
      other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
      this.prevAttrs = void 0;
      this.dom = null;
    }
    setDeco(attrs) {
      if (!attrsEq(this.attrs, attrs)) {
        if (this.dom) {
          this.prevAttrs = this.attrs;
          this.markDirty();
        }
        this.attrs = attrs;
      }
    }
    append(child, openStart) {
      joinInlineInto(this, child, openStart);
    }
    // Only called when building a line view in ContentBuilder
    addLineDeco(deco) {
      let attrs = deco.spec.attributes, cls = deco.spec.class;
      if (attrs)
        this.attrs = combineAttrs(attrs, this.attrs || {});
      if (cls)
        this.attrs = combineAttrs({ class: cls }, this.attrs || {});
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node) {
      if (node.nodeName == "DIV") {
        this.setDOM(node);
        this.flags |= 4 | 2;
      }
    }
    sync(view, track) {
      var _a2;
      if (!this.dom) {
        this.setDOM(document.createElement("div"));
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      } else if (this.flags & 4) {
        clearAttributes(this.dom);
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      }
      if (this.prevAttrs !== void 0) {
        updateAttrs(this.dom, this.prevAttrs, this.attrs);
        this.dom.classList.add("cm-line");
        this.prevAttrs = void 0;
      }
      super.sync(view, track);
      let last = this.dom.lastChild;
      while (last && ContentView.get(last) instanceof MarkView)
        last = last.lastChild;
      if (!last || !this.length || last.nodeName != "BR" && ((_a2 = ContentView.get(last)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser2.ios || !this.children.some((ch) => ch instanceof TextView))) {
        let hack = document.createElement("BR");
        hack.cmIgnore = true;
        this.dom.appendChild(hack);
      }
    }
    measureTextSize() {
      if (this.children.length == 0 || this.length > 20)
        return null;
      let totalWidth = 0, textHeight;
      for (let child of this.children) {
        if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
          return null;
        let rects = clientRectsFor(child.dom);
        if (rects.length != 1)
          return null;
        totalWidth += rects[0].width;
        textHeight = rects[0].height;
      }
      return !totalWidth ? null : {
        lineHeight: this.dom.getBoundingClientRect().height,
        charWidth: totalWidth / this.length,
        textHeight
      };
    }
    coordsAt(pos, side) {
      let rect = coordsInChildren(this, pos, side);
      if (!this.children.length && rect && this.parent) {
        let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
        if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
          let dist2 = (height - heightOracle.textHeight) / 2;
          return { top: rect.top + dist2, bottom: rect.bottom - dist2, left: rect.left, right: rect.left };
        }
      }
      return rect;
    }
    become(_other) {
      return false;
    }
    covers() {
      return true;
    }
    static find(docView, pos) {
      for (let i4 = 0, off = 0; i4 < docView.children.length; i4++) {
        let block = docView.children[i4], end = off + block.length;
        if (end >= pos) {
          if (block instanceof _LineView)
            return block;
          if (end > pos)
            break;
        }
        off = end + block.breakAfter;
      }
      return null;
    }
  };
  var BlockWidgetView = class _BlockWidgetView extends ContentView {
    constructor(widget, length, deco) {
      super();
      this.widget = widget;
      this.length = length;
      this.deco = deco;
      this.breakAfter = 0;
      this.prevWidget = null;
    }
    merge(from, to, source, _takeDeco, openStart, openEnd) {
      if (source && (!(source instanceof _BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from + (source ? source.length : 0) + (this.length - to);
      return true;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
      let len = this.length - at;
      this.length = at;
      let end = new _BlockWidgetView(this.widget, len, this.deco);
      end.breakAfter = this.breakAfter;
      return end;
    }
    get children() {
      return noChildren;
    }
    sync(view) {
      if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(view));
        if (!this.widget.editable)
          this.dom.contentEditable = "false";
      }
    }
    get overrideDOMText() {
      return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
    }
    domBoundsAround() {
      return null;
    }
    become(other) {
      if (other instanceof _BlockWidgetView && other.widget.constructor == this.widget.constructor) {
        if (!other.widget.compare(this.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        this.deco = other.deco;
        this.breakAfter = other.breakAfter;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    get isEditable() {
      return false;
    }
    get isWidget() {
      return true;
    }
    coordsAt(pos, side) {
      return this.widget.coordsAt(this.dom, pos, side);
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
    covers(side) {
      let { startSide, endSide } = this.deco;
      return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
    }
  };
  var WidgetType = class {
    /**
    Compare this instance to another instance of the same type.
    (TypeScript can't express this, but only instances of the same
    specific class will be passed to this method.) This is used to
    avoid redrawing widgets when they are replaced by a new
    decoration of the same type. The default implementation just
    returns `false`, which will cause new instances of the widget to
    always be redrawn.
    */
    eq(widget) {
      return false;
    }
    /**
    Update a DOM element created by a widget of the same type (but
    different, non-`eq` content) to reflect this widget. May return
    true to indicate that it could update, false to indicate it
    couldn't (in which case the widget will be redrawn). The default
    implementation just returns false.
    */
    updateDOM(dom, view) {
      return false;
    }
    /**
    @internal
    */
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    /**
    The estimated height this widget will have, to be used when
    estimating the height of content that hasn't been drawn. May
    return -1 to indicate you don't know. The default implementation
    returns -1.
    */
    get estimatedHeight() {
      return -1;
    }
    /**
    For inline widgets that are displayed inline (as opposed to
    `inline-block`) and introduce line breaks (through `<br>` tags
    or textual newlines), this must indicate the amount of line
    breaks they introduce. Defaults to 0.
    */
    get lineBreaks() {
      return 0;
    }
    /**
    Can be used to configure which kinds of events inside the widget
    should be ignored by the editor. The default is to ignore all
    events.
    */
    ignoreEvent(event) {
      return true;
    }
    /**
    Override the way screen coordinates for positions at/in the
    widget are found. `pos` will be the offset into the widget, and
    `side` the side of the position that is being queried—less than
    zero for before, greater than zero for after, and zero for
    directly at that position.
    */
    coordsAt(dom, pos, side) {
      return null;
    }
    /**
    @internal
    */
    get isHidden() {
      return false;
    }
    /**
    @internal
    */
    get editable() {
      return false;
    }
    /**
    This is called when the an instance of the widget is removed
    from the editor view.
    */
    destroy(dom) {
    }
  };
  var BlockType = /* @__PURE__ */ function(BlockType2) {
    BlockType2[BlockType2["Text"] = 0] = "Text";
    BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
    BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
    BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
    return BlockType2;
  }(BlockType || (BlockType = {}));
  var Decoration = class extends RangeValue {
    constructor(startSide, endSide, widget, spec) {
      super();
      this.startSide = startSide;
      this.endSide = endSide;
      this.widget = widget;
      this.spec = spec;
    }
    /**
    @internal
    */
    get heightRelevant() {
      return false;
    }
    /**
    Create a mark decoration, which influences the styling of the
    content in its range. Nested mark decorations will cause nested
    DOM elements to be created. Nesting order is determined by
    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
    the higher-precedence decorations creating the inner DOM nodes.
    Such elements are split on line boundaries and on the boundaries
    of lower-precedence decorations.
    */
    static mark(spec) {
      return new MarkDecoration(spec);
    }
    /**
    Create a widget decoration, which displays a DOM element at the
    given position.
    */
    static widget(spec) {
      let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
      side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
      return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    /**
    Create a replace decoration which replaces the given range with
    a widget, or simply hides it.
    */
    static replace(spec) {
      let block = !!spec.block, startSide, endSide;
      if (spec.isBlockGap) {
        startSide = -5e8;
        endSide = 4e8;
      } else {
        let { start, end } = getInclusive(spec, block);
        startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
        endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
      }
      return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    /**
    Create a line decoration, which can add DOM attributes to the
    line starting at the given position.
    */
    static line(spec) {
      return new LineDecoration(spec);
    }
    /**
    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
    decorated range or ranges. If the ranges aren't already sorted,
    pass `true` for `sort` to make the library sort them for you.
    */
    static set(of, sort = false) {
      return RangeSet.of(of, sort);
    }
    /**
    @internal
    */
    hasHeight() {
      return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
  };
  Decoration.none = RangeSet.empty;
  var MarkDecoration = class _MarkDecoration extends Decoration {
    constructor(spec) {
      let { start, end } = getInclusive(spec);
      super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
      this.tagName = spec.tagName || "span";
      this.class = spec.class || "";
      this.attrs = spec.attributes || null;
    }
    eq(other) {
      var _a2, _b;
      return this == other || other instanceof _MarkDecoration && this.tagName == other.tagName && (this.class || ((_a2 = this.attrs) === null || _a2 === void 0 ? void 0 : _a2.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, "class");
    }
    range(from, to = from) {
      if (from >= to)
        throw new RangeError("Mark decorations may not be empty");
      return super.range(from, to);
    }
  };
  MarkDecoration.prototype.point = false;
  var LineDecoration = class _LineDecoration extends Decoration {
    constructor(spec) {
      super(-2e8, -2e8, null, spec);
    }
    eq(other) {
      return other instanceof _LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to = from) {
      if (to != from)
        throw new RangeError("Line decoration ranges must be zero-length");
      return super.range(from, to);
    }
  };
  LineDecoration.prototype.mapMode = MapMode.TrackBefore;
  LineDecoration.prototype.point = true;
  var PointDecoration = class _PointDecoration extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
      super(startSide, endSide, widget, spec);
      this.block = block;
      this.isReplace = isReplace;
      this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
    }
    // Only relevant when this.block == true
    get type() {
      return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
      return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
    }
    eq(other) {
      return other instanceof _PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to = from) {
      if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0))
        throw new RangeError("Invalid range for replacement decoration");
      if (!this.isReplace && to != from)
        throw new RangeError("Widget decorations can only have zero-length ranges");
      return super.range(from, to);
    }
  };
  PointDecoration.prototype.point = true;
  function getInclusive(spec, block = false) {
    let { inclusiveStart: start, inclusiveEnd: end } = spec;
    if (start == null)
      start = spec.inclusive;
    if (end == null)
      end = spec.inclusive;
    return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
  }
  function widgetsEq(a4, b4) {
    return a4 == b4 || !!(a4 && b4 && a4.compare(b4));
  }
  function addRange(from, to, ranges, margin = 0) {
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin >= from)
      ranges[last] = Math.max(ranges[last], to);
    else
      ranges.push(from, to);
  }
  var ContentBuilder = class _ContentBuilder {
    constructor(doc2, pos, end, disallowBlockEffectsFor) {
      this.doc = doc2;
      this.pos = pos;
      this.end = end;
      this.disallowBlockEffectsFor = disallowBlockEffectsFor;
      this.content = [];
      this.curLine = null;
      this.breakAtStart = 0;
      this.pendingBuffer = 0;
      this.bufferMarks = [];
      this.atCursorPos = true;
      this.openStart = -1;
      this.openEnd = -1;
      this.text = "";
      this.textOff = 0;
      this.cursor = doc2.iter();
      this.skip = pos;
    }
    posCovered() {
      if (this.content.length == 0)
        return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
      let last = this.content[this.content.length - 1];
      return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);
    }
    getLine() {
      if (!this.curLine) {
        this.content.push(this.curLine = new LineView());
        this.atCursorPos = true;
      }
      return this.curLine;
    }
    flushBuffer(active = this.bufferMarks) {
      if (this.pendingBuffer) {
        this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
        this.pendingBuffer = 0;
      }
    }
    addBlockWidget(view) {
      this.flushBuffer();
      this.curLine = null;
      this.content.push(view);
    }
    finish(openEnd) {
      if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
        this.flushBuffer();
      else
        this.pendingBuffer = 0;
      if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
        this.getLine();
    }
    buildText(length, active, openStart) {
      while (length > 0) {
        if (this.textOff == this.text.length) {
          let { value, lineBreak, done } = this.cursor.next(this.skip);
          this.skip = 0;
          if (done)
            throw new Error("Ran out of text content when drawing inline views");
          if (lineBreak) {
            if (!this.posCovered())
              this.getLine();
            if (this.content.length)
              this.content[this.content.length - 1].breakAfter = 1;
            else
              this.breakAtStart = 1;
            this.flushBuffer();
            this.curLine = null;
            this.atCursorPos = true;
            length--;
            continue;
          } else {
            this.text = value;
            this.textOff = 0;
          }
        }
        let take = Math.min(
          this.text.length - this.textOff,
          length,
          512
          /* T.Chunk */
        );
        this.flushBuffer(active.slice(active.length - openStart));
        this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
        this.atCursorPos = true;
        this.textOff += take;
        length -= take;
        openStart = 0;
      }
    }
    span(from, to, active, openStart) {
      this.buildText(to - from, active, openStart);
      this.pos = to;
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    point(from, to, deco, active, openStart, index) {
      if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
        if (deco.block)
          throw new RangeError("Block decorations may not be specified via plugins");
        if (to > this.doc.lineAt(this.pos).to)
          throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
      }
      let len = to - from;
      if (deco instanceof PointDecoration) {
        if (deco.block) {
          if (deco.startSide > 0 && !this.posCovered())
            this.getLine();
          this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
        } else {
          let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
          let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
          let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
          let line = this.getLine();
          if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable)
            this.pendingBuffer = 0;
          this.flushBuffer(active);
          if (cursorBefore) {
            line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
            openStart = active.length + Math.max(0, openStart - active.length);
          }
          line.append(wrapMarks(view, active), openStart);
          this.atCursorPos = cursorAfter;
          this.pendingBuffer = !cursorAfter ? 0 : from < to || openStart > active.length ? 1 : 2;
          if (this.pendingBuffer)
            this.bufferMarks = active.slice();
        }
      } else if (this.doc.lineAt(this.pos).from == this.pos) {
        this.getLine().addLineDeco(deco);
      }
      if (len) {
        if (this.textOff + len <= this.text.length) {
          this.textOff += len;
        } else {
          this.skip += len - (this.text.length - this.textOff);
          this.text = "";
          this.textOff = 0;
        }
        this.pos = to;
      }
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    static build(text, from, to, decorations2, dynamicDecorationMap) {
      let builder = new _ContentBuilder(text, from, to, dynamicDecorationMap);
      builder.openEnd = RangeSet.spans(decorations2, from, to, builder);
      if (builder.openStart < 0)
        builder.openStart = builder.openEnd;
      builder.finish(builder.openEnd);
      return builder;
    }
  };
  function wrapMarks(view, active) {
    for (let mark of active)
      view = new MarkView(mark, [view], view.length);
    return view;
  }
  var NullWidget = class extends WidgetType {
    constructor(tag) {
      super();
      this.tag = tag;
    }
    eq(other) {
      return other.tag == this.tag;
    }
    toDOM() {
      return document.createElement(this.tag);
    }
    updateDOM(elt) {
      return elt.nodeName.toLowerCase() == this.tag;
    }
    get isHidden() {
      return true;
    }
  };
  NullWidget.inline = /* @__PURE__ */ new NullWidget("span");
  NullWidget.block = /* @__PURE__ */ new NullWidget("div");
  var Direction = /* @__PURE__ */ function(Direction2) {
    Direction2[Direction2["LTR"] = 0] = "LTR";
    Direction2[Direction2["RTL"] = 1] = "RTL";
    return Direction2;
  }(Direction || (Direction = {}));
  var LTR = Direction.LTR;
  var RTL = Direction.RTL;
  function dec(str2) {
    let result = [];
    for (let i4 = 0; i4 < str2.length; i4++)
      result.push(1 << +str2[i4]);
    return result;
  }
  var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
  var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
  var Brackets = /* @__PURE__ */ Object.create(null);
  var BracketStack = [];
  for (let p4 of ["()", "[]", "{}"]) {
    let l4 = /* @__PURE__ */ p4.charCodeAt(0), r3 = /* @__PURE__ */ p4.charCodeAt(1);
    Brackets[l4] = r3;
    Brackets[r3] = -l4;
  }
  function charType(ch) {
    return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8204 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : 1;
  }
  var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
  var BidiSpan = class {
    /**
    The direction of this span.
    */
    get dir() {
      return this.level % 2 ? RTL : LTR;
    }
    /**
    @internal
    */
    constructor(from, to, level) {
      this.from = from;
      this.to = to;
      this.level = level;
    }
    /**
    @internal
    */
    side(end, dir) {
      return this.dir == dir == end ? this.to : this.from;
    }
    /**
    @internal
    */
    forward(forward, dir) {
      return forward == (this.dir == dir);
    }
    /**
    @internal
    */
    static find(order, index, level, assoc) {
      let maybe = -1;
      for (let i4 = 0; i4 < order.length; i4++) {
        let span = order[i4];
        if (span.from <= index && span.to >= index) {
          if (span.level == level)
            return i4;
          if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level))
            maybe = i4;
        }
      }
      if (maybe < 0)
        throw new RangeError("Index out of range");
      return maybe;
    }
  };
  function isolatesEq(a4, b4) {
    if (a4.length != b4.length)
      return false;
    for (let i4 = 0; i4 < a4.length; i4++) {
      let iA = a4[i4], iB = b4[i4];
      if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
        return false;
    }
    return true;
  }
  var types = [];
  function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
    for (let iI = 0; iI <= isolates.length; iI++) {
      let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
      let prevType = iI ? 256 : outerType;
      for (let i4 = from, prev = prevType, prevStrong = prevType; i4 < to; i4++) {
        let type2 = charType(line.charCodeAt(i4));
        if (type2 == 512)
          type2 = prev;
        else if (type2 == 8 && prevStrong == 4)
          type2 = 16;
        types[i4] = type2 == 4 ? 2 : type2;
        if (type2 & 7)
          prevStrong = type2;
        prev = type2;
      }
      for (let i4 = from, prev = prevType, prevStrong = prevType; i4 < to; i4++) {
        let type2 = types[i4];
        if (type2 == 128) {
          if (i4 < to - 1 && prev == types[i4 + 1] && prev & 24)
            type2 = types[i4] = prev;
          else
            types[i4] = 256;
        } else if (type2 == 64) {
          let end = i4 + 1;
          while (end < to && types[end] == 64)
            end++;
          let replace = i4 && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
          for (let j2 = i4; j2 < end; j2++)
            types[j2] = replace;
          i4 = end - 1;
        } else if (type2 == 8 && prevStrong == 1) {
          types[i4] = 1;
        }
        prev = type2;
        if (type2 & 7)
          prevStrong = type2;
      }
    }
  }
  function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
    let oppositeType = outerType == 1 ? 2 : 1;
    for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
      let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
      for (let i4 = from, ch, br, type2; i4 < to; i4++) {
        if (br = Brackets[ch = line.charCodeAt(i4)]) {
          if (br < 0) {
            for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
              if (BracketStack[sJ + 1] == -br) {
                let flags = BracketStack[sJ + 2];
                let type3 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
                if (type3)
                  types[i4] = types[BracketStack[sJ]] = type3;
                sI = sJ;
                break;
              }
            }
          } else if (BracketStack.length == 189) {
            break;
          } else {
            BracketStack[sI++] = i4;
            BracketStack[sI++] = ch;
            BracketStack[sI++] = context;
          }
        } else if ((type2 = types[i4]) == 2 || type2 == 1) {
          let embed = type2 == outerType;
          context = embed ? 0 : 1;
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            let cur = BracketStack[sJ + 2];
            if (cur & 2)
              break;
            if (embed) {
              BracketStack[sJ + 2] |= 2;
            } else {
              if (cur & 4)
                break;
              BracketStack[sJ + 2] |= 4;
            }
          }
        }
      }
    }
  }
  function processNeutrals(rFrom, rTo, isolates, outerType) {
    for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
      let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
      for (let i4 = from; i4 < to; ) {
        let type2 = types[i4];
        if (type2 == 256) {
          let end = i4 + 1;
          for (; ; ) {
            if (end == to) {
              if (iI == isolates.length)
                break;
              end = isolates[iI++].to;
              to = iI < isolates.length ? isolates[iI].from : rTo;
            } else if (types[end] == 256) {
              end++;
            } else {
              break;
            }
          }
          let beforeL = prev == 1;
          let afterL = (end < rTo ? types[end] : outerType) == 1;
          let replace = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
          for (let j2 = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j2 > i4; ) {
            if (j2 == fromJ) {
              j2 = isolates[--jI].from;
              fromJ = jI ? isolates[jI - 1].to : rFrom;
            }
            types[--j2] = replace;
          }
          i4 = end;
        } else {
          prev = type2;
          i4++;
        }
      }
    }
  }
  function emitSpans(line, from, to, level, baseLevel, isolates, order) {
    let ourType = level % 2 ? 2 : 1;
    if (level % 2 == baseLevel % 2) {
      for (let iCh = from, iI = 0; iCh < to; ) {
        let sameDir = true, isNum = false;
        if (iI == isolates.length || iCh < isolates[iI].from) {
          let next = types[iCh];
          if (next != ourType) {
            sameDir = false;
            isNum = next == 16;
          }
        }
        let recurse = !sameDir && ourType == 1 ? [] : null;
        let localLevel = sameDir ? level : level + 1;
        let iScan = iCh;
        run: for (; ; ) {
          if (iI < isolates.length && iScan == isolates[iI].from) {
            if (isNum)
              break run;
            let iso = isolates[iI];
            if (!sameDir)
              for (let upto = iso.to, jI = iI + 1; ; ) {
                if (upto == to)
                  break run;
                if (jI < isolates.length && isolates[jI].from == upto)
                  upto = isolates[jI++].to;
                else if (types[upto] == ourType)
                  break run;
                else
                  break;
              }
            iI++;
            if (recurse) {
              recurse.push(iso);
            } else {
              if (iso.from > iCh)
                order.push(new BidiSpan(iCh, iso.from, localLevel));
              let dirSwap = iso.direction == LTR != !(localLevel % 2);
              computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
              iCh = iso.to;
            }
            iScan = iso.to;
          } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
            break;
          } else {
            iScan++;
          }
        }
        if (recurse)
          emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
        else if (iCh < iScan)
          order.push(new BidiSpan(iCh, iScan, localLevel));
        iCh = iScan;
      }
    } else {
      for (let iCh = to, iI = isolates.length; iCh > from; ) {
        let sameDir = true, isNum = false;
        if (!iI || iCh > isolates[iI - 1].to) {
          let next = types[iCh - 1];
          if (next != ourType) {
            sameDir = false;
            isNum = next == 16;
          }
        }
        let recurse = !sameDir && ourType == 1 ? [] : null;
        let localLevel = sameDir ? level : level + 1;
        let iScan = iCh;
        run: for (; ; ) {
          if (iI && iScan == isolates[iI - 1].to) {
            if (isNum)
              break run;
            let iso = isolates[--iI];
            if (!sameDir)
              for (let upto = iso.from, jI = iI; ; ) {
                if (upto == from)
                  break run;
                if (jI && isolates[jI - 1].to == upto)
                  upto = isolates[--jI].from;
                else if (types[upto - 1] == ourType)
                  break run;
                else
                  break;
              }
            if (recurse) {
              recurse.push(iso);
            } else {
              if (iso.to < iCh)
                order.push(new BidiSpan(iso.to, iCh, localLevel));
              let dirSwap = iso.direction == LTR != !(localLevel % 2);
              computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
              iCh = iso.from;
            }
            iScan = iso.from;
          } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
            break;
          } else {
            iScan--;
          }
        }
        if (recurse)
          emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
        else if (iScan < iCh)
          order.push(new BidiSpan(iScan, iCh, localLevel));
        iCh = iScan;
      }
    }
  }
  function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {
    let outerType = level % 2 ? 2 : 1;
    computeCharTypes(line, from, to, isolates, outerType);
    processBracketPairs(line, from, to, isolates, outerType);
    processNeutrals(from, to, isolates, outerType);
    emitSpans(line, from, to, level, baseLevel, isolates, order);
  }
  function computeOrder(line, direction, isolates) {
    if (!line)
      return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
    if (direction == LTR && !isolates.length && !BidiRE.test(line))
      return trivialOrder(line.length);
    if (isolates.length)
      while (line.length > types.length)
        types[types.length] = 256;
    let order = [], level = direction == LTR ? 0 : 1;
    computeSectionOrder(line, level, level, isolates, 0, line.length, order);
    return order;
  }
  function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
  }
  var movedOver = "";
  function moveVisually(line, order, dir, start, forward) {
    var _a2;
    let startIndex = start.head - line.from;
    let spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
    let span = order[spanI], spanEnd = span.side(forward, dir);
    if (startIndex == spanEnd) {
      let nextI = spanI += forward ? 1 : -1;
      if (nextI < 0 || nextI >= order.length)
        return null;
      span = order[spanI = nextI];
      startIndex = span.side(!forward, dir);
      spanEnd = span.side(forward, dir);
    }
    let nextIndex = findClusterBreak(line.text, startIndex, span.forward(forward, dir));
    if (nextIndex < span.from || nextIndex > span.to)
      nextIndex = spanEnd;
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
      return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
    return EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
  }
  function autoDirection(text, from, to) {
    for (let i4 = from; i4 < to; i4++) {
      let type2 = charType(text.charCodeAt(i4));
      if (type2 == 1)
        return LTR;
      if (type2 == 2 || type2 == 4)
        return RTL;
    }
    return LTR;
  }
  var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
  var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
  var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
  var exceptionSink = /* @__PURE__ */ Facet.define();
  var updateListener = /* @__PURE__ */ Facet.define();
  var inputHandler = /* @__PURE__ */ Facet.define();
  var focusChangeEffect = /* @__PURE__ */ Facet.define();
  var perLineTextDirection = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x2) => x2)
  });
  var nativeSelectionHidden = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x2) => x2)
  });
  var scrollHandler = /* @__PURE__ */ Facet.define();
  var ScrollTarget = class _ScrollTarget {
    constructor(range, y3 = "nearest", x2 = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
      this.range = range;
      this.y = y3;
      this.x = x2;
      this.yMargin = yMargin;
      this.xMargin = xMargin;
      this.isSnapshot = isSnapshot;
    }
    map(changes) {
      return changes.empty ? this : new _ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
    clip(state) {
      return this.range.to <= state.doc.length ? this : new _ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
  };
  var scrollIntoView = /* @__PURE__ */ StateEffect.define({ map: (t5, ch) => t5.map(ch) });
  var setEditContextFormatting = /* @__PURE__ */ StateEffect.define();
  function logException(state, exception2, context) {
    let handler = state.facet(exceptionSink);
    if (handler.length)
      handler[0](exception2);
    else if (window.onerror)
      window.onerror(String(exception2), context, void 0, void 0, exception2);
    else if (context)
      console.error(context + ":", exception2);
    else
      console.error(exception2);
  }
  var editable = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : true });
  var nextPluginID = 0;
  var viewPlugin = /* @__PURE__ */ Facet.define();
  var ViewPlugin = class _ViewPlugin {
    constructor(id2, create, domEventHandlers, domEventObservers, buildExtensions) {
      this.id = id2;
      this.create = create;
      this.domEventHandlers = domEventHandlers;
      this.domEventObservers = domEventObservers;
      this.extension = buildExtensions(this);
    }
    /**
    Define a plugin from a constructor function that creates the
    plugin's value, given an editor view.
    */
    static define(create, spec) {
      const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
      return new _ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, (plugin) => {
        let ext = [viewPlugin.of(plugin)];
        if (deco)
          ext.push(decorations.of((view) => {
            let pluginInst = view.plugin(plugin);
            return pluginInst ? deco(pluginInst) : Decoration.none;
          }));
        if (provide)
          ext.push(provide(plugin));
        return ext;
      });
    }
    /**
    Create a plugin for a class whose constructor takes a single
    editor view as argument.
    */
    static fromClass(cls, spec) {
      return _ViewPlugin.define((view) => new cls(view), spec);
    }
  };
  var PluginInstance = class {
    constructor(spec) {
      this.spec = spec;
      this.mustUpdate = null;
      this.value = null;
    }
    update(view) {
      if (!this.value) {
        if (this.spec) {
          try {
            this.value = this.spec.create(view);
          } catch (e4) {
            logException(view.state, e4, "CodeMirror plugin crashed");
            this.deactivate();
          }
        }
      } else if (this.mustUpdate) {
        let update = this.mustUpdate;
        this.mustUpdate = null;
        if (this.value.update) {
          try {
            this.value.update(update);
          } catch (e4) {
            logException(update.state, e4, "CodeMirror plugin crashed");
            if (this.value.destroy)
              try {
                this.value.destroy();
              } catch (_2) {
              }
            this.deactivate();
          }
        }
      }
      return this;
    }
    destroy(view) {
      var _a2;
      if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
        try {
          this.value.destroy();
        } catch (e4) {
          logException(view.state, e4, "CodeMirror plugin crashed");
        }
      }
    }
    deactivate() {
      this.spec = this.value = null;
    }
  };
  var editorAttributes = /* @__PURE__ */ Facet.define();
  var contentAttributes = /* @__PURE__ */ Facet.define();
  var decorations = /* @__PURE__ */ Facet.define();
  var outerDecorations = /* @__PURE__ */ Facet.define();
  var atomicRanges = /* @__PURE__ */ Facet.define();
  var bidiIsolatedRanges = /* @__PURE__ */ Facet.define();
  function getIsolatedRanges(view, line) {
    let isolates = view.state.facet(bidiIsolatedRanges);
    if (!isolates.length)
      return isolates;
    let sets = isolates.map((i4) => i4 instanceof Function ? i4(view) : i4);
    let result = [];
    RangeSet.spans(sets, line.from, line.to, {
      point() {
      },
      span(fromDoc, toDoc, active, open) {
        let from = fromDoc - line.from, to = toDoc - line.from;
        let level = result;
        for (let i4 = active.length - 1; i4 >= 0; i4--, open--) {
          let direction = active[i4].spec.bidiIsolate, update;
          if (direction == null)
            direction = autoDirection(line.text, from, to);
          if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == direction) {
            update.to = to;
            level = update.inner;
          } else {
            let add2 = { from, to, direction, inner: [] };
            level.push(add2);
            level = add2.inner;
          }
        }
      }
    });
    return result;
  }
  var scrollMargins = /* @__PURE__ */ Facet.define();
  function getScrollMargins(view) {
    let left = 0, right = 0, top2 = 0, bottom = 0;
    for (let source of view.state.facet(scrollMargins)) {
      let m3 = source(view);
      if (m3) {
        if (m3.left != null)
          left = Math.max(left, m3.left);
        if (m3.right != null)
          right = Math.max(right, m3.right);
        if (m3.top != null)
          top2 = Math.max(top2, m3.top);
        if (m3.bottom != null)
          bottom = Math.max(bottom, m3.bottom);
      }
    }
    return { left, right, top: top2, bottom };
  }
  var styleModule = /* @__PURE__ */ Facet.define();
  var ChangedRange = class _ChangedRange {
    constructor(fromA, toA, fromB, toB) {
      this.fromA = fromA;
      this.toA = toA;
      this.fromB = fromB;
      this.toB = toB;
    }
    join(other) {
      return new _ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set2) {
      let i4 = set2.length, me = this;
      for (; i4 > 0; i4--) {
        let range = set2[i4 - 1];
        if (range.fromA > me.toA)
          continue;
        if (range.toA < me.fromA)
          break;
        me = me.join(range);
        set2.splice(i4 - 1, 1);
      }
      set2.splice(i4, 0, me);
      return set2;
    }
    static extendWithRanges(diff, ranges) {
      if (ranges.length == 0)
        return diff;
      let result = [];
      for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
        let next = dI == diff.length ? null : diff[dI], off = posA - posB;
        let end = next ? next.fromB : 1e9;
        while (rI < ranges.length && ranges[rI] < end) {
          let from = ranges[rI], to = ranges[rI + 1];
          let fromB = Math.max(posB, from), toB = Math.min(end, to);
          if (fromB <= toB)
            new _ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
          if (to > end)
            break;
          else
            rI += 2;
        }
        if (!next)
          return result;
        new _ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
        posA = next.toA;
        posB = next.toB;
      }
    }
  };
  var ViewUpdate = class _ViewUpdate {
    constructor(view, state, transactions) {
      this.view = view;
      this.state = state;
      this.transactions = transactions;
      this.flags = 0;
      this.startState = view.state;
      this.changes = ChangeSet.empty(this.startState.doc.length);
      for (let tr of transactions)
        this.changes = this.changes.compose(tr.changes);
      let changedRanges = [];
      this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
      this.changedRanges = changedRanges;
    }
    /**
    @internal
    */
    static create(view, state, transactions) {
      return new _ViewUpdate(view, state, transactions);
    }
    /**
    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
    update.
    */
    get viewportChanged() {
      return (this.flags & 4) > 0;
    }
    /**
    Indicates whether the height of a block element in the editor
    changed in this update.
    */
    get heightChanged() {
      return (this.flags & 2) > 0;
    }
    /**
    Returns true when the document was modified or the size of the
    editor, or elements within the editor, changed.
    */
    get geometryChanged() {
      return this.docChanged || (this.flags & (8 | 2)) > 0;
    }
    /**
    True when this update indicates a focus change.
    */
    get focusChanged() {
      return (this.flags & 1) > 0;
    }
    /**
    Whether the document changed in this update.
    */
    get docChanged() {
      return !this.changes.empty;
    }
    /**
    Whether the selection was explicitly set in this update.
    */
    get selectionSet() {
      return this.transactions.some((tr) => tr.selection);
    }
    /**
    @internal
    */
    get empty() {
      return this.flags == 0 && this.transactions.length == 0;
    }
  };
  var DocView = class extends ContentView {
    get length() {
      return this.view.state.doc.length;
    }
    constructor(view) {
      super();
      this.view = view;
      this.decorations = [];
      this.dynamicDecorationMap = [false];
      this.domChanged = null;
      this.hasComposition = null;
      this.markedForComposition = /* @__PURE__ */ new Set();
      this.editContextFormatting = Decoration.none;
      this.lastCompositionAfterCursor = false;
      this.minWidth = 0;
      this.minWidthFrom = 0;
      this.minWidthTo = 0;
      this.impreciseAnchor = null;
      this.impreciseHead = null;
      this.forceSelection = false;
      this.lastUpdate = Date.now();
      this.setDOM(view.contentDOM);
      this.children = [new LineView()];
      this.children[0].setParent(this);
      this.updateDeco();
      this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
    }
    // Update the document view to a given state.
    update(update) {
      var _a2;
      let changedRanges = update.changedRanges;
      if (this.minWidth > 0 && changedRanges.length) {
        if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
          this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
        } else {
          this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
          this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
        }
      }
      this.updateEditContextFormatting(update);
      let readCompositionAt = -1;
      if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
        if ((_a2 = this.domChanged) === null || _a2 === void 0 ? void 0 : _a2.newSel)
          readCompositionAt = this.domChanged.newSel.head;
        else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
          readCompositionAt = update.state.selection.main.head;
      }
      let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
      this.domChanged = null;
      if (this.hasComposition) {
        this.markedForComposition.clear();
        let { from, to } = this.hasComposition;
        changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());
      }
      this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
      if ((browser2.ie || browser2.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines)
        this.forceSelection = true;
      let prevDeco = this.decorations, deco = this.updateDeco();
      let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
      if (!(this.flags & 7) && changedRanges.length == 0) {
        return false;
      } else {
        this.updateInner(changedRanges, update.startState.doc.length, composition);
        if (update.transactions.length)
          this.lastUpdate = Date.now();
        return true;
      }
    }
    // Used by update and the constructor do perform the actual DOM
    // update
    updateInner(changes, oldLength, composition) {
      this.view.viewState.mustMeasureContent = true;
      this.updateChildren(changes, oldLength, composition);
      let { observer } = this.view;
      observer.ignore(() => {
        this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
        this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
        let track = browser2.chrome || browser2.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
        this.sync(this.view, track);
        this.flags &= ~7;
        if (track && (track.written || observer.selectionRange.focusNode != track.node))
          this.forceSelection = true;
        this.dom.style.height = "";
      });
      this.markedForComposition.forEach(
        (cView) => cView.flags &= ~8
        /* ViewFlag.Composition */
      );
      let gaps = [];
      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
        for (let child of this.children)
          if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
            gaps.push(child.dom);
      }
      observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength, composition) {
      let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
      let cursor = this.childCursor(oldLength);
      for (let i4 = ranges.length - 1; ; i4--) {
        let next = i4 >= 0 ? ranges[i4] : null;
        if (!next)
          break;
        let { fromA, toA, fromB, toB } = next, content2, breakAtStart, openStart, openEnd;
        if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
          let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
          let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
          breakAtStart = before.breakAtStart;
          openStart = before.openStart;
          openEnd = after.openEnd;
          let compLine = this.compositionView(composition);
          if (after.breakAtStart) {
            compLine.breakAfter = 1;
          } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
            compLine.breakAfter = after.content[0].breakAfter;
            after.content.shift();
          }
          if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
            before.content.pop();
          }
          content2 = before.content.concat(compLine).concat(after.content);
        } else {
          ({ content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
        }
        let { i: toI, off: toOff } = cursor.findPos(toA, 1);
        let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
        replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
      }
      if (composition)
        this.fixCompositionDOM(composition);
    }
    updateEditContextFormatting(update) {
      this.editContextFormatting = this.editContextFormatting.map(update.changes);
      for (let tr of update.transactions)
        for (let effect of tr.effects)
          if (effect.is(setEditContextFormatting)) {
            this.editContextFormatting = effect.value;
          }
    }
    compositionView(composition) {
      let cur = new TextView(composition.text.nodeValue);
      cur.flags |= 8;
      for (let { deco } of composition.marks)
        cur = new MarkView(deco, [cur], cur.length);
      let line = new LineView();
      line.append(cur, 0);
      return line;
    }
    fixCompositionDOM(composition) {
      let fix = (dom, cView2) => {
        cView2.flags |= 8 | (cView2.children.some(
          (c4) => c4.flags & 7
          /* ViewFlag.Dirty */
        ) ? 1 : 0);
        this.markedForComposition.add(cView2);
        let prev = ContentView.get(dom);
        if (prev && prev != cView2)
          prev.dom = null;
        cView2.setDOM(dom);
      };
      let pos = this.childPos(composition.range.fromB, 1);
      let cView = this.children[pos.i];
      fix(composition.line, cView);
      for (let i4 = composition.marks.length - 1; i4 >= -1; i4--) {
        pos = cView.childPos(pos.off, 1);
        cView = cView.children[pos.i];
        fix(i4 >= 0 ? composition.marks[i4].node : composition.text, cView);
      }
    }
    // Sync the DOM selection to this.state.selection
    updateSelection(mustRead = false, fromPointer = false) {
      if (mustRead || !this.view.observer.selectionRange.focusNode)
        this.view.observer.readSelectionRange();
      let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
      let selectionNotFocus = !focused && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
      if (!(focused || fromPointer || selectionNotFocus))
        return;
      let force = this.forceSelection;
      this.forceSelection = false;
      let main2 = this.view.state.selection.main;
      let anchor = this.moveToLine(this.domAtPos(main2.anchor));
      let head = main2.empty ? anchor : this.moveToLine(this.domAtPos(main2.head));
      if (browser2.gecko && main2.empty && !this.hasComposition && betweenUneditable(anchor)) {
        let dummy = document.createTextNode("");
        this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
        anchor = head = new DOMPos(dummy, 0);
        force = true;
      }
      let domSel = this.view.observer.selectionRange;
      if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main2)) {
        this.view.observer.ignore(() => {
          if (browser2.android && browser2.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
            this.dom.blur();
            this.dom.focus({ preventScroll: true });
          }
          let rawSel = getSelection(this.view.root);
          if (!rawSel) ;
          else if (main2.empty) {
            if (browser2.gecko) {
              let nextTo = nextToUneditable(anchor.node, anchor.offset);
              if (nextTo && nextTo != (1 | 2)) {
                let text = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
                if (text)
                  anchor = new DOMPos(text.node, text.offset);
              }
            }
            rawSel.collapse(anchor.node, anchor.offset);
            if (main2.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
              rawSel.caretBidiLevel = main2.bidiLevel;
          } else if (rawSel.extend) {
            rawSel.collapse(anchor.node, anchor.offset);
            try {
              rawSel.extend(head.node, head.offset);
            } catch (_2) {
            }
          } else {
            let range = document.createRange();
            if (main2.anchor > main2.head)
              [anchor, head] = [head, anchor];
            range.setEnd(head.node, head.offset);
            range.setStart(anchor.node, anchor.offset);
            rawSel.removeAllRanges();
            rawSel.addRange(range);
          }
          if (selectionNotFocus && this.view.root.activeElement == this.dom) {
            this.dom.blur();
            if (activeElt)
              activeElt.focus();
          }
        });
        this.view.observer.setSelectionRange(anchor, head);
      }
      this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
      this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    // If a zero-length widget is inserted next to the cursor during
    // composition, avoid moving it across it and disrupting the
    // composition.
    suppressWidgetCursorChange(sel, cursor) {
      return this.hasComposition && cursor.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;
    }
    enforceCursorAssoc() {
      if (this.hasComposition)
        return;
      let { view } = this, cursor = view.state.selection.main;
      let sel = getSelection(view.root);
      let { anchorNode, anchorOffset } = view.observer.selectionRange;
      if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
        return;
      let line = LineView.find(this, cursor.head);
      if (!line)
        return;
      let lineStart = line.posAtStart;
      if (cursor.head == lineStart || cursor.head == lineStart + line.length)
        return;
      let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
      if (!before || !after || before.bottom > after.top)
        return;
      let dom = this.domAtPos(cursor.head + cursor.assoc);
      sel.collapse(dom.node, dom.offset);
      sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
      view.observer.readSelectionRange();
      let newRange = view.observer.selectionRange;
      if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
        sel.collapse(anchorNode, anchorOffset);
    }
    // If a position is in/near a block widget, move it to a nearby text
    // line, since we don't want the cursor inside a block widget.
    moveToLine(pos) {
      let dom = this.dom, newPos;
      if (pos.node != dom)
        return pos;
      for (let i4 = pos.offset; !newPos && i4 < dom.childNodes.length; i4++) {
        let view = ContentView.get(dom.childNodes[i4]);
        if (view instanceof LineView)
          newPos = view.domAtPos(0);
      }
      for (let i4 = pos.offset - 1; !newPos && i4 >= 0; i4--) {
        let view = ContentView.get(dom.childNodes[i4]);
        if (view instanceof LineView)
          newPos = view.domAtPos(view.length);
      }
      return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
    }
    nearest(dom) {
      for (let cur = dom; cur; ) {
        let domView = ContentView.get(cur);
        if (domView && domView.rootView == this)
          return domView;
        cur = cur.parentNode;
      }
      return null;
    }
    posFromDOM(node, offset) {
      let view = this.nearest(node);
      if (!view)
        throw new RangeError("Trying to find position for a DOM position outside of the document");
      return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
      let { i: i4, off } = this.childCursor().findPos(pos, -1);
      for (; i4 < this.children.length - 1; ) {
        let child = this.children[i4];
        if (off < child.length || child instanceof LineView)
          break;
        i4++;
        off = 0;
      }
      return this.children[i4].domAtPos(off);
    }
    coordsAt(pos, side) {
      let best = null, bestPos = 0;
      for (let off = this.length, i4 = this.children.length - 1; i4 >= 0; i4--) {
        let child = this.children[i4], end = off - child.breakAfter, start = end - child.length;
        if (end < pos)
          break;
        if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
          best = child;
          bestPos = start;
        } else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
          if (child.deco.startSide < 0)
            break;
          else if (i4)
            best = null;
        }
        off = start;
      }
      return best ? best.coordsAt(pos - bestPos, side) : null;
    }
    coordsForChar(pos) {
      let { i: i4, off } = this.childPos(pos, 1), child = this.children[i4];
      if (!(child instanceof LineView))
        return null;
      while (child.children.length) {
        let { i: i5, off: childOff } = child.childPos(off, 1);
        for (; ; i5++) {
          if (i5 == child.children.length)
            return null;
          if ((child = child.children[i5]).length)
            break;
        }
        off = childOff;
      }
      if (!(child instanceof TextView))
        return null;
      let end = findClusterBreak(child.text, off);
      if (end == off)
        return null;
      let rects = textRange(child.dom, off, end).getClientRects();
      for (let i5 = 0; i5 < rects.length; i5++) {
        let rect = rects[i5];
        if (i5 == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
          return rect;
      }
      return null;
    }
    measureVisibleLineHeights(viewport) {
      let result = [], { from, to } = viewport;
      let contentWidth = this.view.contentDOM.clientWidth;
      let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
      let widest = -1, ltr = this.view.textDirection == Direction.LTR;
      for (let pos = 0, i4 = 0; i4 < this.children.length; i4++) {
        let child = this.children[i4], end = pos + child.length;
        if (end > to)
          break;
        if (pos >= from) {
          let childRect = child.dom.getBoundingClientRect();
          result.push(childRect.height);
          if (isWider) {
            let last = child.dom.lastChild;
            let rects = last ? clientRectsFor(last) : [];
            if (rects.length) {
              let rect = rects[rects.length - 1];
              let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
              if (width > widest) {
                widest = width;
                this.minWidth = contentWidth;
                this.minWidthFrom = pos;
                this.minWidthTo = end;
              }
            }
          }
        }
        pos = end + child.breakAfter;
      }
      return result;
    }
    textDirectionAt(pos) {
      let { i: i4 } = this.childPos(pos, 1);
      return getComputedStyle(this.children[i4].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
      for (let child of this.children) {
        if (child instanceof LineView) {
          let measure = child.measureTextSize();
          if (measure)
            return measure;
        }
      }
      let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
      dummy.className = "cm-line";
      dummy.style.width = "99999px";
      dummy.style.position = "absolute";
      dummy.textContent = "abc def ghi jkl mno pqr stu";
      this.view.observer.ignore(() => {
        this.dom.appendChild(dummy);
        let rect = clientRectsFor(dummy.firstChild)[0];
        lineHeight = dummy.getBoundingClientRect().height;
        charWidth = rect ? rect.width / 27 : 7;
        textHeight = rect ? rect.height : lineHeight;
        dummy.remove();
      });
      return { lineHeight, charWidth, textHeight };
    }
    childCursor(pos = this.length) {
      let i4 = this.children.length;
      if (i4)
        pos -= this.children[--i4].length;
      return new ChildCursor(this.children, pos, i4);
    }
    computeBlockGapDeco() {
      let deco = [], vs = this.view.viewState;
      for (let pos = 0, i4 = 0; ; i4++) {
        let next = i4 == vs.viewports.length ? null : vs.viewports[i4];
        let end = next ? next.from - 1 : this.length;
        if (end > pos) {
          let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
          deco.push(Decoration.replace({
            widget: new BlockGapWidget(height),
            block: true,
            inclusive: true,
            isBlockGap: true
          }).range(pos, end));
        }
        if (!next)
          break;
        pos = next.to + 1;
      }
      return Decoration.set(deco);
    }
    updateDeco() {
      let i4 = 1;
      let allDeco = this.view.state.facet(decorations).map((d3) => {
        let dynamic = this.dynamicDecorationMap[i4++] = typeof d3 == "function";
        return dynamic ? d3(this.view) : d3;
      });
      let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d3, i5) => {
        let dynamic = typeof d3 == "function";
        if (dynamic)
          dynamicOuter = true;
        return dynamic ? d3(this.view) : d3;
      });
      if (outerDeco.length) {
        this.dynamicDecorationMap[i4++] = dynamicOuter;
        allDeco.push(RangeSet.join(outerDeco));
      }
      this.decorations = [
        this.editContextFormatting,
        ...allDeco,
        this.computeBlockGapDeco(),
        this.view.viewState.lineGapDeco
      ];
      while (i4 < this.decorations.length)
        this.dynamicDecorationMap[i4++] = false;
      return this.decorations;
    }
    scrollIntoView(target) {
      if (target.isSnapshot) {
        let ref = this.view.viewState.lineBlockAt(target.range.head);
        this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
        this.view.scrollDOM.scrollLeft = target.xMargin;
        return;
      }
      for (let handler of this.view.state.facet(scrollHandler)) {
        try {
          if (handler(this.view, target.range, target))
            return true;
        } catch (e4) {
          logException(this.view.state, e4, "scroll handler");
        }
      }
      let { range } = target;
      let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
      if (!rect)
        return;
      if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
        rect = {
          left: Math.min(rect.left, other.left),
          top: Math.min(rect.top, other.top),
          right: Math.max(rect.right, other.right),
          bottom: Math.max(rect.bottom, other.bottom)
        };
      let margins = getScrollMargins(this.view);
      let targetRect = {
        left: rect.left - margins.left,
        top: rect.top - margins.top,
        right: rect.right + margins.right,
        bottom: rect.bottom + margins.bottom
      };
      let { offsetWidth, offsetHeight } = this.view.scrollDOM;
      scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
    }
  };
  function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
  }
  var BlockGapWidget = class extends WidgetType {
    constructor(height) {
      super();
      this.height = height;
    }
    toDOM() {
      let elt = document.createElement("div");
      elt.className = "cm-gap";
      this.updateDOM(elt);
      return elt;
    }
    eq(other) {
      return other.height == this.height;
    }
    updateDOM(elt) {
      elt.style.height = this.height + "px";
      return true;
    }
    get editable() {
      return true;
    }
    get estimatedHeight() {
      return this.height;
    }
    ignoreEvent() {
      return false;
    }
  };
  function findCompositionNode(view, headPos) {
    let sel = view.observer.selectionRange;
    if (!sel.focusNode)
      return null;
    let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
    let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
    let textNode = textBefore || textAfter;
    if (textAfter && textBefore && textAfter.node != textBefore.node) {
      let descAfter = ContentView.get(textAfter.node);
      if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
        textNode = textAfter;
      } else if (view.docView.lastCompositionAfterCursor) {
        let descBefore = ContentView.get(textBefore.node);
        if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue))
          textNode = textAfter;
      }
    }
    view.docView.lastCompositionAfterCursor = textNode != textBefore;
    if (!textNode)
      return null;
    let from = headPos - textNode.offset;
    return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };
  }
  function findCompositionRange(view, changes, headPos) {
    let found = findCompositionNode(view, headPos);
    if (!found)
      return null;
    let { node: textNode, from, to } = found, text = textNode.nodeValue;
    if (/[\n\r]/.test(text))
      return null;
    if (view.state.doc.sliceString(found.from, found.to) != text)
      return null;
    let inv = changes.invertedDesc;
    let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);
    let marks2 = [];
    for (let parent = textNode.parentNode; ; parent = parent.parentNode) {
      let parentView = ContentView.get(parent);
      if (parentView instanceof MarkView)
        marks2.push({ node: parent, deco: parentView.mark });
      else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
        return { range, text: textNode, marks: marks2, line: parent };
      else if (parent != view.contentDOM)
        marks2.push({ node: parent, deco: new MarkDecoration({
          inclusive: true,
          attributes: getAttrs(parent),
          tagName: parent.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
  function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
      return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
  }
  var DecorationComparator$1 = class DecorationComparator {
    constructor() {
      this.changes = [];
    }
    compareRange(from, to) {
      addRange(from, to, this.changes);
    }
    comparePoint(from, to) {
      addRange(from, to, this.changes);
    }
  };
  function findChangedDeco(a4, b4, diff) {
    let comp = new DecorationComparator$1();
    RangeSet.compare(a4, b4, diff, comp);
    return comp.changes;
  }
  function inUneditable(node, inside2) {
    for (let cur = node; cur && cur != inside2; cur = cur.assignedSlot || cur.parentNode) {
      if (cur.nodeType == 1 && cur.contentEditable == "false") {
        return true;
      }
    }
    return false;
  }
  function touchesComposition(changes, composition) {
    let touched = false;
    if (composition)
      changes.iterChangedRanges((from, to) => {
        if (from < composition.to && to > composition.from)
          touched = true;
      });
    return touched;
  }
  function groupAt(state, pos, bias = 1) {
    let categorize = state.charCategorizer(pos);
    let line = state.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
      return EditorSelection.cursor(pos);
    if (linePos == 0)
      bias = 1;
    else if (linePos == line.length)
      bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0)
      from = findClusterBreak(line.text, linePos, false);
    else
      to = findClusterBreak(line.text, linePos);
    let cat = categorize(line.text.slice(from, to));
    while (from > 0) {
      let prev = findClusterBreak(line.text, from, false);
      if (categorize(line.text.slice(prev, from)) != cat)
        break;
      from = prev;
    }
    while (to < line.length) {
      let next = findClusterBreak(line.text, to);
      if (categorize(line.text.slice(to, next)) != cat)
        break;
      to = next;
    }
    return EditorSelection.range(from + line.from, to + line.from);
  }
  function getdx(x2, rect) {
    return rect.left > x2 ? rect.left - x2 : Math.max(0, x2 - rect.right);
  }
  function getdy(y3, rect) {
    return rect.top > y3 ? rect.top - y3 : Math.max(0, y3 - rect.bottom);
  }
  function yOverlap(a4, b4) {
    return a4.top < b4.bottom - 1 && a4.bottom > b4.top + 1;
  }
  function upTop(rect, top2) {
    return top2 < rect.top ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
  }
  function upBot(rect, bottom) {
    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
  }
  function domPosAtCoords(parent, x2, y3) {
    let closest, closestRect, closestX, closestY, closestOverlap = false;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
      let rects = clientRectsFor(child);
      for (let i4 = 0; i4 < rects.length; i4++) {
        let rect = rects[i4];
        if (closestRect && yOverlap(closestRect, rect))
          rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
        let dx = getdx(x2, rect), dy = getdy(y3, rect);
        if (dx == 0 && dy == 0)
          return child.nodeType == 3 ? domPosInText(child, x2, y3) : domPosAtCoords(child, x2, y3);
        if (!closest || closestY > dy || closestY == dy && closestX > dx) {
          closest = child;
          closestRect = rect;
          closestX = dx;
          closestY = dy;
          let side = dy ? y3 < rect.top ? -1 : 1 : dx ? x2 < rect.left ? -1 : 1 : 0;
          closestOverlap = !side || (side > 0 ? i4 < rects.length - 1 : i4 > 0);
        }
        if (dx == 0) {
          if (y3 > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
            above = child;
            aboveRect = rect;
          } else if (y3 < rect.top && (!belowRect || belowRect.top > rect.top)) {
            below = child;
            belowRect = rect;
          }
        } else if (aboveRect && yOverlap(aboveRect, rect)) {
          aboveRect = upBot(aboveRect, rect.bottom);
        } else if (belowRect && yOverlap(belowRect, rect)) {
          belowRect = upTop(belowRect, rect.top);
        }
      }
    }
    if (aboveRect && aboveRect.bottom >= y3) {
      closest = above;
      closestRect = aboveRect;
    } else if (belowRect && belowRect.top <= y3) {
      closest = below;
      closestRect = belowRect;
    }
    if (!closest)
      return { node: parent, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x2));
    if (closest.nodeType == 3)
      return domPosInText(closest, clipX, y3);
    if (closestOverlap && closest.contentEditable != "false")
      return domPosAtCoords(closest, clipX, y3);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x2 >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent, offset };
  }
  function domPosInText(node, x2, y3) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i4 = 0; i4 < len; i4++) {
      let rects = textRange(node, i4, i4 + 1).getClientRects();
      for (let j2 = 0; j2 < rects.length; j2++) {
        let rect = rects[j2];
        if (rect.top == rect.bottom)
          continue;
        if (!generalSide)
          generalSide = x2 - rect.left;
        let dy = (rect.top > y3 ? rect.top - y3 : y3 - rect.bottom) - 1;
        if (rect.left - 1 <= x2 && rect.right + 1 >= x2 && dy < closestDY) {
          let right = x2 >= (rect.left + rect.right) / 2, after = right;
          if (browser2.chrome || browser2.gecko) {
            let rectBefore = textRange(node, i4).getBoundingClientRect();
            if (rectBefore.left == rect.right)
              after = !right;
          }
          if (dy <= 0)
            return { node, offset: i4 + (after ? 1 : 0) };
          closestOffset = i4 + (after ? 1 : 0);
          closestDY = dy;
        }
      }
    }
    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
  }
  function posAtCoords(view, coords, precise, bias = -1) {
    var _a2, _b;
    let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
    let block, { docHeight } = view.viewState;
    let { x: x2, y: y3 } = coords, yOffset = y3 - docTop;
    if (yOffset < 0)
      return 0;
    if (yOffset > docHeight)
      return view.state.doc.length;
    for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
      block = view.elementAtHeight(yOffset);
      if (block.type == BlockType.Text)
        break;
      for (; ; ) {
        yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
        if (yOffset >= 0 && yOffset <= docHeight)
          break;
        if (bounced)
          return precise ? null : 0;
        bounced = true;
        bias = -bias;
      }
    }
    y3 = docTop + yOffset;
    let lineStart = block.from;
    if (lineStart < view.viewport.from)
      return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x2, y3);
    if (lineStart > view.viewport.to)
      return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x2, y3);
    let doc2 = view.dom.ownerDocument;
    let root = view.root.elementFromPoint ? view.root : doc2;
    let element = root.elementFromPoint(x2, y3);
    if (element && !view.contentDOM.contains(element))
      element = null;
    if (!element) {
      x2 = Math.max(content2.left + 1, Math.min(content2.right - 1, x2));
      element = root.elementFromPoint(x2, y3);
      if (element && !view.contentDOM.contains(element))
        element = null;
    }
    let node, offset = -1;
    if (element && ((_a2 = view.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
      if (doc2.caretPositionFromPoint) {
        let pos = doc2.caretPositionFromPoint(x2, y3);
        if (pos)
          ({ offsetNode: node, offset } = pos);
      } else if (doc2.caretRangeFromPoint) {
        let range = doc2.caretRangeFromPoint(x2, y3);
        if (range) {
          ({ startContainer: node, startOffset: offset } = range);
          if (!view.contentDOM.contains(node) || browser2.safari && isSuspiciousSafariCaretResult(node, offset, x2) || browser2.chrome && isSuspiciousChromeCaretResult(node, offset, x2))
            node = void 0;
        }
      }
    }
    if (!node || !view.docView.dom.contains(node)) {
      let line = LineView.find(view.docView, lineStart);
      if (!line)
        return yOffset > block.top + block.height / 2 ? block.to : block.from;
      ({ node, offset } = domPosAtCoords(line.dom, x2, y3));
    }
    let nearest = view.docView.nearest(node);
    if (!nearest)
      return null;
    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
      let rect = nearest.dom.getBoundingClientRect();
      return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
    } else {
      return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
    }
  }
  function posAtCoordsImprecise(view, contentRect, block, x2, y3) {
    let into = Math.round((x2 - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
      let textHeight = view.viewState.heightOracle.textHeight;
      let line = Math.floor((y3 - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
      into += line * view.viewState.heightOracle.lineLength;
    }
    let content2 = view.state.sliceDoc(block.from, block.to);
    return block.from + findColumn(content2, into, view.state.tabSize);
  }
  function isSuspiciousSafariCaretResult(node, offset, x2) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
      return false;
    for (let next = node.nextSibling; next; next = next.nextSibling)
      if (next.nodeType != 1 || next.nodeName != "BR")
        return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x2;
  }
  function isSuspiciousChromeCaretResult(node, offset, x2) {
    if (offset != 0)
      return false;
    for (let cur = node; ; ) {
      let parent = cur.parentNode;
      if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
        return false;
      if (parent.classList.contains("cm-line"))
        break;
      cur = parent;
    }
    let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x2 - rect.left > 5;
  }
  function blockAt(view, pos) {
    let line = view.lineBlockAt(pos);
    if (Array.isArray(line.type))
      for (let l4 of line.type) {
        if (l4.to > pos || l4.to == pos && (l4.to == line.to || l4.type == BlockType.Text))
          return l4;
      }
    return line;
  }
  function moveToLineBoundary(view, start, forward, includeWrap) {
    let line = blockAt(view, start.head);
    let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
      let editorRect = view.dom.getBoundingClientRect();
      let direction = view.textDirectionAt(line.from);
      let pos = view.posAtCoords({
        x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
        y: (coords.top + coords.bottom) / 2
      });
      if (pos != null)
        return EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
  }
  function moveByChar(view, start, forward, by) {
    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
    let direction = view.textDirectionAt(line.from);
    for (let cur = start, check = null; ; ) {
      let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;
      if (!next) {
        if (line.number == (forward ? view.state.doc.lines : 1))
          return cur;
        char = "\n";
        line = view.state.doc.line(line.number + (forward ? 1 : -1));
        spans = view.bidiSpans(line);
        next = view.visualLineSide(line, !forward);
      }
      if (!check) {
        if (!by)
          return next;
        check = by(char);
      } else if (!check(char)) {
        return cur;
      }
      cur = next;
    }
  }
  function byGroup(view, pos, start) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start);
    return (next) => {
      let nextCat = categorize(next);
      if (cat == CharCategory.Space)
        cat = nextCat;
      return cat == nextCat;
    };
  }
  function moveVertically(view, start, forward, distance) {
    let startPos = start.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0))
      return EditorSelection.cursor(startPos, start.assoc);
    let goal = start.goalColumn, startY;
    let rect = view.contentDOM.getBoundingClientRect();
    let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
    if (startCoords) {
      if (goal == null)
        goal = startCoords.left - rect.left;
      startY = dir < 0 ? startCoords.top : startCoords.bottom;
    } else {
      let line = view.viewState.lineBlockAt(startPos);
      if (goal == null)
        goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
      startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
    for (let extra = 0; ; extra += 10) {
      let curY = startY + (dist2 + extra) * dir;
      let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
      if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
        let charRect = view.docView.coordsForChar(pos);
        let assoc = !charRect || curY < charRect.top ? -1 : 1;
        return EditorSelection.cursor(pos, assoc, void 0, goal);
      }
    }
  }
  function skipAtomicRanges(atoms, pos, bias) {
    for (; ; ) {
      let moved = 0;
      for (let set2 of atoms) {
        set2.between(pos - 1, pos + 1, (from, to, value) => {
          if (pos > from && pos < to) {
            let side = moved || bias || (pos - from < to - pos ? -1 : 1);
            pos = side < 0 ? from : to;
            moved = side;
          }
        });
      }
      if (!moved)
        return pos;
    }
  }
  function skipAtoms(view, oldPos, pos) {
    let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f3) => f3(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
    return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
  }
  var InputState = class {
    setSelectionOrigin(origin) {
      this.lastSelectionOrigin = origin;
      this.lastSelectionTime = Date.now();
    }
    constructor(view) {
      this.view = view;
      this.lastKeyCode = 0;
      this.lastKeyTime = 0;
      this.lastTouchTime = 0;
      this.lastFocusTime = 0;
      this.lastScrollTop = 0;
      this.lastScrollLeft = 0;
      this.pendingIOSKey = void 0;
      this.tabFocusMode = -1;
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastContextMenu = 0;
      this.scrollHandlers = [];
      this.handlers = /* @__PURE__ */ Object.create(null);
      this.composing = -1;
      this.compositionFirstChange = null;
      this.compositionEndedAt = 0;
      this.compositionPendingKey = false;
      this.compositionPendingChange = false;
      this.mouseSelection = null;
      this.draggedContent = null;
      this.handleEvent = this.handleEvent.bind(this);
      this.notifiedFocused = view.hasFocus;
      if (browser2.safari)
        view.contentDOM.addEventListener("input", () => null);
      if (browser2.gecko)
        firefoxCopyCutHack(view.contentDOM.ownerDocument);
    }
    handleEvent(event) {
      if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
        return;
      if (event.type == "keydown" && this.keydown(event))
        return;
      this.runHandlers(event.type, event);
    }
    runHandlers(type2, event) {
      let handlers2 = this.handlers[type2];
      if (handlers2) {
        for (let observer of handlers2.observers)
          observer(this.view, event);
        for (let handler of handlers2.handlers) {
          if (event.defaultPrevented)
            break;
          if (handler(this.view, event)) {
            event.preventDefault();
            break;
          }
        }
      }
    }
    ensureHandlers(plugins) {
      let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
      for (let type2 in handlers2)
        if (type2 != "scroll") {
          let passive = !handlers2[type2].handlers.length;
          let exists = prev[type2];
          if (exists && passive != !exists.handlers.length) {
            dom.removeEventListener(type2, this.handleEvent);
            exists = null;
          }
          if (!exists)
            dom.addEventListener(type2, this.handleEvent, { passive });
        }
      for (let type2 in prev)
        if (type2 != "scroll" && !handlers2[type2])
          dom.removeEventListener(type2, this.handleEvent);
      this.handlers = handlers2;
    }
    keydown(event) {
      this.lastKeyCode = event.keyCode;
      this.lastKeyTime = Date.now();
      if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
        return true;
      if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
        this.tabFocusMode = -1;
      if (browser2.android && browser2.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
        this.view.observer.delayAndroidKey(event.key, event.keyCode);
        return true;
      }
      let pending;
      if (browser2.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
        this.pendingIOSKey = pending || event;
        setTimeout(() => this.flushIOSKey(), 250);
        return true;
      }
      if (event.keyCode != 229)
        this.view.observer.forceFlush();
      return false;
    }
    flushIOSKey(change) {
      let key = this.pendingIOSKey;
      if (!key)
        return false;
      if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
        return false;
      this.pendingIOSKey = void 0;
      return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : void 0);
    }
    ignoreDuringComposition(event) {
      if (!/^key/.test(event.type))
        return false;
      if (this.composing > 0)
        return true;
      if (browser2.safari && !browser2.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
        this.compositionPendingKey = false;
        return true;
      }
      return false;
    }
    startMouseSelection(mouseSelection) {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
      this.mouseSelection = mouseSelection;
    }
    update(update) {
      this.view.observer.update(update);
      if (this.mouseSelection)
        this.mouseSelection.update(update);
      if (this.draggedContent && update.docChanged)
        this.draggedContent = this.draggedContent.map(update.changes);
      if (update.transactions.length)
        this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
    }
  };
  function bindHandler(plugin, handler) {
    return (view, event) => {
      try {
        return handler.call(plugin, event, view);
      } catch (e4) {
        logException(view.state, e4);
      }
    };
  }
  function computeHandlers(plugins) {
    let result = /* @__PURE__ */ Object.create(null);
    function record(type2) {
      return result[type2] || (result[type2] = { observers: [], handlers: [] });
    }
    for (let plugin of plugins) {
      let spec = plugin.spec;
      if (spec && spec.domEventHandlers)
        for (let type2 in spec.domEventHandlers) {
          let f3 = spec.domEventHandlers[type2];
          if (f3)
            record(type2).handlers.push(bindHandler(plugin.value, f3));
        }
      if (spec && spec.domEventObservers)
        for (let type2 in spec.domEventObservers) {
          let f3 = spec.domEventObservers[type2];
          if (f3)
            record(type2).observers.push(bindHandler(plugin.value, f3));
        }
    }
    for (let type2 in handlers)
      record(type2).handlers.push(handlers[type2]);
    for (let type2 in observers)
      record(type2).observers.push(observers[type2]);
    return result;
  }
  var PendingKeys = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
  ];
  var EmacsyPendingKeys = "dthko";
  var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
  var dragScrollMargin = 6;
  function dragScrollSpeed(dist2) {
    return Math.max(0, dist2) * 0.7 + 8;
  }
  function dist(a4, b4) {
    return Math.max(Math.abs(a4.clientX - b4.clientX), Math.abs(a4.clientY - b4.clientY));
  }
  var MouseSelection = class {
    constructor(view, startEvent, style, mustSelect) {
      this.view = view;
      this.startEvent = startEvent;
      this.style = style;
      this.mustSelect = mustSelect;
      this.scrollSpeed = { x: 0, y: 0 };
      this.scrolling = -1;
      this.lastEvent = startEvent;
      this.scrollParent = scrollableParent(view.contentDOM);
      this.atoms = view.state.facet(atomicRanges).map((f3) => f3(view));
      let doc2 = view.contentDOM.ownerDocument;
      doc2.addEventListener("mousemove", this.move = this.move.bind(this));
      doc2.addEventListener("mouseup", this.up = this.up.bind(this));
      this.extend = startEvent.shiftKey;
      this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
      this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
    }
    start(event) {
      if (this.dragging === false)
        this.select(event);
    }
    move(event) {
      var _a2;
      if (event.buttons == 0)
        return this.destroy();
      if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
        return;
      this.select(this.lastEvent = event);
      let sx = 0, sy = 0;
      let rect = ((_a2 = this.scrollParent) === null || _a2 === void 0 ? void 0 : _a2.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight };
      let margins = getScrollMargins(this.view);
      if (event.clientX - margins.left <= rect.left + dragScrollMargin)
        sx = -dragScrollSpeed(rect.left - event.clientX);
      else if (event.clientX + margins.right >= rect.right - dragScrollMargin)
        sx = dragScrollSpeed(event.clientX - rect.right);
      if (event.clientY - margins.top <= rect.top + dragScrollMargin)
        sy = -dragScrollSpeed(rect.top - event.clientY);
      else if (event.clientY + margins.bottom >= rect.bottom - dragScrollMargin)
        sy = dragScrollSpeed(event.clientY - rect.bottom);
      this.setScrollSpeed(sx, sy);
    }
    up(event) {
      if (this.dragging == null)
        this.select(this.lastEvent);
      if (!this.dragging)
        event.preventDefault();
      this.destroy();
    }
    destroy() {
      this.setScrollSpeed(0, 0);
      let doc2 = this.view.contentDOM.ownerDocument;
      doc2.removeEventListener("mousemove", this.move);
      doc2.removeEventListener("mouseup", this.up);
      this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
    }
    setScrollSpeed(sx, sy) {
      this.scrollSpeed = { x: sx, y: sy };
      if (sx || sy) {
        if (this.scrolling < 0)
          this.scrolling = setInterval(() => this.scroll(), 50);
      } else if (this.scrolling > -1) {
        clearInterval(this.scrolling);
        this.scrolling = -1;
      }
    }
    scroll() {
      if (this.scrollParent) {
        this.scrollParent.scrollLeft += this.scrollSpeed.x;
        this.scrollParent.scrollTop += this.scrollSpeed.y;
      } else {
        this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);
      }
      if (this.dragging === false)
        this.select(this.lastEvent);
    }
    skipAtoms(sel) {
      let ranges = null;
      for (let i4 = 0; i4 < sel.ranges.length; i4++) {
        let range = sel.ranges[i4], updated = null;
        if (range.empty) {
          let pos = skipAtomicRanges(this.atoms, range.from, 0);
          if (pos != range.from)
            updated = EditorSelection.cursor(pos, -1);
        } else {
          let from = skipAtomicRanges(this.atoms, range.from, -1);
          let to = skipAtomicRanges(this.atoms, range.to, 1);
          if (from != range.from || to != range.to)
            updated = EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);
        }
        if (updated) {
          if (!ranges)
            ranges = sel.ranges.slice();
          ranges[i4] = updated;
        }
      }
      return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
    }
    select(event) {
      let { view } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
      if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false))
        this.view.dispatch({
          selection,
          userEvent: "select.pointer"
        });
      this.mustSelect = false;
    }
    update(update) {
      if (update.transactions.some((tr) => tr.isUserEvent("input.type")))
        this.destroy();
      else if (this.style.update(update))
        setTimeout(() => this.select(this.lastEvent), 20);
    }
  };
  function addsSelectionRange(view, event) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser2.mac ? event.metaKey : event.ctrlKey;
  }
  function dragMovesSelection(view, event) {
    let facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser2.mac ? !event.altKey : !event.ctrlKey;
  }
  function isInPrimarySelection(view, event) {
    let { main: main2 } = view.state.selection;
    if (main2.empty)
      return false;
    let sel = getSelection(view.root);
    if (!sel || sel.rangeCount == 0)
      return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i4 = 0; i4 < rects.length; i4++) {
      let rect = rects[i4];
      if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
        return true;
    }
    return false;
  }
  function eventBelongsToEditor(view, event) {
    if (!event.bubbles)
      return true;
    if (event.defaultPrevented)
      return false;
    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
      if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
        return false;
    return true;
  }
  var handlers = /* @__PURE__ */ Object.create(null);
  var observers = /* @__PURE__ */ Object.create(null);
  var brokenClipboardAPI = browser2.ie && browser2.ie_version < 15 || browser2.ios && browser2.webkit_version < 604;
  function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
      view.focus();
      target.remove();
      doPaste(view, target.value);
    }, 50);
  }
  function doPaste(view, input) {
    let { state } = view, changes, i4 = 1, text = state.toText(input);
    let byLine = text.lines == state.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r3) => r3.empty) && lastLinewiseCopy == text.toString();
    if (linewise) {
      let lastLine = -1;
      changes = state.changeByRange((range) => {
        let line = state.doc.lineAt(range.from);
        if (line.from == lastLine)
          return { range };
        lastLine = line.from;
        let insert2 = state.toText((byLine ? text.line(i4++).text : input) + state.lineBreak);
        return {
          changes: { from: line.from, insert: insert2 },
          range: EditorSelection.cursor(range.from + insert2.length)
        };
      });
    } else if (byLine) {
      changes = state.changeByRange((range) => {
        let line = text.line(i4++);
        return {
          changes: { from: range.from, to: range.to, insert: line.text },
          range: EditorSelection.cursor(range.from + line.length)
        };
      });
    } else {
      changes = state.replaceSelection(text);
    }
    view.dispatch(changes, {
      userEvent: "input.paste",
      scrollIntoView: true
    });
  }
  observers.scroll = (view) => {
    view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
    view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
  };
  handlers.keydown = (view, event) => {
    view.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27 && view.inputState.tabFocusMode != 0)
      view.inputState.tabFocusMode = Date.now() + 2e3;
    return false;
  };
  observers.touchstart = (view, e4) => {
    view.inputState.lastTouchTime = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
  };
  observers.touchmove = (view) => {
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlers.mousedown = (view, event) => {
    view.observer.flush();
    if (view.inputState.lastTouchTime > Date.now() - 2e3)
      return false;
    let style = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
      style = makeStyle(view, event);
      if (style)
        break;
    }
    if (!style && event.button == 0)
      style = basicMouseSelection(view, event);
    if (style) {
      let mustFocus = !view.hasFocus;
      view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
      if (mustFocus)
        view.observer.ignore(() => {
          focusPreventScroll(view.contentDOM);
          let active = view.root.activeElement;
          if (active && !active.contains(view.contentDOM))
            active.blur();
        });
      let mouseSel = view.inputState.mouseSelection;
      if (mouseSel) {
        mouseSel.start(event);
        return mouseSel.dragging === false;
      }
    }
    return false;
  };
  function rangeForClick(view, pos, bias, type2) {
    if (type2 == 1) {
      return EditorSelection.cursor(pos, bias);
    } else if (type2 == 2) {
      return groupAt(view.state, pos, bias);
    } else {
      let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
      let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
      if (to < view.state.doc.length && to == line.to)
        to++;
      return EditorSelection.range(from, to);
    }
  }
  var insideY = (y3, rect) => y3 >= rect.top && y3 <= rect.bottom;
  var inside = (x2, y3, rect) => insideY(y3, rect) && x2 >= rect.left && x2 <= rect.right;
  function findPositionSide(view, pos, x2, y3) {
    let line = LineView.find(view.docView, pos);
    if (!line)
      return 1;
    let off = pos - line.posAtStart;
    if (off == 0)
      return 1;
    if (off == line.length)
      return -1;
    let before = line.coordsAt(off, -1);
    if (before && inside(x2, y3, before))
      return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x2, y3, after))
      return 1;
    return before && insideY(y3, before) ? -1 : 1;
  }
  function queryPos(view, event) {
    let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
  }
  var BadMouseDetail = browser2.ie && browser2.ie_version <= 11;
  var lastMouseDown = null;
  var lastMouseDownCount = 0;
  var lastMouseDownTime = 0;
  function getClickType(event) {
    if (!BadMouseDetail)
      return event.detail;
    let last = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
  }
  function basicMouseSelection(view, event) {
    let start = queryPos(view, event), type2 = getClickType(event);
    let startSel = view.state.selection;
    return {
      update(update) {
        if (update.docChanged) {
          start.pos = update.changes.mapPos(start.pos);
          startSel = startSel.map(update.changes);
        }
      },
      get(event2, extend4, multiple) {
        let cur = queryPos(view, event2), removed;
        let range = rangeForClick(view, cur.pos, cur.bias, type2);
        if (start.pos != cur.pos && !extend4) {
          let startRange = rangeForClick(view, start.pos, start.bias, type2);
          let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
          range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
        }
        if (extend4)
          return startSel.replaceRange(startSel.main.extend(range.from, range.to));
        else if (multiple && type2 == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos)))
          return removed;
        else if (multiple)
          return startSel.addRange(range);
        else
          return EditorSelection.create([range]);
      }
    };
  }
  function removeRangeAround(sel, pos) {
    for (let i4 = 0; i4 < sel.ranges.length; i4++) {
      let { from, to } = sel.ranges[i4];
      if (from <= pos && to >= pos)
        return EditorSelection.create(sel.ranges.slice(0, i4).concat(sel.ranges.slice(i4 + 1)), sel.mainIndex == i4 ? 0 : sel.mainIndex - (sel.mainIndex > i4 ? 1 : 0));
    }
    return null;
  }
  handlers.dragstart = (view, event) => {
    let { selection: { main: range } } = view.state;
    if (event.target.draggable) {
      let cView = view.docView.nearest(event.target);
      if (cView && cView.isWidget) {
        let from = cView.posAtStart, to = from + cView.length;
        if (from >= range.to || to <= range.from)
          range = EditorSelection.range(from, to);
      }
    }
    let { inputState } = view;
    if (inputState.mouseSelection)
      inputState.mouseSelection.dragging = true;
    inputState.draggedContent = range;
    if (event.dataTransfer) {
      event.dataTransfer.setData("Text", view.state.sliceDoc(range.from, range.to));
      event.dataTransfer.effectAllowed = "copyMove";
    }
    return false;
  };
  handlers.dragend = (view) => {
    view.inputState.draggedContent = null;
    return false;
  };
  function dropText(view, event, text, direct) {
    if (!text)
      return;
    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let { draggedContent } = view.inputState;
    let del = direct && draggedContent && dragMovesSelection(view, event) ? { from: draggedContent.from, to: draggedContent.to } : null;
    let ins = { from: dropPos, insert: text };
    let changes = view.state.changes(del ? [del, ins] : ins);
    view.focus();
    view.dispatch({
      changes,
      selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
      userEvent: del ? "move.drop" : "input.drop"
    });
    view.inputState.draggedContent = null;
  }
  handlers.drop = (view, event) => {
    if (!event.dataTransfer)
      return false;
    if (view.state.readOnly)
      return true;
    let files = event.dataTransfer.files;
    if (files && files.length) {
      let text = Array(files.length), read = 0;
      let finishFile = () => {
        if (++read == files.length)
          dropText(view, event, text.filter((s4) => s4 != null).join(view.state.lineBreak), false);
      };
      for (let i4 = 0; i4 < files.length; i4++) {
        let reader = new FileReader();
        reader.onerror = finishFile;
        reader.onload = () => {
          if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
            text[i4] = reader.result;
          finishFile();
        };
        reader.readAsText(files[i4]);
      }
      return true;
    } else {
      let text = event.dataTransfer.getData("Text");
      if (text) {
        dropText(view, event, text, true);
        return true;
      }
    }
    return false;
  };
  handlers.paste = (view, event) => {
    if (view.state.readOnly)
      return true;
    view.observer.flush();
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      doPaste(view, data.getData("text/plain") || data.getData("text/uri-list"));
      return true;
    } else {
      capturePaste(view);
      return false;
    }
  };
  function captureCopy(view, text) {
    let parent = view.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(() => {
      target.remove();
      view.focus();
    }, 50);
  }
  function copiedRange(state) {
    let content2 = [], ranges = [], linewise = false;
    for (let range of state.selection.ranges)
      if (!range.empty) {
        content2.push(state.sliceDoc(range.from, range.to));
        ranges.push(range);
      }
    if (!content2.length) {
      let upto = -1;
      for (let { from } of state.selection.ranges) {
        let line = state.doc.lineAt(from);
        if (line.number > upto) {
          content2.push(line.text);
          ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
        }
        upto = line.number;
      }
      linewise = true;
    }
    return { text: content2.join(state.lineBreak), ranges, linewise };
  }
  var lastLinewiseCopy = null;
  handlers.copy = handlers.cut = (view, event) => {
    let { text, ranges, linewise } = copiedRange(view.state);
    if (!text && !linewise)
      return false;
    lastLinewiseCopy = linewise ? text : null;
    if (event.type == "cut" && !view.state.readOnly)
      view.dispatch({
        changes: ranges,
        scrollIntoView: true,
        userEvent: "delete.cut"
      });
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      data.clearData();
      data.setData("text/plain", text);
      return true;
    } else {
      captureCopy(view, text);
      return false;
    }
  };
  var isFocusChange = /* @__PURE__ */ Annotation.define();
  function focusChangeTransaction(state, focus) {
    let effects = [];
    for (let getEffect of state.facet(focusChangeEffect)) {
      let effect = getEffect(state, focus);
      if (effect)
        effects.push(effect);
    }
    return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
  }
  function updateForFocusChange(view) {
    setTimeout(() => {
      let focus = view.hasFocus;
      if (focus != view.inputState.notifiedFocused) {
        let tr = focusChangeTransaction(view.state, focus);
        if (tr)
          view.dispatch(tr);
        else
          view.update([]);
      }
    }, 10);
  }
  observers.focus = (view) => {
    view.inputState.lastFocusTime = Date.now();
    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
      view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
      view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
    }
    updateForFocusChange(view);
  };
  observers.blur = (view) => {
    view.observer.clearSelectionRange();
    updateForFocusChange(view);
  };
  observers.compositionstart = observers.compositionupdate = (view) => {
    if (view.observer.editContext)
      return;
    if (view.inputState.compositionFirstChange == null)
      view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
      view.inputState.composing = 0;
    }
  };
  observers.compositionend = (view) => {
    if (view.observer.editContext)
      return;
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionPendingKey = true;
    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
    view.inputState.compositionFirstChange = null;
    if (browser2.chrome && browser2.android) {
      view.observer.flushSoon();
    } else if (view.inputState.compositionPendingChange) {
      Promise.resolve().then(() => view.observer.flush());
    } else {
      setTimeout(() => {
        if (view.inputState.composing < 0 && view.docView.hasComposition)
          view.update([]);
      }, 50);
    }
  };
  observers.contextmenu = (view) => {
    view.inputState.lastContextMenu = Date.now();
  };
  handlers.beforeinput = (view, event) => {
    var _a2;
    let pending;
    if (browser2.chrome && browser2.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
      view.observer.delayAndroidKey(pending.key, pending.keyCode);
      if (pending.key == "Backspace" || pending.key == "Delete") {
        let startViewHeight = ((_a2 = window.visualViewport) === null || _a2 === void 0 ? void 0 : _a2.height) || 0;
        setTimeout(() => {
          var _a3;
          if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
            view.contentDOM.blur();
            view.focus();
          }
        }, 100);
      }
    }
    if (browser2.ios && event.inputType == "deleteContentForward") {
      view.observer.flushSoon();
    }
    if (browser2.safari && event.inputType == "insertText" && view.inputState.composing >= 0) {
      setTimeout(() => observers.compositionend(view, event), 20);
    }
    return false;
  };
  var appliedFirefoxHack = /* @__PURE__ */ new Set();
  function firefoxCopyCutHack(doc2) {
    if (!appliedFirefoxHack.has(doc2)) {
      appliedFirefoxHack.add(doc2);
      doc2.addEventListener("copy", () => {
      });
      doc2.addEventListener("cut", () => {
      });
    }
  }
  var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
  var HeightOracle = class {
    constructor(lineWrapping) {
      this.lineWrapping = lineWrapping;
      this.doc = Text.empty;
      this.heightSamples = {};
      this.lineHeight = 14;
      this.charWidth = 7;
      this.textHeight = 14;
      this.lineLength = 30;
      this.heightChanged = false;
    }
    heightForGap(from, to) {
      let lines2 = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
      if (this.lineWrapping)
        lines2 += Math.max(0, Math.ceil((to - from - lines2 * this.lineLength * 0.5) / this.lineLength));
      return this.lineHeight * lines2;
    }
    heightForLine(length) {
      if (!this.lineWrapping)
        return this.lineHeight;
      let lines2 = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
      return lines2 * this.lineHeight;
    }
    setDoc(doc2) {
      this.doc = doc2;
      return this;
    }
    mustRefreshForWrapping(whiteSpace) {
      return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
      let newHeight = false;
      for (let i4 = 0; i4 < lineHeights.length; i4++) {
        let h4 = lineHeights[i4];
        if (h4 < 0) {
          i4++;
        } else if (!this.heightSamples[Math.floor(h4 * 10)]) {
          newHeight = true;
          this.heightSamples[Math.floor(h4 * 10)] = true;
        }
      }
      return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
      let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
      let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
      this.lineWrapping = lineWrapping;
      this.lineHeight = lineHeight;
      this.charWidth = charWidth;
      this.textHeight = textHeight;
      this.lineLength = lineLength;
      if (changed) {
        this.heightSamples = {};
        for (let i4 = 0; i4 < knownHeights.length; i4++) {
          let h4 = knownHeights[i4];
          if (h4 < 0)
            i4++;
          else
            this.heightSamples[Math.floor(h4 * 10)] = true;
        }
      }
      return changed;
    }
  };
  var MeasuredHeights = class {
    constructor(from, heights) {
      this.from = from;
      this.heights = heights;
      this.index = 0;
    }
    get more() {
      return this.index < this.heights.length;
    }
  };
  var BlockInfo = class _BlockInfo {
    /**
    @internal
    */
    constructor(from, length, top2, height, _content) {
      this.from = from;
      this.length = length;
      this.top = top2;
      this.height = height;
      this._content = _content;
    }
    /**
    The type of element this is. When querying lines, this may be
    an array of all the blocks that make up the line.
    */
    get type() {
      return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
    }
    /**
    The end of the element as a document position.
    */
    get to() {
      return this.from + this.length;
    }
    /**
    The bottom position of the element.
    */
    get bottom() {
      return this.top + this.height;
    }
    /**
    If this is a widget block, this will return the widget
    associated with it.
    */
    get widget() {
      return this._content instanceof PointDecoration ? this._content.widget : null;
    }
    /**
    If this is a textblock, this holds the number of line breaks
    that appear in widgets inside the block.
    */
    get widgetLineBreaks() {
      return typeof this._content == "number" ? this._content : 0;
    }
    /**
    @internal
    */
    join(other) {
      let content2 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
      return new _BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content2);
    }
  };
  var QueryType = /* @__PURE__ */ function(QueryType2) {
    QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
    QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
    QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
    return QueryType2;
  }(QueryType || (QueryType = {}));
  var Epsilon = 1e-3;
  var HeightMap = class _HeightMap {
    constructor(length, height, flags = 2) {
      this.length = length;
      this.height = height;
      this.flags = flags;
    }
    get outdated() {
      return (this.flags & 2) > 0;
    }
    set outdated(value) {
      this.flags = (value ? 2 : 0) | this.flags & ~2;
    }
    setHeight(oracle, height) {
      if (this.height != height) {
        if (Math.abs(this.height - height) > Epsilon)
          oracle.heightChanged = true;
        this.height = height;
      }
    }
    // Base case is to replace a leaf node, which simply builds a tree
    // from the new nodes and returns that (HeightMapBranch and
    // HeightMapGap override this to actually use from/to)
    replace(_from, _to, nodes) {
      return _HeightMap.of(nodes);
    }
    // Again, these are base cases, and are overridden for branch and gap nodes.
    decomposeLeft(_to, result) {
      result.push(this);
    }
    decomposeRight(_from, result) {
      result.push(this);
    }
    applyChanges(decorations2, oldDoc, oracle, changes) {
      let me = this, doc2 = oracle.doc;
      for (let i4 = changes.length - 1; i4 >= 0; i4--) {
        let { fromA, toA, fromB, toB } = changes[i4];
        let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
        let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
        toB += end.to - toA;
        toA = end.to;
        while (i4 > 0 && start.from <= changes[i4 - 1].toA) {
          fromA = changes[i4 - 1].fromA;
          fromB = changes[i4 - 1].fromB;
          i4--;
          if (fromA < start.from)
            start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
        }
        fromB += start.from - fromA;
        fromA = start.from;
        let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
        me = me.replace(fromA, toA, nodes);
      }
      return me.updateHeight(oracle, 0);
    }
    static empty() {
      return new HeightMapText(0, 0);
    }
    // nodes uses null values to indicate the position of line breaks.
    // There are never line breaks at the start or end of the array, or
    // two line breaks next to each other, and the array isn't allowed
    // to be empty (same restrictions as return value from the builder).
    static of(nodes) {
      if (nodes.length == 1)
        return nodes[0];
      let i4 = 0, j2 = nodes.length, before = 0, after = 0;
      for (; ; ) {
        if (i4 == j2) {
          if (before > after * 2) {
            let split = nodes[i4 - 1];
            if (split.break)
              nodes.splice(--i4, 1, split.left, null, split.right);
            else
              nodes.splice(--i4, 1, split.left, split.right);
            j2 += 1 + split.break;
            before -= split.size;
          } else if (after > before * 2) {
            let split = nodes[j2];
            if (split.break)
              nodes.splice(j2, 1, split.left, null, split.right);
            else
              nodes.splice(j2, 1, split.left, split.right);
            j2 += 2 + split.break;
            after -= split.size;
          } else {
            break;
          }
        } else if (before < after) {
          let next = nodes[i4++];
          if (next)
            before += next.size;
        } else {
          let next = nodes[--j2];
          if (next)
            after += next.size;
        }
      }
      let brk = 0;
      if (nodes[i4 - 1] == null) {
        brk = 1;
        i4--;
      } else if (nodes[i4] == null) {
        brk = 1;
        j2++;
      }
      return new HeightMapBranch(_HeightMap.of(nodes.slice(0, i4)), brk, _HeightMap.of(nodes.slice(j2)));
    }
  };
  HeightMap.prototype.size = 1;
  var HeightMapBlock = class extends HeightMap {
    constructor(length, height, deco) {
      super(length, height);
      this.deco = deco;
    }
    blockAt(_height, _oracle, top2, offset) {
      return new BlockInfo(offset, this.length, top2, this.height, this.deco || 0);
    }
    lineAt(_value, _type, oracle, top2, offset) {
      return this.blockAt(0, oracle, top2, offset);
    }
    forEachLine(from, to, oracle, top2, offset, f3) {
      if (from <= offset + this.length && to >= offset)
        f3(this.blockAt(0, oracle, top2, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      this.outdated = false;
      return this;
    }
    toString() {
      return `block(${this.length})`;
    }
  };
  var HeightMapText = class _HeightMapText extends HeightMapBlock {
    constructor(length, height) {
      super(length, height, null);
      this.collapsed = 0;
      this.widgetHeight = 0;
      this.breaks = 0;
    }
    blockAt(_height, _oracle, top2, offset) {
      return new BlockInfo(offset, this.length, top2, this.height, this.breaks);
    }
    replace(_from, _to, nodes) {
      let node = nodes[0];
      if (nodes.length == 1 && (node instanceof _HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
        if (node instanceof HeightMapGap)
          node = new _HeightMapText(node.length, this.height);
        else
          node.height = this.height;
        if (!this.outdated)
          node.outdated = false;
        return node;
      } else {
        return HeightMap.of(nodes);
      }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      else if (force || this.outdated)
        this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
      this.outdated = false;
      return this;
    }
    toString() {
      return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
  };
  var HeightMapGap = class _HeightMapGap extends HeightMap {
    constructor(length) {
      super(length, 0);
    }
    heightMetrics(oracle, offset) {
      let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
      let lines2 = lastLine - firstLine + 1;
      let perLine, perChar = 0;
      if (oracle.lineWrapping) {
        let totalPerLine = Math.min(this.height, oracle.lineHeight * lines2);
        perLine = totalPerLine / lines2;
        if (this.length > lines2 + 1)
          perChar = (this.height - totalPerLine) / (this.length - lines2 - 1);
      } else {
        perLine = this.height / lines2;
      }
      return { firstLine, lastLine, perLine, perChar };
    }
    blockAt(height, oracle, top2, offset) {
      let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
      if (oracle.lineWrapping) {
        let guess = offset + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length));
        let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
        let lineTop = Math.max(top2, height - lineHeight / 2);
        return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
      } else {
        let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
        let { from, length } = oracle.doc.line(firstLine + line);
        return new BlockInfo(from, length, top2 + perLine * line, perLine, 0);
      }
    }
    lineAt(value, type2, oracle, top2, offset) {
      if (type2 == QueryType.ByHeight)
        return this.blockAt(value, oracle, top2, offset);
      if (type2 == QueryType.ByPosNoHeight) {
        let { from, to } = oracle.doc.lineAt(value);
        return new BlockInfo(from, to - from, 0, 0, 0);
      }
      let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
      let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
      let linesAbove = line.number - firstLine;
      let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
      return new BlockInfo(line.from, line.length, Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)), lineHeight, 0);
    }
    forEachLine(from, to, oracle, top2, offset, f3) {
      from = Math.max(from, offset);
      to = Math.min(to, offset + this.length);
      let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
      for (let pos = from, lineTop = top2; pos <= to; ) {
        let line = oracle.doc.lineAt(pos);
        if (pos == from) {
          let linesAbove = line.number - firstLine;
          lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
        }
        let lineHeight = perLine + perChar * line.length;
        f3(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
        lineTop += lineHeight;
        pos = line.to + 1;
      }
    }
    replace(from, to, nodes) {
      let after = this.length - to;
      if (after > 0) {
        let last = nodes[nodes.length - 1];
        if (last instanceof _HeightMapGap)
          nodes[nodes.length - 1] = new _HeightMapGap(last.length + after);
        else
          nodes.push(null, new _HeightMapGap(after - 1));
      }
      if (from > 0) {
        let first = nodes[0];
        if (first instanceof _HeightMapGap)
          nodes[0] = new _HeightMapGap(from + first.length);
        else
          nodes.unshift(new _HeightMapGap(from - 1), null);
      }
      return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
      result.push(new _HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
      result.push(null, new _HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let end = offset + this.length;
      if (measured && measured.from <= offset + this.length && measured.more) {
        let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
        if (measured.from > offset)
          nodes.push(new _HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
        while (pos <= end && measured.more) {
          let len = oracle.doc.lineAt(pos).length;
          if (nodes.length)
            nodes.push(null);
          let height = measured.heights[measured.index++];
          if (singleHeight == -1)
            singleHeight = height;
          else if (Math.abs(height - singleHeight) >= Epsilon)
            singleHeight = -2;
          let line = new HeightMapText(len, height);
          line.outdated = false;
          nodes.push(line);
          pos += len + 1;
        }
        if (pos <= end)
          nodes.push(null, new _HeightMapGap(end - pos).updateHeight(oracle, pos));
        let result = HeightMap.of(nodes);
        if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
          oracle.heightChanged = true;
        return result;
      } else if (force || this.outdated) {
        this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
        this.outdated = false;
      }
      return this;
    }
    toString() {
      return `gap(${this.length})`;
    }
  };
  var HeightMapBranch = class extends HeightMap {
    constructor(left, brk, right) {
      super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
      this.left = left;
      this.right = right;
      this.size = left.size + right.size;
    }
    get break() {
      return this.flags & 1;
    }
    blockAt(height, oracle, top2, offset) {
      let mid = top2 + this.left.height;
      return height < mid ? this.left.blockAt(height, oracle, top2, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type2, oracle, top2, offset) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      let left = type2 == QueryType.ByHeight ? value < rightTop : value < rightOffset;
      let base2 = left ? this.left.lineAt(value, type2, oracle, top2, offset) : this.right.lineAt(value, type2, oracle, rightTop, rightOffset);
      if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
        return base2;
      let subQuery = type2 == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
      if (left)
        return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
      else
        return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset).join(base2);
    }
    forEachLine(from, to, oracle, top2, offset, f3) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      if (this.break) {
        if (from < rightOffset)
          this.left.forEachLine(from, to, oracle, top2, offset, f3);
        if (to >= rightOffset)
          this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f3);
      } else {
        let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top2, offset);
        if (from < mid.from)
          this.left.forEachLine(from, mid.from - 1, oracle, top2, offset, f3);
        if (mid.to >= from && mid.from <= to)
          f3(mid);
        if (to > mid.to)
          this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f3);
      }
    }
    replace(from, to, nodes) {
      let rightStart = this.left.length + this.break;
      if (to < rightStart)
        return this.balanced(this.left.replace(from, to, nodes), this.right);
      if (from > this.left.length)
        return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
      let result = [];
      if (from > 0)
        this.decomposeLeft(from, result);
      let left = result.length;
      for (let node of nodes)
        result.push(node);
      if (from > 0)
        mergeGaps(result, left - 1);
      if (to < this.length) {
        let right = result.length;
        this.decomposeRight(to, result);
        mergeGaps(result, right);
      }
      return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
      let left = this.left.length;
      if (to <= left)
        return this.left.decomposeLeft(to, result);
      result.push(this.left);
      if (this.break) {
        left++;
        if (to >= left)
          result.push(null);
      }
      if (to > left)
        this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from, result) {
      let left = this.left.length, right = left + this.break;
      if (from >= right)
        return this.right.decomposeRight(from - right, result);
      if (from < left)
        this.left.decomposeRight(from, result);
      if (this.break && from < right)
        result.push(null);
      result.push(this.right);
    }
    balanced(left, right) {
      if (left.size > 2 * right.size || right.size > 2 * left.size)
        return HeightMap.of(this.break ? [left, null, right] : [left, right]);
      this.left = left;
      this.right = right;
      this.height = left.height + right.height;
      this.outdated = left.outdated || right.outdated;
      this.size = left.size + right.size;
      this.length = left.length + this.break + right.length;
      return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
      if (measured && measured.from <= offset + left.length && measured.more)
        rebalance = left = left.updateHeight(oracle, offset, force, measured);
      else
        left.updateHeight(oracle, offset, force);
      if (measured && measured.from <= rightStart + right.length && measured.more)
        rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
      else
        right.updateHeight(oracle, rightStart, force);
      if (rebalance)
        return this.balanced(left, right);
      this.height = this.left.height + this.right.height;
      this.outdated = false;
      return this;
    }
    toString() {
      return this.left + (this.break ? " " : "-") + this.right;
    }
  };
  function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
      nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
  }
  var relevantWidgetHeight = 5;
  var NodeBuilder = class _NodeBuilder {
    constructor(pos, oracle) {
      this.pos = pos;
      this.oracle = oracle;
      this.nodes = [];
      this.lineStart = -1;
      this.lineEnd = -1;
      this.covering = null;
      this.writtenTo = pos;
    }
    get isCovered() {
      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
      if (this.lineStart > -1) {
        let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
        if (last instanceof HeightMapText)
          last.length += end - this.pos;
        else if (end > this.pos || !this.isCovered)
          this.nodes.push(new HeightMapText(end - this.pos, -1));
        this.writtenTo = end;
        if (to > end) {
          this.nodes.push(null);
          this.writtenTo++;
          this.lineStart = -1;
        }
      }
      this.pos = to;
    }
    point(from, to, deco) {
      if (from < to || deco.heightRelevant) {
        let height = deco.widget ? deco.widget.estimatedHeight : 0;
        let breaks = deco.widget ? deco.widget.lineBreaks : 0;
        if (height < 0)
          height = this.oracle.lineHeight;
        let len = to - from;
        if (deco.block) {
          this.addBlock(new HeightMapBlock(len, height, deco));
        } else if (len || breaks || height >= relevantWidgetHeight) {
          this.addLineDeco(height, breaks, len);
        }
      } else if (to > from) {
        this.span(from, to);
      }
      if (this.lineEnd > -1 && this.lineEnd < this.pos)
        this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
      if (this.lineStart > -1)
        return;
      let { from, to } = this.oracle.doc.lineAt(this.pos);
      this.lineStart = from;
      this.lineEnd = to;
      if (this.writtenTo < from) {
        if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
          this.nodes.push(this.blankContent(this.writtenTo, from - 1));
        this.nodes.push(null);
      }
      if (this.pos > from)
        this.nodes.push(new HeightMapText(this.pos - from, -1));
      this.writtenTo = this.pos;
    }
    blankContent(from, to) {
      let gap = new HeightMapGap(to - from);
      if (this.oracle.doc.lineAt(from).to == to)
        gap.flags |= 4;
      return gap;
    }
    ensureLine() {
      this.enterLine();
      let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
      if (last instanceof HeightMapText)
        return last;
      let line = new HeightMapText(0, -1);
      this.nodes.push(line);
      return line;
    }
    addBlock(block) {
      this.enterLine();
      let deco = block.deco;
      if (deco && deco.startSide > 0 && !this.isCovered)
        this.ensureLine();
      this.nodes.push(block);
      this.writtenTo = this.pos = this.pos + block.length;
      if (deco && deco.endSide > 0)
        this.covering = block;
    }
    addLineDeco(height, breaks, length) {
      let line = this.ensureLine();
      line.length += length;
      line.collapsed += length;
      line.widgetHeight = Math.max(line.widgetHeight, height);
      line.breaks += breaks;
      this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
      let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
      if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
        this.nodes.push(new HeightMapText(0, -1));
      else if (this.writtenTo < this.pos || last == null)
        this.nodes.push(this.blankContent(this.writtenTo, this.pos));
      let pos = from;
      for (let node of this.nodes) {
        if (node instanceof HeightMapText)
          node.updateHeight(this.oracle, pos);
        pos += node ? node.length : 1;
      }
      return this.nodes;
    }
    // Always called with a region that on both sides either stretches
    // to a line break or the end of the document.
    // The returned array uses null to indicate line breaks, but never
    // starts or ends in a line break, or has multiple line breaks next
    // to each other.
    static build(oracle, decorations2, from, to) {
      let builder = new _NodeBuilder(from, oracle);
      RangeSet.spans(decorations2, from, to, builder, 0);
      return builder.finish(from);
    }
  };
  function heightRelevantDecoChanges(a4, b4, diff) {
    let comp = new DecorationComparator2();
    RangeSet.compare(a4, b4, diff, comp, 0);
    return comp.changes;
  }
  var DecorationComparator2 = class {
    constructor() {
      this.changes = [];
    }
    compareRange() {
    }
    comparePoint(from, to, a4, b4) {
      if (from < to || a4 && a4.heightRelevant || b4 && b4.heightRelevant)
        addRange(from, to, this.changes, 5);
    }
  };
  function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
    let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
      if (parent.nodeType == 1) {
        let elt = parent;
        let style = window.getComputedStyle(elt);
        if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
          let parentRect = elt.getBoundingClientRect();
          left = Math.max(left, parentRect.left);
          right = Math.min(right, parentRect.right);
          top2 = Math.max(top2, parentRect.top);
          bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);
        }
        parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
      } else if (parent.nodeType == 11) {
        parent = parent.host;
      } else {
        break;
      }
    }
    return {
      left: left - rect.left,
      right: Math.max(left, right) - rect.left,
      top: top2 - (rect.top + paddingTop),
      bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
    };
  }
  function fullPixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    return {
      left: 0,
      right: rect.right - rect.left,
      top: paddingTop,
      bottom: rect.bottom - (rect.top + paddingTop)
    };
  }
  var LineGap = class {
    constructor(from, to, size) {
      this.from = from;
      this.to = to;
      this.size = size;
    }
    static same(a4, b4) {
      if (a4.length != b4.length)
        return false;
      for (let i4 = 0; i4 < a4.length; i4++) {
        let gA = a4[i4], gB = b4[i4];
        if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
          return false;
      }
      return true;
    }
    draw(viewState, wrapping) {
      return Decoration.replace({
        widget: new LineGapWidget(this.size * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
      }).range(this.from, this.to);
    }
  };
  var LineGapWidget = class extends WidgetType {
    constructor(size, vertical) {
      super();
      this.size = size;
      this.vertical = vertical;
    }
    eq(other) {
      return other.size == this.size && other.vertical == this.vertical;
    }
    toDOM() {
      let elt = document.createElement("div");
      if (this.vertical) {
        elt.style.height = this.size + "px";
      } else {
        elt.style.width = this.size + "px";
        elt.style.height = "2px";
        elt.style.display = "inline-block";
      }
      return elt;
    }
    get estimatedHeight() {
      return this.vertical ? this.size : -1;
    }
  };
  var ViewState = class {
    constructor(state) {
      this.state = state;
      this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
      this.inView = true;
      this.paddingTop = 0;
      this.paddingBottom = 0;
      this.contentDOMWidth = 0;
      this.contentDOMHeight = 0;
      this.editorHeight = 0;
      this.editorWidth = 0;
      this.scrollTop = 0;
      this.scrolledToBottom = false;
      this.scaleX = 1;
      this.scaleY = 1;
      this.scrollAnchorPos = 0;
      this.scrollAnchorHeight = -1;
      this.scaler = IdScaler;
      this.scrollTarget = null;
      this.printing = false;
      this.mustMeasureContent = true;
      this.defaultTextDirection = Direction.LTR;
      this.visibleRanges = [];
      this.mustEnforceCursorAssoc = false;
      let guessWrapping = state.facet(contentAttributes).some((v3) => typeof v3 != "function" && v3.class == "cm-lineWrapping");
      this.heightOracle = new HeightOracle(guessWrapping);
      this.stateDeco = state.facet(decorations).filter((d3) => typeof d3 != "function");
      this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
      for (let i4 = 0; i4 < 2; i4++) {
        this.viewport = this.getViewport(0, null);
        if (!this.updateForViewport())
          break;
      }
      this.updateViewportLines();
      this.lineGaps = this.ensureLineGaps([]);
      this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
      this.computeVisibleRanges();
    }
    updateForViewport() {
      let viewports = [this.viewport], { main: main2 } = this.state.selection;
      for (let i4 = 0; i4 <= 1; i4++) {
        let pos = i4 ? main2.head : main2.anchor;
        if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
          let { from, to } = this.lineBlockAt(pos);
          viewports.push(new Viewport(from, to));
        }
      }
      this.viewports = viewports.sort((a4, b4) => a4.from - b4.from);
      return this.updateScaler();
    }
    updateScaler() {
      let scaler = this.scaler;
      this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
      return scaler.eq(this.scaler) ? 0 : 2;
    }
    updateViewportLines() {
      this.viewportLines = [];
      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
        this.viewportLines.push(scaleBlock(block, this.scaler));
      });
    }
    update(update, scrollTarget = null) {
      this.state = update.state;
      let prevDeco = this.stateDeco;
      this.stateDeco = this.state.facet(decorations).filter((d3) => typeof d3 != "function");
      let contentChanges = update.changedRanges;
      let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
      let prevHeight = this.heightMap.height;
      let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
      this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
      if (this.heightMap.height != prevHeight)
        update.flags |= 2;
      if (scrollAnchor) {
        this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
        this.scrollAnchorHeight = scrollAnchor.top;
      } else {
        this.scrollAnchorPos = -1;
        this.scrollAnchorHeight = this.heightMap.height;
      }
      let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
      if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
        viewport = this.getViewport(0, scrollTarget);
      let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
      this.viewport = viewport;
      update.flags |= this.updateForViewport();
      if (viewportChange || !update.changes.empty || update.flags & 2)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
      update.flags |= this.computeVisibleRanges();
      if (scrollTarget)
        this.scrollTarget = scrollTarget;
      if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
        this.mustEnforceCursorAssoc = true;
    }
    measure(view) {
      let dom = view.contentDOM, style = window.getComputedStyle(dom);
      let oracle = this.heightOracle;
      let whiteSpace = style.whiteSpace;
      this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
      let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
      let domRect = dom.getBoundingClientRect();
      let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
      this.contentDOMHeight = domRect.height;
      this.mustMeasureContent = false;
      let result = 0, bias = 0;
      if (domRect.width && domRect.height) {
        let { scaleX, scaleY } = getScale(dom, domRect);
        if (scaleX > 5e-3 && Math.abs(this.scaleX - scaleX) > 5e-3 || scaleY > 5e-3 && Math.abs(this.scaleY - scaleY) > 5e-3) {
          this.scaleX = scaleX;
          this.scaleY = scaleY;
          result |= 8;
          refresh = measureContent = true;
        }
      }
      let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
      let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
      if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
        this.paddingTop = paddingTop;
        this.paddingBottom = paddingBottom;
        result |= 8 | 2;
      }
      if (this.editorWidth != view.scrollDOM.clientWidth) {
        if (oracle.lineWrapping)
          measureContent = true;
        this.editorWidth = view.scrollDOM.clientWidth;
        result |= 8;
      }
      let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
      if (this.scrollTop != scrollTop) {
        this.scrollAnchorHeight = -1;
        this.scrollTop = scrollTop;
      }
      this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
      let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
      let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
      this.pixelViewport = pixelViewport;
      let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
      if (inView != this.inView) {
        this.inView = inView;
        if (inView)
          measureContent = true;
      }
      if (!this.inView && !this.scrollTarget)
        return 0;
      let contentWidth = domRect.width;
      if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
        this.contentDOMWidth = domRect.width;
        this.editorHeight = view.scrollDOM.clientHeight;
        result |= 8;
      }
      if (measureContent) {
        let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
        if (oracle.mustRefreshForHeights(lineHeights))
          refresh = true;
        if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
          let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
          refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
          if (refresh) {
            view.docView.minWidth = 0;
            result |= 8;
          }
        }
        if (dTop > 0 && dBottom > 0)
          bias = Math.max(dTop, dBottom);
        else if (dTop < 0 && dBottom < 0)
          bias = Math.min(dTop, dBottom);
        oracle.heightChanged = false;
        for (let vp of this.viewports) {
          let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
          this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
        }
        if (oracle.heightChanged)
          result |= 2;
      }
      let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
      if (viewportChange) {
        if (result & 2)
          result |= this.updateScaler();
        this.viewport = this.getViewport(bias, this.scrollTarget);
        result |= this.updateForViewport();
      }
      if (result & 2 || viewportChange)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
      result |= this.computeVisibleRanges();
      if (this.mustEnforceCursorAssoc) {
        this.mustEnforceCursorAssoc = false;
        view.docView.enforceCursorAssoc();
      }
      return result;
    }
    get visibleTop() {
      return this.scaler.fromDOM(this.pixelViewport.top);
    }
    get visibleBottom() {
      return this.scaler.fromDOM(this.pixelViewport.bottom);
    }
    getViewport(bias, scrollTarget) {
      let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
      let map2 = this.heightMap, oracle = this.heightOracle;
      let { visibleTop, visibleBottom } = this;
      let viewport = new Viewport(map2.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map2.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
      if (scrollTarget) {
        let { head } = scrollTarget.range;
        if (head < viewport.from || head > viewport.to) {
          let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
          let block = map2.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
          if (scrollTarget.y == "center")
            topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
          else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
            topPos = block.top;
          else
            topPos = block.bottom - viewHeight;
          viewport = new Viewport(map2.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map2.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
        }
      }
      return viewport;
    }
    mapViewport(viewport, changes) {
      let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
      return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
    }
    // Checks if a given viewport covers the visible part of the
    // document and not too much beyond that.
    viewportIsAppropriate({ from, to }, bias = 0) {
      if (!this.inView)
        return true;
      let { top: top2 } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
      let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
      let { visibleTop, visibleBottom } = this;
      return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(
        -bias,
        250
        /* VP.MaxCoverMargin */
      ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(
        bias,
        250
        /* VP.MaxCoverMargin */
      ))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
    }
    mapLineGaps(gaps, changes) {
      if (!gaps.length || changes.empty)
        return gaps;
      let mapped = [];
      for (let gap of gaps)
        if (!changes.touchesRange(gap.from, gap.to))
          mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
      return mapped;
    }
    // Computes positions in the viewport where the start or end of a
    // line should be hidden, trying to reuse existing line gaps when
    // appropriate to avoid unneccesary redraws.
    // Uses crude character-counting for the positioning and sizing,
    // since actual DOM coordinates aren't always available and
    // predictable. Relies on generous margins (see LG.Margin) to hide
    // the artifacts this might produce from the user.
    ensureLineGaps(current, mayMeasure) {
      let wrapping = this.heightOracle.lineWrapping;
      let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
      if (this.defaultTextDirection != Direction.LTR && !wrapping)
        return [];
      let gaps = [];
      let addGap = (from, to, line, structure) => {
        if (to - from < halfMargin)
          return;
        let sel = this.state.selection.main, avoid = [sel.from];
        if (!sel.empty)
          avoid.push(sel.to);
        for (let pos of avoid) {
          if (pos > from && pos < to) {
            addGap(from, pos - 10, line, structure);
            addGap(pos + 10, to, line, structure);
            return;
          }
        }
        let gap = find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
        if (!gap) {
          if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r3) => r3.from <= to && r3.to >= to)) {
            let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
            if (lineStart > from)
              to = lineStart;
          }
          gap = new LineGap(from, to, this.gapSize(line, from, to, structure));
        }
        gaps.push(gap);
      };
      let checkLine = (line) => {
        if (line.length < doubleMargin || line.type != BlockType.Text)
          return;
        let structure = lineStructure(line.from, line.to, this.stateDeco);
        if (structure.total < doubleMargin)
          return;
        let target = this.scrollTarget ? this.scrollTarget.range.head : null;
        let viewFrom, viewTo;
        if (wrapping) {
          let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
          let top2, bot;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
            top2 = targetFrac - spaceFrac;
            bot = targetFrac + spaceFrac;
          } else {
            top2 = (this.visibleTop - line.top - marginHeight) / line.height;
            bot = (this.visibleBottom - line.top + marginHeight) / line.height;
          }
          viewFrom = findPosition(structure, top2);
          viewTo = findPosition(structure, bot);
        } else {
          let totalWidth = structure.total * this.heightOracle.charWidth;
          let marginWidth = margin * this.heightOracle.charWidth;
          let left, right;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
            left = targetFrac - spaceFrac;
            right = targetFrac + spaceFrac;
          } else {
            left = (this.pixelViewport.left - marginWidth) / totalWidth;
            right = (this.pixelViewport.right + marginWidth) / totalWidth;
          }
          viewFrom = findPosition(structure, left);
          viewTo = findPosition(structure, right);
        }
        if (viewFrom > line.from)
          addGap(line.from, viewFrom, line, structure);
        if (viewTo < line.to)
          addGap(viewTo, line.to, line, structure);
      };
      for (let line of this.viewportLines) {
        if (Array.isArray(line.type))
          line.type.forEach(checkLine);
        else
          checkLine(line);
      }
      return gaps;
    }
    gapSize(line, from, to, structure) {
      let fraction = findFraction(structure, to) - findFraction(structure, from);
      if (this.heightOracle.lineWrapping) {
        return line.height * fraction;
      } else {
        return structure.total * this.heightOracle.charWidth * fraction;
      }
    }
    updateLineGaps(gaps) {
      if (!LineGap.same(gaps, this.lineGaps)) {
        this.lineGaps = gaps;
        this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
      }
    }
    computeVisibleRanges() {
      let deco = this.stateDeco;
      if (this.lineGaps.length)
        deco = deco.concat(this.lineGapDeco);
      let ranges = [];
      RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
        span(from, to) {
          ranges.push({ from, to });
        },
        point() {
        }
      }, 20);
      let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r3, i4) => r3.from != ranges[i4].from || r3.to != ranges[i4].to);
      this.visibleRanges = ranges;
      return changed ? 4 : 0;
    }
    lineBlockAt(pos) {
      return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b4) => b4.from <= pos && b4.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
      return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l4) => l4.top <= height && l4.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
    }
    scrollAnchorAt(scrollTop) {
      let block = this.lineBlockAtHeight(scrollTop + 8);
      return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
    }
    elementAtHeight(height) {
      return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
    }
    get docHeight() {
      return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
      return this.docHeight + this.paddingTop + this.paddingBottom;
    }
  };
  var Viewport = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  function lineStructure(from, to, stateDeco) {
    let ranges = [], pos = from, total = 0;
    RangeSet.spans(stateDeco, from, to, {
      span() {
      },
      point(from2, to2) {
        if (from2 > pos) {
          ranges.push({ from: pos, to: from2 });
          total += from2 - pos;
        }
        pos = to2;
      }
    }, 20);
    if (pos < to) {
      ranges.push({ from: pos, to });
      total += to - pos;
    }
    return { total, ranges };
  }
  function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
      return ranges[0].from;
    if (ratio >= 1)
      return ranges[ranges.length - 1].to;
    let dist2 = Math.floor(total * ratio);
    for (let i4 = 0; ; i4++) {
      let { from, to } = ranges[i4], size = to - from;
      if (dist2 <= size)
        return from + dist2;
      dist2 -= size;
    }
  }
  function findFraction(structure, pos) {
    let counted = 0;
    for (let { from, to } of structure.ranges) {
      if (pos <= to) {
        counted += pos - from;
        break;
      }
      counted += to - from;
    }
    return counted / structure.total;
  }
  function find(array, f3) {
    for (let val of array)
      if (f3(val))
        return val;
    return void 0;
  }
  var IdScaler = {
    toDOM(n4) {
      return n4;
    },
    fromDOM(n4) {
      return n4;
    },
    scale: 1,
    eq(other) {
      return other == this;
    }
  };
  var BigScaler = class _BigScaler {
    constructor(oracle, heightMap, viewports) {
      let vpHeight = 0, base2 = 0, domBase = 0;
      this.viewports = viewports.map(({ from, to }) => {
        let top2 = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
        let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
        vpHeight += bottom - top2;
        return { from, to, top: top2, bottom, domTop: 0, domBottom: 0 };
      });
      this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
      for (let obj of this.viewports) {
        obj.domTop = domBase + (obj.top - base2) * this.scale;
        domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
        base2 = obj.bottom;
      }
    }
    toDOM(n4) {
      for (let i4 = 0, base2 = 0, domBase = 0; ; i4++) {
        let vp = i4 < this.viewports.length ? this.viewports[i4] : null;
        if (!vp || n4 < vp.top)
          return domBase + (n4 - base2) * this.scale;
        if (n4 <= vp.bottom)
          return vp.domTop + (n4 - vp.top);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    fromDOM(n4) {
      for (let i4 = 0, base2 = 0, domBase = 0; ; i4++) {
        let vp = i4 < this.viewports.length ? this.viewports[i4] : null;
        if (!vp || n4 < vp.domTop)
          return base2 + (n4 - domBase) / this.scale;
        if (n4 <= vp.domBottom)
          return vp.top + (n4 - vp.domTop);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    eq(other) {
      if (!(other instanceof _BigScaler))
        return false;
      return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp, i4) => vp.from == other.viewports[i4].from && vp.to == other.viewports[i4].to);
    }
  };
  function scaleBlock(block, scaler) {
    if (scaler.scale == 1)
      return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b4) => scaleBlock(b4, scaler)) : block._content);
  }
  var theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
  var darkTheme2 = /* @__PURE__ */ Facet.define({ combine: (values) => values.indexOf(true) > -1 });
  var baseThemeID = /* @__PURE__ */ StyleModule.newName();
  var baseLightID = /* @__PURE__ */ StyleModule.newName();
  var baseDarkID = /* @__PURE__ */ StyleModule.newName();
  var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
  function buildTheme(main2, spec, scopes) {
    return new StyleModule(spec, {
      finish(sel) {
        return /&/.test(sel) ? sel.replace(/&\w*/, (m3) => {
          if (m3 == "&")
            return main2;
          if (!scopes || !scopes[m3])
            throw new RangeError(`Unsupported selector: ${m3}`);
          return scopes[m3];
        }) : main2 + " " + sel;
      }
    });
  }
  var baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
    "&": {
      position: "relative !important",
      boxSizing: "border-box",
      "&.cm-focused": {
        // Provide a simple default outline to make sure a focused
        // editor is visually distinct. Can't leave the default behavior
        // because that will apply to the content element, which is
        // inside the scrollable container and doesn't include the
        // gutters. We also can't use an 'auto' outline, since those
        // are, for some reason, drawn behind the element content, which
        // will cause things like the active line background to cover
        // the outline (#297).
        outline: "1px dotted #212121"
      },
      display: "flex !important",
      flexDirection: "column"
    },
    ".cm-scroller": {
      display: "flex !important",
      alignItems: "flex-start !important",
      fontFamily: "monospace",
      lineHeight: 1.4,
      height: "100%",
      overflowX: "auto",
      position: "relative",
      zIndex: 0
    },
    ".cm-content": {
      margin: 0,
      flexGrow: 2,
      flexShrink: 0,
      display: "block",
      whiteSpace: "pre",
      wordWrap: "normal",
      // https://github.com/codemirror/dev/issues/456
      boxSizing: "border-box",
      minHeight: "100%",
      padding: "4px 0",
      outline: "none",
      "&[contenteditable=true]": {
        WebkitUserModify: "read-write-plaintext-only"
      }
    },
    ".cm-lineWrapping": {
      whiteSpace_fallback: "pre-wrap",
      // For IE
      whiteSpace: "break-spaces",
      wordBreak: "break-word",
      // For Safari, which doesn't support overflow-wrap: anywhere
      overflowWrap: "anywhere",
      flexShrink: 1
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
      display: "block",
      padding: "0 2px 0 6px"
    },
    ".cm-layer": {
      position: "absolute",
      left: 0,
      top: 0,
      contain: "size style",
      "& > *": {
        position: "absolute"
      }
    },
    "&light .cm-selectionBackground": {
      background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
      background: "#222"
    },
    "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#d7d4f0"
    },
    "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#233"
    },
    ".cm-cursorLayer": {
      pointerEvents: "none"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
      animation: "steps(1) cm-blink 1.2s infinite"
    },
    // Two animations defined so that we can switch between them to
    // restart the animation without forcing another style
    // recomputation.
    "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    ".cm-cursor, .cm-dropCursor": {
      borderLeft: "1.2px solid black",
      marginLeft: "-0.6px",
      pointerEvents: "none"
    },
    ".cm-cursor": {
      display: "none"
    },
    "&dark .cm-cursor": {
      borderLeftColor: "#444"
    },
    ".cm-dropCursor": {
      position: "absolute"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
      display: "block"
    },
    ".cm-iso": {
      unicodeBidi: "isolate"
    },
    ".cm-announced": {
      position: "fixed",
      top: "-10000px"
    },
    "@media print": {
      ".cm-announced": { display: "none" }
    },
    "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
    "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-gutters": {
      flexShrink: 0,
      display: "flex",
      height: "100%",
      boxSizing: "border-box",
      insetInlineStart: 0,
      zIndex: 200
    },
    "&light .cm-gutters": {
      backgroundColor: "#f5f5f5",
      color: "#6c6c6c",
      borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
      backgroundColor: "#333338",
      color: "#ccc"
    },
    ".cm-gutter": {
      display: "flex !important",
      // Necessary -- prevents margin collapsing
      flexDirection: "column",
      flexShrink: 0,
      boxSizing: "border-box",
      minHeight: "100%",
      overflow: "hidden"
    },
    ".cm-gutterElement": {
      boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      padding: "0 3px 0 5px",
      minWidth: "20px",
      textAlign: "right",
      whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
      backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
      backgroundColor: "#222227"
    },
    ".cm-panels": {
      boxSizing: "border-box",
      position: "sticky",
      left: 0,
      right: 0
    },
    "&light .cm-panels": {
      backgroundColor: "#f5f5f5",
      color: "black"
    },
    "&light .cm-panels-top": {
      borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
      borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tab": {
      display: "inline-block",
      overflow: "hidden",
      verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
      verticalAlign: "text-top",
      height: "1em",
      width: 0,
      display: "inline"
    },
    ".cm-placeholder": {
      color: "#888",
      display: "inline-block",
      verticalAlign: "top"
    },
    ".cm-highlightSpace:before": {
      content: "attr(data-display)",
      position: "absolute",
      pointerEvents: "none",
      color: "#888"
    },
    ".cm-highlightTab": {
      backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
      backgroundSize: "auto 100%",
      backgroundPosition: "right 90%",
      backgroundRepeat: "no-repeat"
    },
    ".cm-trailingSpace": {
      backgroundColor: "#ff332255"
    },
    ".cm-button": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      padding: ".2em 1em",
      borderRadius: "1px"
    },
    "&light .cm-button": {
      backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
      }
    },
    "&dark .cm-button": {
      backgroundImage: "linear-gradient(#393939, #111)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#111, #333)"
      }
    },
    ".cm-textfield": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      border: "1px solid silver",
      padding: ".2em .5em"
    },
    "&light .cm-textfield": {
      backgroundColor: "white"
    },
    "&dark .cm-textfield": {
      border: "1px solid #555",
      backgroundColor: "inherit"
    }
  }, lightDarkIDs);
  var LineBreakPlaceholder = "\uFFFF";
  var DOMReader = class {
    constructor(points, state) {
      this.points = points;
      this.text = "";
      this.lineSeparator = state.facet(EditorState.lineSeparator);
    }
    append(text) {
      this.text += text;
    }
    lineBreak() {
      this.text += LineBreakPlaceholder;
    }
    readRange(start, end) {
      if (!start)
        return this;
      let parent = start.parentNode;
      for (let cur = start; ; ) {
        this.findPointBefore(parent, cur);
        let oldLen = this.text.length;
        this.readNode(cur);
        let next = cur.nextSibling;
        if (next == end)
          break;
        let view = ContentView.get(cur), nextView = ContentView.get(next);
        if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore) && this.text.length > oldLen)
          this.lineBreak();
        cur = next;
      }
      this.findPointBefore(parent, end);
      return this;
    }
    readTextNode(node) {
      let text = node.nodeValue;
      for (let point of this.points)
        if (point.node == node)
          point.pos = this.text.length + Math.min(point.offset, text.length);
      for (let off = 0, re2 = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
        let nextBreak = -1, breakSize = 1, m3;
        if (this.lineSeparator) {
          nextBreak = text.indexOf(this.lineSeparator, off);
          breakSize = this.lineSeparator.length;
        } else if (m3 = re2.exec(text)) {
          nextBreak = m3.index;
          breakSize = m3[0].length;
        }
        this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
        if (nextBreak < 0)
          break;
        this.lineBreak();
        if (breakSize > 1) {
          for (let point of this.points)
            if (point.node == node && point.pos > this.text.length)
              point.pos -= breakSize - 1;
        }
        off = nextBreak + breakSize;
      }
    }
    readNode(node) {
      if (node.cmIgnore)
        return;
      let view = ContentView.get(node);
      let fromView = view && view.overrideDOMText;
      if (fromView != null) {
        this.findPointInside(node, fromView.length);
        for (let i4 = fromView.iter(); !i4.next().done; ) {
          if (i4.lineBreak)
            this.lineBreak();
          else
            this.append(i4.value);
        }
      } else if (node.nodeType == 3) {
        this.readTextNode(node);
      } else if (node.nodeName == "BR") {
        if (node.nextSibling)
          this.lineBreak();
      } else if (node.nodeType == 1) {
        this.readRange(node.firstChild, null);
      }
    }
    findPointBefore(node, next) {
      for (let point of this.points)
        if (point.node == node && node.childNodes[point.offset] == next)
          point.pos = this.text.length;
    }
    findPointInside(node, length) {
      for (let point of this.points)
        if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
          point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
    }
  };
  function isAtEnd(parent, node, offset) {
    for (; ; ) {
      if (!node || offset < maxOffset(node))
        return false;
      if (node == parent)
        return true;
      offset = domIndex(node) + 1;
      node = node.parentNode;
    }
  }
  var DOMPoint = class {
    constructor(node, offset) {
      this.node = node;
      this.offset = offset;
      this.pos = -1;
    }
  };
  var DOMChange = class {
    constructor(view, start, end, typeOver) {
      this.typeOver = typeOver;
      this.bounds = null;
      this.text = "";
      this.domChanged = start > -1;
      let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
      if (view.state.readOnly && start > -1) {
        this.newSel = null;
      } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
        let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
        let reader = new DOMReader(selPoints, view.state);
        reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
        this.text = reader.text;
        this.newSel = selectionFromPoints(selPoints, this.bounds.from);
      } else {
        let domSel = view.observer.selectionRange;
        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
        let vp = view.viewport;
        if ((browser2.ios || browser2.chrome) && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {
          let from = Math.min(head, anchor), to = Math.max(head, anchor);
          let offFrom = vp.from - from, offTo = vp.to - to;
          if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {
            head = 0;
            anchor = view.state.doc.length;
          }
        }
        this.newSel = EditorSelection.single(anchor, head);
      }
    }
  };
  function applyDOMChange(view, domChange) {
    let change;
    let { newSel } = domChange, sel = view.state.selection.main;
    let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
    if (domChange.bounds) {
      let { from, to } = domChange.bounds;
      let preferredPos = sel.from, preferredSide = null;
      if (lastKey === 8 || browser2.android && domChange.text.length < to - from) {
        preferredPos = sel.to;
        preferredSide = "end";
      }
      let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
      if (diff) {
        if (browser2.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
          diff.toB--;
        change = {
          from: from + diff.from,
          to: from + diff.toA,
          insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
        };
      }
    } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
      newSel = null;
    }
    if (!change && !newSel)
      return false;
    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
      change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
      change = {
        from: sel.from,
        to: sel.to,
        insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
      };
    } else if ((browser2.mac || browser2.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
      if (newSel && change.insert.length == 2)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
    } else if (browser2.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
      if (newSel)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
    }
    if (change) {
      return applyDOMChangeInner(view, change, newSel, lastKey);
    } else if (newSel && !newSel.main.eq(sel)) {
      let scrollIntoView2 = false, userEvent = "select";
      if (view.inputState.lastSelectionTime > Date.now() - 50) {
        if (view.inputState.lastSelectionOrigin == "select")
          scrollIntoView2 = true;
        userEvent = view.inputState.lastSelectionOrigin;
      }
      view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView2, userEvent });
      return true;
    } else {
      return false;
    }
  }
  function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
    if (browser2.ios && view.inputState.flushIOSKey(change))
      return true;
    let sel = view.state.selection.main;
    if (browser2.android && (change.to == sel.to && // GBoard will sometimes remove a space it just inserted
    // after a completion when you press enter
    (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
      return true;
    let text = change.insert.toString();
    if (view.inputState.composing >= 0)
      view.inputState.composing++;
    let defaultTr;
    let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
    if (!view.state.facet(inputHandler).some((h4) => h4(view, change.from, change.to, text, defaultInsert)))
      view.dispatch(defaultInsert());
    return true;
  }
  function applyDefaultInsert(view, change, newSel) {
    let tr, startState = view.state, sel = startState.selection.main;
    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
      let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
      let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
      tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
    } else {
      let changes = startState.changes(change);
      let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
      if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
        let replaced = view.state.sliceDoc(change.from, change.to);
        let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
        if (composition) {
          let dLen = change.insert.length - (change.to - change.from);
          compositionRange = { from: composition.from, to: composition.to - dLen };
        } else {
          compositionRange = view.state.doc.lineAt(sel.head);
        }
        let offset = sel.to - change.to, size = sel.to - sel.from;
        tr = startState.changeByRange((range) => {
          if (range.from == sel.from && range.to == sel.to)
            return { changes, range: mainSel || range.map(changes) };
          let to = range.to - offset, from = to - replaced.length;
          if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || // Unfortunately, there's no way to make multiple
          // changes in the same node work without aborting
          // composition, so cursors in the composition range are
          // ignored.
          range.to >= compositionRange.from && range.from <= compositionRange.to)
            return { range };
          let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
          return {
            changes: rangeChanges,
            range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
          };
        });
      } else {
        tr = {
          changes,
          selection: mainSel && startState.selection.replaceRange(mainSel)
        };
      }
    }
    let userEvent = "input.type";
    if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
      view.inputState.compositionPendingChange = false;
      userEvent += ".compose";
      if (view.inputState.compositionFirstChange) {
        userEvent += ".start";
        view.inputState.compositionFirstChange = false;
      }
    }
    return startState.update(tr, { userEvent, scrollIntoView: true });
  }
  function findDiff(a4, b4, preferredPos, preferredSide) {
    let minLen = Math.min(a4.length, b4.length);
    let from = 0;
    while (from < minLen && a4.charCodeAt(from) == b4.charCodeAt(from))
      from++;
    if (from == minLen && a4.length == b4.length)
      return null;
    let toA = a4.length, toB = b4.length;
    while (toA > 0 && toB > 0 && a4.charCodeAt(toA - 1) == b4.charCodeAt(toB - 1)) {
      toA--;
      toB--;
    }
    if (preferredSide == "end") {
      let adjust = Math.max(0, from - Math.min(toA, toB));
      preferredPos -= toA + adjust - from;
    }
    if (toA < from && a4.length < b4.length) {
      let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
      from -= move;
      toB = from + (toB - toA);
      toA = from;
    } else if (toB < from) {
      let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
      from -= move;
      toA = from + (toA - toB);
      toB = from;
    }
    return { from, toA, toB };
  }
  function selectionPoints(view) {
    let result = [];
    if (view.root.activeElement != view.contentDOM)
      return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
    if (anchorNode) {
      result.push(new DOMPoint(anchorNode, anchorOffset));
      if (focusNode != anchorNode || focusOffset != anchorOffset)
        result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
  }
  function selectionFromPoints(points, base2) {
    if (points.length == 0)
      return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
  }
  var observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
  };
  var useCharData = browser2.ie && browser2.ie_version <= 11;
  var DOMObserver = class {
    constructor(view) {
      this.view = view;
      this.active = false;
      this.editContext = null;
      this.selectionRange = new DOMSelectionState();
      this.selectionChanged = false;
      this.delayedFlush = -1;
      this.resizeTimeout = -1;
      this.queue = [];
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
      this.lastChange = 0;
      this.scrollTargets = [];
      this.intersection = null;
      this.resizeScroll = null;
      this.intersecting = false;
      this.gapIntersection = null;
      this.gaps = [];
      this.printQuery = null;
      this.parentCheck = -1;
      this.dom = view.contentDOM;
      this.observer = new MutationObserver((mutations) => {
        for (let mut of mutations)
          this.queue.push(mut);
        if ((browser2.ie && browser2.ie_version <= 11 || browser2.ios && view.composing) && mutations.some((m3) => m3.type == "childList" && m3.removedNodes.length || m3.type == "characterData" && m3.oldValue.length > m3.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (window.EditContext && view.constructor.EDIT_CONTEXT === true) {
        this.editContext = new EditContextManager(view);
        if (view.state.facet(editable))
          view.contentDOM.editContext = this.editContext.editContext;
      }
      if (useCharData)
        this.onCharData = (event) => {
          this.queue.push({
            target: event.target,
            type: "characterData",
            oldValue: event.prevValue
          });
          this.flushSoon();
        };
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.onResize = this.onResize.bind(this);
      this.onPrint = this.onPrint.bind(this);
      this.onScroll = this.onScroll.bind(this);
      if (window.matchMedia)
        this.printQuery = window.matchMedia("print");
      if (typeof ResizeObserver == "function") {
        this.resizeScroll = new ResizeObserver(() => {
          var _a2;
          if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
            this.onResize();
        });
        this.resizeScroll.observe(view.scrollDOM);
      }
      this.addWindowListeners(this.win = view.win);
      this.start();
      if (typeof IntersectionObserver == "function") {
        this.intersection = new IntersectionObserver((entries) => {
          if (this.parentCheck < 0)
            this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
            this.intersecting = !this.intersecting;
            if (this.intersecting != this.view.inView)
              this.onScrollChanged(document.createEvent("Event"));
          }
        }, { threshold: [0, 1e-3] });
        this.intersection.observe(this.dom);
        this.gapIntersection = new IntersectionObserver((entries) => {
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
            this.onScrollChanged(document.createEvent("Event"));
        }, {});
      }
      this.listenForScroll();
      this.readSelectionRange();
    }
    onScrollChanged(e4) {
      this.view.inputState.runHandlers("scroll", e4);
      if (this.intersecting)
        this.view.measure();
    }
    onScroll(e4) {
      if (this.intersecting)
        this.flush(false);
      if (this.editContext)
        this.view.requestMeasure(this.editContext.measureReq);
      this.onScrollChanged(e4);
    }
    onResize() {
      if (this.resizeTimeout < 0)
        this.resizeTimeout = setTimeout(() => {
          this.resizeTimeout = -1;
          this.view.requestMeasure();
        }, 50);
    }
    onPrint(event) {
      if (event.type == "change" && !event.matches)
        return;
      this.view.viewState.printing = true;
      this.view.measure();
      setTimeout(() => {
        this.view.viewState.printing = false;
        this.view.requestMeasure();
      }, 500);
    }
    updateGaps(gaps) {
      if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g3, i4) => g3 != gaps[i4]))) {
        this.gapIntersection.disconnect();
        for (let gap of gaps)
          this.gapIntersection.observe(gap);
        this.gaps = gaps;
      }
    }
    onSelectionChange(event) {
      let wasChanged = this.selectionChanged;
      if (!this.readSelectionRange() || this.delayedAndroidKey)
        return;
      let { view } = this, sel = this.selectionRange;
      if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
        return;
      let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
      if (context && context.ignoreEvent(event)) {
        if (!wasChanged)
          this.selectionChanged = false;
        return;
      }
      if ((browser2.ie && browser2.ie_version <= 11 || browser2.android && browser2.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
      sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        this.flushSoon();
      else
        this.flush(false);
    }
    readSelectionRange() {
      let { view } = this;
      let selection = getSelection(view.root);
      if (!selection)
        return false;
      let range = browser2.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view, selection) || selection;
      if (!range || this.selectionRange.eq(range))
        return false;
      let local = hasSelection(this.dom, range);
      if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
        this.view.inputState.lastFocusTime = 0;
        view.docView.updateSelection();
        return false;
      }
      this.selectionRange.setRange(range);
      if (local)
        this.selectionChanged = true;
      return true;
    }
    setSelectionRange(anchor, head) {
      this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
      this.selectionChanged = false;
    }
    clearSelectionRange() {
      this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
      this.parentCheck = -1;
      let i4 = 0, changed = null;
      for (let dom = this.dom; dom; ) {
        if (dom.nodeType == 1) {
          if (!changed && i4 < this.scrollTargets.length && this.scrollTargets[i4] == dom)
            i4++;
          else if (!changed)
            changed = this.scrollTargets.slice(0, i4);
          if (changed)
            changed.push(dom);
          dom = dom.assignedSlot || dom.parentNode;
        } else if (dom.nodeType == 11) {
          dom = dom.host;
        } else {
          break;
        }
      }
      if (i4 < this.scrollTargets.length && !changed)
        changed = this.scrollTargets.slice(0, i4);
      if (changed) {
        for (let dom of this.scrollTargets)
          dom.removeEventListener("scroll", this.onScroll);
        for (let dom of this.scrollTargets = changed)
          dom.addEventListener("scroll", this.onScroll);
      }
    }
    ignore(f3) {
      if (!this.active)
        return f3();
      try {
        this.stop();
        return f3();
      } finally {
        this.start();
        this.clear();
      }
    }
    start() {
      if (this.active)
        return;
      this.observer.observe(this.dom, observeOptions);
      if (useCharData)
        this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.active = true;
    }
    stop() {
      if (!this.active)
        return;
      this.active = false;
      this.observer.disconnect();
      if (useCharData)
        this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    // Throw away any pending changes
    clear() {
      this.processRecords();
      this.queue.length = 0;
      this.selectionChanged = false;
    }
    // Chrome Android, especially in combination with GBoard, not only
    // doesn't reliably fire regular key events, but also often
    // surrounds the effect of enter or backspace with a bunch of
    // composition events that, when interrupted, cause text duplication
    // or other kinds of corruption. This hack makes the editor back off
    // from handling DOM changes for a moment when such a key is
    // detected (via beforeinput or keydown), and then tries to flush
    // them or, if that has no effect, dispatches the given key.
    delayAndroidKey(key, keyCode) {
      var _a2;
      if (!this.delayedAndroidKey) {
        let flush = () => {
          let key2 = this.delayedAndroidKey;
          if (key2) {
            this.clearDelayedAndroidKey();
            this.view.inputState.lastKeyCode = key2.keyCode;
            this.view.inputState.lastKeyTime = Date.now();
            let flushed = this.flush();
            if (!flushed && key2.force)
              dispatchKey(this.dom, key2.key, key2.keyCode);
          }
        };
        this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
      }
      if (!this.delayedAndroidKey || key == "Enter")
        this.delayedAndroidKey = {
          key,
          keyCode,
          // Only run the key handler when no changes are detected if
          // this isn't coming right after another change, in which case
          // it is probably part of a weird chain of updates, and should
          // be ignored if it returns the DOM to its previous state.
          force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
        };
    }
    clearDelayedAndroidKey() {
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
    }
    flushSoon() {
      if (this.delayedFlush < 0)
        this.delayedFlush = this.view.win.requestAnimationFrame(() => {
          this.delayedFlush = -1;
          this.flush();
        });
    }
    forceFlush() {
      if (this.delayedFlush >= 0) {
        this.view.win.cancelAnimationFrame(this.delayedFlush);
        this.delayedFlush = -1;
      }
      this.flush();
    }
    pendingRecords() {
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
      return this.queue;
    }
    processRecords() {
      let records = this.pendingRecords();
      if (records.length)
        this.queue = [];
      let from = -1, to = -1, typeOver = false;
      for (let record of records) {
        let range = this.readMutation(record);
        if (!range)
          continue;
        if (range.typeOver)
          typeOver = true;
        if (from == -1) {
          ({ from, to } = range);
        } else {
          from = Math.min(range.from, from);
          to = Math.max(range.to, to);
        }
      }
      return { from, to, typeOver };
    }
    readChange() {
      let { from, to, typeOver } = this.processRecords();
      let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
      if (from < 0 && !newSel)
        return null;
      if (from > -1)
        this.lastChange = Date.now();
      this.view.inputState.lastFocusTime = 0;
      this.selectionChanged = false;
      let change = new DOMChange(this.view, from, to, typeOver);
      this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
      return change;
    }
    // Apply pending changes, if any
    flush(readSelection = true) {
      if (this.delayedFlush >= 0 || this.delayedAndroidKey)
        return false;
      if (readSelection)
        this.readSelectionRange();
      let domChange = this.readChange();
      if (!domChange) {
        this.view.requestMeasure();
        return false;
      }
      let startState = this.view.state;
      let handled = applyDOMChange(this.view, domChange);
      if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main)))
        this.view.update([]);
      return handled;
    }
    readMutation(rec) {
      let cView = this.view.docView.nearest(rec.target);
      if (!cView || cView.ignoreMutation(rec))
        return null;
      cView.markDirty(rec.type == "attributes");
      if (rec.type == "attributes")
        cView.flags |= 4;
      if (rec.type == "childList") {
        let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
        let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
        return {
          from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
          to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
          typeOver: false
        };
      } else if (rec.type == "characterData") {
        return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
      } else {
        return null;
      }
    }
    setWindow(win) {
      if (win != this.win) {
        this.removeWindowListeners(this.win);
        this.win = win;
        this.addWindowListeners(this.win);
      }
    }
    addWindowListeners(win) {
      win.addEventListener("resize", this.onResize);
      if (this.printQuery)
        this.printQuery.addEventListener("change", this.onPrint);
      else
        win.addEventListener("beforeprint", this.onPrint);
      win.addEventListener("scroll", this.onScroll);
      win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
      win.removeEventListener("scroll", this.onScroll);
      win.removeEventListener("resize", this.onResize);
      if (this.printQuery)
        this.printQuery.removeEventListener("change", this.onPrint);
      else
        win.removeEventListener("beforeprint", this.onPrint);
      win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    update(update) {
      if (this.editContext) {
        this.editContext.update(update);
        if (update.startState.facet(editable) != update.state.facet(editable))
          update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
      }
    }
    destroy() {
      var _a2, _b, _c;
      this.stop();
      (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
      (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      this.removeWindowListeners(this.win);
      clearTimeout(this.parentCheck);
      clearTimeout(this.resizeTimeout);
      this.win.cancelAnimationFrame(this.delayedFlush);
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
    }
  };
  function findChild(cView, dom, dir) {
    while (dom) {
      let curView = ContentView.get(dom);
      if (curView && curView.parent == cView)
        return curView;
      let parent = dom.parentNode;
      dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
  }
  function buildSelectionRangeFromRange(view, range) {
    let anchorNode = range.startContainer, anchorOffset = range.startOffset;
    let focusNode = range.endContainer, focusOffset = range.endOffset;
    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
  }
  function safariSelectionRangeHack(view, selection) {
    if (selection.getComposedRanges) {
      let range = selection.getComposedRanges(view.root)[0];
      if (range)
        return buildSelectionRangeFromRange(view, range);
    }
    let found = null;
    function read(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found = event.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    view.dom.ownerDocument.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    return found ? buildSelectionRangeFromRange(view, found) : null;
  }
  var EditContextManager = class {
    constructor(view) {
      this.from = 0;
      this.to = 0;
      this.pendingContextChange = null;
      this.resetRange(view.state);
      let context = this.editContext = new window.EditContext({
        text: view.state.doc.sliceString(this.from, this.to),
        selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
        selectionEnd: this.toContextPos(view.state.selection.main.head)
      });
      context.addEventListener("textupdate", (e4) => {
        let { anchor } = view.state.selection.main;
        let change = {
          from: this.toEditorPos(e4.updateRangeStart),
          to: this.toEditorPos(e4.updateRangeEnd),
          insert: Text.of(e4.text.split("\n"))
        };
        if (change.from == this.from && anchor < this.from)
          change.from = anchor;
        else if (change.to == this.to && anchor > this.to)
          change.to = anchor;
        if (change.from == change.to && !change.insert.length)
          return;
        this.pendingContextChange = change;
        applyDOMChangeInner(view, change, EditorSelection.single(this.toEditorPos(e4.selectionStart), this.toEditorPos(e4.selectionEnd)));
        if (this.pendingContextChange)
          this.revertPending(view.state);
      });
      context.addEventListener("characterboundsupdate", (e4) => {
        let rects = [], prev = null;
        for (let i4 = this.toEditorPos(e4.rangeStart), end = this.toEditorPos(e4.rangeEnd); i4 < end; i4++) {
          let rect = view.coordsForChar(i4);
          prev = rect && new DOMRect(rect.left, rect.right, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect();
          rects.push(prev);
        }
        context.updateCharacterBounds(e4.rangeStart, rects);
      });
      context.addEventListener("textformatupdate", (e4) => {
        let deco = [];
        for (let format of e4.getTextFormats()) {
          let lineStyle = format.underlineStyle, thickness = format.underlineThickness;
          if (lineStyle != "None" && thickness != "None") {
            let style = `text-decoration: underline ${lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${thickness == "Thin" ? 1 : 2}px`;
            deco.push(Decoration.mark({ attributes: { style } }).range(this.toEditorPos(format.rangeStart), this.toEditorPos(format.rangeEnd)));
          }
        }
        view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
      });
      context.addEventListener("compositionstart", () => {
        if (view.inputState.composing < 0) {
          view.inputState.composing = 0;
          view.inputState.compositionFirstChange = true;
        }
      });
      context.addEventListener("compositionend", () => {
        view.inputState.composing = -1;
        view.inputState.compositionFirstChange = null;
      });
      this.measureReq = { read: (view2) => {
        this.editContext.updateControlBounds(view2.contentDOM.getBoundingClientRect());
        let sel = getSelection(view2.root);
        if (sel && sel.rangeCount)
          this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
      } };
    }
    applyEdits(update) {
      let off = 0, abort = false, pending = this.pendingContextChange;
      update.changes.iterChanges((fromA, toA, _fromB, _toB, insert2) => {
        if (abort)
          return;
        let dLen = insert2.length - (toA - fromA);
        if (pending && toA >= pending.to) {
          if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert2)) {
            pending = this.pendingContextChange = null;
            off += dLen;
            return;
          } else {
            pending = null;
            this.revertPending(update.state);
          }
        }
        fromA += off;
        toA += off;
        if (toA <= this.from) {
          this.from += dLen;
          this.to += dLen;
        } else if (fromA < this.to) {
          if (fromA < this.from || toA > this.to || this.to - this.from + insert2.length > 3e4) {
            abort = true;
            return;
          }
          this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert2.toString());
          this.to += dLen;
        }
        off += dLen;
      });
      if (pending && !abort)
        this.revertPending(update.state);
      return !abort;
    }
    update(update) {
      if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
        this.pendingContextChange = null;
        this.resetRange(update.state);
        this.editContext.updateText(0, this.editContext.text.length, update.state.doc.sliceString(this.from, this.to));
        this.setSelection(update.state);
      } else if (update.docChanged || update.selectionSet) {
        this.setSelection(update.state);
      }
      if (update.geometryChanged || update.docChanged || update.selectionSet)
        update.view.requestMeasure(this.measureReq);
    }
    resetRange(state) {
      let { head } = state.selection.main;
      this.from = Math.max(
        0,
        head - 1e4
        /* CxVp.Margin */
      );
      this.to = Math.min(
        state.doc.length,
        head + 1e4
        /* CxVp.Margin */
      );
    }
    revertPending(state) {
      let pending = this.pendingContextChange;
      this.pendingContextChange = null;
      this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.to + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
    }
    setSelection(state) {
      let { main: main2 } = state.selection;
      let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main2.anchor)));
      let end = this.toContextPos(main2.head);
      if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)
        this.editContext.updateSelection(start, end);
    }
    rangeIsValid(state) {
      let { head } = state.selection.main;
      return !(this.from > 0 && head - this.from < 500 || this.to < state.doc.length && this.to - head < 500 || this.to - this.from > 1e4 * 3);
    }
    toEditorPos(contextPos) {
      return contextPos + this.from;
    }
    toContextPos(editorPos) {
      return editorPos - this.from;
    }
  };
  var EditorView = class _EditorView {
    /**
    The current editor state.
    */
    get state() {
      return this.viewState.state;
    }
    /**
    To be able to display large documents without consuming too much
    memory or overloading the browser, CodeMirror only draws the
    code that is visible (plus a margin around it) to the DOM. This
    property tells you the extent of the current drawn viewport, in
    document positions.
    */
    get viewport() {
      return this.viewState.viewport;
    }
    /**
    When there are, for example, large collapsed ranges in the
    viewport, its size can be a lot bigger than the actual visible
    content. Thus, if you are doing something like styling the
    content in the viewport, it is preferable to only do so for
    these ranges, which are the subset of the viewport that is
    actually drawn.
    */
    get visibleRanges() {
      return this.viewState.visibleRanges;
    }
    /**
    Returns false when the editor is entirely scrolled out of view
    or otherwise hidden.
    */
    get inView() {
      return this.viewState.inView;
    }
    /**
    Indicates whether the user is currently composing text via
    [IME](https://en.wikipedia.org/wiki/Input_method), and at least
    one change has been made in the current composition.
    */
    get composing() {
      return this.inputState.composing > 0;
    }
    /**
    Indicates whether the user is currently in composing state. Note
    that on some platforms, like Android, this will be the case a
    lot, since just putting the cursor on a word starts a
    composition there.
    */
    get compositionStarted() {
      return this.inputState.composing >= 0;
    }
    /**
    The document or shadow root that the view lives in.
    */
    get root() {
      return this._root;
    }
    /**
    @internal
    */
    get win() {
      return this.dom.ownerDocument.defaultView || window;
    }
    /**
    Construct a new view. You'll want to either provide a `parent`
    option, or put `view.dom` into your document after creating a
    view, so that the user can see the editor.
    */
    constructor(config = {}) {
      this.plugins = [];
      this.pluginMap = /* @__PURE__ */ new Map();
      this.editorAttrs = {};
      this.contentAttrs = {};
      this.bidiCache = [];
      this.destroyed = false;
      this.updateState = 2;
      this.measureScheduled = -1;
      this.measureRequests = [];
      this.contentDOM = document.createElement("div");
      this.scrollDOM = document.createElement("div");
      this.scrollDOM.tabIndex = -1;
      this.scrollDOM.className = "cm-scroller";
      this.scrollDOM.appendChild(this.contentDOM);
      this.announceDOM = document.createElement("div");
      this.announceDOM.className = "cm-announced";
      this.announceDOM.setAttribute("aria-live", "polite");
      this.dom = document.createElement("div");
      this.dom.appendChild(this.announceDOM);
      this.dom.appendChild(this.scrollDOM);
      if (config.parent)
        config.parent.appendChild(this.dom);
      let { dispatch } = config;
      this.dispatchTransactions = config.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr) => dispatch(tr, this))) || ((trs) => this.update(trs));
      this.dispatch = this.dispatch.bind(this);
      this._root = config.root || getRoot(config.parent) || document;
      this.viewState = new ViewState(config.state || EditorState.create(config));
      if (config.scrollTo && config.scrollTo.is(scrollIntoView))
        this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);
      this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      for (let plugin of this.plugins)
        plugin.update(this);
      this.observer = new DOMObserver(this);
      this.inputState = new InputState(this);
      this.inputState.ensureHandlers(this.plugins);
      this.docView = new DocView(this);
      this.mountStyles();
      this.updateAttrs();
      this.updateState = 0;
      this.requestMeasure();
    }
    dispatch(...input) {
      let trs = input.length == 1 && input[0] instanceof Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];
      this.dispatchTransactions(trs, this);
    }
    /**
    Update the view for the given array of transactions. This will
    update the visible document and selection to match the state
    produced by the transactions, and notify view plugins of the
    change. You should usually call
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
    as a primitive.
    */
    update(transactions) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
      let redrawn = false, attrsChanged = false, update;
      let state = this.state;
      for (let tr of transactions) {
        if (tr.startState != state)
          throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
        state = tr.state;
      }
      if (this.destroyed) {
        this.viewState.state = state;
        return;
      }
      let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
      if (transactions.some((tr) => tr.annotation(isFocusChange))) {
        this.inputState.notifiedFocused = focus;
        focusFlag = 1;
      } else if (focus != this.inputState.notifiedFocused) {
        this.inputState.notifiedFocused = focus;
        dispatchFocus = focusChangeTransaction(state, focus);
        if (!dispatchFocus)
          focusFlag = 1;
      }
      let pendingKey = this.observer.delayedAndroidKey, domChange = null;
      if (pendingKey) {
        this.observer.clearDelayedAndroidKey();
        domChange = this.observer.readChange();
        if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
          domChange = null;
      } else {
        this.observer.clear();
      }
      if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
        return this.setState(state);
      update = ViewUpdate.create(this, state, transactions);
      update.flags |= focusFlag;
      let scrollTarget = this.viewState.scrollTarget;
      try {
        this.updateState = 2;
        for (let tr of transactions) {
          if (scrollTarget)
            scrollTarget = scrollTarget.map(tr.changes);
          if (tr.scrollIntoView) {
            let { main: main2 } = tr.state.selection;
            scrollTarget = new ScrollTarget(main2.empty ? main2 : EditorSelection.cursor(main2.head, main2.head > main2.anchor ? -1 : 1));
          }
          for (let e4 of tr.effects)
            if (e4.is(scrollIntoView))
              scrollTarget = e4.value.clip(this.state);
        }
        this.viewState.update(update, scrollTarget);
        this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
        }
        redrawn = this.docView.update(update);
        if (this.state.facet(styleModule) != this.styleModules)
          this.mountStyles();
        attrsChanged = this.updateAttrs();
        this.showAnnouncements(transactions);
        this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
      } finally {
        this.updateState = 0;
      }
      if (update.startState.facet(theme) != update.state.facet(theme))
        this.viewState.mustMeasureContent = true;
      if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
        this.requestMeasure();
      if (redrawn)
        this.docViewUpdate();
      if (!update.empty)
        for (let listener of this.state.facet(updateListener)) {
          try {
            listener(update);
          } catch (e4) {
            logException(this.state, e4, "update listener");
          }
        }
      if (dispatchFocus || domChange)
        Promise.resolve().then(() => {
          if (dispatchFocus && this.state == dispatchFocus.startState)
            this.dispatch(dispatchFocus);
          if (domChange) {
            if (!applyDOMChange(this, domChange) && pendingKey.force)
              dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
          }
        });
    }
    /**
    Reset the view to the given state. (This will cause the entire
    document to be redrawn and all view plugins to be reinitialized,
    so you should probably only use it when the new state isn't
    derived from the old state. Otherwise, use
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
    */
    setState(newState) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
      if (this.destroyed) {
        this.viewState.state = newState;
        return;
      }
      this.updateState = 2;
      let hadFocus = this.hasFocus;
      try {
        for (let plugin of this.plugins)
          plugin.destroy(this);
        this.viewState = new ViewState(newState);
        this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
        this.pluginMap.clear();
        for (let plugin of this.plugins)
          plugin.update(this);
        this.docView.destroy();
        this.docView = new DocView(this);
        this.inputState.ensureHandlers(this.plugins);
        this.mountStyles();
        this.updateAttrs();
        this.bidiCache = [];
      } finally {
        this.updateState = 0;
      }
      if (hadFocus)
        this.focus();
      this.requestMeasure();
    }
    updatePlugins(update) {
      let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
      if (prevSpecs != specs) {
        let newPlugins = [];
        for (let spec of specs) {
          let found = prevSpecs.indexOf(spec);
          if (found < 0) {
            newPlugins.push(new PluginInstance(spec));
          } else {
            let plugin = this.plugins[found];
            plugin.mustUpdate = update;
            newPlugins.push(plugin);
          }
        }
        for (let plugin of this.plugins)
          if (plugin.mustUpdate != update)
            plugin.destroy(this);
        this.plugins = newPlugins;
        this.pluginMap.clear();
      } else {
        for (let p4 of this.plugins)
          p4.mustUpdate = update;
      }
      for (let i4 = 0; i4 < this.plugins.length; i4++)
        this.plugins[i4].update(this);
      if (prevSpecs != specs)
        this.inputState.ensureHandlers(this.plugins);
    }
    docViewUpdate() {
      for (let plugin of this.plugins) {
        let val = plugin.value;
        if (val && val.docViewUpdate) {
          try {
            val.docViewUpdate(this);
          } catch (e4) {
            logException(this.state, e4, "doc view update listener");
          }
        }
      }
    }
    /**
    @internal
    */
    measure(flush = true) {
      if (this.destroyed)
        return;
      if (this.measureScheduled > -1)
        this.win.cancelAnimationFrame(this.measureScheduled);
      if (this.observer.delayedAndroidKey) {
        this.measureScheduled = -1;
        this.requestMeasure();
        return;
      }
      this.measureScheduled = 0;
      if (flush)
        this.observer.forceFlush();
      let updated = null;
      let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
      let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
      if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
        scrollAnchorHeight = -1;
      this.viewState.scrollAnchorHeight = -1;
      try {
        for (let i4 = 0; ; i4++) {
          if (scrollAnchorHeight < 0) {
            if (isScrolledToBottom(sDOM)) {
              scrollAnchorPos = -1;
              scrollAnchorHeight = this.viewState.heightMap.height;
            } else {
              let block = this.viewState.scrollAnchorAt(scrollTop);
              scrollAnchorPos = block.from;
              scrollAnchorHeight = block.top;
            }
          }
          this.updateState = 1;
          let changed = this.viewState.measure(this);
          if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
            break;
          if (i4 > 5) {
            console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
            break;
          }
          let measuring = [];
          if (!(changed & 4))
            [this.measureRequests, measuring] = [measuring, this.measureRequests];
          let measured = measuring.map((m3) => {
            try {
              return m3.read(this);
            } catch (e4) {
              logException(this.state, e4);
              return BadMeasure;
            }
          });
          let update = ViewUpdate.create(this, this.state, []), redrawn = false;
          update.flags |= changed;
          if (!updated)
            updated = update;
          else
            updated.flags |= changed;
          this.updateState = 2;
          if (!update.empty) {
            this.updatePlugins(update);
            this.inputState.update(update);
            this.updateAttrs();
            redrawn = this.docView.update(update);
            if (redrawn)
              this.docViewUpdate();
          }
          for (let i5 = 0; i5 < measuring.length; i5++)
            if (measured[i5] != BadMeasure) {
              try {
                let m3 = measuring[i5];
                if (m3.write)
                  m3.write(measured[i5], this);
              } catch (e4) {
                logException(this.state, e4);
              }
            }
          if (redrawn)
            this.docView.updateSelection(true);
          if (!update.viewportChanged && this.measureRequests.length == 0) {
            if (this.viewState.editorHeight) {
              if (this.viewState.scrollTarget) {
                this.docView.scrollIntoView(this.viewState.scrollTarget);
                this.viewState.scrollTarget = null;
                scrollAnchorHeight = -1;
                continue;
              } else {
                let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
                let diff = newAnchorHeight - scrollAnchorHeight;
                if (diff > 1 || diff < -1) {
                  scrollTop = scrollTop + diff;
                  sDOM.scrollTop = scrollTop / this.scaleY;
                  scrollAnchorHeight = -1;
                  continue;
                }
              }
            }
            break;
          }
        }
      } finally {
        this.updateState = 0;
        this.measureScheduled = -1;
      }
      if (updated && !updated.empty)
        for (let listener of this.state.facet(updateListener))
          listener(updated);
    }
    /**
    Get the CSS classes for the currently active editor themes.
    */
    get themeClasses() {
      return baseThemeID + " " + (this.state.facet(darkTheme2) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
    }
    updateAttrs() {
      let editorAttrs = attrsFromFacet(this, editorAttributes, {
        class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
      });
      let contentAttrs = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        translate: "no",
        contenteditable: !this.state.facet(editable) ? "false" : "true",
        class: "cm-content",
        style: `${browser2.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true"
      };
      if (this.state.readOnly)
        contentAttrs["aria-readonly"] = "true";
      attrsFromFacet(this, contentAttributes, contentAttrs);
      let changed = this.observer.ignore(() => {
        let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
        let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
        return changedContent || changedEditor;
      });
      this.editorAttrs = editorAttrs;
      this.contentAttrs = contentAttrs;
      return changed;
    }
    showAnnouncements(trs) {
      let first = true;
      for (let tr of trs)
        for (let effect of tr.effects)
          if (effect.is(_EditorView.announce)) {
            if (first)
              this.announceDOM.textContent = "";
            first = false;
            let div = this.announceDOM.appendChild(document.createElement("div"));
            div.textContent = effect.value;
          }
    }
    mountStyles() {
      this.styleModules = this.state.facet(styleModule);
      let nonce = this.state.facet(_EditorView.cspNonce);
      StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : void 0);
    }
    readMeasured() {
      if (this.updateState == 2)
        throw new Error("Reading the editor layout isn't allowed during an update");
      if (this.updateState == 0 && this.measureScheduled > -1)
        this.measure(false);
    }
    /**
    Schedule a layout measurement, optionally providing callbacks to
    do custom DOM measuring followed by a DOM write phase. Using
    this is preferable reading DOM layout directly from, for
    example, an event handler, because it'll make sure measuring and
    drawing done by other components is synchronized, avoiding
    unnecessary DOM layout computations.
    */
    requestMeasure(request) {
      if (this.measureScheduled < 0)
        this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
      if (request) {
        if (this.measureRequests.indexOf(request) > -1)
          return;
        if (request.key != null)
          for (let i4 = 0; i4 < this.measureRequests.length; i4++) {
            if (this.measureRequests[i4].key === request.key) {
              this.measureRequests[i4] = request;
              return;
            }
          }
        this.measureRequests.push(request);
      }
    }
    /**
    Get the value of a specific plugin, if present. Note that
    plugins that crash can be dropped from a view, so even when you
    know you registered a given plugin, it is recommended to check
    the return value of this method.
    */
    plugin(plugin) {
      let known = this.pluginMap.get(plugin);
      if (known === void 0 || known && known.spec != plugin)
        this.pluginMap.set(plugin, known = this.plugins.find((p4) => p4.spec == plugin) || null);
      return known && known.update(this).value;
    }
    /**
    The top position of the document, in screen coordinates. This
    may be negative when the editor is scrolled down. Points
    directly to the top of the first line, not above the padding.
    */
    get documentTop() {
      return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    /**
    Reports the padding above and below the document.
    */
    get documentPadding() {
      return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
    }
    /**
    If the editor is transformed with CSS, this provides the scale
    along the X axis. Otherwise, it will just be 1. Note that
    transforms other than translation and scaling are not supported.
    */
    get scaleX() {
      return this.viewState.scaleX;
    }
    /**
    Provide the CSS transformed scale along the Y axis.
    */
    get scaleY() {
      return this.viewState.scaleY;
    }
    /**
    Find the text line or block widget at the given vertical
    position (which is interpreted as relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
    */
    elementAtHeight(height) {
      this.readMeasured();
      return this.viewState.elementAtHeight(height);
    }
    /**
    Find the line block (see
    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
    height, again interpreted relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
    */
    lineBlockAtHeight(height) {
      this.readMeasured();
      return this.viewState.lineBlockAtHeight(height);
    }
    /**
    Get the extent and vertical position of all [line
    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
    are relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
    */
    get viewportLineBlocks() {
      return this.viewState.viewportLines;
    }
    /**
    Find the line block around the given document position. A line
    block is a range delimited on both sides by either a
    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
    start/end of the document. It will usually just hold a line of
    text, but may be broken into multiple textblocks by block
    widgets.
    */
    lineBlockAt(pos) {
      return this.viewState.lineBlockAt(pos);
    }
    /**
    The editor's total content height.
    */
    get contentHeight() {
      return this.viewState.contentHeight;
    }
    /**
    Move a cursor position by [grapheme
    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
    the motion is away from the line start, or towards it. In
    bidirectional text, the line is traversed in visual order, using
    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
    When the start position was the last one on the line, the
    returned position will be across the line break. If there is no
    further line, the original position is returned.
    
    By default, this method moves over a single cluster. The
    optional `by` argument can be used to move across more. It will
    be called with the first cluster as argument, and should return
    a predicate that determines, for each subsequent cluster,
    whether it should also be moved over.
    */
    moveByChar(start, forward, by) {
      return skipAtoms(this, start, moveByChar(this, start, forward, by));
    }
    /**
    Move a cursor position across the next group of either
    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
    non-whitespace characters.
    */
    moveByGroup(start, forward) {
      return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
    }
    /**
    Get the cursor position visually at the start or end of a line.
    Note that this may differ from the _logical_ position at its
    start or end (which is simply at `line.from`/`line.to`) if text
    at the start or end goes against the line's base text direction.
    */
    visualLineSide(line, end) {
      let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
      let span = order[end ? order.length - 1 : 0];
      return EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
    }
    /**
    Move to the next line boundary in the given direction. If
    `includeWrap` is true, line wrapping is on, and there is a
    further wrap point on the current line, the wrap point will be
    returned. Otherwise this function will return the start or end
    of the line.
    */
    moveToLineBoundary(start, forward, includeWrap = true) {
      return moveToLineBoundary(this, start, forward, includeWrap);
    }
    /**
    Move a cursor position vertically. When `distance` isn't given,
    it defaults to moving to the next line (including wrapped
    lines). Otherwise, `distance` should provide a positive distance
    in pixels.
    
    When `start` has a
    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
    motion will use that as a target horizontal position. Otherwise,
    the cursor's own horizontal position is used. The returned
    cursor will have its goal column set to whichever column was
    used.
    */
    moveVertically(start, forward, distance) {
      return skipAtoms(this, start, moveVertically(this, start, forward, distance));
    }
    /**
    Find the DOM parent node and offset (child offset if `node` is
    an element, character offset when it is a text node) at the
    given document position.
    
    Note that for positions that aren't currently in
    `visibleRanges`, the resulting DOM position isn't necessarily
    meaningful (it may just point before or after a placeholder
    element).
    */
    domAtPos(pos) {
      return this.docView.domAtPos(pos);
    }
    /**
    Find the document position at the given DOM node. Can be useful
    for associating positions with DOM events. Will raise an error
    when `node` isn't part of the editor content.
    */
    posAtDOM(node, offset = 0) {
      return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
      this.readMeasured();
      return posAtCoords(this, coords, precise);
    }
    /**
    Get the screen coordinates at the given document position.
    `side` determines whether the coordinates are based on the
    element before (-1) or after (1) the position (if no element is
    available on the given side, the method will transparently use
    another strategy to get reasonable coordinates).
    */
    coordsAtPos(pos, side = 1) {
      this.readMeasured();
      let rect = this.docView.coordsAt(pos, side);
      if (!rect || rect.left == rect.right)
        return rect;
      let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
      let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
      return flattenRect(rect, span.dir == Direction.LTR == side > 0);
    }
    /**
    Return the rectangle around a given character. If `pos` does not
    point in front of a character that is in the viewport and
    rendered (i.e. not replaced, not a line break), this will return
    null. For space characters that are a line wrap point, this will
    return the position before the line break.
    */
    coordsForChar(pos) {
      this.readMeasured();
      return this.docView.coordsForChar(pos);
    }
    /**
    The default width of a character in the editor. May not
    accurately reflect the width of all characters (given variable
    width fonts or styling of invididual ranges).
    */
    get defaultCharacterWidth() {
      return this.viewState.heightOracle.charWidth;
    }
    /**
    The default height of a line in the editor. May not be accurate
    for all lines.
    */
    get defaultLineHeight() {
      return this.viewState.heightOracle.lineHeight;
    }
    /**
    The text direction
    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
    CSS property) of the editor's content element.
    */
    get textDirection() {
      return this.viewState.defaultTextDirection;
    }
    /**
    Find the text direction of the block at the given position, as
    assigned by CSS. If
    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
    isn't enabled, or the given position is outside of the viewport,
    this will always return the same as
    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
    this may trigger a DOM layout.
    */
    textDirectionAt(pos) {
      let perLine = this.state.facet(perLineTextDirection);
      if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
        return this.textDirection;
      this.readMeasured();
      return this.docView.textDirectionAt(pos);
    }
    /**
    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
    (as determined by the
    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
    CSS property of its content element).
    */
    get lineWrapping() {
      return this.viewState.heightOracle.lineWrapping;
    }
    /**
    Returns the bidirectional text structure of the given line
    (which should be in the current document) as an array of span
    objects. The order of these spans matches the [text
    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
    left-to-right, the leftmost spans come first, otherwise the
    rightmost spans come first.
    */
    bidiSpans(line) {
      if (line.length > MaxBidiLine)
        return trivialOrder(line.length);
      let dir = this.textDirectionAt(line.from), isolates;
      for (let entry of this.bidiCache) {
        if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))
          return entry.order;
      }
      if (!isolates)
        isolates = getIsolatedRanges(this, line);
      let order = computeOrder(line.text, dir, isolates);
      this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
      return order;
    }
    /**
    Check whether the editor has focus.
    */
    get hasFocus() {
      var _a2;
      return (this.dom.ownerDocument.hasFocus() || browser2.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
    }
    /**
    Put focus on the editor.
    */
    focus() {
      this.observer.ignore(() => {
        focusPreventScroll(this.contentDOM);
        this.docView.updateSelection();
      });
    }
    /**
    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
    necessary when moving the editor's existing DOM to a new window or shadow root.
    */
    setRoot(root) {
      if (this._root != root) {
        this._root = root;
        this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
        this.mountStyles();
      }
    }
    /**
    Clean up this editor view, removing its element from the
    document, unregistering event handlers, and notifying
    plugins. The view instance can no longer be used after
    calling this.
    */
    destroy() {
      if (this.root.activeElement == this.contentDOM)
        this.contentDOM.blur();
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.plugins = [];
      this.inputState.destroy();
      this.docView.destroy();
      this.dom.remove();
      this.observer.destroy();
      if (this.measureScheduled > -1)
        this.win.cancelAnimationFrame(this.measureScheduled);
      this.destroyed = true;
    }
    /**
    Returns an effect that can be
    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
    cause it to scroll the given position or range into view.
    */
    static scrollIntoView(pos, options = {}) {
      return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
    }
    /**
    Return an effect that resets the editor to its current (at the
    time this method was called) scroll position. Note that this
    only affects the editor's own scrollable element, not parents.
    See also
    [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
    
    The effect should be used with a document identical to the one
    it was created for. Failing to do so is not an error, but may
    not scroll to the expected position. You can
    [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
    */
    scrollSnapshot() {
      let { scrollTop, scrollLeft } = this.scrollDOM;
      let ref = this.viewState.scrollAnchorAt(scrollTop);
      return scrollIntoView.of(new ScrollTarget(EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
    }
    /**
    Enable or disable tab-focus mode, which disables key bindings
    for Tab and Shift-Tab, letting the browser's default
    focus-changing behavior go through instead. This is useful to
    prevent trapping keyboard users in your editor.
    
    Without argument, this toggles the mode. With a boolean, it
    enables (true) or disables it (false). Given a number, it
    temporarily enables the mode until that number of milliseconds
    have passed or another non-Tab key is pressed.
    */
    setTabFocusMode(to) {
      if (to == null)
        this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
      else if (typeof to == "boolean")
        this.inputState.tabFocusMode = to ? 0 : -1;
      else if (this.inputState.tabFocusMode != 0)
        this.inputState.tabFocusMode = Date.now() + to;
    }
    /**
    Returns an extension that can be used to add DOM event handlers.
    The value should be an object mapping event names to handler
    functions. For any given event, such functions are ordered by
    extension precedence, and the first handler to return true will
    be assumed to have handled that event, and no other handlers or
    built-in behavior will be activated for it. These are registered
    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
    for `scroll` handlers, which will be called any time the
    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
    its parent nodes is scrolled.
    */
    static domEventHandlers(handlers2) {
      return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
    }
    /**
    Create an extension that registers DOM event observers. Contrary
    to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
    observers can't be prevented from running by a higher-precedence
    handler returning true. They also don't prevent other handlers
    and observers from running when they return true, and should not
    call `preventDefault`.
    */
    static domEventObservers(observers2) {
      return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
    }
    /**
    Create a theme extension. The first argument can be a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)
    style spec providing the styles for the theme. These will be
    prefixed with a generated class for the style.
    
    Because the selectors will be prefixed with a scope class, rule
    that directly match the editor's [wrapper
    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
    added—need to be explicitly differentiated by adding an `&` to
    the selector for that element—for example
    `&.cm-focused`.
    
    When `dark` is set to true, the theme will be marked as dark,
    which will cause the `&dark` rules from [base
    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
    `&light` when a light theme is active).
    */
    static theme(spec, options) {
      let prefix = StyleModule.newName();
      let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
      if (options && options.dark)
        result.push(darkTheme2.of(true));
      return result;
    }
    /**
    Create an extension that adds styles to the base theme. Like
    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
    place of the editor wrapper element when directly targeting
    that. You can also use `&dark` or `&light` instead to only
    target editors with a dark or light theme.
    */
    static baseTheme(spec) {
      return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    /**
    Retrieve an editor view instance from the view's DOM
    representation.
    */
    static findFromDOM(dom) {
      var _a2;
      let content2 = dom.querySelector(".cm-content");
      let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
      return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
    }
  };
  EditorView.styleModule = styleModule;
  EditorView.inputHandler = inputHandler;
  EditorView.scrollHandler = scrollHandler;
  EditorView.focusChangeEffect = focusChangeEffect;
  EditorView.perLineTextDirection = perLineTextDirection;
  EditorView.exceptionSink = exceptionSink;
  EditorView.updateListener = updateListener;
  EditorView.editable = editable;
  EditorView.mouseSelectionStyle = mouseSelectionStyle;
  EditorView.dragMovesSelection = dragMovesSelection$1;
  EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
  EditorView.decorations = decorations;
  EditorView.outerDecorations = outerDecorations;
  EditorView.atomicRanges = atomicRanges;
  EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
  EditorView.scrollMargins = scrollMargins;
  EditorView.darkTheme = darkTheme2;
  EditorView.cspNonce = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : "" });
  EditorView.contentAttributes = contentAttributes;
  EditorView.editorAttributes = editorAttributes;
  EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
  EditorView.announce = /* @__PURE__ */ StateEffect.define();
  var MaxBidiLine = 4096;
  var BadMeasure = {};
  var CachedOrder = class _CachedOrder {
    constructor(from, to, dir, isolates, fresh, order) {
      this.from = from;
      this.to = to;
      this.dir = dir;
      this.isolates = isolates;
      this.fresh = fresh;
      this.order = order;
    }
    static update(cache, changes) {
      if (changes.empty && !cache.some((c4) => c4.fresh))
        return cache;
      let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
      for (let i4 = Math.max(0, cache.length - 10); i4 < cache.length; i4++) {
        let entry = cache[i4];
        if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
          result.push(new _CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
      }
      return result;
    }
  };
  function attrsFromFacet(view, facet, base2) {
    for (let sources = view.state.facet(facet), i4 = sources.length - 1; i4 >= 0; i4--) {
      let source = sources[i4], value = typeof source == "function" ? source(view) : source;
      if (value)
        combineAttrs(value, base2);
    }
    return base2;
  }
  var currentPlatform = browser2.mac ? "mac" : browser2.windows ? "win" : browser2.linux ? "linux" : "key";
  function normalizeKeyName(name2, platform) {
    const parts = name2.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt, ctrl, shift2, meta2;
    for (let i4 = 0; i4 < parts.length - 1; ++i4) {
      const mod = parts[i4];
      if (/^(cmd|meta|m)$/i.test(mod))
        meta2 = true;
      else if (/^a(lt)?$/i.test(mod))
        alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod))
        shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (platform == "mac")
          meta2 = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta2)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function modifiers(name2, event, shift2) {
    if (event.altKey)
      name2 = "Alt-" + name2;
    if (event.ctrlKey)
      name2 = "Ctrl-" + name2;
    if (event.metaKey)
      name2 = "Meta-" + name2;
    if (shift2 !== false && event.shiftKey)
      name2 = "Shift-" + name2;
    return name2;
  }
  var handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
    keydown(event, view) {
      return runHandlers(getKeymap(view.state), event, view, "editor");
    }
  }));
  var keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
  var Keymaps = /* @__PURE__ */ new WeakMap();
  function getKeymap(state) {
    let bindings = state.facet(keymap);
    let map2 = Keymaps.get(bindings);
    if (!map2)
      Keymaps.set(bindings, map2 = buildKeymap(bindings.reduce((a4, b4) => a4.concat(b4), [])));
    return map2;
  }
  var storedPrefix = null;
  var PrefixTimeout = 4e3;
  function buildKeymap(bindings, platform = currentPlatform) {
    let bound = /* @__PURE__ */ Object.create(null);
    let isPrefix = /* @__PURE__ */ Object.create(null);
    let checkPrefix = (name2, is) => {
      let current = isPrefix[name2];
      if (current == null)
        isPrefix[name2] = is;
      else if (current != is)
        throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add2 = (scope, key, command, preventDefault, stopPropagation) => {
      var _a2, _b;
      let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
      let parts = key.split(/ (?!$)/).map((k2) => normalizeKeyName(k2, platform));
      for (let i4 = 1; i4 < parts.length; i4++) {
        let prefix = parts.slice(0, i4).join(" ");
        checkPrefix(prefix, true);
        if (!scopeObj[prefix])
          scopeObj[prefix] = {
            preventDefault: true,
            stopPropagation: false,
            run: [(view) => {
              let ourObj = storedPrefix = { view, prefix, scope };
              setTimeout(() => {
                if (storedPrefix == ourObj)
                  storedPrefix = null;
              }, PrefixTimeout);
              return true;
            }]
          };
      }
      let full = parts.join(" ");
      checkPrefix(full, false);
      let binding = scopeObj[full] || (scopeObj[full] = {
        preventDefault: false,
        stopPropagation: false,
        run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
      });
      if (command)
        binding.run.push(command);
      if (preventDefault)
        binding.preventDefault = true;
      if (stopPropagation)
        binding.stopPropagation = true;
    };
    for (let b4 of bindings) {
      let scopes = b4.scope ? b4.scope.split(" ") : ["editor"];
      if (b4.any)
        for (let scope of scopes) {
          let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
          if (!scopeObj._any)
            scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
          let { any } = b4;
          for (let key in scopeObj)
            scopeObj[key].run.push((view) => any(view, currentKeyEvent));
        }
      let name2 = b4[platform] || b4.key;
      if (!name2)
        continue;
      for (let scope of scopes) {
        add2(scope, name2, b4.run, b4.preventDefault, b4.stopPropagation);
        if (b4.shift)
          add2(scope, "Shift-" + name2, b4.shift, b4.preventDefault, b4.stopPropagation);
      }
    }
    return bound;
  }
  var currentKeyEvent = null;
  function runHandlers(map2, event, view, scope) {
    currentKeyEvent = event;
    let name2 = keyName(event);
    let charCode = codePointAt(name2, 0), isChar = codePointSize(charCode) == name2.length && name2 != " ";
    let prefix = "", handled = false, prevented = false, stopPropagation = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
      prefix = storedPrefix.prefix + " ";
      if (modifierCodes.indexOf(event.keyCode) < 0) {
        prevented = true;
        storedPrefix = null;
      }
    }
    let ran = /* @__PURE__ */ new Set();
    let runFor = (binding) => {
      if (binding) {
        for (let cmd2 of binding.run)
          if (!ran.has(cmd2)) {
            ran.add(cmd2);
            if (cmd2(view)) {
              if (binding.stopPropagation)
                stopPropagation = true;
              return true;
            }
          }
        if (binding.preventDefault) {
          if (binding.stopPropagation)
            stopPropagation = true;
          prevented = true;
        }
      }
      return false;
    };
    let scopeObj = map2[scope], baseName, shiftName;
    if (scopeObj) {
      if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)])) {
        handled = true;
      } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(browser2.windows && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name2) {
        if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
          handled = true;
        } else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
          handled = true;
        }
      } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name2, event, true)])) {
        handled = true;
      }
      if (!handled && runFor(scopeObj._any))
        handled = true;
    }
    if (prevented)
      handled = true;
    if (handled && stopPropagation)
      event.stopPropagation();
    currentKeyEvent = null;
    return handled;
  }
  var CanHidePrimary = !browser2.ios;
  var themeSpec = {
    ".cm-line": {
      "& ::selection, &::selection": { backgroundColor: "transparent !important" }
    },
    ".cm-content": {
      "& :focus": {
        caretColor: "initial !important",
        "&::selection, & ::selection": {
          backgroundColor: "Highlight !important"
        }
      }
    }
  };
  if (CanHidePrimary)
    themeSpec[".cm-line"].caretColor = themeSpec[".cm-content"].caretColor = "transparent !important";
  function iterMatches(doc2, re2, from, to, f3) {
    re2.lastIndex = 0;
    for (let cursor = doc2.iterRange(from, to), pos = from, m3; !cursor.next().done; pos += cursor.value.length) {
      if (!cursor.lineBreak)
        while (m3 = re2.exec(cursor.value))
          f3(pos + m3.index, m3);
    }
  }
  function matchRanges(view, maxLength) {
    let visible = view.visibleRanges;
    if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
      return visible;
    let result = [];
    for (let { from, to } of visible) {
      from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
      to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
      if (result.length && result[result.length - 1].to >= from)
        result[result.length - 1].to = to;
      else
        result.push({ from, to });
    }
    return result;
  }
  var MatchDecorator = class {
    /**
    Create a decorator.
    */
    constructor(config) {
      const { regexp, decoration, decorate, boundary, maxLength = 1e3 } = config;
      if (!regexp.global)
        throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
      this.regexp = regexp;
      if (decorate) {
        this.addMatch = (match, view, from, add2) => decorate(add2, from, from + match[0].length, match, view);
      } else if (typeof decoration == "function") {
        this.addMatch = (match, view, from, add2) => {
          let deco = decoration(match, view, from);
          if (deco)
            add2(from, from + match[0].length, deco);
        };
      } else if (decoration) {
        this.addMatch = (match, _view, from, add2) => add2(from, from + match[0].length, decoration);
      } else {
        throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
      }
      this.boundary = boundary;
      this.maxLength = maxLength;
    }
    /**
    Compute the full set of decorations for matches in the given
    view's viewport. You'll want to call this when initializing your
    plugin.
    */
    createDeco(view) {
      let build = new RangeSetBuilder(), add2 = build.add.bind(build);
      for (let { from, to } of matchRanges(view, this.maxLength))
        iterMatches(view.state.doc, this.regexp, from, to, (from2, m3) => this.addMatch(m3, view, from2, add2));
      return build.finish();
    }
    /**
    Update a set of decorations for a view update. `deco` _must_ be
    the set of decorations produced by _this_ `MatchDecorator` for
    the view state before the update.
    */
    updateDeco(update, deco) {
      let changeFrom = 1e9, changeTo = -1;
      if (update.docChanged)
        update.changes.iterChanges((_f, _t, from, to) => {
          if (to > update.view.viewport.from && from < update.view.viewport.to) {
            changeFrom = Math.min(from, changeFrom);
            changeTo = Math.max(to, changeTo);
          }
        });
      if (update.viewportChanged || changeTo - changeFrom > 1e3)
        return this.createDeco(update.view);
      if (changeTo > -1)
        return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
      return deco;
    }
    updateRange(view, deco, updateFrom, updateTo) {
      for (let r3 of view.visibleRanges) {
        let from = Math.max(r3.from, updateFrom), to = Math.min(r3.to, updateTo);
        if (to > from) {
          let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
          let start = Math.max(r3.from, fromLine.from), end = Math.min(r3.to, toLine.to);
          if (this.boundary) {
            for (; from > fromLine.from; from--)
              if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                start = from;
                break;
              }
            for (; to < toLine.to; to++)
              if (this.boundary.test(toLine.text[to - toLine.from])) {
                end = to;
                break;
              }
          }
          let ranges = [], m3;
          let add2 = (from2, to2, deco2) => ranges.push(deco2.range(from2, to2));
          if (fromLine == toLine) {
            this.regexp.lastIndex = start - fromLine.from;
            while ((m3 = this.regexp.exec(fromLine.text)) && m3.index < end - fromLine.from)
              this.addMatch(m3, view, m3.index + fromLine.from, add2);
          } else {
            iterMatches(view.state.doc, this.regexp, start, end, (from2, m4) => this.addMatch(m4, view, from2, add2));
          }
          deco = deco.update({ filterFrom: start, filterTo: end, filter: (from2, to2) => from2 < start || to2 > end, add: ranges });
        }
      }
      return deco;
    }
  };
  var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
  var Specials = /* @__PURE__ */ new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
  var Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
  };
  var _supportsTabSize = null;
  function supportsTabSize() {
    var _a2;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
      let styles = document.body.style;
      _supportsTabSize = ((_a2 = styles.tabSize) !== null && _a2 !== void 0 ? _a2 : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
  }
  var specialCharConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let config = combineConfig(configs, {
        render: null,
        specialChars: Specials,
        addSpecialChars: null
      });
      if (config.replaceTabs = !supportsTabSize())
        config.specialChars = new RegExp("	|" + config.specialChars.source, UnicodeRegexpSupport);
      if (config.addSpecialChars)
        config.specialChars = new RegExp(config.specialChars.source + "|" + config.addSpecialChars.source, UnicodeRegexpSupport);
      return config;
    }
  });
  function highlightSpecialChars(config = {}) {
    return [specialCharConfig.of(config), specialCharPlugin()];
  }
  var _plugin = null;
  function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.decorations = Decoration.none;
        this.decorationCache = /* @__PURE__ */ Object.create(null);
        this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
        this.decorations = this.decorator.createDeco(view);
      }
      makeDecorator(conf) {
        return new MatchDecorator({
          regexp: conf.specialChars,
          decoration: (m3, view, pos) => {
            let { doc: doc2 } = view.state;
            let code = codePointAt(m3[0], 0);
            if (code == 9) {
              let line = doc2.lineAt(pos);
              let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
              return Decoration.replace({
                widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)
              });
            }
            return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
          },
          boundary: conf.replaceTabs ? void 0 : /[^]/
        });
      }
      update(update) {
        let conf = update.state.facet(specialCharConfig);
        if (update.startState.facet(specialCharConfig) != conf) {
          this.decorator = this.makeDecorator(conf);
          this.decorations = this.decorator.createDeco(update.view);
        } else {
          this.decorations = this.decorator.updateDeco(update, this.decorations);
        }
      }
    }, {
      decorations: (v3) => v3.decorations
    }));
  }
  var DefaultPlaceholder = "\u2022";
  function placeholder$1(code) {
    if (code >= 32)
      return DefaultPlaceholder;
    if (code == 10)
      return "\u2424";
    return String.fromCharCode(9216 + code);
  }
  var SpecialCharWidget = class extends WidgetType {
    constructor(options, code) {
      super();
      this.options = options;
      this.code = code;
    }
    eq(other) {
      return other.code == this.code;
    }
    toDOM(view) {
      let ph = placeholder$1(this.code);
      let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
      let custom2 = this.options.render && this.options.render(this.code, desc, ph);
      if (custom2)
        return custom2;
      let span = document.createElement("span");
      span.textContent = ph;
      span.title = desc;
      span.setAttribute("aria-label", desc);
      span.className = "cm-specialChar";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  };
  var TabWidget = class extends WidgetType {
    constructor(width) {
      super();
      this.width = width;
    }
    eq(other) {
      return other.width == this.width;
    }
    toDOM() {
      let span = document.createElement("span");
      span.textContent = "	";
      span.className = "cm-tab";
      span.style.width = this.width + "px";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  };
  var Outside = "-10000px";
  var TooltipViewManager = class {
    constructor(view, facet, createTooltipView, removeTooltipView) {
      this.facet = facet;
      this.createTooltipView = createTooltipView;
      this.removeTooltipView = removeTooltipView;
      this.input = view.state.facet(facet);
      this.tooltips = this.input.filter((t5) => t5);
      let prev = null;
      this.tooltipViews = this.tooltips.map((t5) => prev = createTooltipView(t5, prev));
    }
    update(update, above) {
      var _a2;
      let input = update.state.facet(this.facet);
      let tooltips = input.filter((x2) => x2);
      if (input === this.input) {
        for (let t5 of this.tooltipViews)
          if (t5.update)
            t5.update(update);
        return false;
      }
      let tooltipViews = [], newAbove = above ? [] : null;
      for (let i4 = 0; i4 < tooltips.length; i4++) {
        let tip = tooltips[i4], known = -1;
        if (!tip)
          continue;
        for (let i5 = 0; i5 < this.tooltips.length; i5++) {
          let other = this.tooltips[i5];
          if (other && other.create == tip.create)
            known = i5;
        }
        if (known < 0) {
          tooltipViews[i4] = this.createTooltipView(tip, i4 ? tooltipViews[i4 - 1] : null);
          if (newAbove)
            newAbove[i4] = !!tip.above;
        } else {
          let tooltipView = tooltipViews[i4] = this.tooltipViews[known];
          if (newAbove)
            newAbove[i4] = above[known];
          if (tooltipView.update)
            tooltipView.update(update);
        }
      }
      for (let t5 of this.tooltipViews)
        if (tooltipViews.indexOf(t5) < 0) {
          this.removeTooltipView(t5);
          (_a2 = t5.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t5);
        }
      if (above) {
        newAbove.forEach((val, i4) => above[i4] = val);
        above.length = newAbove.length;
      }
      this.input = input;
      this.tooltips = tooltips;
      this.tooltipViews = tooltipViews;
      return true;
    }
  };
  function windowSpace(view) {
    let { win } = view;
    return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth };
  }
  var tooltipConfig = /* @__PURE__ */ Facet.define({
    combine: (values) => {
      var _a2, _b, _c;
      return {
        position: browser2.ios ? "absolute" : ((_a2 = values.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
        parent: ((_b = values.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
        tooltipSpace: ((_c = values.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
      };
    }
  });
  var knownHeight = /* @__PURE__ */ new WeakMap();
  var tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.above = [];
      this.inView = true;
      this.madeAbsolute = false;
      this.lastTransaction = 0;
      this.measureTimeout = -1;
      let config = view.state.facet(tooltipConfig);
      this.position = config.position;
      this.parent = config.parent;
      this.classes = view.themeClasses;
      this.createContainer();
      this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
      this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
      this.manager = new TooltipViewManager(view, showTooltip, (t5, p4) => this.createTooltip(t5, p4), (t5) => {
        if (this.resizeObserver)
          this.resizeObserver.unobserve(t5.dom);
        t5.dom.remove();
      });
      this.above = this.manager.tooltips.map((t5) => !!t5.above);
      this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
        if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
          this.measureSoon();
      }, { threshold: [1] }) : null;
      this.observeIntersection();
      view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
      this.maybeMeasure();
    }
    createContainer() {
      if (this.parent) {
        this.container = document.createElement("div");
        this.container.style.position = "relative";
        this.container.className = this.view.themeClasses;
        this.parent.appendChild(this.container);
      } else {
        this.container = this.view.dom;
      }
    }
    observeIntersection() {
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect();
        for (let tooltip of this.manager.tooltipViews)
          this.intersectionObserver.observe(tooltip.dom);
      }
    }
    measureSoon() {
      if (this.measureTimeout < 0)
        this.measureTimeout = setTimeout(() => {
          this.measureTimeout = -1;
          this.maybeMeasure();
        }, 50);
    }
    update(update) {
      if (update.transactions.length)
        this.lastTransaction = Date.now();
      let updated = this.manager.update(update, this.above);
      if (updated)
        this.observeIntersection();
      let shouldMeasure = updated || update.geometryChanged;
      let newConfig = update.state.facet(tooltipConfig);
      if (newConfig.position != this.position && !this.madeAbsolute) {
        this.position = newConfig.position;
        for (let t5 of this.manager.tooltipViews)
          t5.dom.style.position = this.position;
        shouldMeasure = true;
      }
      if (newConfig.parent != this.parent) {
        if (this.parent)
          this.container.remove();
        this.parent = newConfig.parent;
        this.createContainer();
        for (let t5 of this.manager.tooltipViews)
          this.container.appendChild(t5.dom);
        shouldMeasure = true;
      } else if (this.parent && this.view.themeClasses != this.classes) {
        this.classes = this.container.className = this.view.themeClasses;
      }
      if (shouldMeasure)
        this.maybeMeasure();
    }
    createTooltip(tooltip, prev) {
      let tooltipView = tooltip.create(this.view);
      let before = prev ? prev.dom : null;
      tooltipView.dom.classList.add("cm-tooltip");
      if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
        let arrow = document.createElement("div");
        arrow.className = "cm-tooltip-arrow";
        tooltipView.dom.appendChild(arrow);
      }
      tooltipView.dom.style.position = this.position;
      tooltipView.dom.style.top = Outside;
      tooltipView.dom.style.left = "0px";
      this.container.insertBefore(tooltipView.dom, before);
      if (tooltipView.mount)
        tooltipView.mount(this.view);
      if (this.resizeObserver)
        this.resizeObserver.observe(tooltipView.dom);
      return tooltipView;
    }
    destroy() {
      var _a2, _b, _c;
      this.view.win.removeEventListener("resize", this.measureSoon);
      for (let tooltipView of this.manager.tooltipViews) {
        tooltipView.dom.remove();
        (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
      }
      if (this.parent)
        this.container.remove();
      (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
      clearTimeout(this.measureTimeout);
    }
    readMeasure() {
      let editor = this.view.dom.getBoundingClientRect();
      let scaleX = 1, scaleY = 1, makeAbsolute = false;
      if (this.position == "fixed" && this.manager.tooltipViews.length) {
        let { dom } = this.manager.tooltipViews[0];
        if (browser2.gecko) {
          makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
        } else if (dom.style.top == Outside && dom.style.left == "0px") {
          let rect = dom.getBoundingClientRect();
          makeAbsolute = Math.abs(rect.top + 1e4) > 1 || Math.abs(rect.left) > 1;
        }
      }
      if (makeAbsolute || this.position == "absolute") {
        if (this.parent) {
          let rect = this.parent.getBoundingClientRect();
          if (rect.width && rect.height) {
            scaleX = rect.width / this.parent.offsetWidth;
            scaleY = rect.height / this.parent.offsetHeight;
          }
        } else {
          ({ scaleX, scaleY } = this.view.viewState);
        }
      }
      return {
        editor,
        parent: this.parent ? this.container.getBoundingClientRect() : editor,
        pos: this.manager.tooltips.map((t5, i4) => {
          let tv = this.manager.tooltipViews[i4];
          return tv.getCoords ? tv.getCoords(t5.pos) : this.view.coordsAtPos(t5.pos);
        }),
        size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
        space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
        scaleX,
        scaleY,
        makeAbsolute
      };
    }
    writeMeasure(measured) {
      var _a2;
      if (measured.makeAbsolute) {
        this.madeAbsolute = true;
        this.position = "absolute";
        for (let t5 of this.manager.tooltipViews)
          t5.dom.style.position = "absolute";
      }
      let { editor, space, scaleX, scaleY } = measured;
      let others = [];
      for (let i4 = 0; i4 < this.manager.tooltips.length; i4++) {
        let tooltip = this.manager.tooltips[i4], tView = this.manager.tooltipViews[i4], { dom } = tView;
        let pos = measured.pos[i4], size = measured.size[i4];
        if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - 0.1 || pos.left > Math.min(editor.right, space.right) + 0.1) {
          dom.style.top = Outside;
          continue;
        }
        let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
        let arrowHeight = arrow ? 7 : 0;
        let width = size.right - size.left, height = (_a2 = knownHeight.get(tView)) !== null && _a2 !== void 0 ? _a2 : size.bottom - size.top;
        let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
        let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow ? 14 : 0) - offset.x);
        let above = this.above[i4];
        if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space.top : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top)
          above = this.above[i4] = !above;
        let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
        if (spaceVert < height && tView.resize !== false) {
          if (spaceVert < this.view.defaultLineHeight) {
            dom.style.top = Outside;
            continue;
          }
          knownHeight.set(tView, height);
          dom.style.height = (height = spaceVert) / scaleY + "px";
        } else if (dom.style.height) {
          dom.style.height = "";
        }
        let top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
        let right = left + width;
        if (tView.overlap !== true) {
          for (let r3 of others)
            if (r3.left < right && r3.right > left && r3.top < top2 + height && r3.bottom > top2)
              top2 = above ? r3.top - height - 2 - arrowHeight : r3.bottom + arrowHeight + 2;
        }
        if (this.position == "absolute") {
          dom.style.top = (top2 - measured.parent.top) / scaleY + "px";
          dom.style.left = (left - measured.parent.left) / scaleX + "px";
        } else {
          dom.style.top = top2 / scaleY + "px";
          dom.style.left = left / scaleX + "px";
        }
        if (arrow) {
          let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7);
          arrow.style.left = arrowLeft / scaleX + "px";
        }
        if (tView.overlap !== true)
          others.push({ left, top: top2, right, bottom: top2 + height });
        dom.classList.toggle("cm-tooltip-above", above);
        dom.classList.toggle("cm-tooltip-below", !above);
        if (tView.positioned)
          tView.positioned(measured.space);
      }
    }
    maybeMeasure() {
      if (this.manager.tooltips.length) {
        if (this.view.inView)
          this.view.requestMeasure(this.measureReq);
        if (this.inView != this.view.inView) {
          this.inView = this.view.inView;
          if (!this.inView)
            for (let tv of this.manager.tooltipViews)
              tv.dom.style.top = Outside;
        }
      }
    }
  }, {
    eventObservers: {
      scroll() {
        this.maybeMeasure();
      }
    }
  });
  var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip": {
      zIndex: 100,
      boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
      border: "1px solid #bbb",
      backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
      borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tooltip-arrow": {
      height: `${7}px`,
      width: `${7 * 2}px`,
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: `${7}px solid transparent`,
        borderRight: `${7}px solid transparent`
      },
      ".cm-tooltip-above &": {
        bottom: `-${7}px`,
        "&:before": {
          borderTop: `${7}px solid #bbb`
        },
        "&:after": {
          borderTop: `${7}px solid #f5f5f5`,
          bottom: "1px"
        }
      },
      ".cm-tooltip-below &": {
        top: `-${7}px`,
        "&:before": {
          borderBottom: `${7}px solid #bbb`
        },
        "&:after": {
          borderBottom: `${7}px solid #f5f5f5`,
          top: "1px"
        }
      }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": {
        borderTopColor: "#333338",
        borderBottomColor: "#333338"
      },
      "&:after": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      }
    }
  });
  var noOffset = { x: 0, y: 0 };
  var showTooltip = /* @__PURE__ */ Facet.define({
    enables: [tooltipPlugin, baseTheme]
  });
  var showHoverTooltip = /* @__PURE__ */ Facet.define({
    combine: (inputs) => inputs.reduce((a4, i4) => a4.concat(i4), [])
  });
  var HoverTooltipHost = class _HoverTooltipHost {
    // Needs to be static so that host tooltip instances always match
    static create(view) {
      return new _HoverTooltipHost(view);
    }
    constructor(view) {
      this.view = view;
      this.mounted = false;
      this.dom = document.createElement("div");
      this.dom.classList.add("cm-tooltip-hover");
      this.manager = new TooltipViewManager(view, showHoverTooltip, (t5, p4) => this.createHostedView(t5, p4), (t5) => t5.dom.remove());
    }
    createHostedView(tooltip, prev) {
      let hostedView = tooltip.create(this.view);
      hostedView.dom.classList.add("cm-tooltip-section");
      this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);
      if (this.mounted && hostedView.mount)
        hostedView.mount(this.view);
      return hostedView;
    }
    mount(view) {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.mount)
          hostedView.mount(view);
      }
      this.mounted = true;
    }
    positioned(space) {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.positioned)
          hostedView.positioned(space);
      }
    }
    update(update) {
      this.manager.update(update);
    }
    destroy() {
      var _a2;
      for (let t5 of this.manager.tooltipViews)
        (_a2 = t5.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t5);
    }
    passProp(name2) {
      let value = void 0;
      for (let view of this.manager.tooltipViews) {
        let given = view[name2];
        if (given !== void 0) {
          if (value === void 0)
            value = given;
          else if (value !== given)
            return void 0;
        }
      }
      return value;
    }
    get offset() {
      return this.passProp("offset");
    }
    get getCoords() {
      return this.passProp("getCoords");
    }
    get overlap() {
      return this.passProp("overlap");
    }
    get resize() {
      return this.passProp("resize");
    }
  };
  var showHoverTooltipHost = /* @__PURE__ */ showTooltip.compute([showHoverTooltip], (state) => {
    let tooltips = state.facet(showHoverTooltip);
    if (tooltips.length === 0)
      return null;
    return {
      pos: Math.min(...tooltips.map((t5) => t5.pos)),
      end: Math.max(...tooltips.map((t5) => {
        var _a2;
        return (_a2 = t5.end) !== null && _a2 !== void 0 ? _a2 : t5.pos;
      })),
      create: HoverTooltipHost.create,
      above: tooltips[0].above,
      arrow: tooltips.some((t5) => t5.arrow)
    };
  });
  var HoverPlugin = class {
    constructor(view, source, field, setHover, hoverTime) {
      this.view = view;
      this.source = source;
      this.field = field;
      this.setHover = setHover;
      this.hoverTime = hoverTime;
      this.hoverTimeout = -1;
      this.restartTimeout = -1;
      this.pending = null;
      this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
      this.checkHover = this.checkHover.bind(this);
      view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
      view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
      if (this.pending) {
        this.pending = null;
        clearTimeout(this.restartTimeout);
        this.restartTimeout = setTimeout(() => this.startHover(), 20);
      }
    }
    get active() {
      return this.view.state.field(this.field);
    }
    checkHover() {
      this.hoverTimeout = -1;
      if (this.active.length)
        return;
      let hovered = Date.now() - this.lastMove.time;
      if (hovered < this.hoverTime)
        this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
      else
        this.startHover();
    }
    startHover() {
      clearTimeout(this.restartTimeout);
      let { view, lastMove } = this;
      let desc = view.docView.nearest(lastMove.target);
      if (!desc)
        return;
      let pos, side = 1;
      if (desc instanceof WidgetView) {
        pos = desc.posAtStart;
      } else {
        pos = view.posAtCoords(lastMove);
        if (pos == null)
          return;
        let posCoords = view.coordsAtPos(pos);
        if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth)
          return;
        let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s4) => s4.from <= pos && s4.to >= pos);
        let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
        side = lastMove.x < posCoords.left ? -rtl : rtl;
      }
      let open = this.source(view, pos, side);
      if (open === null || open === void 0 ? void 0 : open.then) {
        let pending = this.pending = { pos };
        open.then((result) => {
          if (this.pending == pending) {
            this.pending = null;
            if (result && !(Array.isArray(result) && !result.length))
              view.dispatch({ effects: this.setHover.of(Array.isArray(result) ? result : [result]) });
          }
        }, (e4) => logException(view.state, e4, "hover tooltip"));
      } else if (open && !(Array.isArray(open) && !open.length)) {
        view.dispatch({ effects: this.setHover.of(Array.isArray(open) ? open : [open]) });
      }
    }
    get tooltip() {
      let plugin = this.view.plugin(tooltipPlugin);
      let index = plugin ? plugin.manager.tooltips.findIndex((t5) => t5.create == HoverTooltipHost.create) : -1;
      return index > -1 ? plugin.manager.tooltipViews[index] : null;
    }
    mousemove(event) {
      var _a2, _b;
      this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
      if (this.hoverTimeout < 0)
        this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
      let { active, tooltip } = this;
      if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {
        let { pos } = active[0] || this.pending, end = (_b = (_a2 = active[0]) === null || _a2 === void 0 ? void 0 : _a2.end) !== null && _b !== void 0 ? _b : pos;
        if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {
          this.view.dispatch({ effects: this.setHover.of([]) });
          this.pending = null;
        }
      }
    }
    mouseleave(event) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = -1;
      let { active } = this;
      if (active.length) {
        let { tooltip } = this;
        let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);
        if (!inTooltip)
          this.view.dispatch({ effects: this.setHover.of([]) });
        else
          this.watchTooltipLeave(tooltip.dom);
      }
    }
    watchTooltipLeave(tooltip) {
      let watch = (event) => {
        tooltip.removeEventListener("mouseleave", watch);
        if (this.active.length && !this.view.dom.contains(event.relatedTarget))
          this.view.dispatch({ effects: this.setHover.of([]) });
      };
      tooltip.addEventListener("mouseleave", watch);
    }
    destroy() {
      clearTimeout(this.hoverTimeout);
      this.view.dom.removeEventListener("mouseleave", this.mouseleave);
      this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
  };
  var tooltipMargin = 4;
  function isInTooltip(tooltip, event) {
    let rect = tooltip.getBoundingClientRect();
    return event.clientX >= rect.left - tooltipMargin && event.clientX <= rect.right + tooltipMargin && event.clientY >= rect.top - tooltipMargin && event.clientY <= rect.bottom + tooltipMargin;
  }
  function isOverRange(view, from, to, x2, y3, margin) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
    if (rect.left > x2 || rect.right < x2 || rect.top > y3 || Math.min(rect.bottom, docBottom) < y3)
      return false;
    let pos = view.posAtCoords({ x: x2, y: y3 }, false);
    return pos >= from && pos <= to;
  }
  function hoverTooltip(source, options = {}) {
    let setHover = StateEffect.define();
    let hoverState = StateField.define({
      create() {
        return [];
      },
      update(value, tr) {
        if (value.length) {
          if (options.hideOnChange && (tr.docChanged || tr.selection))
            value = [];
          else if (options.hideOn)
            value = value.filter((v3) => !options.hideOn(tr, v3));
          if (tr.docChanged) {
            let mapped = [];
            for (let tooltip of value) {
              let newPos = tr.changes.mapPos(tooltip.pos, -1, MapMode.TrackDel);
              if (newPos != null) {
                let copy = Object.assign(/* @__PURE__ */ Object.create(null), tooltip);
                copy.pos = newPos;
                if (copy.end != null)
                  copy.end = tr.changes.mapPos(copy.end);
                mapped.push(copy);
              }
            }
            value = mapped;
          }
        }
        for (let effect of tr.effects) {
          if (effect.is(setHover))
            value = effect.value;
          if (effect.is(closeHoverTooltipEffect))
            value = [];
        }
        return value;
      },
      provide: (f3) => showHoverTooltip.from(f3)
    });
    return [
      hoverState,
      ViewPlugin.define((view) => new HoverPlugin(
        view,
        source,
        hoverState,
        setHover,
        options.hoverTime || 300
        /* Hover.Time */
      )),
      showHoverTooltipHost
    ];
  }
  var closeHoverTooltipEffect = /* @__PURE__ */ StateEffect.define();
  var panelConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let topContainer, bottomContainer;
      for (let c4 of configs) {
        topContainer = topContainer || c4.topContainer;
        bottomContainer = bottomContainer || c4.bottomContainer;
      }
      return { topContainer, bottomContainer };
    }
  });
  var panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.input = view.state.facet(showPanel);
      this.specs = this.input.filter((s4) => s4);
      this.panels = this.specs.map((spec) => spec(view));
      let conf = view.state.facet(panelConfig);
      this.top = new PanelGroup(view, true, conf.topContainer);
      this.bottom = new PanelGroup(view, false, conf.bottomContainer);
      this.top.sync(this.panels.filter((p4) => p4.top));
      this.bottom.sync(this.panels.filter((p4) => !p4.top));
      for (let p4 of this.panels) {
        p4.dom.classList.add("cm-panel");
        if (p4.mount)
          p4.mount();
      }
    }
    update(update) {
      let conf = update.state.facet(panelConfig);
      if (this.top.container != conf.topContainer) {
        this.top.sync([]);
        this.top = new PanelGroup(update.view, true, conf.topContainer);
      }
      if (this.bottom.container != conf.bottomContainer) {
        this.bottom.sync([]);
        this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
      }
      this.top.syncClasses();
      this.bottom.syncClasses();
      let input = update.state.facet(showPanel);
      if (input != this.input) {
        let specs = input.filter((x2) => x2);
        let panels = [], top2 = [], bottom = [], mount = [];
        for (let spec of specs) {
          let known = this.specs.indexOf(spec), panel;
          if (known < 0) {
            panel = spec(update.view);
            mount.push(panel);
          } else {
            panel = this.panels[known];
            if (panel.update)
              panel.update(update);
          }
          panels.push(panel);
          (panel.top ? top2 : bottom).push(panel);
        }
        this.specs = specs;
        this.panels = panels;
        this.top.sync(top2);
        this.bottom.sync(bottom);
        for (let p4 of mount) {
          p4.dom.classList.add("cm-panel");
          if (p4.mount)
            p4.mount();
        }
      } else {
        for (let p4 of this.panels)
          if (p4.update)
            p4.update(update);
      }
    }
    destroy() {
      this.top.sync([]);
      this.bottom.sync([]);
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view) => {
      let value = view.plugin(plugin);
      return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
    })
  });
  var PanelGroup = class {
    constructor(view, top2, container) {
      this.view = view;
      this.top = top2;
      this.container = container;
      this.dom = void 0;
      this.classes = "";
      this.panels = [];
      this.syncClasses();
    }
    sync(panels) {
      for (let p4 of this.panels)
        if (p4.destroy && panels.indexOf(p4) < 0)
          p4.destroy();
      this.panels = panels;
      this.syncDOM();
    }
    syncDOM() {
      if (this.panels.length == 0) {
        if (this.dom) {
          this.dom.remove();
          this.dom = void 0;
        }
        return;
      }
      if (!this.dom) {
        this.dom = document.createElement("div");
        this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
        this.dom.style[this.top ? "top" : "bottom"] = "0";
        let parent = this.container || this.view.dom;
        parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
      }
      let curDOM = this.dom.firstChild;
      for (let panel of this.panels) {
        if (panel.dom.parentNode == this.dom) {
          while (curDOM != panel.dom)
            curDOM = rm(curDOM);
          curDOM = curDOM.nextSibling;
        } else {
          this.dom.insertBefore(panel.dom, curDOM);
        }
      }
      while (curDOM)
        curDOM = rm(curDOM);
    }
    scrollMargin() {
      return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
      if (!this.container || this.classes == this.view.themeClasses)
        return;
      for (let cls of this.classes.split(" "))
        if (cls)
          this.container.classList.remove(cls);
      for (let cls of (this.classes = this.view.themeClasses).split(" "))
        if (cls)
          this.container.classList.add(cls);
    }
  };
  function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
  }
  var showPanel = /* @__PURE__ */ Facet.define({
    enables: panelPlugin
  });
  var GutterMarker = class extends RangeValue {
    /**
    @internal
    */
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    /**
    Compare this marker to another marker of the same type.
    */
    eq(other) {
      return false;
    }
    /**
    Called if the marker has a `toDOM` method and its representation
    was removed from a gutter.
    */
    destroy(dom) {
    }
  };
  GutterMarker.prototype.elementClass = "";
  GutterMarker.prototype.toDOM = void 0;
  GutterMarker.prototype.mapMode = MapMode.TrackBefore;
  GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
  GutterMarker.prototype.point = true;
  var gutterLineClass = /* @__PURE__ */ Facet.define();
  var defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => RangeSet.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
  };
  var activeGutters = /* @__PURE__ */ Facet.define();
  function gutter(config) {
    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];
  }
  var unfixGutters = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x2) => x2)
  });
  function gutters(config) {
    let result = [
      gutterView
    ];
    if (config && config.fixed === false)
      result.push(unfixGutters.of(true));
    return result;
  }
  var gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.prevViewport = view.viewport;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutters";
      this.dom.setAttribute("aria-hidden", "true");
      this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
      this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
      for (let gutter2 of this.gutters)
        this.dom.appendChild(gutter2.dom);
      this.fixed = !view.state.facet(unfixGutters);
      if (this.fixed) {
        this.dom.style.position = "sticky";
      }
      this.syncGutters(false);
      view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    }
    update(update) {
      if (this.updateGutters(update)) {
        let vpA = this.prevViewport, vpB = update.view.viewport;
        let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
        this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
      }
      if (update.geometryChanged) {
        this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
      }
      if (this.view.state.facet(unfixGutters) != !this.fixed) {
        this.fixed = !this.fixed;
        this.dom.style.position = this.fixed ? "sticky" : "";
      }
      this.prevViewport = update.view.viewport;
    }
    syncGutters(detach) {
      let after = this.dom.nextSibling;
      if (detach)
        this.dom.remove();
      let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
      let classSet = [];
      let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
      for (let line of this.view.viewportLineBlocks) {
        if (classSet.length)
          classSet = [];
        if (Array.isArray(line.type)) {
          let first = true;
          for (let b4 of line.type) {
            if (b4.type == BlockType.Text && first) {
              advanceCursor(lineClasses, classSet, b4.from);
              for (let cx of contexts)
                cx.line(this.view, b4, classSet);
              first = false;
            } else if (b4.widget) {
              for (let cx of contexts)
                cx.widget(this.view, b4);
            }
          }
        } else if (line.type == BlockType.Text) {
          advanceCursor(lineClasses, classSet, line.from);
          for (let cx of contexts)
            cx.line(this.view, line, classSet);
        } else if (line.widget) {
          for (let cx of contexts)
            cx.widget(this.view, line);
        }
      }
      for (let cx of contexts)
        cx.finish();
      if (detach)
        this.view.scrollDOM.insertBefore(this.dom, after);
    }
    updateGutters(update) {
      let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);
      let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
      if (prev == cur) {
        for (let gutter2 of this.gutters)
          if (gutter2.update(update))
            change = true;
      } else {
        change = true;
        let gutters2 = [];
        for (let conf of cur) {
          let known = prev.indexOf(conf);
          if (known < 0) {
            gutters2.push(new SingleGutterView(this.view, conf));
          } else {
            this.gutters[known].update(update);
            gutters2.push(this.gutters[known]);
          }
        }
        for (let g3 of this.gutters) {
          g3.dom.remove();
          if (gutters2.indexOf(g3) < 0)
            g3.destroy();
        }
        for (let g3 of gutters2)
          this.dom.appendChild(g3.dom);
        this.gutters = gutters2;
      }
      return change;
    }
    destroy() {
      for (let view of this.gutters)
        view.destroy();
      this.dom.remove();
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view) => {
      let value = view.plugin(plugin);
      if (!value || value.gutters.length == 0 || !value.fixed)
        return null;
      return view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth * view.scaleX } : { right: value.dom.offsetWidth * view.scaleX };
    })
  });
  function asArray2(val) {
    return Array.isArray(val) ? val : [val];
  }
  function advanceCursor(cursor, collect, pos) {
    while (cursor.value && cursor.from <= pos) {
      if (cursor.from == pos)
        collect.push(cursor.value);
      cursor.next();
    }
  }
  var UpdateContext = class {
    constructor(gutter2, viewport, height) {
      this.gutter = gutter2;
      this.height = height;
      this.i = 0;
      this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
    }
    addElement(view, block, markers) {
      let { gutter: gutter2 } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
      if (this.i == gutter2.elements.length) {
        let newElt = new GutterElement(view, height, above, markers);
        gutter2.elements.push(newElt);
        gutter2.dom.appendChild(newElt.dom);
      } else {
        gutter2.elements[this.i].update(view, height, above, markers);
      }
      this.height = block.bottom;
      this.i++;
    }
    line(view, line, extraMarkers) {
      let localMarkers = [];
      advanceCursor(this.cursor, localMarkers, line.from);
      if (extraMarkers.length)
        localMarkers = localMarkers.concat(extraMarkers);
      let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
      if (forLine)
        localMarkers.unshift(forLine);
      let gutter2 = this.gutter;
      if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
        return;
      this.addElement(view, line, localMarkers);
    }
    widget(view, block) {
      let marker = this.gutter.config.widgetMarker(view, block.widget, block);
      if (marker)
        this.addElement(view, block, [marker]);
    }
    finish() {
      let gutter2 = this.gutter;
      while (gutter2.elements.length > this.i) {
        let last = gutter2.elements.pop();
        gutter2.dom.removeChild(last.dom);
        last.destroy();
      }
    }
  };
  var SingleGutterView = class {
    constructor(view, config) {
      this.view = view;
      this.config = config;
      this.elements = [];
      this.spacer = null;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
      for (let prop in config.domEventHandlers) {
        this.dom.addEventListener(prop, (event) => {
          let target = event.target, y3;
          if (target != this.dom && this.dom.contains(target)) {
            while (target.parentNode != this.dom)
              target = target.parentNode;
            let rect = target.getBoundingClientRect();
            y3 = (rect.top + rect.bottom) / 2;
          } else {
            y3 = event.clientY;
          }
          let line = view.lineBlockAtHeight(y3 - view.documentTop);
          if (config.domEventHandlers[prop](view, line, event))
            event.preventDefault();
        });
      }
      this.markers = asArray2(config.markers(view));
      if (config.initialSpacer) {
        this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
        this.dom.appendChild(this.spacer.dom);
        this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
      }
    }
    update(update) {
      let prevMarkers = this.markers;
      this.markers = asArray2(this.config.markers(update.view));
      if (this.spacer && this.config.updateSpacer) {
        let updated = this.config.updateSpacer(this.spacer.markers[0], update);
        if (updated != this.spacer.markers[0])
          this.spacer.update(update.view, 0, 0, [updated]);
      }
      let vp = update.view.viewport;
      return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
    }
    destroy() {
      for (let elt of this.elements)
        elt.destroy();
    }
  };
  var GutterElement = class {
    constructor(view, height, above, markers) {
      this.height = -1;
      this.above = 0;
      this.markers = [];
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutterElement";
      this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
      if (this.height != height) {
        this.height = height;
        this.dom.style.height = height + "px";
      }
      if (this.above != above)
        this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
      if (!sameMarkers(this.markers, markers))
        this.setMarkers(view, markers);
    }
    setMarkers(view, markers) {
      let cls = "cm-gutterElement", domPos = this.dom.firstChild;
      for (let iNew = 0, iOld = 0; ; ) {
        let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
        if (marker) {
          let c4 = marker.elementClass;
          if (c4)
            cls += " " + c4;
          for (let i4 = iOld; i4 < this.markers.length; i4++)
            if (this.markers[i4].compare(marker)) {
              skipTo = i4;
              matched = true;
              break;
            }
        } else {
          skipTo = this.markers.length;
        }
        while (iOld < skipTo) {
          let next = this.markers[iOld++];
          if (next.toDOM) {
            next.destroy(domPos);
            let after = domPos.nextSibling;
            domPos.remove();
            domPos = after;
          }
        }
        if (!marker)
          break;
        if (marker.toDOM) {
          if (matched)
            domPos = domPos.nextSibling;
          else
            this.dom.insertBefore(marker.toDOM(view), domPos);
        }
        if (matched)
          iOld++;
      }
      this.dom.className = cls;
      this.markers = markers;
    }
    destroy() {
      this.setMarkers(null, []);
    }
  };
  function sameMarkers(a4, b4) {
    if (a4.length != b4.length)
      return false;
    for (let i4 = 0; i4 < a4.length; i4++)
      if (!a4[i4].compare(b4[i4]))
        return false;
    return true;
  }
  var lineNumberMarkers = /* @__PURE__ */ Facet.define();
  var lineNumberConfig = /* @__PURE__ */ Facet.define({
    combine(values) {
      return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
        domEventHandlers(a4, b4) {
          let result = Object.assign({}, a4);
          for (let event in b4) {
            let exists = result[event], add2 = b4[event];
            result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add2(view, line, event2) : add2;
          }
          return result;
        }
      });
    }
  });
  var NumberMarker = class extends GutterMarker {
    constructor(number2) {
      super();
      this.number = number2;
    }
    eq(other) {
      return this.number == other.number;
    }
    toDOM() {
      return document.createTextNode(this.number);
    }
  };
  function formatNumber(view, number2) {
    return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
  }
  var lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state) => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view) {
      return view.state.facet(lineNumberMarkers);
    },
    lineMarker(view, line, others) {
      if (others.some((m3) => m3.toDOM))
        return null;
      return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    widgetMarker: () => null,
    lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
    initialSpacer(view) {
      return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update) {
      let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
      return max == spacer.number ? spacer : new NumberMarker(max);
    },
    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
  }));
  function lineNumbers(config = {}) {
    return [
      lineNumberConfig.of(config),
      gutters(),
      lineNumberGutter
    ];
  }
  function maxLineNumber(lines2) {
    let last = 9;
    while (last < lines2)
      last = last * 10 + 9;
    return last;
  }
  var activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
    constructor() {
      super(...arguments);
      this.elementClass = "cm-activeLineGutter";
    }
  }();
  var activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state) => {
    let marks2 = [], last = -1;
    for (let range of state.selection.ranges) {
      let linePos = state.doc.lineAt(range.head).from;
      if (linePos > last) {
        last = linePos;
        marks2.push(activeLineGutterMarker.range(linePos));
      }
    }
    return RangeSet.of(marks2);
  });
  function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
  }

  // node_modules/.pnpm/@lezer+highlight@1.2.0/node_modules/@lezer/highlight/dist/index.js
  var nextTagID = 0;
  var Tag = class _Tag {
    /**
    @internal
    */
    constructor(set2, base2, modified) {
      this.set = set2;
      this.base = base2;
      this.modified = modified;
      this.id = nextTagID++;
    }
    /**
    Define a new tag. If `parent` is given, the tag is treated as a
    sub-tag of that parent, and
    [highlighters](#highlight.tagHighlighter) that don't mention
    this tag will try to fall back to the parent tag (or grandparent
    tag, etc).
    */
    static define(parent) {
      if (parent === null || parent === void 0 ? void 0 : parent.base)
        throw new Error("Can not derive from a modified tag");
      let tag = new _Tag([], null, []);
      tag.set.push(tag);
      if (parent)
        for (let t5 of parent.set)
          tag.set.push(t5);
      return tag;
    }
    /**
    Define a tag _modifier_, which is a function that, given a tag,
    will return a tag that is a subtag of the original. Applying the
    same modifier to a twice tag will return the same value (`m1(t1)
    == m1(t1)`) and applying multiple modifiers will, regardless or
    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
    
    When multiple modifiers are applied to a given base tag, each
    smaller set of modifiers is registered as a parent, so that for
    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
    `m1(m3(t1)`, and so on.
    */
    static defineModifier() {
      let mod = new Modifier();
      return (tag) => {
        if (tag.modified.indexOf(mod) > -1)
          return tag;
        return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a4, b4) => a4.id - b4.id));
      };
    }
  };
  var nextModifierID = 0;
  var Modifier = class _Modifier {
    constructor() {
      this.instances = [];
      this.id = nextModifierID++;
    }
    static get(base2, mods) {
      if (!mods.length)
        return base2;
      let exists = mods[0].instances.find((t5) => t5.base == base2 && sameArray2(mods, t5.modified));
      if (exists)
        return exists;
      let set2 = [], tag = new Tag(set2, base2, mods);
      for (let m3 of mods)
        m3.instances.push(tag);
      let configs = powerSet(mods);
      for (let parent of base2.set)
        if (!parent.modified.length)
          for (let config of configs)
            set2.push(_Modifier.get(parent, config));
      return tag;
    }
  };
  function sameArray2(a4, b4) {
    return a4.length == b4.length && a4.every((x2, i4) => x2 == b4[i4]);
  }
  function powerSet(array) {
    let sets = [[]];
    for (let i4 = 0; i4 < array.length; i4++) {
      for (let j2 = 0, e4 = sets.length; j2 < e4; j2++) {
        sets.push(sets[j2].concat(array[i4]));
      }
    }
    return sets.sort((a4, b4) => b4.length - a4.length);
  }
  function styleTags(spec) {
    let byName = /* @__PURE__ */ Object.create(null);
    for (let prop in spec) {
      let tags2 = spec[prop];
      if (!Array.isArray(tags2))
        tags2 = [tags2];
      for (let part of prop.split(" "))
        if (part) {
          let pieces = [], mode = 2, rest = part;
          for (let pos = 0; ; ) {
            if (rest == "..." && pos > 0 && pos + 3 == part.length) {
              mode = 1;
              break;
            }
            let m3 = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
            if (!m3)
              throw new RangeError("Invalid path: " + part);
            pieces.push(m3[0] == "*" ? "" : m3[0][0] == '"' ? JSON.parse(m3[0]) : m3[0]);
            pos += m3[0].length;
            if (pos == part.length)
              break;
            let next = part[pos++];
            if (pos == part.length && next == "!") {
              mode = 0;
              break;
            }
            if (next != "/")
              throw new RangeError("Invalid path: " + part);
            rest = part.slice(pos);
          }
          let last = pieces.length - 1, inner = pieces[last];
          if (!inner)
            throw new RangeError("Invalid path: " + part);
          let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
          byName[inner] = rule.sort(byName[inner]);
        }
    }
    return ruleNodeProp.add(byName);
  }
  var ruleNodeProp = new NodeProp();
  var Rule = class {
    constructor(tags2, mode, context, next) {
      this.tags = tags2;
      this.mode = mode;
      this.context = context;
      this.next = next;
    }
    get opaque() {
      return this.mode == 0;
    }
    get inherit() {
      return this.mode == 1;
    }
    sort(other) {
      if (!other || other.depth < this.depth) {
        this.next = other;
        return this;
      }
      other.next = this.sort(other.next);
      return other;
    }
    get depth() {
      return this.context ? this.context.length : 0;
    }
  };
  Rule.empty = new Rule([], 2, null);
  function tagHighlighter(tags2, options) {
    let map2 = /* @__PURE__ */ Object.create(null);
    for (let style of tags2) {
      if (!Array.isArray(style.tag))
        map2[style.tag.id] = style.class;
      else
        for (let tag of style.tag)
          map2[tag.id] = style.class;
    }
    let { scope, all = null } = options || {};
    return {
      style: (tags3) => {
        let cls = all;
        for (let tag of tags3) {
          for (let sub of tag.set) {
            let tagClass = map2[sub.id];
            if (tagClass) {
              cls = cls ? cls + " " + tagClass : tagClass;
              break;
            }
          }
        }
        return cls;
      },
      scope
    };
  }
  function highlightTags(highlighters, tags2) {
    let result = null;
    for (let highlighter of highlighters) {
      let value = highlighter.style(tags2);
      if (value)
        result = result ? result + " " + value : value;
    }
    return result;
  }
  function highlightTree(tree, highlighter, putStyle, from = 0, to = tree.length) {
    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
    builder.flush(to);
  }
  var HighlightBuilder = class {
    constructor(at, highlighters, span) {
      this.at = at;
      this.highlighters = highlighters;
      this.span = span;
      this.class = "";
    }
    startSpan(at, cls) {
      if (cls != this.class) {
        this.flush(at);
        if (at > this.at)
          this.at = at;
        this.class = cls;
      }
    }
    flush(to) {
      if (to > this.at && this.class)
        this.span(this.at, to, this.class);
    }
    highlightRange(cursor, from, to, inheritedClass, highlighters) {
      let { type: type2, from: start, to: end } = cursor;
      if (start >= to || end <= from)
        return;
      if (type2.isTop)
        highlighters = this.highlighters.filter((h4) => !h4.scope || h4.scope(type2));
      let cls = inheritedClass;
      let rule = getStyleTags(cursor) || Rule.empty;
      let tagCls = highlightTags(highlighters, rule.tags);
      if (tagCls) {
        if (cls)
          cls += " ";
        cls += tagCls;
        if (rule.mode == 1)
          inheritedClass += (inheritedClass ? " " : "") + tagCls;
      }
      this.startSpan(Math.max(from, start), cls);
      if (rule.opaque)
        return;
      let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
      if (mounted && mounted.overlay) {
        let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
        let innerHighlighters = this.highlighters.filter((h4) => !h4.scope || h4.scope(mounted.tree.type));
        let hasChild2 = cursor.firstChild();
        for (let i4 = 0, pos = start; ; i4++) {
          let next = i4 < mounted.overlay.length ? mounted.overlay[i4] : null;
          let nextPos = next ? next.from + start : end;
          let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
          if (rangeFrom < rangeTo && hasChild2) {
            while (cursor.from < rangeTo) {
              this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
              this.startSpan(Math.min(rangeTo, cursor.to), cls);
              if (cursor.to >= nextPos || !cursor.nextSibling())
                break;
            }
          }
          if (!next || nextPos > to)
            break;
          pos = next.to + start;
          if (pos > from) {
            this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), "", innerHighlighters);
            this.startSpan(Math.min(to, pos), cls);
          }
        }
        if (hasChild2)
          cursor.parent();
      } else if (cursor.firstChild()) {
        if (mounted)
          inheritedClass = "";
        do {
          if (cursor.to <= from)
            continue;
          if (cursor.from >= to)
            break;
          this.highlightRange(cursor, from, to, inheritedClass, highlighters);
          this.startSpan(Math.min(to, cursor.to), cls);
        } while (cursor.nextSibling());
        cursor.parent();
      }
    }
  };
  function getStyleTags(node) {
    let rule = node.type.prop(ruleNodeProp);
    while (rule && rule.context && !node.matchContext(rule.context))
      rule = rule.next;
    return rule || null;
  }
  var t2 = Tag.define;
  var comment = t2();
  var name = t2();
  var typeName = t2(name);
  var propertyName = t2(name);
  var literal = t2();
  var string = t2(literal);
  var number = t2(literal);
  var content = t2();
  var heading = t2(content);
  var keyword = t2();
  var operator = t2();
  var punctuation = t2();
  var bracket = t2(punctuation);
  var meta = t2();
  var tags = {
    /**
    A comment.
    */
    comment,
    /**
    A line [comment](#highlight.tags.comment).
    */
    lineComment: t2(comment),
    /**
    A block [comment](#highlight.tags.comment).
    */
    blockComment: t2(comment),
    /**
    A documentation [comment](#highlight.tags.comment).
    */
    docComment: t2(comment),
    /**
    Any kind of identifier.
    */
    name,
    /**
    The [name](#highlight.tags.name) of a variable.
    */
    variableName: t2(name),
    /**
    A type [name](#highlight.tags.name).
    */
    typeName,
    /**
    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
    */
    tagName: t2(typeName),
    /**
    A property or field [name](#highlight.tags.name).
    */
    propertyName,
    /**
    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
    */
    attributeName: t2(propertyName),
    /**
    The [name](#highlight.tags.name) of a class.
    */
    className: t2(name),
    /**
    A label [name](#highlight.tags.name).
    */
    labelName: t2(name),
    /**
    A namespace [name](#highlight.tags.name).
    */
    namespace: t2(name),
    /**
    The [name](#highlight.tags.name) of a macro.
    */
    macroName: t2(name),
    /**
    A literal value.
    */
    literal,
    /**
    A string [literal](#highlight.tags.literal).
    */
    string,
    /**
    A documentation [string](#highlight.tags.string).
    */
    docString: t2(string),
    /**
    A character literal (subtag of [string](#highlight.tags.string)).
    */
    character: t2(string),
    /**
    An attribute value (subtag of [string](#highlight.tags.string)).
    */
    attributeValue: t2(string),
    /**
    A number [literal](#highlight.tags.literal).
    */
    number,
    /**
    An integer [number](#highlight.tags.number) literal.
    */
    integer: t2(number),
    /**
    A floating-point [number](#highlight.tags.number) literal.
    */
    float: t2(number),
    /**
    A boolean [literal](#highlight.tags.literal).
    */
    bool: t2(literal),
    /**
    Regular expression [literal](#highlight.tags.literal).
    */
    regexp: t2(literal),
    /**
    An escape [literal](#highlight.tags.literal), for example a
    backslash escape in a string.
    */
    escape: t2(literal),
    /**
    A color [literal](#highlight.tags.literal).
    */
    color: t2(literal),
    /**
    A URL [literal](#highlight.tags.literal).
    */
    url: t2(literal),
    /**
    A language keyword.
    */
    keyword,
    /**
    The [keyword](#highlight.tags.keyword) for the self or this
    object.
    */
    self: t2(keyword),
    /**
    The [keyword](#highlight.tags.keyword) for null.
    */
    null: t2(keyword),
    /**
    A [keyword](#highlight.tags.keyword) denoting some atomic value.
    */
    atom: t2(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that represents a unit.
    */
    unit: t2(keyword),
    /**
    A modifier [keyword](#highlight.tags.keyword).
    */
    modifier: t2(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that acts as an operator.
    */
    operatorKeyword: t2(keyword),
    /**
    A control-flow related [keyword](#highlight.tags.keyword).
    */
    controlKeyword: t2(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that defines something.
    */
    definitionKeyword: t2(keyword),
    /**
    A [keyword](#highlight.tags.keyword) related to defining or
    interfacing with modules.
    */
    moduleKeyword: t2(keyword),
    /**
    An operator.
    */
    operator,
    /**
    An [operator](#highlight.tags.operator) that dereferences something.
    */
    derefOperator: t2(operator),
    /**
    Arithmetic-related [operator](#highlight.tags.operator).
    */
    arithmeticOperator: t2(operator),
    /**
    Logical [operator](#highlight.tags.operator).
    */
    logicOperator: t2(operator),
    /**
    Bit [operator](#highlight.tags.operator).
    */
    bitwiseOperator: t2(operator),
    /**
    Comparison [operator](#highlight.tags.operator).
    */
    compareOperator: t2(operator),
    /**
    [Operator](#highlight.tags.operator) that updates its operand.
    */
    updateOperator: t2(operator),
    /**
    [Operator](#highlight.tags.operator) that defines something.
    */
    definitionOperator: t2(operator),
    /**
    Type-related [operator](#highlight.tags.operator).
    */
    typeOperator: t2(operator),
    /**
    Control-flow [operator](#highlight.tags.operator).
    */
    controlOperator: t2(operator),
    /**
    Program or markup punctuation.
    */
    punctuation,
    /**
    [Punctuation](#highlight.tags.punctuation) that separates
    things.
    */
    separator: t2(punctuation),
    /**
    Bracket-style [punctuation](#highlight.tags.punctuation).
    */
    bracket,
    /**
    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
    tokens).
    */
    angleBracket: t2(bracket),
    /**
    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
    tokens).
    */
    squareBracket: t2(bracket),
    /**
    Parentheses (usually `(` and `)` tokens). Subtag of
    [bracket](#highlight.tags.bracket).
    */
    paren: t2(bracket),
    /**
    Braces (usually `{` and `}` tokens). Subtag of
    [bracket](#highlight.tags.bracket).
    */
    brace: t2(bracket),
    /**
    Content, for example plain text in XML or markup documents.
    */
    content,
    /**
    [Content](#highlight.tags.content) that represents a heading.
    */
    heading,
    /**
    A level 1 [heading](#highlight.tags.heading).
    */
    heading1: t2(heading),
    /**
    A level 2 [heading](#highlight.tags.heading).
    */
    heading2: t2(heading),
    /**
    A level 3 [heading](#highlight.tags.heading).
    */
    heading3: t2(heading),
    /**
    A level 4 [heading](#highlight.tags.heading).
    */
    heading4: t2(heading),
    /**
    A level 5 [heading](#highlight.tags.heading).
    */
    heading5: t2(heading),
    /**
    A level 6 [heading](#highlight.tags.heading).
    */
    heading6: t2(heading),
    /**
    A prose separator (such as a horizontal rule).
    */
    contentSeparator: t2(content),
    /**
    [Content](#highlight.tags.content) that represents a list.
    */
    list: t2(content),
    /**
    [Content](#highlight.tags.content) that represents a quote.
    */
    quote: t2(content),
    /**
    [Content](#highlight.tags.content) that is emphasized.
    */
    emphasis: t2(content),
    /**
    [Content](#highlight.tags.content) that is styled strong.
    */
    strong: t2(content),
    /**
    [Content](#highlight.tags.content) that is part of a link.
    */
    link: t2(content),
    /**
    [Content](#highlight.tags.content) that is styled as code or
    monospace.
    */
    monospace: t2(content),
    /**
    [Content](#highlight.tags.content) that has a strike-through
    style.
    */
    strikethrough: t2(content),
    /**
    Inserted text in a change-tracking format.
    */
    inserted: t2(),
    /**
    Deleted text.
    */
    deleted: t2(),
    /**
    Changed text.
    */
    changed: t2(),
    /**
    An invalid or unsyntactic element.
    */
    invalid: t2(),
    /**
    Metadata or meta-instruction.
    */
    meta,
    /**
    [Metadata](#highlight.tags.meta) that applies to the entire
    document.
    */
    documentMeta: t2(meta),
    /**
    [Metadata](#highlight.tags.meta) that annotates or adds
    attributes to a given syntactic element.
    */
    annotation: t2(meta),
    /**
    Processing instruction or preprocessor directive. Subtag of
    [meta](#highlight.tags.meta).
    */
    processingInstruction: t2(meta),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates that a
    given element is being defined. Expected to be used with the
    various [name](#highlight.tags.name) tags.
    */
    definition: Tag.defineModifier(),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates that
    something is constant. Mostly expected to be used with
    [variable names](#highlight.tags.variableName).
    */
    constant: Tag.defineModifier(),
    /**
    [Modifier](#highlight.Tag^defineModifier) used to indicate that
    a [variable](#highlight.tags.variableName) or [property
    name](#highlight.tags.propertyName) is being called or defined
    as a function.
    */
    function: Tag.defineModifier(),
    /**
    [Modifier](#highlight.Tag^defineModifier) that can be applied to
    [names](#highlight.tags.name) to indicate that they belong to
    the language's standard environment.
    */
    standard: Tag.defineModifier(),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates a given
    [names](#highlight.tags.name) is local to some scope.
    */
    local: Tag.defineModifier(),
    /**
    A generic variant [modifier](#highlight.Tag^defineModifier) that
    can be used to tag language-specific alternative variants of
    some common tag. It is recommended for themes to define special
    forms of at least the [string](#highlight.tags.string) and
    [variable name](#highlight.tags.variableName) tags, since those
    come up a lot.
    */
    special: Tag.defineModifier()
  };
  var classHighlighter = tagHighlighter([
    { tag: tags.link, class: "tok-link" },
    { tag: tags.heading, class: "tok-heading" },
    { tag: tags.emphasis, class: "tok-emphasis" },
    { tag: tags.strong, class: "tok-strong" },
    { tag: tags.keyword, class: "tok-keyword" },
    { tag: tags.atom, class: "tok-atom" },
    { tag: tags.bool, class: "tok-bool" },
    { tag: tags.url, class: "tok-url" },
    { tag: tags.labelName, class: "tok-labelName" },
    { tag: tags.inserted, class: "tok-inserted" },
    { tag: tags.deleted, class: "tok-deleted" },
    { tag: tags.literal, class: "tok-literal" },
    { tag: tags.string, class: "tok-string" },
    { tag: tags.number, class: "tok-number" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
    { tag: tags.variableName, class: "tok-variableName" },
    { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
    { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
    { tag: tags.special(tags.variableName), class: "tok-variableName2" },
    { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
    { tag: tags.typeName, class: "tok-typeName" },
    { tag: tags.namespace, class: "tok-namespace" },
    { tag: tags.className, class: "tok-className" },
    { tag: tags.macroName, class: "tok-macroName" },
    { tag: tags.propertyName, class: "tok-propertyName" },
    { tag: tags.operator, class: "tok-operator" },
    { tag: tags.comment, class: "tok-comment" },
    { tag: tags.meta, class: "tok-meta" },
    { tag: tags.invalid, class: "tok-invalid" },
    { tag: tags.punctuation, class: "tok-punctuation" }
  ]);

  // node_modules/.pnpm/@codemirror+language@6.10.2/node_modules/@codemirror/language/dist/index.js
  var _a;
  var languageDataProp = /* @__PURE__ */ new NodeProp();
  function defineLanguageFacet(baseData) {
    return Facet.define({
      combine: baseData ? (values) => values.concat(baseData) : void 0
    });
  }
  var sublanguageProp = /* @__PURE__ */ new NodeProp();
  var Language = class {
    /**
    Construct a language object. If you need to invoke this
    directly, first define a data facet with
    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
    to the language's outer syntax node.
    */
    constructor(data, parser4, extraExtensions = [], name2 = "") {
      this.data = data;
      this.name = name2;
      if (!EditorState.prototype.hasOwnProperty("tree"))
        Object.defineProperty(EditorState.prototype, "tree", { get() {
          return syntaxTree(this);
        } });
      this.parser = parser4;
      this.extension = [
        language.of(this),
        EditorState.languageData.of((state, pos, side) => {
          let top2 = topNodeAt(state, pos, side), data2 = top2.type.prop(languageDataProp);
          if (!data2)
            return [];
          let base2 = state.facet(data2), sub = top2.type.prop(sublanguageProp);
          if (sub) {
            let innerNode = top2.resolve(pos - top2.from, side);
            for (let sublang of sub)
              if (sublang.test(innerNode, state)) {
                let data3 = state.facet(sublang.facet);
                return sublang.type == "replace" ? data3 : data3.concat(base2);
              }
          }
          return base2;
        })
      ].concat(extraExtensions);
    }
    /**
    Query whether this language is active at the given position.
    */
    isActiveAt(state, pos, side = -1) {
      return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
    }
    /**
    Find the document regions that were parsed using this language.
    The returned regions will _include_ any nested languages rooted
    in this language, when those exist.
    */
    findRegions(state) {
      let lang = state.facet(language);
      if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
        return [{ from: 0, to: state.doc.length }];
      if (!lang || !lang.allowsNesting)
        return [];
      let result = [];
      let explore = (tree, from) => {
        if (tree.prop(languageDataProp) == this.data) {
          result.push({ from, to: from + tree.length });
          return;
        }
        let mount = tree.prop(NodeProp.mounted);
        if (mount) {
          if (mount.tree.prop(languageDataProp) == this.data) {
            if (mount.overlay)
              for (let r3 of mount.overlay)
                result.push({ from: r3.from + from, to: r3.to + from });
            else
              result.push({ from, to: from + tree.length });
            return;
          } else if (mount.overlay) {
            let size = result.length;
            explore(mount.tree, mount.overlay[0].from + from);
            if (result.length > size)
              return;
          }
        }
        for (let i4 = 0; i4 < tree.children.length; i4++) {
          let ch = tree.children[i4];
          if (ch instanceof Tree)
            explore(ch, tree.positions[i4] + from);
        }
      };
      explore(syntaxTree(state), 0);
      return result;
    }
    /**
    Indicates whether this language allows nested languages. The
    default implementation returns true.
    */
    get allowsNesting() {
      return true;
    }
  };
  Language.setState = /* @__PURE__ */ StateEffect.define();
  function topNodeAt(state, pos, side) {
    let topLang = state.facet(language), tree = syntaxTree(state).topNode;
    if (!topLang || topLang.allowsNesting) {
      for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
        if (node.type.isTop)
          tree = node;
    }
    return tree;
  }
  var LRLanguage = class _LRLanguage extends Language {
    constructor(data, parser4, name2) {
      super(data, parser4, [], name2);
      this.parser = parser4;
    }
    /**
    Define a language from a parser.
    */
    static define(spec) {
      let data = defineLanguageFacet(spec.languageData);
      return new _LRLanguage(data, spec.parser.configure({
        props: [languageDataProp.add((type2) => type2.isTop ? data : void 0)]
      }), spec.name);
    }
    /**
    Create a new instance of this language with a reconfigured
    version of its parser and optionally a new name.
    */
    configure(options, name2) {
      return new _LRLanguage(this.data, this.parser.configure(options), name2 || this.name);
    }
    get allowsNesting() {
      return this.parser.hasWrappers();
    }
  };
  function syntaxTree(state) {
    let field = state.field(Language.state, false);
    return field ? field.tree : Tree.empty;
  }
  var DocInput = class {
    /**
    Create an input object for the given document.
    */
    constructor(doc2) {
      this.doc = doc2;
      this.cursorPos = 0;
      this.string = "";
      this.cursor = doc2.iter();
    }
    get length() {
      return this.doc.length;
    }
    syncTo(pos) {
      this.string = this.cursor.next(pos - this.cursorPos).value;
      this.cursorPos = pos + this.string.length;
      return this.cursorPos - this.string.length;
    }
    chunk(pos) {
      this.syncTo(pos);
      return this.string;
    }
    get lineChunks() {
      return true;
    }
    read(from, to) {
      let stringStart = this.cursorPos - this.string.length;
      if (from < stringStart || to >= this.cursorPos)
        return this.doc.sliceString(from, to);
      else
        return this.string.slice(from - stringStart, to - stringStart);
    }
  };
  var currentContext = null;
  var ParseContext = class _ParseContext {
    constructor(parser4, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
      this.parser = parser4;
      this.state = state;
      this.fragments = fragments;
      this.tree = tree;
      this.treeLen = treeLen;
      this.viewport = viewport;
      this.skipped = skipped;
      this.scheduleOn = scheduleOn;
      this.parse = null;
      this.tempSkipped = [];
    }
    /**
    @internal
    */
    static create(parser4, state, viewport) {
      return new _ParseContext(parser4, state, [], Tree.empty, 0, viewport, [], null);
    }
    startParse() {
      return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    /**
    @internal
    */
    work(until, upto) {
      if (upto != null && upto >= this.state.doc.length)
        upto = void 0;
      if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
        this.takeTree();
        return true;
      }
      return this.withContext(() => {
        var _a2;
        if (typeof until == "number") {
          let endTime = Date.now() + until;
          until = () => Date.now() > endTime;
        }
        if (!this.parse)
          this.parse = this.startParse();
        if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
          this.parse.stopAt(upto);
        for (; ; ) {
          let done = this.parse.advance();
          if (done) {
            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
            this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
            this.tree = done;
            this.parse = null;
            if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
              this.parse = this.startParse();
            else
              return true;
          }
          if (until())
            return false;
        }
      });
    }
    /**
    @internal
    */
    takeTree() {
      let pos, tree;
      if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
        if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
          this.parse.stopAt(pos);
        this.withContext(() => {
          while (!(tree = this.parse.advance())) {
          }
        });
        this.treeLen = pos;
        this.tree = tree;
        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
        this.parse = null;
      }
    }
    withContext(f3) {
      let prev = currentContext;
      currentContext = this;
      try {
        return f3();
      } finally {
        currentContext = prev;
      }
    }
    withoutTempSkipped(fragments) {
      for (let r3; r3 = this.tempSkipped.pop(); )
        fragments = cutFragments(fragments, r3.from, r3.to);
      return fragments;
    }
    /**
    @internal
    */
    changes(changes, newState) {
      let { fragments, tree, treeLen, viewport, skipped } = this;
      this.takeTree();
      if (!changes.empty) {
        let ranges = [];
        changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
        fragments = TreeFragment.applyChanges(fragments, ranges);
        tree = Tree.empty;
        treeLen = 0;
        viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
        if (this.skipped.length) {
          skipped = [];
          for (let r3 of this.skipped) {
            let from = changes.mapPos(r3.from, 1), to = changes.mapPos(r3.to, -1);
            if (from < to)
              skipped.push({ from, to });
          }
        }
      }
      return new _ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    /**
    @internal
    */
    updateViewport(viewport) {
      if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
        return false;
      this.viewport = viewport;
      let startLen = this.skipped.length;
      for (let i4 = 0; i4 < this.skipped.length; i4++) {
        let { from, to } = this.skipped[i4];
        if (from < viewport.to && to > viewport.from) {
          this.fragments = cutFragments(this.fragments, from, to);
          this.skipped.splice(i4--, 1);
        }
      }
      if (this.skipped.length >= startLen)
        return false;
      this.reset();
      return true;
    }
    /**
    @internal
    */
    reset() {
      if (this.parse) {
        this.takeTree();
        this.parse = null;
      }
    }
    /**
    Notify the parse scheduler that the given region was skipped
    because it wasn't in view, and the parse should be restarted
    when it comes into view.
    */
    skipUntilInView(from, to) {
      this.skipped.push({ from, to });
    }
    /**
    Returns a parser intended to be used as placeholder when
    asynchronously loading a nested parser. It'll skip its input and
    mark it as not-really-parsed, so that the next update will parse
    it again.
    
    When `until` is given, a reparse will be scheduled when that
    promise resolves.
    */
    static getSkippingParser(until) {
      return new class extends Parser {
        createParse(input, fragments, ranges) {
          let from = ranges[0].from, to = ranges[ranges.length - 1].to;
          let parser4 = {
            parsedPos: from,
            advance() {
              let cx = currentContext;
              if (cx) {
                for (let r3 of ranges)
                  cx.tempSkipped.push(r3);
                if (until)
                  cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
              }
              this.parsedPos = to;
              return new Tree(NodeType.none, [], [], to - from);
            },
            stoppedAt: null,
            stopAt() {
            }
          };
          return parser4;
        }
      }();
    }
    /**
    @internal
    */
    isDone(upto) {
      upto = Math.min(upto, this.state.doc.length);
      let frags = this.fragments;
      return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    /**
    Get the context for the current parse, or `null` if no editor
    parse is in progress.
    */
    static get() {
      return currentContext;
    }
  };
  function cutFragments(fragments, from, to) {
    return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
  }
  var LanguageState = class _LanguageState {
    constructor(context) {
      this.context = context;
      this.tree = context.tree;
    }
    apply(tr) {
      if (!tr.docChanged && this.tree == this.context.tree)
        return this;
      let newCx = this.context.changes(tr.changes, tr.state);
      let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
      if (!newCx.work(20, upto))
        newCx.takeTree();
      return new _LanguageState(newCx);
    }
    static init(state) {
      let vpTo = Math.min(3e3, state.doc.length);
      let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
      if (!parseState.work(20, vpTo))
        parseState.takeTree();
      return new _LanguageState(parseState);
    }
  };
  Language.state = /* @__PURE__ */ StateField.define({
    create: LanguageState.init,
    update(value, tr) {
      for (let e4 of tr.effects)
        if (e4.is(Language.setState))
          return e4.value;
      if (tr.startState.facet(language) != tr.state.facet(language))
        return LanguageState.init(tr.state);
      return value.apply(tr);
    }
  });
  var requestIdle = (callback) => {
    let timeout = setTimeout(
      () => callback(),
      500
      /* Work.MaxPause */
    );
    return () => clearTimeout(timeout);
  };
  if (typeof requestIdleCallback != "undefined")
    requestIdle = (callback) => {
      let idle = -1, timeout = setTimeout(
        () => {
          idle = requestIdleCallback(callback, {
            timeout: 500 - 100
            /* Work.MinPause */
          });
        },
        100
        /* Work.MinPause */
      );
      return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
    };
  var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
  var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
    constructor(view) {
      this.view = view;
      this.working = null;
      this.workScheduled = 0;
      this.chunkEnd = -1;
      this.chunkBudget = -1;
      this.work = this.work.bind(this);
      this.scheduleWork();
    }
    update(update) {
      let cx = this.view.state.field(Language.state).context;
      if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
        this.scheduleWork();
      if (update.docChanged || update.selectionSet) {
        if (this.view.hasFocus)
          this.chunkBudget += 50;
        this.scheduleWork();
      }
      this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
      if (this.working)
        return;
      let { state } = this.view, field = state.field(Language.state);
      if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
        this.working = requestIdle(this.work);
    }
    work(deadline) {
      this.working = null;
      let now = Date.now();
      if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
        this.chunkEnd = now + 3e4;
        this.chunkBudget = 3e3;
      }
      if (this.chunkBudget <= 0)
        return;
      let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
      if (field.tree == field.context.tree && field.context.isDone(
        vpTo + 1e5
        /* Work.MaxParseAhead */
      ))
        return;
      let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
      let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
      let done = field.context.work(() => {
        return isInputPending && isInputPending() || Date.now() > endTime;
      }, vpTo + (viewportFirst ? 0 : 1e5));
      this.chunkBudget -= Date.now() - now;
      if (done || this.chunkBudget <= 0) {
        field.context.takeTree();
        this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
      }
      if (this.chunkBudget > 0 && !(done && !viewportFirst))
        this.scheduleWork();
      this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
      if (cx.scheduleOn) {
        this.workScheduled++;
        cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
        cx.scheduleOn = null;
      }
    }
    destroy() {
      if (this.working)
        this.working();
    }
    isWorking() {
      return !!(this.working || this.workScheduled > 0);
    }
  }, {
    eventHandlers: { focus() {
      this.scheduleWork();
    } }
  });
  var language = /* @__PURE__ */ Facet.define({
    combine(languages) {
      return languages.length ? languages[0] : null;
    },
    enables: (language2) => [
      Language.state,
      parseWorker,
      EditorView.contentAttributes.compute([language2], (state) => {
        let lang = state.facet(language2);
        return lang && lang.name ? { "data-language": lang.name } : {};
      })
    ]
  });
  var LanguageSupport = class {
    /**
    Create a language support object.
    */
    constructor(language2, support = []) {
      this.language = language2;
      this.support = support;
      this.extension = [language2, support];
    }
  };
  var indentService = /* @__PURE__ */ Facet.define();
  var indentUnit = /* @__PURE__ */ Facet.define({
    combine: (values) => {
      if (!values.length)
        return "  ";
      let unit = values[0];
      if (!unit || /\S/.test(unit) || Array.from(unit).some((e4) => e4 != unit[0]))
        throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
      return unit;
    }
  });
  function getIndentUnit(state) {
    let unit = state.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
  }
  function indentString(state, cols) {
    let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
    if (ch == "	") {
      while (cols >= ts) {
        result += "	";
        cols -= ts;
      }
      ch = " ";
    }
    for (let i4 = 0; i4 < cols; i4++)
      result += ch;
    return result;
  }
  function getIndentation(context, pos) {
    if (context instanceof EditorState)
      context = new IndentContext(context);
    for (let service of context.state.facet(indentService)) {
      let result = service(context, pos);
      if (result !== void 0)
        return result;
    }
    let tree = syntaxTree(context.state);
    return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
  }
  var IndentContext = class {
    /**
    Create an indent context.
    */
    constructor(state, options = {}) {
      this.state = state;
      this.options = options;
      this.unit = getIndentUnit(state);
    }
    /**
    Get a description of the line at the given position, taking
    [simulated line
    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    into account. If there is such a break at `pos`, the `bias`
    argument determines whether the part of the line line before or
    after the break is used.
    */
    lineAt(pos, bias = 1) {
      let line = this.state.doc.lineAt(pos);
      let { simulateBreak, simulateDoubleBreak } = this.options;
      if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
        if (simulateDoubleBreak && simulateBreak == pos)
          return { text: "", from: pos };
        else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
          return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
        else
          return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
      }
      return line;
    }
    /**
    Get the text directly after `pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
    textAfterPos(pos, bias = 1) {
      if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
        return "";
      let { text, from } = this.lineAt(pos, bias);
      return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
    }
    /**
    Find the column for the given position.
    */
    column(pos, bias = 1) {
      let { text, from } = this.lineAt(pos, bias);
      let result = this.countColumn(text, pos - from);
      let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
      if (override > -1)
        result += override - this.countColumn(text, text.search(/\S|$/));
      return result;
    }
    /**
    Find the column position (taking tabs into account) of the given
    position in the given string.
    */
    countColumn(line, pos = line.length) {
      return countColumn(line, this.state.tabSize, pos);
    }
    /**
    Find the indentation column of the line at the given point.
    */
    lineIndent(pos, bias = 1) {
      let { text, from } = this.lineAt(pos, bias);
      let override = this.options.overrideIndentation;
      if (override) {
        let overriden = override(from);
        if (overriden > -1)
          return overriden;
      }
      return this.countColumn(text, text.search(/\S|$/));
    }
    /**
    Returns the [simulated line
    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    for this context, if any.
    */
    get simulatedBreak() {
      return this.options.simulateBreak || null;
    }
  };
  var indentNodeProp = /* @__PURE__ */ new NodeProp();
  function syntaxIndentation(cx, ast, pos) {
    let stack = ast.resolveStack(pos);
    let inner = stack.node.enterUnfinishedNodesBefore(pos);
    if (inner != stack.node) {
      let add2 = [];
      for (let cur = inner; cur != stack.node; cur = cur.parent)
        add2.push(cur);
      for (let i4 = add2.length - 1; i4 >= 0; i4--)
        stack = { node: add2[i4], next: stack };
    }
    return indentFor(stack, cx, pos);
  }
  function indentFor(stack, cx, pos) {
    for (let cur = stack; cur; cur = cur.next) {
      let strategy = indentStrategy(cur.node);
      if (strategy)
        return strategy(TreeIndentContext.create(cx, pos, cur));
    }
    return 0;
  }
  function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
  }
  function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
      return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(NodeProp.closedBy))) {
      let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
      return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
    }
    return tree.parent == null ? topIndent : null;
  }
  function topIndent() {
    return 0;
  }
  var TreeIndentContext = class _TreeIndentContext extends IndentContext {
    constructor(base2, pos, context) {
      super(base2.state, base2.options);
      this.base = base2;
      this.pos = pos;
      this.context = context;
    }
    /**
    The syntax tree node to which the indentation strategy
    applies.
    */
    get node() {
      return this.context.node;
    }
    /**
    @internal
    */
    static create(base2, pos, context) {
      return new _TreeIndentContext(base2, pos, context);
    }
    /**
    Get the text directly after `this.pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
    get textAfter() {
      return this.textAfterPos(this.pos);
    }
    /**
    Get the indentation at the reference line for `this.node`, which
    is the line on which it starts, unless there is a node that is
    _not_ a parent of this node covering the start of that line. If
    so, the line at the start of that node is tried, again skipping
    on if it is covered by another such node.
    */
    get baseIndent() {
      return this.baseIndentFor(this.node);
    }
    /**
    Get the indentation for the reference line of the given node
    (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
    */
    baseIndentFor(node) {
      let line = this.state.doc.lineAt(node.from);
      for (; ; ) {
        let atBreak = node.resolve(line.from);
        while (atBreak.parent && atBreak.parent.from == atBreak.from)
          atBreak = atBreak.parent;
        if (isParent(atBreak, node))
          break;
        line = this.state.doc.lineAt(atBreak.from);
      }
      return this.lineIndent(line.from);
    }
    /**
    Continue looking for indentations in the node's parent nodes,
    and return the result of that.
    */
    continue() {
      return indentFor(this.context.next, this.base, this.pos);
    }
  };
  function isParent(parent, of) {
    for (let cur = of; cur; cur = cur.parent)
      if (parent == cur)
        return true;
    return false;
  }
  function bracketedAligned(context) {
    let tree = context.node;
    let openToken = tree.childAfter(tree.from), last = tree.lastChild;
    if (!openToken)
      return null;
    let sim = context.options.simulateBreak;
    let openLine = context.state.doc.lineAt(openToken.from);
    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to; ; ) {
      let next = tree.childAfter(pos);
      if (!next || next == last)
        return null;
      if (!next.type.isSkipped)
        return next.from < lineEnd ? openToken : null;
      pos = next.to;
    }
  }
  function delimitedIndent({ closing, align = true, units = 1 }) {
    return (context) => delimitedStrategy(context, align, units, closing);
  }
  function delimitedStrategy(context, align, units, closing, closedAt) {
    let after = context.textAfter, space = after.match(/^\s*/)[0].length;
    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
    let aligned = align ? bracketedAligned(context) : null;
    if (aligned)
      return closed ? context.column(aligned.from) : context.column(aligned.to);
    return context.baseIndent + (closed ? 0 : context.unit * units);
  }
  var foldNodeProp = /* @__PURE__ */ new NodeProp();
  function foldInside(node) {
    let first = node.firstChild, last = node.lastChild;
    return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;
  }
  var HighlightStyle = class _HighlightStyle {
    constructor(specs, options) {
      this.specs = specs;
      let modSpec;
      function def(spec) {
        let cls = StyleModule.newName();
        (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
        return cls;
      }
      const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
      const scopeOpt = options.scope;
      this.scope = scopeOpt instanceof Language ? (type2) => type2.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type2) => type2 == scopeOpt : void 0;
      this.style = tagHighlighter(specs.map((style) => ({
        tag: style.tag,
        class: style.class || def(Object.assign({}, style, { tag: null }))
      })), {
        all
      }).style;
      this.module = modSpec ? new StyleModule(modSpec) : null;
      this.themeType = options.themeType;
    }
    /**
    Create a highlighter style that associates the given styles to
    the given tags. The specs must be objects that hold a style tag
    or array of tags in their `tag` property, and either a single
    `class` property providing a static CSS class (for highlighter
    that rely on external styling), or a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
    set of CSS properties (which define the styling for those tags).
    
    The CSS rules created for a highlighter will be emitted in the
    order of the spec's properties. That means that for elements that
    have multiple tags associated with them, styles defined further
    down in the list will have a higher CSS precedence than styles
    defined earlier.
    */
    static define(specs, options) {
      return new _HighlightStyle(specs, options || {});
    }
  };
  var highlighterFacet = /* @__PURE__ */ Facet.define();
  var fallbackHighlighter = /* @__PURE__ */ Facet.define({
    combine(values) {
      return values.length ? [values[0]] : null;
    }
  });
  function getHighlighters(state) {
    let main2 = state.facet(highlighterFacet);
    return main2.length ? main2 : state.facet(fallbackHighlighter);
  }
  function syntaxHighlighting(highlighter, options) {
    let ext = [treeHighlighter], themeType;
    if (highlighter instanceof HighlightStyle) {
      if (highlighter.module)
        ext.push(EditorView.styleModule.of(highlighter.module));
      themeType = highlighter.themeType;
    }
    if (options === null || options === void 0 ? void 0 : options.fallback)
      ext.push(fallbackHighlighter.of(highlighter));
    else if (themeType)
      ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
        return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
      }));
    else
      ext.push(highlighterFacet.of(highlighter));
    return ext;
  }
  var TreeHighlighter = class {
    constructor(view) {
      this.markCache = /* @__PURE__ */ Object.create(null);
      this.tree = syntaxTree(view.state);
      this.decorations = this.buildDeco(view, getHighlighters(view.state));
      this.decoratedTo = view.viewport.to;
    }
    update(update) {
      let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
      let styleChange = highlighters != getHighlighters(update.startState);
      let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);
      if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
        this.decorations = this.decorations.map(update.changes);
        this.decoratedTo = decoratedToMapped;
      } else if (tree != this.tree || update.viewportChanged || styleChange) {
        this.tree = tree;
        this.decorations = this.buildDeco(update.view, highlighters);
        this.decoratedTo = viewport.to;
      }
    }
    buildDeco(view, highlighters) {
      if (!highlighters || !this.tree.length)
        return Decoration.none;
      let builder = new RangeSetBuilder();
      for (let { from, to } of view.visibleRanges) {
        highlightTree(this.tree, highlighters, (from2, to2, style) => {
          builder.add(from2, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
        }, from, to);
      }
      return builder.finish();
    }
  };
  var treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
    decorations: (v3) => v3.decorations
  }));
  var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
    {
      tag: tags.meta,
      color: "#404740"
    },
    {
      tag: tags.link,
      textDecoration: "underline"
    },
    {
      tag: tags.heading,
      textDecoration: "underline",
      fontWeight: "bold"
    },
    {
      tag: tags.emphasis,
      fontStyle: "italic"
    },
    {
      tag: tags.strong,
      fontWeight: "bold"
    },
    {
      tag: tags.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: tags.keyword,
      color: "#708"
    },
    {
      tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
      color: "#219"
    },
    {
      tag: [tags.literal, tags.inserted],
      color: "#164"
    },
    {
      tag: [tags.string, tags.deleted],
      color: "#a11"
    },
    {
      tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
      color: "#e40"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.variableName),
      color: "#00f"
    },
    {
      tag: /* @__PURE__ */ tags.local(tags.variableName),
      color: "#30a"
    },
    {
      tag: [tags.typeName, tags.namespace],
      color: "#085"
    },
    {
      tag: tags.className,
      color: "#167"
    },
    {
      tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
      color: "#256"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.propertyName),
      color: "#00c"
    },
    {
      tag: tags.comment,
      color: "#940"
    },
    {
      tag: tags.invalid,
      color: "#f00"
    }
  ]);
  var noTokens = /* @__PURE__ */ Object.create(null);
  var typeArray = [NodeType.none];
  var warned = [];
  var byTag = /* @__PURE__ */ Object.create(null);
  var defaultTable = /* @__PURE__ */ Object.create(null);
  for (let [legacyName, name2] of [
    ["variable", "variableName"],
    ["variable-2", "variableName.special"],
    ["string-2", "string.special"],
    ["def", "variableName.definition"],
    ["tag", "tagName"],
    ["attribute", "attributeName"],
    ["type", "typeName"],
    ["builtin", "variableName.standard"],
    ["qualifier", "modifier"],
    ["error", "invalid"],
    ["header", "heading"],
    ["property", "propertyName"]
  ])
    defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2);
  function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1)
      return;
    warned.push(part);
    console.warn(msg);
  }
  function createTokenType(extra, tagStr) {
    let tags$1 = [];
    for (let name3 of tagStr.split(" ")) {
      let found = [];
      for (let part of name3.split(".")) {
        let value = extra[part] || tags[part];
        if (!value) {
          warnForPart(part, `Unknown highlighting tag ${part}`);
        } else if (typeof value == "function") {
          if (!found.length)
            warnForPart(part, `Modifier ${part} used at start of tag`);
          else
            found = found.map(value);
        } else {
          if (found.length)
            warnForPart(part, `Tag ${part} used as modifier`);
          else
            found = Array.isArray(value) ? value : [value];
        }
      }
      for (let tag of found)
        tags$1.push(tag);
    }
    if (!tags$1.length)
      return 0;
    let name2 = tagStr.replace(/ /g, "_"), key = name2 + " " + tags$1.map((t5) => t5.id);
    let known = byTag[key];
    if (known)
      return known.id;
    let type2 = byTag[key] = NodeType.define({
      id: typeArray.length,
      name: name2,
      props: [styleTags({ [name2]: tags$1 })]
    });
    typeArray.push(type2);
    return type2.id;
  }
  var marks = {
    rtl: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "rtl" }, bidiIsolate: Direction.RTL }),
    ltr: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "ltr" }, bidiIsolate: Direction.LTR }),
    auto: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "auto" }, bidiIsolate: null })
  };

  // node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/dist/js-yaml.mjs
  function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
  }
  function isObject(subject) {
    return typeof subject === "object" && subject !== null;
  }
  function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];
    return [sequence];
  }
  function extend2(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index = 0, length = sourceKeys.length; index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }
    return target;
  }
  function repeat(string2, count) {
    var result = "", cycle;
    for (cycle = 0; cycle < count; cycle += 1) {
      result += string2;
    }
    return result;
  }
  function isNegativeZero(number2) {
    return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
  }
  var isNothing_1 = isNothing;
  var isObject_1 = isObject;
  var toArray_1 = toArray;
  var repeat_1 = repeat;
  var isNegativeZero_1 = isNegativeZero;
  var extend_1 = extend2;
  var common = {
    isNothing: isNothing_1,
    isObject: isObject_1,
    toArray: toArray_1,
    repeat: repeat_1,
    isNegativeZero: isNegativeZero_1,
    extend: extend_1
  };
  function formatError(exception2, compact) {
    var where = "", message = exception2.reason || "(unknown reason)";
    if (!exception2.mark) return message;
    if (exception2.mark.name) {
      where += 'in "' + exception2.mark.name + '" ';
    }
    where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
    if (!compact && exception2.mark.snippet) {
      where += "\n\n" + exception2.mark.snippet;
    }
    return message + " " + where;
  }
  function YAMLException$1(reason, mark) {
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack || "";
    }
  }
  YAMLException$1.prototype = Object.create(Error.prototype);
  YAMLException$1.prototype.constructor = YAMLException$1;
  YAMLException$1.prototype.toString = function toString(compact) {
    return this.name + ": " + formatError(this, compact);
  };
  var exception = YAMLException$1;
  function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
    var head = "";
    var tail = "";
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
    if (position - lineStart > maxHalfLength) {
      head = " ... ";
      lineStart = position - maxHalfLength + head.length;
    }
    if (lineEnd - position > maxHalfLength) {
      tail = " ...";
      lineEnd = position + maxHalfLength - tail.length;
    }
    return {
      str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
      pos: position - lineStart + head.length
      // relative position
    };
  }
  function padStart(string2, max) {
    return common.repeat(" ", max - string2.length) + string2;
  }
  function makeSnippet(mark, options) {
    options = Object.create(options || null);
    if (!mark.buffer) return null;
    if (!options.maxLength) options.maxLength = 79;
    if (typeof options.indent !== "number") options.indent = 1;
    if (typeof options.linesBefore !== "number") options.linesBefore = 3;
    if (typeof options.linesAfter !== "number") options.linesAfter = 2;
    var re2 = /\r?\n|\r|\0/g;
    var lineStarts = [0];
    var lineEnds = [];
    var match;
    var foundLineNo = -1;
    while (match = re2.exec(mark.buffer)) {
      lineEnds.push(match.index);
      lineStarts.push(match.index + match[0].length);
      if (mark.position <= match.index && foundLineNo < 0) {
        foundLineNo = lineStarts.length - 2;
      }
    }
    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
    var result = "", i4, line;
    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
    for (i4 = 1; i4 <= options.linesBefore; i4++) {
      if (foundLineNo - i4 < 0) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo - i4],
        lineEnds[foundLineNo - i4],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i4]),
        maxLineLength
      );
      result = common.repeat(" ", options.indent) + padStart((mark.line - i4 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
    }
    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
    for (i4 = 1; i4 <= options.linesAfter; i4++) {
      if (foundLineNo + i4 >= lineEnds.length) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo + i4],
        lineEnds[foundLineNo + i4],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i4]),
        maxLineLength
      );
      result += common.repeat(" ", options.indent) + padStart((mark.line + i4 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    }
    return result.replace(/\n$/, "");
  }
  var snippet = makeSnippet;
  var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ];
  var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map2) {
    var result = {};
    if (map2 !== null) {
      Object.keys(map2).forEach(function(style) {
        map2[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      });
    }
    return result;
  }
  function Type$1(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name2) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name2) === -1) {
        throw new exception('Unknown option "' + name2 + '" is met in definition of "' + tag + '" YAML type.');
      }
    });
    this.options = options;
    this.tag = tag;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
      return true;
    };
    this.construct = options["construct"] || function(data) {
      return data;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.representName = options["representName"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.multi = options["multi"] || false;
    this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }
  var type = Type$1;
  function compileList(schema2, name2) {
    var result = [];
    schema2[name2].forEach(function(currentType) {
      var newIndex = result.length;
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
          newIndex = previousIndex;
        }
      });
      result[newIndex] = currentType;
    });
    return result;
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, index, length;
    function collectType(type2) {
      if (type2.multi) {
        result.multi[type2.kind].push(type2);
        result.multi["fallback"].push(type2);
      } else {
        result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
      }
    }
    for (index = 0, length = arguments.length; index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }
  function Schema$1(definition) {
    return this.extend(definition);
  }
  Schema$1.prototype.extend = function extend3(definition) {
    var implicit = [];
    var explicit = [];
    if (definition instanceof type) {
      explicit.push(definition);
    } else if (Array.isArray(definition)) {
      explicit = explicit.concat(definition);
    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
      if (definition.implicit) implicit = implicit.concat(definition.implicit);
      if (definition.explicit) explicit = explicit.concat(definition.explicit);
    } else {
      throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    }
    implicit.forEach(function(type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      if (type$1.loadKind && type$1.loadKind !== "scalar") {
        throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
      if (type$1.multi) {
        throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
      }
    });
    explicit.forEach(function(type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
    });
    var result = Object.create(Schema$1.prototype);
    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);
    result.compiledImplicit = compileList(result, "implicit");
    result.compiledExplicit = compileList(result, "explicit");
    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
    return result;
  };
  var schema = Schema$1;
  var str = new type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  });
  var seq = new type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  });
  var map = new type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  });
  var failsafe = new schema({
    explicit: [
      str,
      seq,
      map
    ]
  });
  function resolveYamlNull(data) {
    if (data === null) return true;
    var max = data.length;
    return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  var _null = new type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  });
  function resolveYamlBoolean(data) {
    if (data === null) return false;
    var max = data.length;
    return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  var bool = new type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
  function isHexCode(c4) {
    return 48 <= c4 && c4 <= 57 || 65 <= c4 && c4 <= 70 || 97 <= c4 && c4 <= 102;
  }
  function isOctCode(c4) {
    return 48 <= c4 && c4 <= 55;
  }
  function isDecCode(c4) {
    return 48 <= c4 && c4 <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null) return false;
    var max = data.length, index = 0, hasDigits = false, ch;
    if (!max) return false;
    ch = data[index];
    if (ch === "-" || ch === "+") {
      ch = data[++index];
    }
    if (ch === "0") {
      if (index + 1 === max) return true;
      ch = data[++index];
      if (ch === "b") {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (ch !== "0" && ch !== "1") return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (!isHexCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "o") {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (!isOctCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
    }
    if (ch === "_") return false;
    for (; index < max; index++) {
      ch = data[index];
      if (ch === "_") continue;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch === "_") return false;
    return true;
  }
  function constructYamlInteger(data) {
    var value = data, sign = 1, ch;
    if (value.indexOf("_") !== -1) {
      value = value.replace(/_/g, "");
    }
    ch = value[0];
    if (ch === "-" || ch === "+") {
      if (ch === "-") sign = -1;
      value = value.slice(1);
      ch = value[0];
    }
    if (value === "0") return 0;
    if (ch === "0") {
      if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
      if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
      if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
    }
    return sign * parseInt(value, 10);
  }
  function isInteger(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
  }
  var int = new type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  });
  var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function resolveYamlFloat(data) {
    if (data === null) return false;
    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_") {
      return false;
    }
    return true;
  }
  function constructYamlFloat(data) {
    var value, sign;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    if ("+-".indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }
    if (value === ".inf") {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === ".nan") {
      return NaN;
    }
    return sign * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) {
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    } else if (common.isNegativeZero(object)) {
      return "-0.0";
    }
    res = object.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
  }
  var float = new type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  });
  var json = failsafe.extend({
    implicit: [
      _null,
      bool,
      int,
      float
    ]
  });
  var core = json;
  var YAML_DATE_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  );
  var YAML_TIMESTAMP_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
  }
  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null) throw new Error("Date resolve error");
    year = +match[1];
    month = +match[2] - 1;
    day = +match[3];
    if (!match[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += "0";
      }
      fraction = +fraction;
    }
    if (match[9]) {
      tz_hour = +match[10];
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 6e4;
      if (match[9] === "-") delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta) date.setTime(date.getTime() - delta);
    return date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  var timestamp = new type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  var merge = new type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  });
  var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
  function resolveYamlBinary(data) {
    if (data === null) return false;
    var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max; idx++) {
      code = map2.indexOf(data.charAt(idx));
      if (code > 64) continue;
      if (code < 0) return false;
      bitlen += 6;
    }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      }
      bits = bits << 6 | map2.indexOf(input.charAt(idx));
    }
    tailbits = max % 4 * 6;
    if (tailbits === 0) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 255);
      result.push(bits >> 2 & 255);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 255);
    }
    return new Uint8Array(result);
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map2[bits >> 18 & 63];
        result += map2[bits >> 12 & 63];
        result += map2[bits >> 6 & 63];
        result += map2[bits & 63];
      }
      bits = (bits << 8) + object[idx];
    }
    tail = max % 3;
    if (tail === 0) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    } else if (tail === 2) {
      result += map2[bits >> 10 & 63];
      result += map2[bits >> 4 & 63];
      result += map2[bits << 2 & 63];
      result += map2[64];
    } else if (tail === 1) {
      result += map2[bits >> 2 & 63];
      result += map2[bits << 4 & 63];
      result += map2[64];
      result += map2[64];
    }
    return result;
  }
  function isBinary(obj) {
    return Object.prototype.toString.call(obj) === "[object Uint8Array]";
  }
  var binary = new type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });
  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  var _toString$2 = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null) return true;
    var objectKeys = [], index, length, pair2, pairKey, pairHasKey, object = data;
    for (index = 0, length = object.length; index < length; index += 1) {
      pair2 = object[index];
      pairHasKey = false;
      if (_toString$2.call(pair2) !== "[object Object]") return false;
      for (pairKey in pair2) {
        if (_hasOwnProperty$3.call(pair2, pairKey)) {
          if (!pairHasKey) pairHasKey = true;
          else return false;
        }
      }
      if (!pairHasKey) return false;
      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return false;
    }
    return true;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  var omap = new type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
  var _toString$1 = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null) return true;
    var index, length, pair2, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length; index < length; index += 1) {
      pair2 = object[index];
      if (_toString$1.call(pair2) !== "[object Object]") return false;
      keys = Object.keys(pair2);
      if (keys.length !== 1) return false;
      result[index] = [keys[0], pair2[keys[0]]];
    }
    return true;
  }
  function constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair2, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length; index < length; index += 1) {
      pair2 = object[index];
      keys = Object.keys(pair2);
      result[index] = [keys[0], pair2[keys[0]]];
    }
    return result;
  }
  var pairs = new type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null) return true;
    var key, object = data;
    for (key in object) {
      if (_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null) return false;
      }
    }
    return true;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  var set = new type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
  var _default = core.extend({
    implicit: [
      timestamp,
      merge
    ],
    explicit: [
      binary,
      omap,
      pairs,
      set
    ]
  });
  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c4) {
    return c4 === 10 || c4 === 13;
  }
  function is_WHITE_SPACE(c4) {
    return c4 === 9 || c4 === 32;
  }
  function is_WS_OR_EOL(c4) {
    return c4 === 9 || c4 === 32 || c4 === 10 || c4 === 13;
  }
  function is_FLOW_INDICATOR(c4) {
    return c4 === 44 || c4 === 91 || c4 === 93 || c4 === 123 || c4 === 125;
  }
  function fromHexCode(c4) {
    var lc;
    if (48 <= c4 && c4 <= 57) {
      return c4 - 48;
    }
    lc = c4 | 32;
    if (97 <= lc && lc <= 102) {
      return lc - 97 + 10;
    }
    return -1;
  }
  function escapedHexLen(c4) {
    if (c4 === 120) {
      return 2;
    }
    if (c4 === 117) {
      return 4;
    }
    if (c4 === 85) {
      return 8;
    }
    return 0;
  }
  function fromDecimalCode(c4) {
    if (48 <= c4 && c4 <= 57) {
      return c4 - 48;
    }
    return -1;
  }
  function simpleEscapeSequence(c4) {
    return c4 === 48 ? "\0" : c4 === 97 ? "\x07" : c4 === 98 ? "\b" : c4 === 116 ? "	" : c4 === 9 ? "	" : c4 === 110 ? "\n" : c4 === 118 ? "\v" : c4 === 102 ? "\f" : c4 === 114 ? "\r" : c4 === 101 ? "\x1B" : c4 === 32 ? " " : c4 === 34 ? '"' : c4 === 47 ? "/" : c4 === 92 ? "\\" : c4 === 78 ? "\x85" : c4 === 95 ? "\xA0" : c4 === 76 ? "\u2028" : c4 === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c4) {
    if (c4 <= 65535) {
      return String.fromCharCode(c4);
    }
    return String.fromCharCode(
      (c4 - 65536 >> 10) + 55296,
      (c4 - 65536 & 1023) + 56320
    );
  }
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (i4 = 0; i4 < 256; i4++) {
    simpleEscapeCheck[i4] = simpleEscapeSequence(i4) ? 1 : 0;
    simpleEscapeMap[i4] = simpleEscapeSequence(i4);
  }
  var i4;
  function State$1(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || _default;
    this.onWarning = options["onWarning"] || null;
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.firstTabInLine = -1;
    this.documents = [];
  }
  function generateError(state, message) {
    var mark = {
      name: state.filename,
      buffer: state.input.slice(0, -1),
      // omit trailing \0
      position: state.position,
      line: state.line,
      column: state.position - state.lineStart
    };
    mark.snippet = snippet(mark);
    return new exception(message, mark);
  }
  function throwError(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }
  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name2, args) {
      var match, major, minor;
      if (state.version !== null) {
        throwError(state, "duplication of %YAML directive");
      }
      if (args.length !== 1) {
        throwError(state, "YAML directive accepts exactly one argument");
      }
      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
      if (match === null) {
        throwError(state, "ill-formed argument of the YAML directive");
      }
      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);
      if (major !== 1) {
        throwError(state, "unacceptable YAML version of the document");
      }
      state.version = args[0];
      state.checkLineBreaks = minor < 2;
      if (minor !== 1 && minor !== 2) {
        throwWarning(state, "unsupported YAML version of the document");
      }
    },
    TAG: function handleTagDirective(state, name2, args) {
      var handle, prefix;
      if (args.length !== 2) {
        throwError(state, "TAG directive accepts exactly two arguments");
      }
      handle = args[0];
      prefix = args[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
      }
      if (_hasOwnProperty$1.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
      }
      try {
        prefix = decodeURIComponent(prefix);
      } catch (err) {
        throwError(state, "tag prefix is malformed: " + prefix);
      }
      state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      _result = state.input.slice(start, end);
      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
            throwError(state, "expected valid JSON character");
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, "the stream contains non-printable characters");
      }
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!common.isObject(source)) {
      throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];
      if (!_hasOwnProperty$1.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);
      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, "nested arrays are not supported inside keys");
        }
        if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
          keyNode[index] = "[object Object]";
        }
      }
    }
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
      keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.lineStart = startLineStart || state.lineStart;
        state.position = startPos || state.position;
        throwError(state, "duplicated mapping key");
      }
      if (keyNode === "__proto__") {
        Object.defineProperty(_result, keyNode, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: valueNode
        });
      } else {
        _result[keyNode] = valueNode;
      }
      delete overridableKeys[keyNode];
    }
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 10) {
      state.position++;
    } else if (ch === 13) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 10) {
        state.position++;
      }
    } else {
      throwError(state, "a line break is expected");
    }
    state.line += 1;
    state.lineStart = state.position;
    state.firstTabInLine = -1;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        if (ch === 9 && state.firstTabInLine === -1) {
          state.firstTabInLine = state.position;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      if (allowComments && ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 10 && ch !== 13 && ch !== 0);
      }
      if (is_EOL(ch)) {
        readLineBreak(state);
        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;
        while (ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, "deficient indentation");
    }
    return lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch = state.input.charCodeAt(_position);
      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }
    return false;
  }
  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += " ";
    } else if (count > 1) {
      state.result += common.repeat("\n", count - 1);
    }
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
      return false;
    }
    if (ch === 63 || ch === 45) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while (ch !== 0) {
      if (ch === 58) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 35) {
        preceding = state.input.charCodeAt(state.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;
      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);
        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
      return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 39) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 39) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (ch === 39) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a single quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 34) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 34) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 92) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);
            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, "expected hexadecimal character");
            }
          }
          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError(state, "unknown escape sequence");
        }
        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a double quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 91) {
      terminator = 93;
      isMapping = false;
      _result = [];
    } else if (ch === 123) {
      terminator = 125;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? "mapping" : "sequence";
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, "missed comma between flow collection entries");
      } else if (ch === 44) {
        throwError(state, "expected the node content, but found ','");
      }
      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;
      if (ch === 63) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }
      _line = state.line;
      _lineStart = state.lineStart;
      _pos = state.position;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if ((isExplicitPair || state.line === _line) && ch === 58) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }
      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === 44) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }
    throwError(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 124) {
      folding = false;
    } else if (ch === 62) {
      folding = true;
    } else {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
      if (ch === 43 || ch === 45) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, "repeat of a chomping mode identifier");
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, "repeat of an indentation width identifier");
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch)) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch));
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
    }
    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch = state.input.charCodeAt(state.position);
      while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }
      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state.result += "\n";
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common.repeat("\n", emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state.result += " ";
          }
        } else {
          state.result += common.repeat("\n", emptyLines);
        }
      } else {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;
      while (!is_EOL(ch) && ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, state.position, false);
    }
    return true;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      if (ch !== 45) {
        break;
      }
      following = state.input.charCodeAt(state.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state.position++;
      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a sequence entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "sequence";
      state.result = _result;
      return true;
    }
    return false;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (!atExplicitKey && state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line;
      if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
        if (ch === 63) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
        }
        state.position += 1;
        ch = following;
      } else {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          break;
        }
        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 58) {
            ch = state.input.charCodeAt(++state.position);
            if (!is_WS_OR_EOL(ch)) {
              throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
            throwError(state, "can not read an implicit mapping pair; a colon is missed");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      }
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (atExplicitKey) {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
        }
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a mapping entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "mapping";
      state.result = _result;
    }
    return detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 33) return false;
    if (state.tag !== null) {
      throwError(state, "duplication of a tag property");
    }
    ch = state.input.charCodeAt(++state.position);
    if (ch === 60) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 33) {
      isNamed = true;
      tagHandle = "!!";
      ch = state.input.charCodeAt(++state.position);
    } else {
      tagHandle = "!";
    }
    _position = state.position;
    if (isVerbatim) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0 && ch !== 62);
      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, "unexpected end of the stream within a verbatim tag");
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        if (ch === 33) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, "named tag handle cannot contain such characters");
            }
            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, "tag suffix cannot contain exclamation marks");
          }
        }
        ch = state.input.charCodeAt(++state.position);
      }
      tagName = state.input.slice(_position, state.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, "tag suffix cannot contain flow indicator characters");
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, "tag name cannot contain such characters: " + tagName);
    }
    try {
      tagName = decodeURIComponent(tagName);
    } catch (err) {
      throwError(state, "tag name is malformed: " + tagName);
    }
    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
      state.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
      state.tag = "tag:yaml.org,2002:" + tagName;
    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 38) return false;
    if (state.anchor !== null) {
      throwError(state, "duplication of an anchor property");
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an anchor node must contain at least one character");
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
  }
  function readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 42) return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an alias node must contain at least one character");
    }
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
    if (state.listener !== null) {
      state.listener("open", state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state.position - state.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state)) {
            hasContent = true;
            if (state.tag !== null || state.anchor !== null) {
              throwError(state, "alias node should not have any properties");
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;
            if (state.tag === null) {
              state.tag = "?";
            }
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }
    if (state.tag === null) {
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    } else if (state.tag === "?") {
      if (state.result !== null && state.kind !== "scalar") {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type2 = state.implicitTypes[typeIndex];
        if (type2.resolve(state.result)) {
          state.result = type2.construct(state.result);
          state.tag = type2.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (state.tag !== "!") {
      if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
        type2 = state.typeMap[state.kind || "fallback"][state.tag];
      } else {
        type2 = null;
        typeList = state.typeMap.multi[state.kind || "fallback"];
        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type2 = typeList[typeIndex];
            break;
          }
        }
      }
      if (!type2) {
        throwError(state, "unknown tag !<" + state.tag + ">");
      }
      if (state.result !== null && type2.kind !== state.kind) {
        throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
      }
      if (!type2.resolve(state.result, state.tag)) {
        throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
      } else {
        state.result = type2.construct(state.result, state.tag);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    }
    if (state.listener !== null) {
      state.listener("close", state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = /* @__PURE__ */ Object.create(null);
    state.anchorMap = /* @__PURE__ */ Object.create(null);
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if (state.lineIndent > 0 || ch !== 37) {
        break;
      }
      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError(state, "directive name must not be less than one character in length");
      }
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch)) break;
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      if (ch !== 0) readLineBreak(state);
      if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
      throwError(state, "directives end mark is expected");
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, "non-ASCII line breaks are interpreted as content");
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 46) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }
    if (state.position < state.length - 1) {
      throwError(state, "end of the stream or a document separator is expected");
    } else {
      return;
    }
  }
  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
        input += "\n";
      }
      if (input.charCodeAt(0) === 65279) {
        input = input.slice(1);
      }
    }
    var state = new State$1(input, options);
    var nullpos = input.indexOf("\0");
    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, "null byte is not allowed in input");
    }
    state.input += "\0";
    while (state.input.charCodeAt(state.position) === 32) {
      state.lineIndent += 1;
      state.position += 1;
    }
    while (state.position < state.length - 1) {
      readDocument(state);
    }
    return state.documents;
  }
  function loadAll$1(input, iterator, options) {
    if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
      options = iterator;
      iterator = null;
    }
    var documents = loadDocuments(input, options);
    if (typeof iterator !== "function") {
      return documents;
    }
    for (var index = 0, length = documents.length; index < length; index += 1) {
      iterator(documents[index]);
    }
  }
  function load$1(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) {
      return void 0;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new exception("expected a single document in the stream, but found more");
  }
  var loadAll_1 = loadAll$1;
  var load_1 = load$1;
  var loader = {
    loadAll: loadAll_1,
    load: load_1
  };
  var _toString = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CHAR_BOM = 65279;
  var CHAR_TAB = 9;
  var CHAR_LINE_FEED = 10;
  var CHAR_CARRIAGE_RETURN = 13;
  var CHAR_SPACE = 32;
  var CHAR_EXCLAMATION = 33;
  var CHAR_DOUBLE_QUOTE = 34;
  var CHAR_SHARP = 35;
  var CHAR_PERCENT = 37;
  var CHAR_AMPERSAND = 38;
  var CHAR_SINGLE_QUOTE = 39;
  var CHAR_ASTERISK = 42;
  var CHAR_COMMA = 44;
  var CHAR_MINUS = 45;
  var CHAR_COLON = 58;
  var CHAR_EQUALS = 61;
  var CHAR_GREATER_THAN = 62;
  var CHAR_QUESTION = 63;
  var CHAR_COMMERCIAL_AT = 64;
  var CHAR_LEFT_SQUARE_BRACKET = 91;
  var CHAR_RIGHT_SQUARE_BRACKET = 93;
  var CHAR_GRAVE_ACCENT = 96;
  var CHAR_LEFT_CURLY_BRACKET = 123;
  var CHAR_VERTICAL_LINE = 124;
  var CHAR_RIGHT_CURLY_BRACKET = 125;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0";
  ESCAPE_SEQUENCES[7] = "\\a";
  ESCAPE_SEQUENCES[8] = "\\b";
  ESCAPE_SEQUENCES[9] = "\\t";
  ESCAPE_SEQUENCES[10] = "\\n";
  ESCAPE_SEQUENCES[11] = "\\v";
  ESCAPE_SEQUENCES[12] = "\\f";
  ESCAPE_SEQUENCES[13] = "\\r";
  ESCAPE_SEQUENCES[27] = "\\e";
  ESCAPE_SEQUENCES[34] = '\\"';
  ESCAPE_SEQUENCES[92] = "\\\\";
  ESCAPE_SEQUENCES[133] = "\\N";
  ESCAPE_SEQUENCES[160] = "\\_";
  ESCAPE_SEQUENCES[8232] = "\\L";
  ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function compileStyleMap(schema2, map2) {
    var result, keys, index, length, tag, style, type2;
    if (map2 === null) return {};
    result = {};
    keys = Object.keys(map2);
    for (index = 0, length = keys.length; index < length; index += 1) {
      tag = keys[index];
      style = String(map2[tag]);
      if (tag.slice(0, 2) === "!!") {
        tag = "tag:yaml.org,2002:" + tag.slice(2);
      }
      type2 = schema2.compiledTypeMap["fallback"][tag];
      if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
        style = type2.styleAliases[style];
      }
      result[tag] = style;
    }
    return result;
  }
  function encodeHex(character) {
    var string2, handle, length;
    string2 = character.toString(16).toUpperCase();
    if (character <= 255) {
      handle = "x";
      length = 2;
    } else if (character <= 65535) {
      handle = "u";
      length = 4;
    } else if (character <= 4294967295) {
      handle = "U";
      length = 8;
    } else {
      throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common.repeat("0", length - string2.length) + string2;
  }
  var QUOTING_TYPE_SINGLE = 1;
  var QUOTING_TYPE_DOUBLE = 2;
  function State(options) {
    this.schema = options["schema"] || _default;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes = options["forceQuotes"] || false;
    this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
  }
  function indentString2(string2, spaces) {
    var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string2.length;
    while (position < length) {
      next = string2.indexOf("\n", position);
      if (next === -1) {
        line = string2.slice(position);
        position = length;
      } else {
        line = string2.slice(position, next + 1);
        position = next + 1;
      }
      if (line.length && line !== "\n") result += ind;
      result += line;
    }
    return result;
  }
  function generateNextLine(state, level) {
    return "\n" + common.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str2) {
    var index, length, type2;
    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
      type2 = state.implicitTypes[index];
      if (type2.resolve(str2)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespace(c4) {
    return c4 === CHAR_SPACE || c4 === CHAR_TAB;
  }
  function isPrintable(c4) {
    return 32 <= c4 && c4 <= 126 || 161 <= c4 && c4 <= 55295 && c4 !== 8232 && c4 !== 8233 || 57344 <= c4 && c4 <= 65533 && c4 !== CHAR_BOM || 65536 <= c4 && c4 <= 1114111;
  }
  function isNsCharOrWhitespace(c4) {
    return isPrintable(c4) && c4 !== CHAR_BOM && c4 !== CHAR_CARRIAGE_RETURN && c4 !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c4, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c4);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c4);
    return (
      // ns-plain-safe
      (inblock ? (
        // c = flow-in
        cIsNsCharOrWhitespace
      ) : cIsNsCharOrWhitespace && c4 !== CHAR_COMMA && c4 !== CHAR_LEFT_SQUARE_BRACKET && c4 !== CHAR_RIGHT_SQUARE_BRACKET && c4 !== CHAR_LEFT_CURLY_BRACKET && c4 !== CHAR_RIGHT_CURLY_BRACKET) && c4 !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c4 === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
    );
  }
  function isPlainSafeFirst(c4) {
    return isPrintable(c4) && c4 !== CHAR_BOM && !isWhitespace(c4) && c4 !== CHAR_MINUS && c4 !== CHAR_QUESTION && c4 !== CHAR_COLON && c4 !== CHAR_COMMA && c4 !== CHAR_LEFT_SQUARE_BRACKET && c4 !== CHAR_RIGHT_SQUARE_BRACKET && c4 !== CHAR_LEFT_CURLY_BRACKET && c4 !== CHAR_RIGHT_CURLY_BRACKET && c4 !== CHAR_SHARP && c4 !== CHAR_AMPERSAND && c4 !== CHAR_ASTERISK && c4 !== CHAR_EXCLAMATION && c4 !== CHAR_VERTICAL_LINE && c4 !== CHAR_EQUALS && c4 !== CHAR_GREATER_THAN && c4 !== CHAR_SINGLE_QUOTE && c4 !== CHAR_DOUBLE_QUOTE && c4 !== CHAR_PERCENT && c4 !== CHAR_COMMERCIAL_AT && c4 !== CHAR_GRAVE_ACCENT;
  }
  function isPlainSafeLast(c4) {
    return !isWhitespace(c4) && c4 !== CHAR_COLON;
  }
  function codePointAt2(string2, pos) {
    var first = string2.charCodeAt(pos), second;
    if (first >= 55296 && first <= 56319 && pos + 1 < string2.length) {
      second = string2.charCodeAt(pos + 1);
      if (second >= 56320 && second <= 57343) {
        return (first - 55296) * 1024 + second - 56320 + 65536;
      }
    }
    return first;
  }
  function needIndentIndicator(string2) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string2);
  }
  var STYLE_PLAIN = 1;
  var STYLE_SINGLE = 2;
  var STYLE_LITERAL = 3;
  var STYLE_FOLDED = 4;
  var STYLE_DOUBLE = 5;
  function chooseScalarStyle(string2, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
    var i4;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(codePointAt2(string2, 0)) && isPlainSafeLast(codePointAt2(string2, string2.length - 1));
    if (singleLineOnly || forceQuotes) {
      for (i4 = 0; i4 < string2.length; char >= 65536 ? i4 += 2 : i4++) {
        char = codePointAt2(string2, i4);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
    } else {
      for (i4 = 0; i4 < string2.length; char >= 65536 ? i4 += 2 : i4++) {
        char = codePointAt2(string2, i4);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
            i4 - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ";
            previousLineBreak = i4;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i4 - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ");
    }
    if (!hasLineBreak && !hasFoldableLine) {
      if (plain && !forceQuotes && !testAmbiguousType(string2)) {
        return STYLE_PLAIN;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    if (indentPerLevel > 9 && needIndentIndicator(string2)) {
      return STYLE_DOUBLE;
    }
    if (!forceQuotes) {
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  function writeScalar(state, string2, level, iskey, inblock) {
    state.dump = function() {
      if (string2.length === 0) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      }
      if (!state.noCompatMode) {
        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string2) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string2)) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string2 + '"' : "'" + string2 + "'";
        }
      }
      var indent = state.indent * Math.max(1, level);
      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
      var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string3) {
        return testImplicitResolving(state, string3);
      }
      switch (chooseScalarStyle(
        string2,
        singleLineOnly,
        state.indent,
        lineWidth,
        testAmbiguity,
        state.quotingType,
        state.forceQuotes && !iskey,
        inblock
      )) {
        case STYLE_PLAIN:
          return string2;
        case STYLE_SINGLE:
          return "'" + string2.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string2, state.indent) + dropEndingNewline(indentString2(string2, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string2, state.indent) + dropEndingNewline(indentString2(foldString(string2, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string2) + '"';
        default:
          throw new exception("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string2, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string2) ? String(indentPerLevel) : "";
    var clip2 = string2[string2.length - 1] === "\n";
    var keep = clip2 && (string2[string2.length - 2] === "\n" || string2 === "\n");
    var chomp = keep ? "+" : clip2 ? "" : "-";
    return indentIndicator + chomp + "\n";
  }
  function dropEndingNewline(string2) {
    return string2[string2.length - 1] === "\n" ? string2.slice(0, -1) : string2;
  }
  function foldString(string2, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = function() {
      var nextLF = string2.indexOf("\n");
      nextLF = nextLF !== -1 ? nextLF : string2.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string2.slice(0, nextLF), width);
    }();
    var prevMoreIndented = string2[0] === "\n" || string2[0] === " ";
    var moreIndented;
    var match;
    while (match = lineRe.exec(string2)) {
      var prefix = match[1], line = match[2];
      moreIndented = line[0] === " ";
      result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line, width) {
    if (line === "" || line[0] === " ") return line;
    var breakRe = / [^ ]/g;
    var match;
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    while (match = breakRe.exec(line)) {
      next = match.index;
      if (next - start > width) {
        end = curr > start ? curr : next;
        result += "\n" + line.slice(start, end);
        start = end + 1;
      }
      curr = next;
    }
    result += "\n";
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }
    return result.slice(1);
  }
  function escapeString(string2) {
    var result = "";
    var char = 0;
    var escapeSeq;
    for (var i4 = 0; i4 < string2.length; char >= 65536 ? i4 += 2 : i4++) {
      char = codePointAt2(string2, i4);
      escapeSeq = ESCAPE_SEQUENCES[char];
      if (!escapeSeq && isPrintable(char)) {
        result += string2[i4];
        if (char >= 65536) result += string2[i4 + 1];
      } else {
        result += escapeSeq || encodeHex(char);
      }
    }
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];
      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }
      if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
        if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];
      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }
      if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
        if (!compact || _result !== "") {
          _result += generateNextLine(state, level);
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += "-";
        } else {
          _result += "- ";
        }
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = "";
      if (_result !== "") pairBuffer += ", ";
      if (state.condenseFlow) pairBuffer += '"';
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state, level, objectKey, false, false)) {
        continue;
      }
      if (state.dump.length > 1024) pairBuffer += "? ";
      pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
      if (!writeNode(state, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state.sortKeys === "function") {
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      throw new exception("sortKeys must be a boolean or a function");
    }
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = "";
      if (!compact || _result !== "") {
        pairBuffer += generateNextLine(state, level);
      }
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += "?";
        } else {
          pairBuffer += "? ";
        }
      }
      pairBuffer += state.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }
      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ":";
      } else {
        pairBuffer += ": ";
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type2, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for (index = 0, length = typeList.length; index < length; index += 1) {
      type2 = typeList[index];
      if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
        if (explicit) {
          if (type2.multi && type2.representName) {
            state.tag = type2.representName(object);
          } else {
            state.tag = type2.tag;
          }
        } else {
          state.tag = "?";
        }
        if (type2.represent) {
          style = state.styleMap[type2.tag] || type2.defaultStyle;
          if (_toString.call(type2.represent) === "[object Function]") {
            _result = type2.represent(object, style);
          } else if (_hasOwnProperty.call(type2.represent, style)) {
            _result = type2.represent[style](object, style);
          } else {
            throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
          }
          state.dump = _result;
        }
        return true;
      }
    }
    return false;
  }
  function writeNode(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }
    var type2 = _toString.call(state.dump);
    var inblock = block;
    var tagStr;
    if (block) {
      block = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
      compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = "*ref_" + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type2 === "[object Object]") {
        if (block && Object.keys(state.dump).length !== 0) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object Array]") {
        if (block && state.dump.length !== 0) {
          if (state.noArrayIndent && !isblockseq && level > 0) {
            writeBlockSequence(state, level - 1, state.dump, compact);
          } else {
            writeBlockSequence(state, level, state.dump, compact);
          }
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object String]") {
        if (state.tag !== "?") {
          writeScalar(state, state.dump, level, iskey, inblock);
        }
      } else if (type2 === "[object Undefined]") {
        return false;
      } else {
        if (state.skipInvalid) return false;
        throw new exception("unacceptable kind of an object to dump " + type2);
      }
      if (state.tag !== null && state.tag !== "?") {
        tagStr = encodeURI(
          state.tag[0] === "!" ? state.tag.slice(1) : state.tag
        ).replace(/!/g, "%21");
        if (state.tag[0] === "!") {
          tagStr = "!" + tagStr;
        } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
          tagStr = "!!" + tagStr.slice(18);
        } else {
          tagStr = "!<" + tagStr + ">";
        }
        state.dump = tagStr + " " + state.dump;
      }
    }
    return true;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    inspectNode(object, objects, duplicatesIndexes);
    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object === "object") {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);
        if (Array.isArray(object)) {
          for (index = 0, length = object.length; index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }
  function dump$1(input, options) {
    options = options || {};
    var state = new State(options);
    if (!state.noRefs) getDuplicateReferences(input, state);
    var value = input;
    if (state.replacer) {
      value = state.replacer.call({ "": value }, "", value);
    }
    if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
    return "";
  }
  var dump_1 = dump$1;
  var dumper = {
    dump: dump_1
  };
  function renamed(from, to) {
    return function() {
      throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
    };
  }
  var load = loader.load;
  var loadAll = loader.loadAll;
  var dump = dumper.dump;
  var safeLoad = renamed("safeLoad", "load");
  var safeLoadAll = renamed("safeLoadAll", "loadAll");
  var safeDump = renamed("safeDump", "dump");

  // node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/index.mjs
  var util;
  (function(util2) {
    util2.assertEqual = (val) => val;
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
      const filtered = {};
      for (const k2 of validKeys) {
        filtered[k2] = obj[k2];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e4) {
        return obj[e4];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_2, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  var ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var getParsedType = (data) => {
    const t5 = typeof data;
    switch (t5) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  var ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var quotelessJson = (obj) => {
    const json2 = JSON.stringify(obj, null, 2);
    return json2.replace(/"([^"]+)":/g, "$1:");
  };
  var ZodError = class _ZodError extends Error {
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    get errors() {
      return this.issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i4 = 0;
            while (i4 < issue.path.length) {
              const el = issue.path[i4];
              const terminal = i4 === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i4++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof _ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
  var errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  var overrideErrorMap = errorMap;
  function setErrorMap(map2) {
    overrideErrorMap = map2;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  var makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== void 0) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m3) => !!m3).slice().reverse();
    for (const map2 of maps) {
      errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  var EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        overrideMap,
        overrideMap === errorMap ? void 0 : errorMap
        // then global default map
      ].filter((x2) => !!x2)
    });
    ctx.common.issues.push(issue);
  }
  var ParseStatus = class _ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s4 of results) {
        if (s4.status === "aborted")
          return INVALID;
        if (s4.status === "dirty")
          status.dirty();
        arrayValue.push(s4.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs2) {
      const syncPairs = [];
      for (const pair2 of pairs2) {
        const key = await pair2.key;
        const value = await pair2.value;
        syncPairs.push({
          key,
          value
        });
      }
      return _ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs2) {
      const finalObject = {};
      for (const pair2 of pairs2) {
        const { key, value } = pair2;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair2.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  };
  var INVALID = Object.freeze({
    status: "aborted"
  });
  var DIRTY = (value) => ({ status: "dirty", value });
  var OK = (value) => ({ status: "valid", value });
  var isAborted = (x2) => x2.status === "aborted";
  var isDirty = (x2) => x2.status === "dirty";
  var isValid = (x2) => x2.status === "valid";
  var isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
  function __classPrivateFieldGet(receiver, state, kind, f3) {
    if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value, kind, f3) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
  }
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
  })(errorUtil || (errorUtil = {}));
  var _ZodEnum_cache;
  var _ZodNativeEnum_cache;
  var ParseInputLazyPath = class {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  };
  var handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      var _a2, _b;
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: (_a2 = message !== null && message !== void 0 ? message : required_error) !== null && _a2 !== void 0 ? _a2 : ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  var ZodType = class {
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a2;
      const ctx = {
        common: {
          issues: [],
          async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this, this._def);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  var cuidRegex = /^c[^\s-]{8,}$/i;
  var cuid2Regex = /^[0-9a-z]+$/;
  var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
  var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  var nanoidRegex = /^[a-z0-9_-]{21}$/i;
  var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  var emojiRegex;
  var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
  var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  var dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
    if (args.precision) {
      regex = `${regex}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      regex = `${regex}(\\.\\d+)?`;
    }
    return regex;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  var ZodString = class _ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a2) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a2, _b;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false,
        local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === void 0 ? void 0 : options.position,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString.create = (params) => {
    var _a2;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  var ZodNumber = class _ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new _ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null, min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  var ZodBigInt = class _ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = BigInt(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new _ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt.create = (params) => {
    var _a2;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
      ...processCreateParams(params)
    });
  };
  var ZodBoolean = class extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  var ZodDate = class _ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new _ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  var ZodSymbol = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  var ZodUndefined = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  var ZodNull = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  var ZodAny = class extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  var ZodUnknown = class extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  var ZodNever = class extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  var ZodVoid = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  var ZodArray = class _ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i4) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i4));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i4) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i4));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new _ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new _ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new _ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema2, params) => {
    return new ZodArray({
      type: schema2,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema2) {
    if (schema2 instanceof ZodObject) {
      const newShape = {};
      for (const key in schema2.shape) {
        const fieldSchema = schema2.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema2._def,
        shape: () => newShape
      });
    } else if (schema2 instanceof ZodArray) {
      return new ZodArray({
        ...schema2._def,
        type: deepPartialify(schema2.element)
      });
    } else if (schema2 instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema2.unwrap()));
    } else if (schema2 instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema2.unwrap()));
    } else if (schema2 instanceof ZodTuple) {
      return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
    } else {
      return schema2;
    }
  }
  var ZodObject = class _ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      return this._cached = { shape, keys };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs2 = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs2.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs2.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs2.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair2 of pairs2) {
            const key = await pair2.key;
            const value = await pair2.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair2.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs2);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            var _a2, _b, _c, _d;
            const defaultError = (_c = (_b = (_a2 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a2, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new _ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new _ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema2) {
      return this.augment({ [key]: schema2 });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new _ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  var ZodUnion = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types2, params) => {
    return new ZodUnion({
      options: types2,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  var getDiscriminator = (type2) => {
    if (type2 instanceof ZodLazy) {
      return getDiscriminator(type2.schema);
    } else if (type2 instanceof ZodEffects) {
      return getDiscriminator(type2.innerType());
    } else if (type2 instanceof ZodLiteral) {
      return [type2.value];
    } else if (type2 instanceof ZodEnum) {
      return type2.options;
    } else if (type2 instanceof ZodNativeEnum) {
      return util.objectValues(type2.enum);
    } else if (type2 instanceof ZodDefault) {
      return getDiscriminator(type2._def.innerType);
    } else if (type2 instanceof ZodUndefined) {
      return [void 0];
    } else if (type2 instanceof ZodNull) {
      return [null];
    } else if (type2 instanceof ZodOptional) {
      return [void 0, ...getDiscriminator(type2.unwrap())];
    } else if (type2 instanceof ZodNullable) {
      return [null, ...getDiscriminator(type2.unwrap())];
    } else if (type2 instanceof ZodBranded) {
      return getDiscriminator(type2.unwrap());
    } else if (type2 instanceof ZodReadonly) {
      return getDiscriminator(type2.unwrap());
    } else if (type2 instanceof ZodCatch) {
      return getDiscriminator(type2._def.innerType);
    } else {
      return [];
    }
  };
  var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type2 of options) {
        const discriminatorValues = getDiscriminator(type2.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type2);
        }
      }
      return new _ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  function mergeValues(a4, b4) {
    const aType = getParsedType(a4);
    const bType = getParsedType(b4);
    if (a4 === b4) {
      return { valid: true, data: a4 };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b4);
      const sharedKeys = util.objectKeys(a4).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a4, ...b4 };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a4[key], b4[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a4.length !== b4.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a4.length; index++) {
        const itemA = a4[index];
        const itemB = b4[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a4 === +b4) {
      return { valid: true, data: a4 };
    } else {
      return { valid: false };
    }
  }
  var ZodIntersection = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  var ZodTuple = class _ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema2 = this._def.items[itemIndex] || this._def.rest;
        if (!schema2)
          return null;
        return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x2) => !!x2);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new _ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  var ZodRecord = class _ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs2 = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs2.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs2);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs2);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new _ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new _ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  var ZodMap = class extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs2 = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair2 of pairs2) {
            const key = await pair2.key;
            const value = await pair2.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair2 of pairs2) {
          const key = pair2.key;
          const value = pair2.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  var ZodSet = class _ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i4) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i4)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new _ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new _ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  var ZodFunction = class _ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x2) => !!x2),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x2) => !!x2),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e4) => {
            error.addIssue(makeArgsIssue(args, e4));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e4) => {
            error.addIssue(makeReturnsIssue(result, e4));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new _ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new _ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new _ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  var ZodLazy = class extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  var ZodLiteral = class extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  var ZodEnum = class _ZodEnum extends ZodType {
    constructor() {
      super(...arguments);
      _ZodEnum_cache.set(this, void 0);
    }
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
        __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
      }
      if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return _ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  };
  _ZodEnum_cache = /* @__PURE__ */ new WeakMap();
  ZodEnum.create = createZodEnum;
  var ZodNativeEnum = class extends ZodType {
    constructor() {
      super(...arguments);
      _ZodNativeEnum_cache.set(this, void 0);
    }
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
        __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
      }
      if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  var ZodPromise = class extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema2, params) => {
    return new ZodPromise({
      type: schema2,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  var ZodEffects = class extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base2 = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base2))
            return base2;
          const result = effect.transform(base2.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
            if (!isValid(base2))
              return base2;
            return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema2, effect, params) => {
    return new ZodEffects({
      schema: schema2,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema2, params) => {
    return new ZodEffects({
      schema: schema2,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  var ZodOptional = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type2, params) => {
    return new ZodOptional({
      innerType: type2,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  var ZodNullable = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type2, params) => {
    return new ZodNullable({
      innerType: type2,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  var ZodDefault = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type2, params) => {
    return new ZodDefault({
      innerType: type2,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  var ZodCatch = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type2, params) => {
    return new ZodCatch({
      innerType: type2,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  var ZodNaN = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  var BRAND = Symbol("zod_brand");
  var ZodBranded = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  var ZodPipeline = class _ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a4, b4) {
      return new _ZodPipeline({
        in: a4,
        out: b4,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  var ZodReadonly = class extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodReadonly.create = (type2, params) => {
    return new ZodReadonly({
      innerType: type2,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  function custom(check, params = {}, fatal) {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        var _a2, _b;
        if (!check(data)) {
          const p4 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
          const _fatal = (_b = (_a2 = p4.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b !== void 0 ? _b : true;
          const p22 = typeof p4 === "string" ? { message: p4 } : p4;
          ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
        }
      });
    return ZodAny.create();
  }
  var late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  var instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  var stringType = ZodString.create;
  var numberType = ZodNumber.create;
  var nanType = ZodNaN.create;
  var bigIntType = ZodBigInt.create;
  var booleanType = ZodBoolean.create;
  var dateType = ZodDate.create;
  var symbolType = ZodSymbol.create;
  var undefinedType = ZodUndefined.create;
  var nullType = ZodNull.create;
  var anyType = ZodAny.create;
  var unknownType = ZodUnknown.create;
  var neverType = ZodNever.create;
  var voidType = ZodVoid.create;
  var arrayType = ZodArray.create;
  var objectType = ZodObject.create;
  var strictObjectType = ZodObject.strictCreate;
  var unionType = ZodUnion.create;
  var discriminatedUnionType = ZodDiscriminatedUnion.create;
  var intersectionType = ZodIntersection.create;
  var tupleType = ZodTuple.create;
  var recordType = ZodRecord.create;
  var mapType = ZodMap.create;
  var setType = ZodSet.create;
  var functionType = ZodFunction.create;
  var lazyType = ZodLazy.create;
  var literalType = ZodLiteral.create;
  var enumType = ZodEnum.create;
  var nativeEnumType = ZodNativeEnum.create;
  var promiseType = ZodPromise.create;
  var effectsType = ZodEffects.create;
  var optionalType = ZodOptional.create;
  var nullableType = ZodNullable.create;
  var preprocessType = ZodEffects.createWithPreprocess;
  var pipelineType = ZodPipeline.create;
  var ostring = () => stringType().optional();
  var onumber = () => numberType().optional();
  var oboolean = () => booleanType().optional();
  var coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  var NEVER = INVALID;
  var z = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync,
    get util() {
      return util;
    },
    get objectUtil() {
      return objectUtil;
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    datetimeRegex,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    ZodReadonly,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    "enum": enumType,
    "function": functionType,
    "instanceof": instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    "null": nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    "undefined": undefinedType,
    union: unionType,
    unknown: unknownType,
    "void": voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
  });

  // src/common/match-pattern.ts
  function parseMatchPattern(pattern) {
    const execResult = matchPatternRegExp.exec(pattern);
    if (!execResult) {
      return null;
    }
    const groups = execResult.groups;
    return groups.allURLs != null ? { allURLs: true } : {
      allURLs: false,
      scheme: groups.scheme.toLowerCase(),
      host: groups.host.toLowerCase(),
      path: groups.path
    };
  }
  var matchPatternRegExp = (() => {
    const allURLs = String.raw`(?<allURLs><all_urls>)`;
    const scheme = String.raw`(?<scheme>\*|[A-Za-z][0-9A-Za-z+.-]*)`;
    const label = String.raw`(?:[0-9A-Za-z](?:[0-9A-Za-z-]*[0-9A-Za-z])?)`;
    const host = String.raw`(?<host>(?:\*|${label})(?:\.${label})*)`;
    const path = String.raw`(?<path>/(?:\*|[0-9A-Za-z._~:/?[\]@!$&'()+,;=-]|%[0-9A-Fa-f]{2})*)`;
    return new RegExp(String.raw`^(?:${allURLs}|${scheme}://${host}${path})$`);
  })();
  var MatchPatternMap = class _MatchPatternMap {
    static supportedSchemes = ["http", "https"];
    allURLs;
    hostMap;
    constructor(json2) {
      if (json2) {
        this.allURLs = json2[0];
        this.hostMap = json2[1];
      } else {
        this.allURLs = [];
        this.hostMap = [[], []];
      }
    }
    toJSON() {
      return [this.allURLs, this.hostMap];
    }
    get(url) {
      const { protocol, hostname: host, pathname, search } = new URL(url);
      const scheme = protocol.slice(0, -1);
      const path = `${pathname}${search}`;
      if (!_MatchPatternMap.supportedSchemes.includes(scheme)) {
        return [];
      }
      const values = [...this.allURLs];
      let node = this.hostMap;
      for (const label of host.split(".").reverse()) {
        collectBucket(node[1], scheme, path, values);
        if (!node[2]?.[label]) {
          return values;
        }
        node = node[2][label];
      }
      collectBucket(node[1], scheme, path, values);
      collectBucket(node[0], scheme, path, values);
      return values;
    }
    set(pattern, value) {
      const parseResult = parseMatchPattern(pattern);
      if (!parseResult) {
        throw new Error(`Invalid match pattern: ${pattern}`);
      }
      if (parseResult.allURLs) {
        this.allURLs.push(value);
        return;
      }
      const { scheme, host, path } = parseResult;
      if (scheme !== "*" && !_MatchPatternMap.supportedSchemes.includes(scheme)) {
        throw new Error(`Unsupported scheme: ${scheme}`);
      }
      const labels = host.split(".").reverse();
      const anySubdomain = labels[labels.length - 1] === "*";
      if (anySubdomain) {
        labels.pop();
      }
      let node = this.hostMap;
      for (const label of labels) {
        node[2] ||= {};
        node = node[2][label] ||= [[], []];
      }
      node[anySubdomain ? 1 : 0].push(
        path === "/*" ? scheme === "*" ? [value] : [value, scheme] : [value, scheme, path]
      );
    }
  };
  function collectBucket(bucket, scheme, path, values) {
    for (const [value, schemePattern = "*", pathPattern = "/*"] of bucket) {
      if (testScheme(schemePattern, scheme) && testPath(pathPattern, path)) {
        values.push(value);
      }
    }
  }
  function testScheme(schemePattern, scheme) {
    return schemePattern === "*" ? scheme === "http" || scheme === "https" : scheme === schemePattern;
  }
  function testPath(pathPattern, path) {
    if (pathPattern === "/*") {
      return true;
    }
    const [first, ...rest] = pathPattern.split("*");
    if (rest.length === 0) {
      return path === first;
    }
    if (!path.startsWith(first)) {
      return false;
    }
    let pos = first.length;
    for (const part of rest.slice(0, -1)) {
      const partPos = path.indexOf(part, pos);
      if (partPos === -1) {
        return false;
      }
      pos = partPos + part.length;
    }
    return path.slice(pos).endsWith(rest[rest.length - 1]);
  }

  // node_modules/.pnpm/@lezer+lr@1.4.1/node_modules/@lezer/lr/dist/index.js
  var Stack = class _Stack {
    /**
    @internal
    */
    constructor(p4, stack, state, reducePos, pos, score, buffer, bufferBase, curContext, lookAhead = 0, parent) {
      this.p = p4;
      this.stack = stack;
      this.state = state;
      this.reducePos = reducePos;
      this.pos = pos;
      this.score = score;
      this.buffer = buffer;
      this.bufferBase = bufferBase;
      this.curContext = curContext;
      this.lookAhead = lookAhead;
      this.parent = parent;
    }
    /**
    @internal
    */
    toString() {
      return `[${this.stack.filter((_2, i4) => i4 % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /**
    @internal
    */
    static start(p4, state, pos = 0) {
      let cx = p4.parser.context;
      return new _Stack(p4, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    /**
    The stack's current [context](#lr.ContextTracker) value, if
    any. Its type will depend on the context tracker's type
    parameter, or it will be `null` if there is no context
    tracker.
    */
    get context() {
      return this.curContext ? this.curContext.context : null;
    }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /**
    @internal
    */
    pushState(state, start) {
      this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
      this.state = state;
    }
    // Apply a reduce action
    /**
    @internal
    */
    reduce(action) {
      var _a2;
      let depth = action >> 19, type2 = action & 65535;
      let { parser: parser4 } = this.p;
      if (this.reducePos < this.pos - 25)
        this.setLookAhead(this.pos);
      let dPrec = parser4.dynamicPrecedence(type2);
      if (dPrec)
        this.score += dPrec;
      if (depth == 0) {
        this.pushState(parser4.getGoto(this.state, type2, true), this.reducePos);
        if (type2 < parser4.minRepeatTerm)
          this.storeNode(type2, this.reducePos, this.reducePos, 4, true);
        this.reduceContext(type2, this.reducePos);
        return;
      }
      let base2 = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
      let start = base2 ? this.stack[base2 - 2] : this.p.ranges[0].from, size = this.reducePos - start;
      if (size >= 2e3 && !((_a2 = this.p.parser.nodeSet.types[type2]) === null || _a2 === void 0 ? void 0 : _a2.isAnonymous)) {
        if (start == this.p.lastBigReductionStart) {
          this.p.bigReductionCount++;
          this.p.lastBigReductionSize = size;
        } else if (this.p.lastBigReductionSize < size) {
          this.p.bigReductionCount = 1;
          this.p.lastBigReductionStart = start;
          this.p.lastBigReductionSize = size;
        }
      }
      let bufferBase = base2 ? this.stack[base2 - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
      if (type2 < parser4.minRepeatTerm || action & 131072) {
        let pos = parser4.stateFlag(
          this.state,
          1
          /* StateFlag.Skipped */
        ) ? this.pos : this.reducePos;
        this.storeNode(type2, start, pos, count + 4, true);
      }
      if (action & 262144) {
        this.state = this.stack[base2];
      } else {
        let baseStateID = this.stack[base2 - 3];
        this.state = parser4.getGoto(baseStateID, type2, true);
      }
      while (this.stack.length > base2)
        this.stack.pop();
      this.reduceContext(type2, start);
    }
    // Shift a value into the buffer
    /**
    @internal
    */
    storeNode(term, start, end, size = 4, isReduce = false) {
      if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
        let cur = this, top2 = this.buffer.length;
        if (top2 == 0 && cur.parent) {
          top2 = cur.bufferBase - cur.parent.bufferBase;
          cur = cur.parent;
        }
        if (top2 > 0 && cur.buffer[top2 - 4] == 0 && cur.buffer[top2 - 1] > -1) {
          if (start == end)
            return;
          if (cur.buffer[top2 - 2] >= start) {
            cur.buffer[top2 - 2] = end;
            return;
          }
        }
      }
      if (!isReduce || this.pos == end) {
        this.buffer.push(term, start, end, size);
      } else {
        let index = this.buffer.length;
        if (index > 0 && this.buffer[index - 4] != 0)
          while (index > 0 && this.buffer[index - 2] > end) {
            this.buffer[index] = this.buffer[index - 4];
            this.buffer[index + 1] = this.buffer[index - 3];
            this.buffer[index + 2] = this.buffer[index - 2];
            this.buffer[index + 3] = this.buffer[index - 1];
            index -= 4;
            if (size > 4)
              size -= 4;
          }
        this.buffer[index] = term;
        this.buffer[index + 1] = start;
        this.buffer[index + 2] = end;
        this.buffer[index + 3] = size;
      }
    }
    // Apply a shift action
    /**
    @internal
    */
    shift(action, type2, start, end) {
      if (action & 131072) {
        this.pushState(action & 65535, this.pos);
      } else if ((action & 262144) == 0) {
        let nextState = action, { parser: parser4 } = this.p;
        if (end > this.pos || type2 <= parser4.maxNode) {
          this.pos = end;
          if (!parser4.stateFlag(
            nextState,
            1
            /* StateFlag.Skipped */
          ))
            this.reducePos = end;
        }
        this.pushState(nextState, start);
        this.shiftContext(type2, start);
        if (type2 <= parser4.maxNode)
          this.buffer.push(type2, start, end, 4);
      } else {
        this.pos = end;
        this.shiftContext(type2, start);
        if (type2 <= this.p.parser.maxNode)
          this.buffer.push(type2, start, end, 4);
      }
    }
    // Apply an action
    /**
    @internal
    */
    apply(action, next, nextStart, nextEnd) {
      if (action & 65536)
        this.reduce(action);
      else
        this.shift(action, next, nextStart, nextEnd);
    }
    // Add a prebuilt (reused) node into the buffer.
    /**
    @internal
    */
    useNode(value, next) {
      let index = this.p.reused.length - 1;
      if (index < 0 || this.p.reused[index] != value) {
        this.p.reused.push(value);
        index++;
      }
      let start = this.pos;
      this.reducePos = this.pos = start + value.length;
      this.pushState(next, start);
      this.buffer.push(
        index,
        start,
        this.reducePos,
        -1
        /* size == -1 means this is a reused value */
      );
      if (this.curContext)
        this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /**
    @internal
    */
    split() {
      let parent = this;
      let off = parent.buffer.length;
      while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
        off -= 4;
      let buffer = parent.buffer.slice(off), base2 = parent.bufferBase + off;
      while (parent && base2 == parent.bufferBase)
        parent = parent.parent;
      return new _Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /**
    @internal
    */
    recoverByDelete(next, nextEnd) {
      let isNode = next <= this.p.parser.maxNode;
      if (isNode)
        this.storeNode(next, this.pos, nextEnd, 4);
      this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
      this.pos = this.reducePos = nextEnd;
      this.score -= 190;
    }
    /**
    Check if the given term would be able to be shifted (optionally
    after some reductions) on this stack. This can be useful for
    external tokenizers that want to make sure they only provide a
    given token when it applies.
    */
    canShift(term) {
      for (let sim = new SimulatedStack(this); ; ) {
        let action = this.p.parser.stateSlot(
          sim.state,
          4
          /* ParseState.DefaultReduce */
        ) || this.p.parser.hasAction(sim.state, term);
        if (action == 0)
          return false;
        if ((action & 65536) == 0)
          return true;
        sim.reduce(action);
      }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /**
    @internal
    */
    recoverByInsert(next) {
      if (this.stack.length >= 300)
        return [];
      let nextStates = this.p.parser.nextStates(this.state);
      if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
        let best = [];
        for (let i4 = 0, s4; i4 < nextStates.length; i4 += 2) {
          if ((s4 = nextStates[i4 + 1]) != this.state && this.p.parser.hasAction(s4, next))
            best.push(nextStates[i4], s4);
        }
        if (this.stack.length < 120)
          for (let i4 = 0; best.length < 4 << 1 && i4 < nextStates.length; i4 += 2) {
            let s4 = nextStates[i4 + 1];
            if (!best.some((v3, i5) => i5 & 1 && v3 == s4))
              best.push(nextStates[i4], s4);
          }
        nextStates = best;
      }
      let result = [];
      for (let i4 = 0; i4 < nextStates.length && result.length < 4; i4 += 2) {
        let s4 = nextStates[i4 + 1];
        if (s4 == this.state)
          continue;
        let stack = this.split();
        stack.pushState(s4, this.pos);
        stack.storeNode(0, stack.pos, stack.pos, 4, true);
        stack.shiftContext(nextStates[i4], this.pos);
        stack.reducePos = this.pos;
        stack.score -= 200;
        result.push(stack);
      }
      return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /**
    @internal
    */
    forceReduce() {
      let { parser: parser4 } = this.p;
      let reduce = parser4.stateSlot(
        this.state,
        5
        /* ParseState.ForcedReduce */
      );
      if ((reduce & 65536) == 0)
        return false;
      if (!parser4.validAction(this.state, reduce)) {
        let depth = reduce >> 19, term = reduce & 65535;
        let target = this.stack.length - depth * 3;
        if (target < 0 || parser4.getGoto(this.stack[target], term, false) < 0) {
          let backup = this.findForcedReduction();
          if (backup == null)
            return false;
          reduce = backup;
        }
        this.storeNode(0, this.pos, this.pos, 4, true);
        this.score -= 100;
      }
      this.reducePos = this.pos;
      this.reduce(reduce);
      return true;
    }
    /**
    Try to scan through the automaton to find some kind of reduction
    that can be applied. Used when the regular ForcedReduce field
    isn't a valid action. @internal
    */
    findForcedReduction() {
      let { parser: parser4 } = this.p, seen = [];
      let explore = (state, depth) => {
        if (seen.includes(state))
          return;
        seen.push(state);
        return parser4.allActions(state, (action) => {
          if (action & (262144 | 131072)) ;
          else if (action & 65536) {
            let rDepth = (action >> 19) - depth;
            if (rDepth > 1) {
              let term = action & 65535, target = this.stack.length - rDepth * 3;
              if (target >= 0 && parser4.getGoto(this.stack[target], term, false) >= 0)
                return rDepth << 19 | 65536 | term;
            }
          } else {
            let found = explore(action, depth + 1);
            if (found != null)
              return found;
          }
        });
      };
      return explore(this.state, 0);
    }
    /**
    @internal
    */
    forceAll() {
      while (!this.p.parser.stateFlag(
        this.state,
        2
        /* StateFlag.Accepting */
      )) {
        if (!this.forceReduce()) {
          this.storeNode(0, this.pos, this.pos, 4, true);
          break;
        }
      }
      return this;
    }
    /**
    Check whether this state has no further actions (assumed to be a direct descendant of the
    top state, since any other states must be able to continue
    somehow). @internal
    */
    get deadEnd() {
      if (this.stack.length != 3)
        return false;
      let { parser: parser4 } = this.p;
      return parser4.data[parser4.stateSlot(
        this.state,
        1
        /* ParseState.Actions */
      )] == 65535 && !parser4.stateSlot(
        this.state,
        4
        /* ParseState.DefaultReduce */
      );
    }
    /**
    Restart the stack (put it back in its start state). Only safe
    when this.stack.length == 3 (state is directly below the top
    state). @internal
    */
    restart() {
      this.storeNode(0, this.pos, this.pos, 4, true);
      this.state = this.stack[0];
      this.stack.length = 0;
    }
    /**
    @internal
    */
    sameState(other) {
      if (this.state != other.state || this.stack.length != other.stack.length)
        return false;
      for (let i4 = 0; i4 < this.stack.length; i4 += 3)
        if (this.stack[i4] != other.stack[i4])
          return false;
      return true;
    }
    /**
    Get the parser used by this stack.
    */
    get parser() {
      return this.p.parser;
    }
    /**
    Test whether a given dialect (by numeric ID, as exported from
    the terms file) is enabled.
    */
    dialectEnabled(dialectID) {
      return this.p.parser.dialect.flags[dialectID];
    }
    shiftContext(term, start) {
      if (this.curContext)
        this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    reduceContext(term, start) {
      if (this.curContext)
        this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    /**
    @internal
    */
    emitContext() {
      let last = this.buffer.length - 1;
      if (last < 0 || this.buffer[last] != -3)
        this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
    }
    /**
    @internal
    */
    emitLookAhead() {
      let last = this.buffer.length - 1;
      if (last < 0 || this.buffer[last] != -4)
        this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
    }
    updateContext(context) {
      if (context != this.curContext.context) {
        let newCx = new StackContext(this.curContext.tracker, context);
        if (newCx.hash != this.curContext.hash)
          this.emitContext();
        this.curContext = newCx;
      }
    }
    /**
    @internal
    */
    setLookAhead(lookAhead) {
      if (lookAhead > this.lookAhead) {
        this.emitLookAhead();
        this.lookAhead = lookAhead;
      }
    }
    /**
    @internal
    */
    close() {
      if (this.curContext && this.curContext.tracker.strict)
        this.emitContext();
      if (this.lookAhead > 0)
        this.emitLookAhead();
    }
  };
  var StackContext = class {
    constructor(tracker, context) {
      this.tracker = tracker;
      this.context = context;
      this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
  };
  var SimulatedStack = class {
    constructor(start) {
      this.start = start;
      this.state = start.state;
      this.stack = start.stack;
      this.base = this.stack.length;
    }
    reduce(action) {
      let term = action & 65535, depth = action >> 19;
      if (depth == 0) {
        if (this.stack == this.start.stack)
          this.stack = this.stack.slice();
        this.stack.push(this.state, 0, 0);
        this.base += 3;
      } else {
        this.base -= (depth - 1) * 3;
      }
      let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
      this.state = goto;
    }
  };
  var StackBufferCursor = class _StackBufferCursor {
    constructor(stack, pos, index) {
      this.stack = stack;
      this.pos = pos;
      this.index = index;
      this.buffer = stack.buffer;
      if (this.index == 0)
        this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
      return new _StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
      let next = this.stack.parent;
      if (next != null) {
        this.index = this.stack.bufferBase - next.bufferBase;
        this.stack = next;
        this.buffer = next.buffer;
      }
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    next() {
      this.index -= 4;
      this.pos -= 4;
      if (this.index == 0)
        this.maybeNext();
    }
    fork() {
      return new _StackBufferCursor(this.stack, this.pos, this.index);
    }
  };
  function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
      return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length; ) {
      let value = 0;
      for (; ; ) {
        let next = input.charCodeAt(pos++), stop = false;
        if (next == 126) {
          value = 65535;
          break;
        }
        if (next >= 92)
          next--;
        if (next >= 34)
          next--;
        let digit = next - 32;
        if (digit >= 46) {
          digit -= 46;
          stop = true;
        }
        value += digit;
        if (stop)
          break;
        value *= 46;
      }
      if (array)
        array[out++] = value;
      else
        array = new Type(value);
    }
    return array;
  }
  var CachedToken = class {
    constructor() {
      this.start = -1;
      this.value = -1;
      this.end = -1;
      this.extended = -1;
      this.lookAhead = 0;
      this.mask = 0;
      this.context = 0;
    }
  };
  var nullToken = new CachedToken();
  var InputStream = class {
    /**
    @internal
    */
    constructor(input, ranges) {
      this.input = input;
      this.ranges = ranges;
      this.chunk = "";
      this.chunkOff = 0;
      this.chunk2 = "";
      this.chunk2Pos = 0;
      this.next = -1;
      this.token = nullToken;
      this.rangeIndex = 0;
      this.pos = this.chunkPos = ranges[0].from;
      this.range = ranges[0];
      this.end = ranges[ranges.length - 1].to;
      this.readNext();
    }
    /**
    @internal
    */
    resolveOffset(offset, assoc) {
      let range = this.range, index = this.rangeIndex;
      let pos = this.pos + offset;
      while (pos < range.from) {
        if (!index)
          return null;
        let next = this.ranges[--index];
        pos -= range.from - next.to;
        range = next;
      }
      while (assoc < 0 ? pos > range.to : pos >= range.to) {
        if (index == this.ranges.length - 1)
          return null;
        let next = this.ranges[++index];
        pos += next.from - range.to;
        range = next;
      }
      return pos;
    }
    /**
    @internal
    */
    clipPos(pos) {
      if (pos >= this.range.from && pos < this.range.to)
        return pos;
      for (let range of this.ranges)
        if (range.to > pos)
          return Math.max(pos, range.from);
      return this.end;
    }
    /**
    Look at a code unit near the stream position. `.peek(0)` equals
    `.next`, `.peek(-1)` gives you the previous character, and so
    on.
    
    Note that looking around during tokenizing creates dependencies
    on potentially far-away content, which may reduce the
    effectiveness incremental parsing—when looking forward—or even
    cause invalid reparses when looking backward more than 25 code
    units, since the library does not track lookbehind.
    */
    peek(offset) {
      let idx = this.chunkOff + offset, pos, result;
      if (idx >= 0 && idx < this.chunk.length) {
        pos = this.pos + offset;
        result = this.chunk.charCodeAt(idx);
      } else {
        let resolved = this.resolveOffset(offset, 1);
        if (resolved == null)
          return -1;
        pos = resolved;
        if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
          result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
        } else {
          let i4 = this.rangeIndex, range = this.range;
          while (range.to <= pos)
            range = this.ranges[++i4];
          this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
          if (pos + this.chunk2.length > range.to)
            this.chunk2 = this.chunk2.slice(0, range.to - pos);
          result = this.chunk2.charCodeAt(0);
        }
      }
      if (pos >= this.token.lookAhead)
        this.token.lookAhead = pos + 1;
      return result;
    }
    /**
    Accept a token. By default, the end of the token is set to the
    current stream position, but you can pass an offset (relative to
    the stream position) to change that.
    */
    acceptToken(token, endOffset = 0) {
      let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
      if (end == null || end < this.token.start)
        throw new RangeError("Token end out of bounds");
      this.token.value = token;
      this.token.end = end;
    }
    /**
    Accept a token ending at a specific given position.
    */
    acceptTokenTo(token, endPos) {
      this.token.value = token;
      this.token.end = endPos;
    }
    getChunk() {
      if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
        let { chunk, chunkPos } = this;
        this.chunk = this.chunk2;
        this.chunkPos = this.chunk2Pos;
        this.chunk2 = chunk;
        this.chunk2Pos = chunkPos;
        this.chunkOff = this.pos - this.chunkPos;
      } else {
        this.chunk2 = this.chunk;
        this.chunk2Pos = this.chunkPos;
        let nextChunk = this.input.chunk(this.pos);
        let end = this.pos + nextChunk.length;
        this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
        this.chunkPos = this.pos;
        this.chunkOff = 0;
      }
    }
    readNext() {
      if (this.chunkOff >= this.chunk.length) {
        this.getChunk();
        if (this.chunkOff == this.chunk.length)
          return this.next = -1;
      }
      return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    /**
    Move the stream forward N (defaults to 1) code units. Returns
    the new value of [`next`](#lr.InputStream.next).
    */
    advance(n4 = 1) {
      this.chunkOff += n4;
      while (this.pos + n4 >= this.range.to) {
        if (this.rangeIndex == this.ranges.length - 1)
          return this.setDone();
        n4 -= this.range.to - this.pos;
        this.range = this.ranges[++this.rangeIndex];
        this.pos = this.range.from;
      }
      this.pos += n4;
      if (this.pos >= this.token.lookAhead)
        this.token.lookAhead = this.pos + 1;
      return this.readNext();
    }
    setDone() {
      this.pos = this.chunkPos = this.end;
      this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
      this.chunk = "";
      return this.next = -1;
    }
    /**
    @internal
    */
    reset(pos, token) {
      if (token) {
        this.token = token;
        token.start = pos;
        token.lookAhead = pos + 1;
        token.value = token.extended = -1;
      } else {
        this.token = nullToken;
      }
      if (this.pos != pos) {
        this.pos = pos;
        if (pos == this.end) {
          this.setDone();
          return this;
        }
        while (pos < this.range.from)
          this.range = this.ranges[--this.rangeIndex];
        while (pos >= this.range.to)
          this.range = this.ranges[++this.rangeIndex];
        if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
          this.chunkOff = pos - this.chunkPos;
        } else {
          this.chunk = "";
          this.chunkOff = 0;
        }
        this.readNext();
      }
      return this;
    }
    /**
    @internal
    */
    read(from, to) {
      if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
        return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
      if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
        return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
      if (from >= this.range.from && to <= this.range.to)
        return this.input.read(from, to);
      let result = "";
      for (let r3 of this.ranges) {
        if (r3.from >= to)
          break;
        if (r3.to > from)
          result += this.input.read(Math.max(r3.from, from), Math.min(r3.to, to));
      }
      return result;
    }
  };
  var TokenGroup = class {
    constructor(data, id2) {
      this.data = data;
      this.id = id2;
    }
    token(input, stack) {
      let { parser: parser4 } = stack.p;
      readToken(this.data, input, stack, this.id, parser4.data, parser4.tokenPrecTable);
    }
  };
  TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
  var LocalTokenGroup = class {
    constructor(data, precTable, elseToken) {
      this.precTable = precTable;
      this.elseToken = elseToken;
      this.data = typeof data == "string" ? decodeArray(data) : data;
    }
    token(input, stack) {
      let start = input.pos, skipped = 0;
      for (; ; ) {
        let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);
        readToken(this.data, input, stack, 0, this.data, this.precTable);
        if (input.token.value > -1)
          break;
        if (this.elseToken == null)
          return;
        if (!atEof)
          skipped++;
        if (nextPos == null)
          break;
        input.reset(nextPos, input.token);
      }
      if (skipped) {
        input.reset(start, input.token);
        input.acceptToken(this.elseToken, skipped);
      }
    }
  };
  LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
  var ExternalTokenizer = class {
    /**
    Create a tokenizer. The first argument is the function that,
    given an input stream, scans for the types of tokens it
    recognizes at the stream's position, and calls
    [`acceptToken`](#lr.InputStream.acceptToken) when it finds
    one.
    */
    constructor(token, options = {}) {
      this.token = token;
      this.contextual = !!options.contextual;
      this.fallback = !!options.fallback;
      this.extend = !!options.extend;
    }
  };
  function readToken(data, input, stack, group, precTable, precOffset) {
    let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
    scan: for (; ; ) {
      if ((groupMask & data[state]) == 0)
        break;
      let accEnd = data[state + 1];
      for (let i4 = state + 3; i4 < accEnd; i4 += 2)
        if ((data[i4 + 1] & groupMask) > 0) {
          let term = data[i4];
          if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
            input.acceptToken(term);
            break;
          }
        }
      let next = input.next, low = 0, high = data[state + 2];
      if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535) {
        state = data[accEnd + high * 3 - 1];
        continue scan;
      }
      for (; low < high; ) {
        let mid = low + high >> 1;
        let index = accEnd + mid + (mid << 1);
        let from = data[index], to = data[index + 1] || 65536;
        if (next < from)
          high = mid;
        else if (next >= to)
          low = mid + 1;
        else {
          state = data[index + 2];
          input.advance();
          continue scan;
        }
      }
      break;
    }
  }
  function findOffset(data, start, term) {
    for (let i4 = start, next; (next = data[i4]) != 65535; i4++)
      if (next == term)
        return i4 - start;
    return -1;
  }
  function overrides(token, prev, tableData, tableOffset) {
    let iPrev = findOffset(tableData, tableOffset, prev);
    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
  }
  var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
  var stackIDs = null;
  function cutAt(tree, pos, side) {
    let cursor = tree.cursor(IterMode.IncludeAnonymous);
    cursor.moveTo(pos);
    for (; ; ) {
      if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
        for (; ; ) {
          if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
            return side < 0 ? Math.max(0, Math.min(
              cursor.to - 1,
              pos - 25
              /* Lookahead.Margin */
            )) : Math.min(tree.length, Math.max(
              cursor.from + 1,
              pos + 25
              /* Lookahead.Margin */
            ));
          if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
            break;
          if (!cursor.parent())
            return side < 0 ? 0 : tree.length;
        }
    }
  }
  var FragmentCursor2 = class {
    constructor(fragments, nodeSet) {
      this.fragments = fragments;
      this.nodeSet = nodeSet;
      this.i = 0;
      this.fragment = null;
      this.safeFrom = -1;
      this.safeTo = -1;
      this.trees = [];
      this.start = [];
      this.index = [];
      this.nextFragment();
    }
    nextFragment() {
      let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
      if (fr) {
        this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
        this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
        while (this.trees.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
        }
        this.trees.push(fr.tree);
        this.start.push(-fr.offset);
        this.index.push(0);
        this.nextStart = this.safeFrom;
      } else {
        this.nextStart = 1e9;
      }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
      if (pos < this.nextStart)
        return null;
      while (this.fragment && this.safeTo <= pos)
        this.nextFragment();
      if (!this.fragment)
        return null;
      for (; ; ) {
        let last = this.trees.length - 1;
        if (last < 0) {
          this.nextFragment();
          return null;
        }
        let top2 = this.trees[last], index = this.index[last];
        if (index == top2.children.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
          continue;
        }
        let next = top2.children[index];
        let start = this.start[last] + top2.positions[index];
        if (start > pos) {
          this.nextStart = start;
          return null;
        }
        if (next instanceof Tree) {
          if (start == pos) {
            if (start < this.safeFrom)
              return null;
            let end = start + next.length;
            if (end <= this.safeTo) {
              let lookAhead = next.prop(NodeProp.lookAhead);
              if (!lookAhead || end + lookAhead < this.fragment.to)
                return next;
            }
          }
          this.index[last]++;
          if (start + next.length >= Math.max(this.safeFrom, pos)) {
            this.trees.push(next);
            this.start.push(start);
            this.index.push(0);
          }
        } else {
          this.index[last]++;
          this.nextStart = start + next.length;
        }
      }
    }
  };
  var TokenCache = class {
    constructor(parser4, stream) {
      this.stream = stream;
      this.tokens = [];
      this.mainToken = null;
      this.actions = [];
      this.tokens = parser4.tokenizers.map((_2) => new CachedToken());
    }
    getActions(stack) {
      let actionIndex = 0;
      let main2 = null;
      let { parser: parser4 } = stack.p, { tokenizers } = parser4;
      let mask = parser4.stateSlot(
        stack.state,
        3
        /* ParseState.TokenizerMask */
      );
      let context = stack.curContext ? stack.curContext.hash : 0;
      let lookAhead = 0;
      for (let i4 = 0; i4 < tokenizers.length; i4++) {
        if ((1 << i4 & mask) == 0)
          continue;
        let tokenizer = tokenizers[i4], token = this.tokens[i4];
        if (main2 && !tokenizer.fallback)
          continue;
        if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
          this.updateCachedToken(token, tokenizer, stack);
          token.mask = mask;
          token.context = context;
        }
        if (token.lookAhead > token.end + 25)
          lookAhead = Math.max(token.lookAhead, lookAhead);
        if (token.value != 0) {
          let startIndex = actionIndex;
          if (token.extended > -1)
            actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
          actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
          if (!tokenizer.extend) {
            main2 = token;
            if (actionIndex > startIndex)
              break;
          }
        }
      }
      while (this.actions.length > actionIndex)
        this.actions.pop();
      if (lookAhead)
        stack.setLookAhead(lookAhead);
      if (!main2 && stack.pos == this.stream.end) {
        main2 = new CachedToken();
        main2.value = stack.p.parser.eofTerm;
        main2.start = main2.end = stack.pos;
        actionIndex = this.addActions(stack, main2.value, main2.end, actionIndex);
      }
      this.mainToken = main2;
      return this.actions;
    }
    getMainToken(stack) {
      if (this.mainToken)
        return this.mainToken;
      let main2 = new CachedToken(), { pos, p: p4 } = stack;
      main2.start = pos;
      main2.end = Math.min(pos + 1, p4.stream.end);
      main2.value = pos == p4.stream.end ? p4.parser.eofTerm : 0;
      return main2;
    }
    updateCachedToken(token, tokenizer, stack) {
      let start = this.stream.clipPos(stack.pos);
      tokenizer.token(this.stream.reset(start, token), stack);
      if (token.value > -1) {
        let { parser: parser4 } = stack.p;
        for (let i4 = 0; i4 < parser4.specialized.length; i4++)
          if (parser4.specialized[i4] == token.value) {
            let result = parser4.specializers[i4](this.stream.read(token.start, token.end), stack);
            if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
              if ((result & 1) == 0)
                token.value = result >> 1;
              else
                token.extended = result >> 1;
              break;
            }
          }
      } else {
        token.value = 0;
        token.end = this.stream.clipPos(start + 1);
      }
    }
    putAction(action, token, end, index) {
      for (let i4 = 0; i4 < index; i4 += 3)
        if (this.actions[i4] == action)
          return index;
      this.actions[index++] = action;
      this.actions[index++] = token;
      this.actions[index++] = end;
      return index;
    }
    addActions(stack, token, end, index) {
      let { state } = stack, { parser: parser4 } = stack.p, { data } = parser4;
      for (let set2 = 0; set2 < 2; set2++) {
        for (let i4 = parser4.stateSlot(
          state,
          set2 ? 2 : 1
          /* ParseState.Actions */
        ); ; i4 += 3) {
          if (data[i4] == 65535) {
            if (data[i4 + 1] == 1) {
              i4 = pair(data, i4 + 2);
            } else {
              if (index == 0 && data[i4 + 1] == 2)
                index = this.putAction(pair(data, i4 + 2), token, end, index);
              break;
            }
          }
          if (data[i4] == token)
            index = this.putAction(pair(data, i4 + 1), token, end, index);
        }
      }
      return index;
    }
  };
  var Parse = class {
    constructor(parser4, input, fragments, ranges) {
      this.parser = parser4;
      this.input = input;
      this.ranges = ranges;
      this.recovering = 0;
      this.nextStackID = 9812;
      this.minStackPos = 0;
      this.reused = [];
      this.stoppedAt = null;
      this.lastBigReductionStart = -1;
      this.lastBigReductionSize = 0;
      this.bigReductionCount = 0;
      this.stream = new InputStream(input, ranges);
      this.tokens = new TokenCache(parser4, this.stream);
      this.topTerm = parser4.top[1];
      let { from } = ranges[0];
      this.stacks = [Stack.start(this, parser4.top[0], from)];
      this.fragments = fragments.length && this.stream.end - from > parser4.bufferLength * 4 ? new FragmentCursor2(fragments, parser4.nodeSet) : null;
    }
    get parsedPos() {
      return this.minStackPos;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
      let stacks = this.stacks, pos = this.minStackPos;
      let newStacks = this.stacks = [];
      let stopped, stoppedTokens;
      if (this.bigReductionCount > 300 && stacks.length == 1) {
        let [s4] = stacks;
        while (s4.forceReduce() && s4.stack.length && s4.stack[s4.stack.length - 2] >= this.lastBigReductionStart) {
        }
        this.bigReductionCount = this.lastBigReductionSize = 0;
      }
      for (let i4 = 0; i4 < stacks.length; i4++) {
        let stack = stacks[i4];
        for (; ; ) {
          this.tokens.mainToken = null;
          if (stack.pos > pos) {
            newStacks.push(stack);
          } else if (this.advanceStack(stack, newStacks, stacks)) {
            continue;
          } else {
            if (!stopped) {
              stopped = [];
              stoppedTokens = [];
            }
            stopped.push(stack);
            let tok = this.tokens.getMainToken(stack);
            stoppedTokens.push(tok.value, tok.end);
          }
          break;
        }
      }
      if (!newStacks.length) {
        let finished = stopped && findFinished(stopped);
        if (finished) {
          if (verbose)
            console.log("Finish with " + this.stackID(finished));
          return this.stackToTree(finished);
        }
        if (this.parser.strict) {
          if (verbose && stopped)
            console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
          throw new SyntaxError("No parse at " + pos);
        }
        if (!this.recovering)
          this.recovering = 5;
      }
      if (this.recovering && stopped) {
        let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
        if (finished) {
          if (verbose)
            console.log("Force-finish " + this.stackID(finished));
          return this.stackToTree(finished.forceAll());
        }
      }
      if (this.recovering) {
        let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
        if (newStacks.length > maxRemaining) {
          newStacks.sort((a4, b4) => b4.score - a4.score);
          while (newStacks.length > maxRemaining)
            newStacks.pop();
        }
        if (newStacks.some((s4) => s4.reducePos > pos))
          this.recovering--;
      } else if (newStacks.length > 1) {
        outer: for (let i4 = 0; i4 < newStacks.length - 1; i4++) {
          let stack = newStacks[i4];
          for (let j2 = i4 + 1; j2 < newStacks.length; j2++) {
            let other = newStacks[j2];
            if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
              if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                newStacks.splice(j2--, 1);
              } else {
                newStacks.splice(i4--, 1);
                continue outer;
              }
            }
          }
        }
        if (newStacks.length > 12)
          newStacks.splice(
            12,
            newStacks.length - 12
            /* Rec.MaxStackCount */
          );
      }
      this.minStackPos = newStacks[0].pos;
      for (let i4 = 1; i4 < newStacks.length; i4++)
        if (newStacks[i4].pos < this.minStackPos)
          this.minStackPos = newStacks[i4].pos;
      return null;
    }
    stopAt(pos) {
      if (this.stoppedAt != null && this.stoppedAt < pos)
        throw new RangeError("Can't move stoppedAt forward");
      this.stoppedAt = pos;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split) {
      let start = stack.pos, { parser: parser4 } = this;
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (this.stoppedAt != null && start > this.stoppedAt)
        return stack.forceReduce() ? stack : null;
      if (this.fragments) {
        let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
        for (let cached = this.fragments.nodeAt(start); cached; ) {
          let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser4.getGoto(stack.state, cached.type.id) : -1;
          if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
            stack.useNode(cached, match);
            if (verbose)
              console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser4.getName(cached.type.id)})`);
            return true;
          }
          if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
            break;
          let inner = cached.children[0];
          if (inner instanceof Tree && cached.positions[0] == 0)
            cached = inner;
          else
            break;
        }
      }
      let defaultReduce = parser4.stateSlot(
        stack.state,
        4
        /* ParseState.DefaultReduce */
      );
      if (defaultReduce > 0) {
        stack.reduce(defaultReduce);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser4.getName(
            defaultReduce & 65535
            /* Action.ValueMask */
          )})`);
        return true;
      }
      if (stack.stack.length >= 8400) {
        while (stack.stack.length > 6e3 && stack.forceReduce()) {
        }
      }
      let actions = this.tokens.getActions(stack);
      for (let i4 = 0; i4 < actions.length; ) {
        let action = actions[i4++], term = actions[i4++], end = actions[i4++];
        let last = i4 == actions.length || !split;
        let localStack = last ? stack : stack.split();
        let main2 = this.tokens.mainToken;
        localStack.apply(action, term, main2 ? main2.start : localStack.pos, end);
        if (verbose)
          console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser4.getName(
            action & 65535
            /* Action.ValueMask */
          )}`} for ${parser4.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
        if (last)
          return true;
        else if (localStack.pos > start)
          stacks.push(localStack);
        else
          split.push(localStack);
      }
      return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
      let pos = stack.pos;
      for (; ; ) {
        if (!this.advanceStack(stack, null, null))
          return false;
        if (stack.pos > pos) {
          pushStackDedup(stack, newStacks);
          return true;
        }
      }
    }
    runRecovery(stacks, tokens, newStacks) {
      let finished = null, restarted = false;
      for (let i4 = 0; i4 < stacks.length; i4++) {
        let stack = stacks[i4], token = tokens[i4 << 1], tokenEnd = tokens[(i4 << 1) + 1];
        let base2 = verbose ? this.stackID(stack) + " -> " : "";
        if (stack.deadEnd) {
          if (restarted)
            continue;
          restarted = true;
          stack.restart();
          if (verbose)
            console.log(base2 + this.stackID(stack) + " (restarted)");
          let done = this.advanceFully(stack, newStacks);
          if (done)
            continue;
        }
        let force = stack.split(), forceBase = base2;
        for (let j2 = 0; force.forceReduce() && j2 < 10; j2++) {
          if (verbose)
            console.log(forceBase + this.stackID(force) + " (via force-reduce)");
          let done = this.advanceFully(force, newStacks);
          if (done)
            break;
          if (verbose)
            forceBase = this.stackID(force) + " -> ";
        }
        for (let insert2 of stack.recoverByInsert(token)) {
          if (verbose)
            console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
          this.advanceFully(insert2, newStacks);
        }
        if (this.stream.end > stack.pos) {
          if (tokenEnd == stack.pos) {
            tokenEnd++;
            token = 0;
          }
          stack.recoverByDelete(token, tokenEnd);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
          pushStackDedup(stack, newStacks);
        } else if (!finished || finished.score < stack.score) {
          finished = stack;
        }
      }
      return finished;
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack) {
      stack.close();
      return Tree.build({
        buffer: StackBufferCursor.create(stack),
        nodeSet: this.parser.nodeSet,
        topID: this.topTerm,
        maxBufferLength: this.parser.bufferLength,
        reused: this.reused,
        start: this.ranges[0].from,
        length: stack.pos - this.ranges[0].from,
        minRepeatType: this.parser.minRepeatTerm
      });
    }
    stackID(stack) {
      let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
      if (!id2)
        stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
      return id2 + stack;
    }
  };
  function pushStackDedup(stack, newStacks) {
    for (let i4 = 0; i4 < newStacks.length; i4++) {
      let other = newStacks[i4];
      if (other.pos == stack.pos && other.sameState(stack)) {
        if (newStacks[i4].score < stack.score)
          newStacks[i4] = stack;
        return;
      }
    }
    newStacks.push(stack);
  }
  var Dialect = class {
    constructor(source, flags, disabled) {
      this.source = source;
      this.flags = flags;
      this.disabled = disabled;
    }
    allows(term) {
      return !this.disabled || this.disabled[term] == 0;
    }
  };
  var id = (x2) => x2;
  var ContextTracker = class {
    /**
    Define a context tracker.
    */
    constructor(spec) {
      this.start = spec.start;
      this.shift = spec.shift || id;
      this.reduce = spec.reduce || id;
      this.reuse = spec.reuse || id;
      this.hash = spec.hash || (() => 0);
      this.strict = spec.strict !== false;
    }
  };
  var LRParser = class _LRParser extends Parser {
    /**
    @internal
    */
    constructor(spec) {
      super();
      this.wrappers = [];
      if (spec.version != 14)
        throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
      let nodeNames = spec.nodeNames.split(" ");
      this.minRepeatTerm = nodeNames.length;
      for (let i4 = 0; i4 < spec.repeatNodeCount; i4++)
        nodeNames.push("");
      let topTerms = Object.keys(spec.topRules).map((r3) => spec.topRules[r3][1]);
      let nodeProps = [];
      for (let i4 = 0; i4 < nodeNames.length; i4++)
        nodeProps.push([]);
      function setProp(nodeID, prop, value) {
        nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
      }
      if (spec.nodeProps)
        for (let propSpec of spec.nodeProps) {
          let prop = propSpec[0];
          if (typeof prop == "string")
            prop = NodeProp[prop];
          for (let i4 = 1; i4 < propSpec.length; ) {
            let next = propSpec[i4++];
            if (next >= 0) {
              setProp(next, prop, propSpec[i4++]);
            } else {
              let value = propSpec[i4 + -next];
              for (let j2 = -next; j2 > 0; j2--)
                setProp(propSpec[i4++], prop, value);
              i4++;
            }
          }
        }
      this.nodeSet = new NodeSet(nodeNames.map((name2, i4) => NodeType.define({
        name: i4 >= this.minRepeatTerm ? void 0 : name2,
        id: i4,
        props: nodeProps[i4],
        top: topTerms.indexOf(i4) > -1,
        error: i4 == 0,
        skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i4) > -1
      })));
      if (spec.propSources)
        this.nodeSet = this.nodeSet.extend(...spec.propSources);
      this.strict = false;
      this.bufferLength = DefaultBufferLength;
      let tokenArray = decodeArray(spec.tokenData);
      this.context = spec.context;
      this.specializerSpecs = spec.specialized || [];
      this.specialized = new Uint16Array(this.specializerSpecs.length);
      for (let i4 = 0; i4 < this.specializerSpecs.length; i4++)
        this.specialized[i4] = this.specializerSpecs[i4].term;
      this.specializers = this.specializerSpecs.map(getSpecializer);
      this.states = decodeArray(spec.states, Uint32Array);
      this.data = decodeArray(spec.stateData);
      this.goto = decodeArray(spec.goto);
      this.maxTerm = spec.maxTerm;
      this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
      this.topRules = spec.topRules;
      this.dialects = spec.dialects || {};
      this.dynamicPrecedences = spec.dynamicPrecedences || null;
      this.tokenPrecTable = spec.tokenPrec;
      this.termNames = spec.termNames || null;
      this.maxNode = this.nodeSet.types.length - 1;
      this.dialect = this.parseDialect();
      this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
      let parse = new Parse(this, input, fragments, ranges);
      for (let w2 of this.wrappers)
        parse = w2(parse, input, fragments, ranges);
      return parse;
    }
    /**
    Get a goto table entry @internal
    */
    getGoto(state, term, loose = false) {
      let table = this.goto;
      if (term >= table[0])
        return -1;
      for (let pos = table[term + 1]; ; ) {
        let groupTag = table[pos++], last = groupTag & 1;
        let target = table[pos++];
        if (last && loose)
          return target;
        for (let end = pos + (groupTag >> 1); pos < end; pos++)
          if (table[pos] == state)
            return target;
        if (last)
          return -1;
      }
    }
    /**
    Check if this state has an action for a given terminal @internal
    */
    hasAction(state, terminal) {
      let data = this.data;
      for (let set2 = 0; set2 < 2; set2++) {
        for (let i4 = this.stateSlot(
          state,
          set2 ? 2 : 1
          /* ParseState.Actions */
        ), next; ; i4 += 3) {
          if ((next = data[i4]) == 65535) {
            if (data[i4 + 1] == 1)
              next = data[i4 = pair(data, i4 + 2)];
            else if (data[i4 + 1] == 2)
              return pair(data, i4 + 2);
            else
              break;
          }
          if (next == terminal || next == 0)
            return pair(data, i4 + 1);
        }
      }
      return 0;
    }
    /**
    @internal
    */
    stateSlot(state, slot) {
      return this.states[state * 6 + slot];
    }
    /**
    @internal
    */
    stateFlag(state, flag) {
      return (this.stateSlot(
        state,
        0
        /* ParseState.Flags */
      ) & flag) > 0;
    }
    /**
    @internal
    */
    validAction(state, action) {
      return !!this.allActions(state, (a4) => a4 == action ? true : null);
    }
    /**
    @internal
    */
    allActions(state, action) {
      let deflt = this.stateSlot(
        state,
        4
        /* ParseState.DefaultReduce */
      );
      let result = deflt ? action(deflt) : void 0;
      for (let i4 = this.stateSlot(
        state,
        1
        /* ParseState.Actions */
      ); result == null; i4 += 3) {
        if (this.data[i4] == 65535) {
          if (this.data[i4 + 1] == 1)
            i4 = pair(this.data, i4 + 2);
          else
            break;
        }
        result = action(pair(this.data, i4 + 1));
      }
      return result;
    }
    /**
    Get the states that can follow this one through shift actions or
    goto jumps. @internal
    */
    nextStates(state) {
      let result = [];
      for (let i4 = this.stateSlot(
        state,
        1
        /* ParseState.Actions */
      ); ; i4 += 3) {
        if (this.data[i4] == 65535) {
          if (this.data[i4 + 1] == 1)
            i4 = pair(this.data, i4 + 2);
          else
            break;
        }
        if ((this.data[i4 + 2] & 65536 >> 16) == 0) {
          let value = this.data[i4 + 1];
          if (!result.some((v3, i5) => i5 & 1 && v3 == value))
            result.push(this.data[i4], value);
        }
      }
      return result;
    }
    /**
    Configure the parser. Returns a new parser instance that has the
    given settings modified. Settings not provided in `config` are
    kept from the original parser.
    */
    configure(config) {
      let copy = Object.assign(Object.create(_LRParser.prototype), this);
      if (config.props)
        copy.nodeSet = this.nodeSet.extend(...config.props);
      if (config.top) {
        let info = this.topRules[config.top];
        if (!info)
          throw new RangeError(`Invalid top rule name ${config.top}`);
        copy.top = info;
      }
      if (config.tokenizers)
        copy.tokenizers = this.tokenizers.map((t5) => {
          let found = config.tokenizers.find((r3) => r3.from == t5);
          return found ? found.to : t5;
        });
      if (config.specializers) {
        copy.specializers = this.specializers.slice();
        copy.specializerSpecs = this.specializerSpecs.map((s4, i4) => {
          let found = config.specializers.find((r3) => r3.from == s4.external);
          if (!found)
            return s4;
          let spec = Object.assign(Object.assign({}, s4), { external: found.to });
          copy.specializers[i4] = getSpecializer(spec);
          return spec;
        });
      }
      if (config.contextTracker)
        copy.context = config.contextTracker;
      if (config.dialect)
        copy.dialect = this.parseDialect(config.dialect);
      if (config.strict != null)
        copy.strict = config.strict;
      if (config.wrap)
        copy.wrappers = copy.wrappers.concat(config.wrap);
      if (config.bufferLength != null)
        copy.bufferLength = config.bufferLength;
      return copy;
    }
    /**
    Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
    are registered for this parser.
    */
    hasWrappers() {
      return this.wrappers.length > 0;
    }
    /**
    Returns the name associated with a given term. This will only
    work for all terms when the parser was generated with the
    `--names` option. By default, only the names of tagged terms are
    stored.
    */
    getName(term) {
      return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /**
    The eof term id is always allocated directly after the node
    types. @internal
    */
    get eofTerm() {
      return this.maxNode + 1;
    }
    /**
    The type of top node produced by the parser.
    */
    get topNode() {
      return this.nodeSet.types[this.top[1]];
    }
    /**
    @internal
    */
    dynamicPrecedence(term) {
      let prec2 = this.dynamicPrecedences;
      return prec2 == null ? 0 : prec2[term] || 0;
    }
    /**
    @internal
    */
    parseDialect(dialect) {
      let values = Object.keys(this.dialects), flags = values.map(() => false);
      if (dialect)
        for (let part of dialect.split(" ")) {
          let id2 = values.indexOf(part);
          if (id2 >= 0)
            flags[id2] = true;
        }
      let disabled = null;
      for (let i4 = 0; i4 < values.length; i4++)
        if (!flags[i4]) {
          for (let j2 = this.dialects[values[i4]], id2; (id2 = this.data[j2++]) != 65535; )
            (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
        }
      return new Dialect(dialect, flags, disabled);
    }
    /**
    Used by the output of the parser generator. Not available to
    user code. @hide
    */
    static deserialize(spec) {
      return new _LRParser(spec);
    }
  };
  function pair(data, off) {
    return data[off] | data[off + 1] << 16;
  }
  function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
      let stopped = stack.p.stoppedAt;
      if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(
        stack.state,
        2
        /* StateFlag.Accepting */
      ) && (!best || best.score < stack.score))
        best = stack;
    }
    return best;
  }
  function getSpecializer(spec) {
    if (spec.external) {
      let mask = spec.extend ? 1 : 0;
      return (value, stack) => spec.external(value, stack) << 1 | mask;
    }
    return spec.get;
  }

  // node_modules/.pnpm/@lezer+yaml@1.0.3/node_modules/@lezer/yaml/dist/index.js
  var blockEnd = 63;
  var eof = 64;
  var DirectiveEnd = 1;
  var DocEnd = 2;
  var sequenceStartMark = 3;
  var sequenceContinueMark = 4;
  var explicitMapStartMark = 5;
  var explicitMapContinueMark = 6;
  var flowMapMark = 7;
  var mapStartMark = 65;
  var mapContinueMark = 66;
  var Literal = 8;
  var QuotedLiteral = 9;
  var Anchor = 10;
  var Alias = 11;
  var Tag2 = 12;
  var BlockLiteralContent = 13;
  var BracketL = 19;
  var FlowSequence = 20;
  var Colon = 29;
  var BraceL = 33;
  var FlowMapping = 34;
  var BlockLiteralHeader = 47;
  var type_Top = 0;
  var type_Seq = 1;
  var type_Map = 2;
  var type_Flow = 3;
  var type_Lit = 4;
  var Context = class {
    constructor(parent, depth, type2) {
      this.parent = parent;
      this.depth = depth;
      this.type = type2;
      this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + depth + (depth << 4) + type2;
    }
  };
  Context.top = new Context(null, -1, type_Top);
  function findColumn2(input, pos) {
    for (let col = 0, p4 = pos - input.pos - 1; ; p4--, col++) {
      let ch = input.peek(p4);
      if (isBreakSpace(ch) || ch == -1) return col;
    }
  }
  function isNonBreakSpace(ch) {
    return ch == 32 || ch == 9;
  }
  function isBreakSpace(ch) {
    return ch == 10 || ch == 13;
  }
  function isSpace(ch) {
    return isNonBreakSpace(ch) || isBreakSpace(ch);
  }
  function isSep(ch) {
    return ch < 0 || isSpace(ch);
  }
  var indentation = new ContextTracker({
    start: Context.top,
    reduce(context, term) {
      return context.type == type_Flow && (term == FlowSequence || term == FlowMapping) ? context.parent : context;
    },
    shift(context, term, stack, input) {
      if (term == sequenceStartMark)
        return new Context(context, findColumn2(input, input.pos), type_Seq);
      if (term == mapStartMark || term == explicitMapStartMark)
        return new Context(context, findColumn2(input, input.pos), type_Map);
      if (term == blockEnd)
        return context.parent;
      if (term == BracketL || term == BraceL)
        return new Context(context, 0, type_Flow);
      if (term == BlockLiteralContent && context.type == type_Lit)
        return context.parent;
      if (term == BlockLiteralHeader) {
        let indent = /[1-9]/.exec(input.read(input.pos, stack.pos));
        if (indent) return new Context(context, context.depth + +indent[0], type_Lit);
      }
      return context;
    },
    hash(context) {
      return context.hash;
    }
  });
  function three(input, ch, off = 0) {
    return input.peek(off) == ch && input.peek(off + 1) == ch && input.peek(off + 2) == ch && isSep(input.peek(off + 3));
  }
  var newlines = new ExternalTokenizer((input, stack) => {
    if (input.next == -1 && stack.canShift(eof))
      return input.acceptToken(eof);
    let prev = input.peek(-1);
    if ((isBreakSpace(prev) || prev < 0) && stack.context.type != type_Flow) {
      if (three(
        input,
        45
        /* '-' */
      )) {
        if (stack.canShift(blockEnd)) input.acceptToken(blockEnd);
        else return input.acceptToken(DirectiveEnd, 3);
      }
      if (three(
        input,
        46
        /* '.' */
      )) {
        if (stack.canShift(blockEnd)) input.acceptToken(blockEnd);
        else return input.acceptToken(DocEnd, 3);
      }
      let depth = 0;
      while (input.next == 32) {
        depth++;
        input.advance();
      }
      if ((depth < stack.context.depth || depth == stack.context.depth && stack.context.type == type_Seq && (input.next != 45 || !isSep(input.peek(1)))) && // Not blank
      input.next != -1 && !isBreakSpace(input.next) && input.next != 35)
        input.acceptToken(blockEnd, -depth);
    }
  }, { contextual: true });
  var blockMark = new ExternalTokenizer((input, stack) => {
    if (stack.context.type == type_Flow) {
      if (input.next == 63) {
        input.advance();
        if (isSep(input.next)) input.acceptToken(flowMapMark);
      }
      return;
    }
    if (input.next == 45) {
      input.advance();
      if (isSep(input.next))
        input.acceptToken(stack.context.type == type_Seq && stack.context.depth == findColumn2(input, input.pos - 1) ? sequenceContinueMark : sequenceStartMark);
    } else if (input.next == 63) {
      input.advance();
      if (isSep(input.next))
        input.acceptToken(stack.context.type == type_Map && stack.context.depth == findColumn2(input, input.pos - 1) ? explicitMapContinueMark : explicitMapStartMark);
    } else {
      let start = input.pos;
      for (; ; ) {
        if (isNonBreakSpace(input.next)) {
          if (input.pos == start) return;
          input.advance();
        } else if (input.next == 33) {
          readTag(input);
        } else if (input.next == 38) {
          readAnchor(input);
        } else if (input.next == 42) {
          readAnchor(input);
          break;
        } else if (input.next == 39 || input.next == 34) {
          if (readQuoted(input, true)) break;
          return;
        } else if (input.next == 91 || input.next == 123) {
          if (!scanBrackets(input)) return;
          break;
        } else {
          readPlain(input, true, false, 0);
          break;
        }
      }
      while (isNonBreakSpace(input.next)) input.advance();
      if (input.next == 58) {
        if (input.pos == start && stack.canShift(Colon)) return;
        let after = input.peek(1);
        if (isSep(after))
          input.acceptTokenTo(stack.context.type == type_Map && stack.context.depth == findColumn2(input, start) ? mapContinueMark : mapStartMark, start);
      }
    }
  }, { contextual: true });
  function uriChar(ch) {
    return ch > 32 && ch < 127 && ch != 34 && ch != 37 && ch != 44 && ch != 60 && ch != 62 && ch != 92 && ch != 94 && ch != 96 && ch != 123 && ch != 124 && ch != 125;
  }
  function hexChar(ch) {
    return ch >= 48 && ch <= 57 || ch >= 97 && ch <= 102 || ch >= 65 && ch <= 70;
  }
  function readUriChar(input, quoted) {
    if (input.next == 37) {
      input.advance();
      if (hexChar(input.next)) input.advance();
      if (hexChar(input.next)) input.advance();
      return true;
    } else if (uriChar(input.next) || quoted && input.next == 44) {
      input.advance();
      return true;
    }
    return false;
  }
  function readTag(input) {
    input.advance();
    if (input.next == 60) {
      input.advance();
      for (; ; ) {
        if (!readUriChar(input, true)) {
          if (input.next == 62) input.advance();
          break;
        }
      }
    } else {
      while (readUriChar(input, false)) {
      }
    }
  }
  function readAnchor(input) {
    input.advance();
    while (!isSep(input.next) && charTag(input.tag) != "f") input.advance();
  }
  function readQuoted(input, scan) {
    let quote = input.next, lineBreak = false, start = input.pos;
    input.advance();
    for (; ; ) {
      let ch = input.next;
      if (ch < 0) break;
      input.advance();
      if (ch == quote) {
        if (ch == 39) {
          if (input.next == 39) input.advance();
          else break;
        } else {
          break;
        }
      } else if (ch == 92 && quote == 34) {
        if (input.next >= 0) input.advance();
      } else if (isBreakSpace(ch)) {
        if (scan) return false;
        lineBreak = true;
      } else if (scan && input.pos >= start + 1024) {
        return false;
      }
    }
    return !lineBreak;
  }
  function scanBrackets(input) {
    for (let stack = [], end = input.pos + 1024; ; ) {
      if (input.next == 91 || input.next == 123) {
        stack.push(input.next);
        input.advance();
      } else if (input.next == 39 || input.next == 34) {
        if (!readQuoted(input, true)) return false;
      } else if (input.next == 93 || input.next == 125) {
        if (stack[stack.length - 1] != input.next - 2) return false;
        stack.pop();
        input.advance();
        if (!stack.length) return true;
      } else if (input.next < 0 || input.pos > end || isBreakSpace(input.next)) {
        return false;
      } else {
        input.advance();
      }
    }
  }
  var charTable = "iiisiiissisfissssssssssssisssiiissssssssssssssssssssssssssfsfssissssssssssssssssssssssssssfif";
  function charTag(ch) {
    if (ch < 33) return "u";
    if (ch > 125) return "s";
    return charTable[ch - 33];
  }
  function isSafe(ch, inFlow) {
    let tag = charTag(ch);
    return tag != "u" && !(inFlow && tag == "f");
  }
  function readPlain(input, scan, inFlow, indent) {
    if (charTag(input.next) == "s" || (input.next == 63 || input.next == 58 || input.next == 45) && isSafe(input.peek(1), inFlow)) {
      input.advance();
    } else {
      return false;
    }
    let start = input.pos;
    for (; ; ) {
      let next = input.next, off = 0, lineIndent = indent + 1;
      while (isSpace(next)) {
        if (isBreakSpace(next)) {
          if (scan) return false;
          lineIndent = 0;
        } else {
          lineIndent++;
        }
        next = input.peek(++off);
      }
      let safe = next >= 0 && (next == 58 ? isSafe(input.peek(off + 1), inFlow) : next == 35 ? input.peek(off - 1) != 32 : isSafe(next, inFlow));
      if (!safe || !inFlow && lineIndent <= indent || lineIndent == 0 && !inFlow && (three(input, 45, off) || three(input, 46, off)))
        break;
      if (scan && charTag(next) == "f") return false;
      for (let i4 = off; i4 >= 0; i4--) input.advance();
      if (scan && input.pos > start + 1024) return false;
    }
    return true;
  }
  var literals = new ExternalTokenizer((input, stack) => {
    if (input.next == 33) {
      readTag(input);
      input.acceptToken(Tag2);
    } else if (input.next == 38 || input.next == 42) {
      let token = input.next == 38 ? Anchor : Alias;
      readAnchor(input);
      input.acceptToken(token);
    } else if (input.next == 39 || input.next == 34) {
      readQuoted(input, false);
      input.acceptToken(QuotedLiteral);
    } else if (readPlain(input, false, stack.context.type == type_Flow, stack.context.depth)) {
      input.acceptToken(Literal);
    }
  });
  var blockLiteral = new ExternalTokenizer((input, stack) => {
    let indent = stack.context.type == type_Lit ? stack.context.depth : -1, upto = input.pos;
    scan: for (; ; ) {
      let depth = 0, next = input.next;
      while (next == 32) next = input.peek(++depth);
      if (!depth && (three(input, 45, depth) || three(input, 46, depth))) break;
      if (!isBreakSpace(next)) {
        if (indent < 0) indent = Math.max(stack.context.depth + 1, depth);
        if (depth < indent) break;
      }
      for (; ; ) {
        if (input.next < 0) break scan;
        let isBreak = isBreakSpace(input.next);
        input.advance();
        if (isBreak) continue scan;
        upto = input.pos;
      }
    }
    input.acceptTokenTo(BlockLiteralContent, upto);
  });
  var yamlHighlighting = styleTags({
    DirectiveName: tags.keyword,
    DirectiveContent: tags.attributeValue,
    "DirectiveEnd DocEnd": tags.meta,
    QuotedLiteral: tags.string,
    BlockLiteralHeader: tags.special(tags.string),
    BlockLiteralContent: tags.content,
    Literal: tags.content,
    "Key/Literal Key/QuotedLiteral": tags.definition(tags.propertyName),
    "Anchor Alias": tags.labelName,
    Tag: tags.typeName,
    Comment: tags.lineComment,
    ": , -": tags.separator,
    "?": tags.punctuation,
    "[ ]": tags.squareBracket,
    "{ }": tags.brace
  });
  var parser = LRParser.deserialize({
    version: 14,
    states: "5lQ!ZQgOOO#PQfO'#CpO#uQfO'#DOOOQR'#Dv'#DvO$qQgO'#DRO%gQdO'#DUO%nQgO'#DUO&ROaO'#D[OOQR'#Du'#DuO&{QgO'#D^O'rQgO'#D`OOQR'#Dt'#DtO(iOqO'#DbOOQP'#Dj'#DjO(zQaO'#CmO)YQgO'#CmOOQP'#Cm'#CmQ)jQaOOQ)uQgOOQ]QgOOO*PQdO'#CrO*nQdO'#CtOOQO'#Dw'#DwO+]Q`O'#CxO+hQdO'#CwO+rQ`O'#CwOOQO'#Cv'#CvO+wQdO'#CvOOQO'#Cq'#CqO,UQ`O,59[O,^QfO,59[OOQR,59[,59[OOQO'#Cx'#CxO,eQ`O'#DPO,pQdO'#DPOOQO'#Dx'#DxO,zQdO'#DxO-XQ`O,59jO-aQfO,59jOOQR,59j,59jOOQR'#DS'#DSO-hQcO,59mO-sQgO'#DVO.TQ`O'#DVO.YQcO,59pOOQR'#DX'#DXO#|QfO'#DWO.hQcO'#DWOOQR,59v,59vO.yOWO,59vO/OOaO,59vO/WOaO,59vO/cQgO'#D_OOQR,59x,59xO0VQgO'#DaOOQR,59z,59zOOQP,59|,59|O0yOaO,59|O1ROaO,59|O1aOqO,59|OOQP-E7h-E7hO1oQgO,59XOOQP,59X,59XO2PQaO'#DeO2_QgO'#DeO2oQgO'#DkOOQP'#Dk'#DkQ)jQaOOO3PQdO'#CsOOQO,59^,59^O3kQdO'#CuOOQO,59`,59`OOQO,59c,59cO4VQdO,59cO4aQdO'#CzO4kQ`O'#CzOOQO,59b,59bOOQU,5:Q,5:QOOQR1G.v1G.vO4pQ`O1G.vOOQU-E7d-E7dO4xQdO,59kOOQO,59k,59kO5SQdO'#DQO5^Q`O'#DQOOQO,5:d,5:dOOQU,5:R,5:ROOQR1G/U1G/UO5cQ`O1G/UOOQU-E7e-E7eO5kQgO'#DhO5xQcO1G/XOOQR1G/X1G/XOOQR,59q,59qO6TQgO,59qO6eQdO'#DiO6lQgO'#DiO7PQcO1G/[OOQR1G/[1G/[OOQR,59r,59rO#|QfO,59rOOQR1G/b1G/bO7_OWO1G/bO7dOaO1G/bOOQR,59y,59yOOQR,59{,59{OOQP1G/h1G/hO7lOaO1G/hO7tOaO1G/hO8POaO1G/hOOQP1G.s1G.sO8_QgO,5:POOQP,5:P,5:POOQP,5:V,5:VOOQP-E7i-E7iOOQO,59_,59_OOQO,59a,59aOOQO1G.}1G.}OOQO,59f,59fO8oQdO,59fOOQR7+$b7+$bP,XQ`O'#DfOOQO1G/V1G/VOOQO,59l,59lO8yQdO,59lOOQR7+$p7+$pP9TQ`O'#DgOOQR'#DT'#DTOOQR,5:S,5:SOOQR-E7f-E7fOOQR7+$s7+$sOOQR1G/]1G/]O9YQgO'#DYO9jQ`O'#DYOOQR,5:T,5:TO#|QfO'#DZO9oQcO'#DZOOQR-E7g-E7gOOQR7+$v7+$vOOQR1G/^1G/^OOQR7+$|7+$|O:QOWO7+$|OOQP7+%S7+%SO:VOaO7+%SO:_OaO7+%SOOQP1G/k1G/kOOQO1G/Q1G/QOOQO1G/W1G/WOOQR,59t,59tO:jQgO,59tOOQR,59u,59uO#|QfO,59uOOQR<<Hh<<HhOOQP<<Hn<<HnO:zOaO<<HnOOQR1G/`1G/`OOQR1G/a1G/aOOQPAN>YAN>Y",
    stateData: ";S~O!fOS!gOS^OS~OP_OQbORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!V[O!cTO~O`cO~P]OVkOWROXROYeOZfO[dOcPOmhOqQO~OboO~P!bOVtOWROXROYeOZfO[dOcPOmrOqQO~OpwO~P#WORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!cTO~OSvP!avP!bvP~P#|OWROXROYeOZfO[dOcPOqQO~OmzO~P%OOm!OOUzP!azP!bzP!dzP~P#|O^!SO!b!QO!f!TO!g!RO~ORSOTUOWROXROcPOqQO!PVO!cTO~OY!UOP!QXQ!QX!V!QX!`!QXS!QX!a!QX!b!QXU!QXm!QX!d!QX~P&aO[!WOP!SXQ!SX!V!SX!`!SXS!SX!a!SX!b!SXU!SXm!SX!d!SX~P&aO^!ZO!W![O!b!YO!f!]O!g!YO~OP!_O!V[OQaX!`aX~OPaXQaX!VaX!`aX~P#|OP!bOQ!cO!V[O~OP_O!V[O~P#|OWROXROY!fOcPOqQObfXmfXofXpfX~OWROXRO[!hOcPOqQObhXmhXohXphX~ObeXmlXoeX~ObkXokX~P%OOm!kO~Om!lObnPonP~P%OOb!pOo!oO~Ob!pO~P!bOm!sOosXpsX~OosXpsX~P%OOm!uOotPptP~P%OOo!xOp!yO~Op!yO~P#WOS!|O!a#OO!b#OO~OUyX!ayX!byX!dyX~P#|Om#QO~OU#SO!a#UO!b#UO!d#RO~Om#WOUzX!azX!bzX!dzX~O]#XO~O!b#XO!g#YO~O^#ZO!b#XO!g#YO~OP!RXQ!RX!V!RX!`!RXS!RX!a!RX!b!RXU!RXm!RX!d!RX~P&aOP!TXQ!TX!V!TX!`!TXS!TX!a!TX!b!TXU!TXm!TX!d!TX~P&aO!b#^O!g#^O~O^#_O!b#^O!f#`O!g#^O~O^#_O!W#aO!b#^O!g#^O~OPaaQaa!Vaa!`aa~P#|OP#cO!V[OQ!XX!`!XX~OP!XXQ!XX!V!XX!`!XX~P#|OP_O!V[OQ!_X!`!_X~P#|OWROXROcPOqQObgXmgXogXpgX~OWROXROcPOqQObiXmiXoiXpiX~Obkaoka~P%OObnXonX~P%OOm#kO~Ob#lOo!oO~Oosapsa~P%OOotXptX~P%OOm#pO~Oo!xOp#qO~OSwP!awP!bwP~P#|OS!|O!a#vO!b#vO~OUya!aya!bya!dya~P#|Om#xO~P%OOm#{OU}P!a}P!b}P!d}P~P#|OU#SO!a$OO!b$OO!d#RO~O]$QO~O!b$QO!g$RO~O!b$SO!g$SO~O^$TO!b$SO!g$SO~O^$TO!b$SO!f$UO!g$SO~OP!XaQ!Xa!V!Xa!`!Xa~P#|Obnaona~P%OOotapta~P%OOo!xO~OU|X!a|X!b|X!d|X~P#|Om$ZO~Om$]OU}X!a}X!b}X!d}X~O]$^O~O!b$_O!g$_O~O^$`O!b$_O!g$_O~OU|a!a|a!b|a!d|a~P#|O!b$cO!g$cO~O",
    goto: ",]!mPPPPPPPPPPPPPPPPP!nPP!v#v#|$`#|$c$f$j$nP%VPPP!v%Y%^%a%{&O%a&R&U&X&_&b%aP&e&{&e'O'RPP']'a'g'm's'y(XPPPPPPPP(_)e*X+c,VUaObcR#e!c!{ROPQSTUXY_bcdehknrtvz!O!U!W!_!b!c!f!h!k!l!s!u!|#Q#R#S#W#c#k#p#x#{$Z$]QmPR!qnqfPQThknrtv!k!l!s!u#R#k#pR!gdR!ieTlPnTjPnSiPnSqQvQ{TQ!mkQ!trQ!vtR#y#RR!nkTsQvR!wt!RWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]RySR#t!|R|TR|UQ!PUR#|#SR#z#RR#z#SyZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]R!VXR!XYa]O^abc!a!c!eT!da!eQnPR!rnQvQR!{vQ!}yR#u!}Q#T|R#}#TW^Obc!cS!^^!aT!aa!eQ!eaR#f!eW`Obc!cQxSS}U#SQ!`_Q#PzQ#V!OQ#b!_Q#d!bQ#s!|Q#w#QQ$P#WQ$V#cQ$Y#xQ$[#{Q$a$ZR$b$]xZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]Q!VXQ!XYQ#[!UR#]!W!QWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]pfPQThknrtv!k!l!s!u#R#k#pQ!gdQ!ieQ#g!fR#h!hSgPn^pQTkrtv#RQ!jhQ#i!kQ#j!lQ#n!sQ#o!uQ$W#kR$X#pQuQR!zv",
    nodeNames: "\u26A0 DirectiveEnd DocEnd - - ? ? ? Literal QuotedLiteral Anchor Alias Tag BlockLiteralContent Comment Stream BOM Document ] [ FlowSequence Item Tagged Anchored Anchored Tagged FlowMapping Pair Key : Pair , } { FlowMapping Pair Pair BlockSequence Item Item BlockMapping Pair Pair Key Pair Pair BlockLiteral BlockLiteralHeader Tagged Anchored Anchored Tagged Directive DirectiveName DirectiveContent Document",
    maxTerm: 74,
    context: indentation,
    nodeProps: [
      ["isolate", -3, 8, 9, 14, ""],
      ["openedBy", 18, "[", 32, "{"],
      ["closedBy", 19, "]", 33, "}"]
    ],
    propSources: [yamlHighlighting],
    skippedNodes: [0],
    repeatNodeCount: 6,
    tokenData: "-Y~RnOX#PXY$QYZ$]Z]#P]^$]^p#Ppq$Qqs#Pst$btu#Puv$yv|#P|}&e}![#P![!]'O!]!`#P!`!a'i!a!}#P!}#O*g#O#P#P#P#Q+Q#Q#o#P#o#p+k#p#q'i#q#r,U#r;'S#P;'S;=`#z<%l?HT#P?HT?HU,o?HUO#PQ#UU!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PQ#kTOY#PZs#Pt;'S#P;'S;=`#z<%lO#PQ#}P;=`<%l#P~$VQ!f~XY$Qpq$Q~$bO!g~~$gS^~OY$bZ;'S$b;'S;=`$s<%lO$b~$vP;=`<%l$bR%OX!WQOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR%rX!WQ!VPOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR&bP;=`<%l%kR&lUoP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'VUmP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'p[!PP!WQOY#PZp#Ppq#hq{#P{|(f|}#P}!O(f!O!R#P!R![)p![;'S#P;'S;=`#z<%lO#PR(mW!PP!WQOY#PZp#Ppq#hq!R#P!R![)V![;'S#P;'S;=`#z<%lO#PR)^U!PP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR)wY!PP!WQOY#PZp#Ppq#hq{#P{|)V|}#P}!O)V!O;'S#P;'S;=`#z<%lO#PR*nUcP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+XUbP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+rUqP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,]UpP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,vU`P!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#P",
    tokenizers: [newlines, blockMark, literals, blockLiteral, 0, 1],
    topRules: { "Stream": [0, 15] },
    tokenPrec: 0
  });

  // node_modules/.pnpm/@codemirror+lang-yaml@6.1.1_@codemirror+view@6.28.1/node_modules/@codemirror/lang-yaml/dist/index.js
  var parser2 = /* @__PURE__ */ LRParser.deserialize({
    version: 14,
    states: "!vOQOPOOO]OPO'#C_OhOPO'#C^OOOO'#Cc'#CcOpOPO'#CaQOOOOOO{OPOOOOOO'#Cb'#CbO!WOPO'#C`O!`OPO,58xOOOO-E6a-E6aOOOO-E6`-E6`OOOO'#C_'#C_OOOO1G.d1G.d",
    stateData: "!h~OXPOYROWTP~OWVXXRXYRX~OYVOXSP~OXROYROWTX~OXROYROWTP~OYVOXSX~OX[O~OXY~",
    goto: "vWPPX[beioRUOQQOR]XRXQTTOUQWQRZWSSOURYS",
    nodeNames: "\u26A0 Document Frontmatter DashLine FrontmatterContent Body",
    maxTerm: 10,
    skippedNodes: [0],
    repeatNodeCount: 2,
    tokenData: "$z~RXOYnYZ!^Z]n]^!^^}n}!O!i!O;'Sn;'S;=`!c<%lOn~qXOYnYZ!^Z]n]^!^^;'Sn;'S;=`!c<%l~n~On~~!^~!cOY~~!fP;=`<%ln~!lZOYnYZ!^Z]n]^!^^}n}!O#_!O;'Sn;'S;=`!c<%l~n~On~~!^~#bZOYnYZ!^Z]n]^!^^}n}!O$T!O;'Sn;'S;=`!c<%l~n~On~~!^~$WXOYnYZ$sZ]n]^$s^;'Sn;'S;=`!c<%l~n~On~~$s~$zOX~Y~",
    tokenizers: [0],
    topRules: { "Document": [0, 1] },
    tokenPrec: 67
  });
  var yamlLanguage = /* @__PURE__ */ LRLanguage.define({
    name: "yaml",
    parser: /* @__PURE__ */ parser.configure({
      props: [
        /* @__PURE__ */ indentNodeProp.add({
          Stream: (cx) => {
            for (let before = cx.node.resolve(cx.pos, -1); before && before.to >= cx.pos; before = before.parent) {
              if (before.name == "BlockLiteralContent" && before.from < before.to)
                return cx.baseIndentFor(before);
              if (before.name == "BlockLiteral")
                return cx.baseIndentFor(before) + cx.unit;
              if (before.name == "BlockSequence" || before.name == "BlockMapping")
                return cx.column(before.from, 1);
              if (before.name == "QuotedLiteral")
                return null;
              if (before.name == "Literal") {
                let col = cx.column(before.from, 1);
                if (col == cx.lineIndent(before.from, 1))
                  return col;
                if (before.to > cx.pos)
                  return null;
              }
            }
            return null;
          },
          FlowMapping: /* @__PURE__ */ delimitedIndent({ closing: "}" }),
          FlowSequence: /* @__PURE__ */ delimitedIndent({ closing: "]" })
        }),
        /* @__PURE__ */ foldNodeProp.add({
          "FlowMapping FlowSequence": foldInside,
          "BlockSequence Pair BlockLiteral": (node, state) => ({ from: state.doc.lineAt(node.from).to, to: node.to })
        })
      ]
    }),
    languageData: {
      commentTokens: { line: "#" },
      indentOnInput: /^\s*[\]\}]$/
    }
  });
  var frontmatterLanguage = /* @__PURE__ */ LRLanguage.define({
    name: "yaml-frontmatter",
    parser: /* @__PURE__ */ parser2.configure({
      props: [/* @__PURE__ */ styleTags({ DashLine: tags.meta })]
    })
  });
  function yamlFrontmatter(config) {
    let { language: language2, support } = config.content instanceof LanguageSupport ? config.content : { language: config.content, support: [] };
    return new LanguageSupport(frontmatterLanguage.configure({
      wrap: parseMixed((node) => {
        return node.name == "FrontmatterContent" ? { parser: yamlLanguage.parser } : node.name == "Body" ? { parser: language2.parser } : null;
      })
    }), support);
  }

  // node_modules/.pnpm/crelt@1.0.6/node_modules/crelt/index.js
  function crelt() {
    var elt = arguments[0];
    if (typeof elt == "string") elt = document.createElement(elt);
    var i4 = 1, next = arguments[1];
    if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
      for (var name2 in next) if (Object.prototype.hasOwnProperty.call(next, name2)) {
        var value = next[name2];
        if (typeof value == "string") elt.setAttribute(name2, value);
        else if (value != null) elt[name2] = value;
      }
      i4++;
    }
    for (; i4 < arguments.length; i4++) add(elt, arguments[i4]);
    return elt;
  }
  function add(elt, child) {
    if (typeof child == "string") {
      elt.appendChild(document.createTextNode(child));
    } else if (child == null) {
    } else if (child.nodeType != null) {
      elt.appendChild(child);
    } else if (Array.isArray(child)) {
      for (var i4 = 0; i4 < child.length; i4++) add(elt, child[i4]);
    } else {
      throw new RangeError("Unsupported child node: " + child);
    }
  }

  // node_modules/.pnpm/@codemirror+lint@6.8.0/node_modules/@codemirror/lint/dist/index.js
  var SelectedDiagnostic = class {
    constructor(from, to, diagnostic) {
      this.from = from;
      this.to = to;
      this.diagnostic = diagnostic;
    }
  };
  var LintState = class _LintState {
    constructor(diagnostics, panel, selected) {
      this.diagnostics = diagnostics;
      this.panel = panel;
      this.selected = selected;
    }
    static init(diagnostics, panel, state) {
      let markedDiagnostics = diagnostics;
      let diagnosticFilter = state.facet(lintConfig).markerFilter;
      if (diagnosticFilter)
        markedDiagnostics = diagnosticFilter(markedDiagnostics, state);
      let ranges = Decoration.set(markedDiagnostics.map((d3) => {
        return d3.from == d3.to || d3.from == d3.to - 1 && state.doc.lineAt(d3.from).to == d3.from ? Decoration.widget({
          widget: new DiagnosticWidget(d3),
          diagnostic: d3
        }).range(d3.from) : Decoration.mark({
          attributes: { class: "cm-lintRange cm-lintRange-" + d3.severity + (d3.markClass ? " " + d3.markClass : "") },
          diagnostic: d3,
          inclusive: true
        }).range(d3.from, d3.to);
      }), true);
      return new _LintState(ranges, panel, findDiagnostic(ranges));
    }
  };
  function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
    let found = null;
    diagnostics.between(after, 1e9, (from, to, { spec }) => {
      if (diagnostic && spec.diagnostic != diagnostic)
        return;
      found = new SelectedDiagnostic(from, to, spec.diagnostic);
      return false;
    });
    return found;
  }
  function hideTooltip(tr, tooltip) {
    let from = tooltip.pos, to = tooltip.end || from;
    let result = tr.state.facet(lintConfig).hideOn(tr, from, to);
    if (result != null)
      return result;
    let line = tr.startState.doc.lineAt(tooltip.pos);
    return !!(tr.effects.some((e4) => e4.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, Math.max(line.to, to)));
  }
  function maybeEnableLint(state, effects) {
    return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
  }
  function setDiagnostics(state, diagnostics) {
    return {
      effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
    };
  }
  var setDiagnosticsEffect = /* @__PURE__ */ StateEffect.define();
  var togglePanel = /* @__PURE__ */ StateEffect.define();
  var movePanelSelection = /* @__PURE__ */ StateEffect.define();
  var lintState = /* @__PURE__ */ StateField.define({
    create() {
      return new LintState(Decoration.none, null, null);
    },
    update(value, tr) {
      if (tr.docChanged && value.diagnostics.size) {
        let mapped = value.diagnostics.map(tr.changes), selected = null, panel = value.panel;
        if (value.selected) {
          let selPos = tr.changes.mapPos(value.selected.from, 1);
          selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
        }
        if (!mapped.size && panel && tr.state.facet(lintConfig).autoPanel)
          panel = null;
        value = new LintState(mapped, panel, selected);
      }
      for (let effect of tr.effects) {
        if (effect.is(setDiagnosticsEffect)) {
          let panel = !tr.state.facet(lintConfig).autoPanel ? value.panel : effect.value.length ? LintPanel.open : null;
          value = LintState.init(effect.value, panel, tr.state);
        } else if (effect.is(togglePanel)) {
          value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
        } else if (effect.is(movePanelSelection)) {
          value = new LintState(value.diagnostics, value.panel, effect.value);
        }
      }
      return value;
    },
    provide: (f3) => [
      showPanel.from(f3, (val) => val.panel),
      EditorView.decorations.from(f3, (s4) => s4.diagnostics)
    ]
  });
  var activeMark = /* @__PURE__ */ Decoration.mark({ class: "cm-lintRange cm-lintRange-active", inclusive: true });
  function lintTooltip(view, pos, side) {
    let { diagnostics } = view.state.field(lintState);
    let found = [], stackStart = 2e8, stackEnd = 0;
    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
      if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
        found.push(spec.diagnostic);
        stackStart = Math.min(from, stackStart);
        stackEnd = Math.max(to, stackEnd);
      }
    });
    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
    if (diagnosticFilter)
      found = diagnosticFilter(found, view.state);
    if (!found.length)
      return null;
    return {
      pos: stackStart,
      end: stackEnd,
      above: view.state.doc.lineAt(stackStart).to < stackEnd,
      create() {
        return { dom: diagnosticsTooltip(view, found) };
      }
    };
  }
  function diagnosticsTooltip(view, diagnostics) {
    return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d3) => renderDiagnostic(view, d3, false)));
  }
  var closeLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
      return false;
    view.dispatch({ effects: togglePanel.of(false) });
    return true;
  };
  var lintPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.timeout = -1;
      this.set = true;
      let { delay } = view.state.facet(lintConfig);
      this.lintTime = Date.now() + delay;
      this.run = this.run.bind(this);
      this.timeout = setTimeout(this.run, delay);
    }
    run() {
      clearTimeout(this.timeout);
      let now = Date.now();
      if (now < this.lintTime - 10) {
        this.timeout = setTimeout(this.run, this.lintTime - now);
      } else {
        this.set = false;
        let { state } = this.view, { sources } = state.facet(lintConfig);
        if (sources.length)
          Promise.all(sources.map((source) => Promise.resolve(source(this.view)))).then((annotations) => {
            let all = annotations.reduce((a4, b4) => a4.concat(b4));
            if (this.view.state.doc == state.doc)
              this.view.dispatch(setDiagnostics(this.view.state, all));
          }, (error) => {
            logException(this.view.state, error);
          });
      }
    }
    update(update) {
      let config = update.state.facet(lintConfig);
      if (update.docChanged || config != update.startState.facet(lintConfig) || config.needsRefresh && config.needsRefresh(update)) {
        this.lintTime = Date.now() + config.delay;
        if (!this.set) {
          this.set = true;
          this.timeout = setTimeout(this.run, config.delay);
        }
      }
    }
    force() {
      if (this.set) {
        this.lintTime = Date.now();
        this.run();
      }
    }
    destroy() {
      clearTimeout(this.timeout);
    }
  });
  var lintConfig = /* @__PURE__ */ Facet.define({
    combine(input) {
      return Object.assign({ sources: input.map((i4) => i4.source).filter((x2) => x2 != null) }, combineConfig(input.map((i4) => i4.config), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null,
        needsRefresh: null,
        hideOn: () => null
      }, {
        needsRefresh: (a4, b4) => !a4 ? b4 : !b4 ? a4 : (u4) => a4(u4) || b4(u4)
      }));
    }
  });
  function linter(source, config = {}) {
    return [
      lintConfig.of({ source, config }),
      lintPlugin,
      lintExtensions
    ];
  }
  function assignKeys(actions) {
    let assigned = [];
    if (actions)
      actions: for (let { name: name2 } of actions) {
        for (let i4 = 0; i4 < name2.length; i4++) {
          let ch = name2[i4];
          if (/[a-zA-Z]/.test(ch) && !assigned.some((c4) => c4.toLowerCase() == ch.toLowerCase())) {
            assigned.push(ch);
            continue actions;
          }
        }
        assigned.push("");
      }
    return assigned;
  }
  function renderDiagnostic(view, diagnostic, inPanel) {
    var _a2;
    let keys = inPanel ? assignKeys(diagnostic.actions) : [];
    return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action, i4) => {
      let fired = false, click = (e4) => {
        e4.preventDefault();
        if (fired)
          return;
        fired = true;
        let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
        if (found)
          action.apply(view, found.from, found.to);
      };
      let { name: name2 } = action, keyIndex = keys[i4] ? name2.indexOf(keys[i4]) : -1;
      let nameElt = keyIndex < 0 ? name2 : [
        name2.slice(0, keyIndex),
        crelt("u", name2.slice(keyIndex, keyIndex + 1)),
        name2.slice(keyIndex + 1)
      ];
      return crelt("button", {
        type: "button",
        class: "cm-diagnosticAction",
        onclick: click,
        onmousedown: click,
        "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys[i4]})"`}.`
      }, nameElt);
    }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
  }
  var DiagnosticWidget = class extends WidgetType {
    constructor(diagnostic) {
      super();
      this.diagnostic = diagnostic;
    }
    eq(other) {
      return other.diagnostic == this.diagnostic;
    }
    toDOM() {
      return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
    }
  };
  var PanelItem = class {
    constructor(view, diagnostic) {
      this.diagnostic = diagnostic;
      this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
      this.dom = renderDiagnostic(view, diagnostic, true);
      this.dom.id = this.id;
      this.dom.setAttribute("role", "option");
    }
  };
  var LintPanel = class _LintPanel {
    constructor(view) {
      this.view = view;
      this.items = [];
      let onkeydown = (event) => {
        if (event.keyCode == 27) {
          closeLintPanel(this.view);
          this.view.focus();
        } else if (event.keyCode == 38 || event.keyCode == 33) {
          this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
        } else if (event.keyCode == 40 || event.keyCode == 34) {
          this.moveSelection((this.selectedIndex + 1) % this.items.length);
        } else if (event.keyCode == 36) {
          this.moveSelection(0);
        } else if (event.keyCode == 35) {
          this.moveSelection(this.items.length - 1);
        } else if (event.keyCode == 13) {
          this.view.focus();
        } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
          let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);
          for (let i4 = 0; i4 < keys.length; i4++)
            if (keys[i4].toUpperCase().charCodeAt(0) == event.keyCode) {
              let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
              if (found)
                diagnostic.actions[i4].apply(view, found.from, found.to);
            }
        } else {
          return;
        }
        event.preventDefault();
      };
      let onclick = (event) => {
        for (let i4 = 0; i4 < this.items.length; i4++) {
          if (this.items[i4].dom.contains(event.target))
            this.moveSelection(i4);
        }
      };
      this.list = crelt("ul", {
        tabIndex: 0,
        role: "listbox",
        "aria-label": this.view.state.phrase("Diagnostics"),
        onkeydown,
        onclick
      });
      this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
        type: "button",
        name: "close",
        "aria-label": this.view.state.phrase("close"),
        onclick: () => closeLintPanel(this.view)
      }, "\xD7"));
      this.update();
    }
    get selectedIndex() {
      let selected = this.view.state.field(lintState).selected;
      if (!selected)
        return -1;
      for (let i4 = 0; i4 < this.items.length; i4++)
        if (this.items[i4].diagnostic == selected.diagnostic)
          return i4;
      return -1;
    }
    update() {
      let { diagnostics, selected } = this.view.state.field(lintState);
      let i4 = 0, needsSync = false, newSelectedItem = null;
      diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
        let found = -1, item;
        for (let j2 = i4; j2 < this.items.length; j2++)
          if (this.items[j2].diagnostic == spec.diagnostic) {
            found = j2;
            break;
          }
        if (found < 0) {
          item = new PanelItem(this.view, spec.diagnostic);
          this.items.splice(i4, 0, item);
          needsSync = true;
        } else {
          item = this.items[found];
          if (found > i4) {
            this.items.splice(i4, found - i4);
            needsSync = true;
          }
        }
        if (selected && item.diagnostic == selected.diagnostic) {
          if (!item.dom.hasAttribute("aria-selected")) {
            item.dom.setAttribute("aria-selected", "true");
            newSelectedItem = item;
          }
        } else if (item.dom.hasAttribute("aria-selected")) {
          item.dom.removeAttribute("aria-selected");
        }
        i4++;
      });
      while (i4 < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
        needsSync = true;
        this.items.pop();
      }
      if (this.items.length == 0) {
        this.items.push(new PanelItem(this.view, {
          from: -1,
          to: -1,
          severity: "info",
          message: this.view.state.phrase("No diagnostics")
        }));
        needsSync = true;
      }
      if (newSelectedItem) {
        this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
        this.view.requestMeasure({
          key: this,
          read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
          write: ({ sel, panel }) => {
            let scaleY = panel.height / this.list.offsetHeight;
            if (sel.top < panel.top)
              this.list.scrollTop -= (panel.top - sel.top) / scaleY;
            else if (sel.bottom > panel.bottom)
              this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
          }
        });
      } else if (this.selectedIndex < 0) {
        this.list.removeAttribute("aria-activedescendant");
      }
      if (needsSync)
        this.sync();
    }
    sync() {
      let domPos = this.list.firstChild;
      function rm2() {
        let prev = domPos;
        domPos = prev.nextSibling;
        prev.remove();
      }
      for (let item of this.items) {
        if (item.dom.parentNode == this.list) {
          while (domPos != item.dom)
            rm2();
          domPos = item.dom.nextSibling;
        } else {
          this.list.insertBefore(item.dom, domPos);
        }
      }
      while (domPos)
        rm2();
    }
    moveSelection(selectedIndex) {
      if (this.selectedIndex < 0)
        return;
      let field = this.view.state.field(lintState);
      let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
      if (!selection)
        return;
      this.view.dispatch({
        selection: { anchor: selection.from, head: selection.to },
        scrollIntoView: true,
        effects: movePanelSelection.of(selection)
      });
    }
    static open(view) {
      return new _LintPanel(view);
    }
  };
  function svg(content2, attrs = `viewBox="0 0 40 40"`) {
    return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
  }
  function underline(color) {
    return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
  }
  var baseTheme2 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-diagnostic": {
      padding: "3px 6px 3px 8px",
      marginLeft: "-1px",
      display: "block",
      whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
    ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
    ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
    ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
    ".cm-diagnosticAction": {
      font: "inherit",
      border: "none",
      padding: "2px 4px",
      backgroundColor: "#444",
      color: "white",
      borderRadius: "3px",
      marginLeft: "8px",
      cursor: "pointer"
    },
    ".cm-diagnosticSource": {
      fontSize: "70%",
      opacity: 0.7
    },
    ".cm-lintRange": {
      backgroundPosition: "left bottom",
      backgroundRepeat: "repeat-x",
      paddingBottom: "0.7px"
    },
    ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ underline("#d11") },
    ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ underline("orange") },
    ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ underline("#999") },
    ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ underline("#66d") },
    ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
    ".cm-tooltip-lint": {
      padding: 0,
      margin: 0
    },
    ".cm-lintPoint": {
      position: "relative",
      "&:after": {
        content: '""',
        position: "absolute",
        bottom: 0,
        left: "-2px",
        borderLeft: "3px solid transparent",
        borderRight: "3px solid transparent",
        borderBottom: "4px solid #d11"
      }
    },
    ".cm-lintPoint-warning": {
      "&:after": { borderBottomColor: "orange" }
    },
    ".cm-lintPoint-info": {
      "&:after": { borderBottomColor: "#999" }
    },
    ".cm-lintPoint-hint": {
      "&:after": { borderBottomColor: "#66d" }
    },
    ".cm-panel.cm-panel-lint": {
      position: "relative",
      "& ul": {
        maxHeight: "100px",
        overflowY: "auto",
        "& [aria-selected]": {
          backgroundColor: "#ddd",
          "& u": { textDecoration: "underline" }
        },
        "&:focus [aria-selected]": {
          background_fallback: "#bdf",
          backgroundColor: "Highlight",
          color_fallback: "white",
          color: "HighlightText"
        },
        "& u": { textDecoration: "none" },
        padding: 0,
        margin: 0
      },
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "2px",
        background: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      }
    }
  });
  function severityWeight(sev) {
    return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
  }
  var LintGutterMarker = class extends GutterMarker {
    constructor(diagnostics) {
      super();
      this.diagnostics = diagnostics;
      this.severity = diagnostics.reduce((max, d3) => severityWeight(max) < severityWeight(d3.severity) ? d3.severity : max, "hint");
    }
    toDOM(view) {
      let elt = document.createElement("div");
      elt.className = "cm-lint-marker cm-lint-marker-" + this.severity;
      let diagnostics = this.diagnostics;
      let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;
      if (diagnosticsFilter)
        diagnostics = diagnosticsFilter(diagnostics, view.state);
      if (diagnostics.length)
        elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics);
      return elt;
    }
  };
  function trackHoverOn(view, marker) {
    let mousemove = (event) => {
      let rect = marker.getBoundingClientRect();
      if (event.clientX > rect.left - 10 && event.clientX < rect.right + 10 && event.clientY > rect.top - 10 && event.clientY < rect.bottom + 10)
        return;
      for (let target = event.target; target; target = target.parentNode) {
        if (target.nodeType == 1 && target.classList.contains("cm-tooltip-lint"))
          return;
      }
      window.removeEventListener("mousemove", mousemove);
      if (view.state.field(lintGutterTooltip))
        view.dispatch({ effects: setLintGutterTooltip.of(null) });
    };
    window.addEventListener("mousemove", mousemove);
  }
  function gutterMarkerMouseOver(view, marker, diagnostics) {
    function hovered() {
      let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);
      const linePos = view.coordsAtPos(line.from);
      if (linePos) {
        view.dispatch({ effects: setLintGutterTooltip.of({
          pos: line.from,
          above: false,
          create() {
            return {
              dom: diagnosticsTooltip(view, diagnostics),
              getCoords: () => marker.getBoundingClientRect()
            };
          }
        }) });
      }
      marker.onmouseout = marker.onmousemove = null;
      trackHoverOn(view, marker);
    }
    let { hoverTime } = view.state.facet(lintGutterConfig);
    let hoverTimeout = setTimeout(hovered, hoverTime);
    marker.onmouseout = () => {
      clearTimeout(hoverTimeout);
      marker.onmouseout = marker.onmousemove = null;
    };
    marker.onmousemove = () => {
      clearTimeout(hoverTimeout);
      hoverTimeout = setTimeout(hovered, hoverTime);
    };
  }
  function markersForDiagnostics(doc2, diagnostics) {
    let byLine = /* @__PURE__ */ Object.create(null);
    for (let diagnostic of diagnostics) {
      let line = doc2.lineAt(diagnostic.from);
      (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);
    }
    let markers = [];
    for (let line in byLine) {
      markers.push(new LintGutterMarker(byLine[line]).range(+line));
    }
    return RangeSet.of(markers, true);
  }
  var lintGutterExtension = /* @__PURE__ */ gutter({
    class: "cm-gutter-lint",
    markers: (view) => view.state.field(lintGutterMarkers)
  });
  var lintGutterMarkers = /* @__PURE__ */ StateField.define({
    create() {
      return RangeSet.empty;
    },
    update(markers, tr) {
      markers = markers.map(tr.changes);
      let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;
      for (let effect of tr.effects) {
        if (effect.is(setDiagnosticsEffect)) {
          let diagnostics = effect.value;
          if (diagnosticFilter)
            diagnostics = diagnosticFilter(diagnostics || [], tr.state);
          markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));
        }
      }
      return markers;
    }
  });
  var setLintGutterTooltip = /* @__PURE__ */ StateEffect.define();
  var lintGutterTooltip = /* @__PURE__ */ StateField.define({
    create() {
      return null;
    },
    update(tooltip, tr) {
      if (tooltip && tr.docChanged)
        tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), { pos: tr.changes.mapPos(tooltip.pos) });
      return tr.effects.reduce((t5, e4) => e4.is(setLintGutterTooltip) ? e4.value : t5, tooltip);
    },
    provide: (field) => showTooltip.from(field)
  });
  var lintGutterTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-gutter-lint": {
      width: "1.4em",
      "& .cm-gutterElement": {
        padding: ".2em"
      }
    },
    ".cm-lint-marker": {
      width: "1em",
      height: "1em"
    },
    ".cm-lint-marker-info": {
      content: /* @__PURE__ */ svg(`<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>`)
    },
    ".cm-lint-marker-warning": {
      content: /* @__PURE__ */ svg(`<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>`)
    },
    ".cm-lint-marker-error": {
      content: /* @__PURE__ */ svg(`<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>`)
    }
  });
  var lintExtensions = [
    lintState,
    /* @__PURE__ */ EditorView.decorations.compute([lintState], (state) => {
      let { selected, panel } = state.field(lintState);
      return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
        activeMark.range(selected.from, selected.to)
      ]);
    }),
    /* @__PURE__ */ hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
    baseTheme2
  ];
  var lintGutterConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        hoverTime: 300,
        markerFilter: null,
        tooltipFilter: null
      });
    }
  });
  function lintGutter(config = {}) {
    return [lintGutterConfig.of(config), lintGutterMarkers, lintGutterExtension, lintGutterTheme, lintGutterTooltip];
  }

  // src/scripts/ruleset/parser.js
  var spec_Identifier = { __proto__: null, HTTP: 67, HTTp: 67, HTtP: 67, HTtp: 67, HtTP: 67, HtTp: 67, HttP: 67, Http: 67, hTTP: 67, hTTp: 67, hTtP: 67, hTtp: 67, htTP: 67, htTp: 67, httP: 67, http: 67, HTTPS: 67, HTTpS: 67, HTtPS: 67, HTtpS: 67, HtTPS: 67, HtTpS: 67, HttPS: 67, HttpS: 67, hTTPS: 67, hTTpS: 67, hTtPS: 67, hTtpS: 67, htTPS: 67, htTpS: 67, httPS: 67, httpS: 67, HTTPs: 67, HTTps: 67, HTtPs: 67, HTtps: 67, HtTPs: 67, HtTps: 67, HttPs: 67, Https: 67, hTTPs: 67, hTTps: 67, hTtPs: 67, hTtps: 67, htTPs: 67, htTps: 67, httPs: 67, https: 67 };
  var parser3 = LRParser.deserialize({
    version: 14,
    states: "&fQwQPOOOOQO'#C`'#C`OOQO'#Cb'#CbOOQO'#Cd'#CdO!OOPO'#CdO!TQQO'#CiOOQO'#Ci'#CiO!`QPO'#CoO!`QPO'#CqO!nQPO'#C_OOQO'#DR'#DRO!|QPO'#C_O`QPO'#C_O#XQPO'#CwQ#cQPOOQ#cQPOOO#hOSO,59OO#mQPO,59TOOQO,59T,59TO#rQPO,59TO#wQPO,59ZOOQO,59],59]O!`QPO,59_O!`QPO,59aO$SQPO'#CfOOQO,58y,58yO$XQPO,58yO$gQPO,58yOOQO,59c,59cOOQO-E6u-E6uO$rOSO1G.jO$wQQO1G.oOOQO1G.o1G.oOOQO1G.u1G.uOOQO1G.y1G.yO%]QPO1G.{O!`QPO,59QOOQO1G.e1G.eOOQO7+$U7+$UOOQO7+$Z7+$ZO%nQPO1G.lOOQO7+$W7+$W",
    stateData: "&O~OnOSPOS~OTPOVQOXTO[VObUOfWOoROpSOqSO~Ov]O~PYOr`O~O^aOacObbO~OXTO[VObUOfWO~OhfOjgOlRXvRX~OZhOlRXvRX~OlkXvkX~PYOv]O~OsnO~O_oO~ObpO~OdqOhfOjgO~O[tO~OhfOjgOlRavRa~OZhOlRavRa~OtvO~O`wOh]ij]il]iv]id]i~OhfOjiiliiviidii~OdyOhfOjgO~OVZTZ~",
    goto: "#XvPPPw}P}P!RP!YPP!`PPPPP!`P!`P!`P!`P!jPPPPPPPPP!qQ_ORl]T[O]SZO]Rk[QiZRukaYOVW[]fgtS^O_Rm^SXO]QdVQeWQj[QrfQsgRxt",
    nodeNames: "\u26A0 Comment Ruleset Rule NegateSpecifier @ HighlightSpecifier AtInteger MatchPattern Identifier IfSpecifier @if ( MatchExpression StringMatchOperator String CaseSensitivity RegExpMatchOperator RegExp ParenthesizedExpression ) NegateExpression ! AndExpression & OrExpression |",
    maxTerm: 38,
    nodeProps: [
      ["group", -5, 13, 19, 21, 23, 25, "Expression"]
    ],
    skippedNodes: [0, 1],
    repeatNodeCount: 1,
    tokenData: ">e~RlXY!yYZ#X]^!ypq!yqr#^rs#cst$jtu%Rvw%xwx%}xy'Pyz'Uz{'Z!P!Q(i!Q!['t![!]:_!^!_:p!_!`;}!b!c<[!c!k=S!k!l=m!l!}=S#Q#R>Y#R#S%g#T#]=S#]#^=m#^#o=S#p#q>`~#ORn~XY!y]^!ypq!y~#^Ov~~#cOf~~#fWOY#cZr#crs$Os#O#c#O#P$T#P;'S#c;'S;=`$d<%lO#c~$TO_~~$WSOY#cZ;'S#c;'S;=`$d<%lO#c~$gP;=`<%l#c~$oSP~OY$jZ;'S$j;'S;=`${<%lO$j~%OP;=`<%l$jR%US!_!`%b!c!}%g#R#S%g#T#o%gQ%gO^QP%lSXP!Q![%g!c!}%g#R#S%g#T#o%g~%}Oh~~&QWOY%}Zw%}wx$Ox#O%}#O#P&j#P;'S%};'S;=`&y<%lO%}~&mSOY%}Z;'S%};'S;=`&y<%lO%}~&|P;=`<%l%}~'UO[~~'ZOd~V'bQpPsS!O!P'h!_!`%bS'kR!Q!['t!c!}'t#T#o'tS'yTsS}!O(Y!O!P'h!Q!['t!c!}'t#T#o'tS(]S}!O(Y!Q!['t!c!}'t#T#o'tV(nutSOY+RZq+Rqr-Urt+Rtu-Uuv/nvw-Uwx-Uxy-Uyz-Uz{-U{|-U|}-U}!O-U!O!P-U!P!Q3z!Q![-U![!]-U!]!^-U!^!_+R!_!`-U!`!a+R!a!b-U!b!c-U!c!}-U!}#O6W#O#P,o#P#Q-U#Q#R+R#R#S-U#S#T+R#T#o-U#o#r+R#r#s-U#s;'S+R;'S;=`-O<%lO+RR+UXOY+RZ!P+R!P!Q+q!Q!}+R!}#O,S#O#P,o#P;'S+R;'S;=`-O<%lO+RR+vSbR#]#^+q#a#b+q#g#h+q#i#j+qR,VUOY,SZ#O,S#P#Q+R#Q;'S,S;'S;=`,i<%lO,SR,lP;=`<%l,SR,rSOY+RZ;'S+R;'S;=`-O<%lO+RR-RP;=`<%l+RV-ZutSOY+RZq+Rqr-Urt+Rtu-Uuv/nvw-Uwx-Uxy-Uyz-Uz{-U{|-U|}-U}!O-U!O!P-U!P!Q1l!Q![-U![!]-U!]!^-U!^!_+R!_!`-U!`!a+R!a!b-U!b!c-U!c!}-U!}#O6W#O#P,o#P#Q-U#Q#R+R#R#S-U#S#T+R#T#o-U#o#r+R#r#s-U#s;'S+R;'S;=`-O<%lO+RV/q^OY+RZ!P+R!P!Q+q!Q![0m![!c+R!c!i0m!i!}+R!}#O,S#O#P,o#P#T+R#T#Z0m#Z;'S+R;'S;=`-O<%lO+RV0p^OY+RZ!P+R!P!Q+q!Q![-U![!c+R!c!i-U!i!}+R!}#O,S#O#P,o#P#T+R#T#Z-U#Z;'S+R;'S;=`-O<%lO+RV1sqbRtSqr3ztu3zuv5nvw3zwx3zxy3zyz3zz{3z{|3z|}3z}!O3z!O!P3z!P!Q3z!Q![3z![!]3z!]!^3z!_!`3z!a!b3z!b!c3z!c!}3z!}#O3z#P#Q3z#R#S3z#T#]3z#]#^1l#^#a3z#a#b1l#b#g3z#g#h1l#h#i3z#i#j1l#j#o3z#r#s3zS4PitSqr3ztu3zuv5nvw3zwx3zxy3zyz3zz{3z{|3z|}3z}!O3z!O!P3z!P!Q3z!Q![3z![!]3z!]!^3z!_!`3z!a!b3z!b!c3z!c!}3z!}#O3z#P#Q3z#R#S3z#T#o3z#r#s3zS5qR!Q![5z!c!i5z#T#Z5zS5}R!Q![3z!c!i3z#T#Z3zV6]ttSOY,SZq,Sqr6Wrt,Stu6Wuv8mvw6Wwx6Wxy6Wyz6Wz{6W{|6W|}6W}!O6W!O!P6W!P!Q6W!Q![6W![!]6W!]!^6W!^!_,S!_!`6W!`!a,S!a!b6W!b!c6W!c!}6W!}#O6W#P#Q-U#Q#R,S#R#S6W#S#T,S#T#o6W#o#r,S#r#s6W#s;'S,S;'S;=`,i<%lO,SV8p[OY,SZ!Q,S!Q![9f![!c,S!c!i9f!i#O,S#P#Q+R#Q#T,S#T#Z9f#Z;'S,S;'S;=`,i<%lO,SV9i[OY,SZ!Q,S!Q![6W![!c,S!c!i6W!i#O,S#P#Q+R#Q#T,S#T#Z6W#Z;'S,S;'S;=`,i<%lO,S~:bP!P!Q:e~:hP!P!Q:k~:pOr~~:sP#T#U:v~:yP#`#a:|~;PP#`#a;S~;VP#R#S;Y~;]P#i#j;`~;cP#f#g;f~;iP#`#a;l~;oP#g#h;r~;uP!`!a;x~;}Oo~~<SP^Q#r#s<V~<[Oa~~<aRT~!Q!R<j!R![<o#]#^<w~<oOV~~<tPV~!Q![<o~<zP#Y#Z<}~=SOZ~T=ZUXPsS}!O(Y!O!P'h!Q![=S!c!}=S#R#S%g#T#o=SV=vU`QXPsS}!O(Y!O!P'h!Q![=S!c!}=S#R#S%g#T#o=SQ>]P!_!`%b~>eOj~",
    tokenizers: [0, 1, 2],
    topRules: { "Ruleset": [0, 2] },
    specialized: [{ term: 9, get: (value) => spec_Identifier[value] || -1 }],
    tokenPrec: 225
  });

  // src/scripts/ruleset/utils.ts
  function parseString(string2) {
    return string2.slice(1, -1).replaceAll(
      /\\(?:0[0-9]?|u(?:[0-9A-Fa-f]{4}|\{(?:10[0-9A-Fa-f]{4}|0[0-9A-Fa-f]{5}|[0-9A-Fa-f]{1,5})\})?|x(?:[0-9A-Fa-f]{2})?|.)/g,
      (s4) => {
        const c4 = s4[1];
        if (c4 === "0") {
          if (s4.length > 2) {
            throw new SyntaxError("Deprecated octal escape sequence");
          }
          return "\0";
        }
        if (c4 === "u") {
          if (s4.length === 2) {
            throw new SyntaxError("Invalid Unicode escape sequence");
          }
          if (s4[2] === "{") {
            return String.fromCodePoint(Number.parseInt(s4.slice(3, -1), 16));
          }
          return String.fromCodePoint(Number.parseInt(s4.slice(2), 16));
        }
        if (c4 === "x") {
          if (s4.length === 2) {
            throw new SyntaxError("Invalid hexadecimal escape sequence");
          }
          return String.fromCodePoint(Number.parseInt(s4.slice(2), 16));
        }
        return { b: "\b", f: "\f", n: "\n", r: "\r", t: "	", v: "\v" }[c4] ?? c4;
      }
    );
  }
  function parseRegExp(regExp) {
    const patternEnd = regExp.lastIndexOf("/");
    const pattern = regExp.slice(1, patternEnd);
    const flags = regExp.slice(patternEnd + 1);
    new RegExp(pattern, flags);
    return { pattern, flags };
  }

  // src/scripts/ruleset/lang.ts
  var rulesetLanguage = LRLanguage.define({
    name: "ruleset",
    parser: parser3.configure({
      props: [
        styleTags({
          Comment: tags.lineComment,
          "@ AtInteger @if": tags.modifier,
          Identifier: tags.variableName,
          "StringMatchOperator CaseSensitivity RegExpMatchOperator": tags.compareOperator,
          String: tags.string,
          RegExp: tags.regexp,
          "( )": tags.paren,
          '"!" & |': tags.logicOperator
        })
      ]
    }),
    languageData: {
      commentTokens: { line: "#" }
    }
  });
  function getMessage(error) {
    if (error instanceof Error) {
      return error.message;
    }
    return "Unknown error";
  }
  var rulesetLinter = linter((view) => {
    const diagnostics = [];
    syntaxTree(view.state).cursor().iterate((node) => {
      const pushError = (message) => {
        diagnostics.push({
          from: node.from,
          to: node.to,
          severity: "error",
          message
        });
      };
      if (node.type.isError) {
        pushError("Syntax error");
      } else if (node.name === "String") {
        try {
          parseString(view.state.sliceDoc(node.from, node.to));
        } catch (error) {
          pushError(getMessage(error));
        }
      } else if (node.name === "RegExp") {
        try {
          parseRegExp(view.state.sliceDoc(node.from, node.to));
        } catch (error) {
          pushError(getMessage(error));
        }
      }
    });
    return diagnostics;
  });
  function ruleset() {
    return yamlFrontmatter({
      content: new LanguageSupport(rulesetLanguage, rulesetLinter)
    });
  }

  // src/scripts/ruleset/ruleset.ts
  var regExpSymbol = Symbol("RegExp");

  // src/scripts/utilities.ts
  var AltURL = class {
    scheme;
    host;
    path;
    constructor(url) {
      const u4 = new URL(url);
      this.scheme = u4.protocol.slice(0, -1);
      this.host = u4.hostname;
      this.path = `${u4.pathname}${u4.search}`;
    }
    toString() {
      return `${this.scheme}://${this.host}${this.path}`;
    }
  };
  var HTTPError = class extends Error {
    constructor(status, statusText) {
      super(`${status}${statusText ? " " : ""}${statusText}`);
      this.status = status;
      this.statusText = statusText;
      this.name = "HTTPError";
    }
  };
  var UnexpectedResponse = class extends Error {
    constructor(response) {
      super(JSON.stringify(response));
      this.response = response;
      this.name = "UnexpectedResponse";
    }
  };
  function isErrorResult(result) {
    return result.type === "error";
  }
  function stringKeys(record) {
    return Object.keys(record);
  }
  function stringEntries(record) {
    return Object.entries(record);
  }
  function numberKeys(record) {
    return Object.keys(record).map(Number);
  }
  function numberEntries(record) {
    return Object.entries(record).map(([key, value]) => [Number(key), value]);
  }
  function lines(s4) {
    return s4 ? s4.split("\n") : [];
  }
  function downloadTextFile(filename, mimeType, content2) {
    const a4 = document.createElement("a");
    a4.href = `data:${mimeType},${encodeURIComponent(content2)}`;
    a4.download = filename;
    a4.click();
  }
  function uploadTextFile(mimeType) {
    return new Promise((resolve) => {
      const fileInput = document.createElement("input");
      fileInput.accept = mimeType;
      fileInput.type = "file";
      fileInput.addEventListener("input", () => {
        const file = fileInput.files?.[0];
        if (!file) {
          resolve(null);
          return;
        }
        const fileReader = new FileReader();
        fileReader.addEventListener("load", () => {
          resolve(fileReader.result);
        });
        fileReader.addEventListener("error", () => {
          resolve(null);
        });
        fileReader.readAsText(file);
      });
      fileInput.click();
    });
  }
  function svgToDataURL(svg2) {
    return `data:image/svg+xml,${encodeURIComponent(svg2)}`;
  }
  function parseJSON(text) {
    try {
      return JSON.parse(text);
    } catch {
      return void 0;
    }
  }

  // src/scripts/options/about-section.tsx
  var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
  var AboutSection = () => {
    const version = (0, import_react13.useMemo)(() => browser.runtime.getManifest().version, []);
    const thirdPartyNoticesURL = (0, import_react13.useMemo)(
      () => browser.runtime.getURL("third-party-notices.txt"),
      []
    );
    const nameClassName = useClassName(
      () => ({
        fontSize: "1.5em"
      }),
      []
    );
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(Section, { "aria-labelledby": "aboutSectionTitle", id: "about", children: [
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(SectionHeader, { children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(SectionTitle, { id: "aboutSectionTitle", children: translate("options_aboutTitle") }) }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(SectionBody, { children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(SectionItem, { children: /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(Row, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Indent, { depth: 1.5, children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Icon, { iconSize: "36px", url: svgToDataURL(icon_default) }) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(LabelWrapper, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Label, { className: nameClassName, children: translate("extensionName") }),
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(SubLabel, { children: `${translate(
            "options_aboutVersion"
          )}: ${version}` }),
          /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(SubLabel, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Link, { href: getWebsiteURL("/docs"), children: translate("options_aboutDocumentation") }),
            " / ",
            /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Link, { href: "https://github.com/iorate/ublacklist/releases", children: translate("options_aboutReleaseNotes") }),
            " / ",
            /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Link, { href: getWebsiteURL("/privacy-policy"), children: translate("options_aboutPrivacyPolicy") }),
            " / ",
            /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Link, { href: thirdPartyNoticesURL, children: translate("options_aboutThirdPartyNotices") })
          ] })
        ] }) })
      ] }) }) })
    ] });
  };

  // node_modules/.pnpm/@mdi+svg@7.4.47/node_modules/@mdi/svg/svg/delete.svg
  var delete_default = '<svg xmlns="http://www.w3.org/2000/svg" id="mdi-delete" viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" /></svg>';

  // node_modules/.pnpm/@mdi+svg@7.4.47/node_modules/@mdi/svg/svg/plus.svg
  var plus_default = '<svg xmlns="http://www.w3.org/2000/svg" id="mdi-plus" viewBox="0 0 24 24"><path d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" /></svg>';

  // src/scripts/options/appearance-section.tsx
  var import_react20 = __toESM(require_react(), 1);

  // node_modules/.pnpm/colord@2.9.3/node_modules/colord/index.mjs
  var r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
  var t3 = function(r3) {
    return "string" == typeof r3 ? r3.length > 0 : "number" == typeof r3;
  };
  var n2 = function(r3, t5, n4) {
    return void 0 === t5 && (t5 = 0), void 0 === n4 && (n4 = Math.pow(10, t5)), Math.round(n4 * r3) / n4 + 0;
  };
  var e2 = function(r3, t5, n4) {
    return void 0 === t5 && (t5 = 0), void 0 === n4 && (n4 = 1), r3 > n4 ? n4 : r3 > t5 ? r3 : t5;
  };
  var u2 = function(r3) {
    return (r3 = isFinite(r3) ? r3 % 360 : 0) > 0 ? r3 : r3 + 360;
  };
  var a2 = function(r3) {
    return { r: e2(r3.r, 0, 255), g: e2(r3.g, 0, 255), b: e2(r3.b, 0, 255), a: e2(r3.a) };
  };
  var o2 = function(r3) {
    return { r: n2(r3.r), g: n2(r3.g), b: n2(r3.b), a: n2(r3.a, 3) };
  };
  var i2 = /^#([0-9a-f]{3,8})$/i;
  var s2 = function(r3) {
    var t5 = r3.toString(16);
    return t5.length < 2 ? "0" + t5 : t5;
  };
  var h2 = function(r3) {
    var t5 = r3.r, n4 = r3.g, e4 = r3.b, u4 = r3.a, a4 = Math.max(t5, n4, e4), o4 = a4 - Math.min(t5, n4, e4), i4 = o4 ? a4 === t5 ? (n4 - e4) / o4 : a4 === n4 ? 2 + (e4 - t5) / o4 : 4 + (t5 - n4) / o4 : 0;
    return { h: 60 * (i4 < 0 ? i4 + 6 : i4), s: a4 ? o4 / a4 * 100 : 0, v: a4 / 255 * 100, a: u4 };
  };
  var b2 = function(r3) {
    var t5 = r3.h, n4 = r3.s, e4 = r3.v, u4 = r3.a;
    t5 = t5 / 360 * 6, n4 /= 100, e4 /= 100;
    var a4 = Math.floor(t5), o4 = e4 * (1 - n4), i4 = e4 * (1 - (t5 - a4) * n4), s4 = e4 * (1 - (1 - t5 + a4) * n4), h4 = a4 % 6;
    return { r: 255 * [e4, i4, o4, o4, s4, e4][h4], g: 255 * [s4, e4, e4, i4, o4, o4][h4], b: 255 * [o4, o4, s4, e4, e4, i4][h4], a: u4 };
  };
  var g = function(r3) {
    return { h: u2(r3.h), s: e2(r3.s, 0, 100), l: e2(r3.l, 0, 100), a: e2(r3.a) };
  };
  var d = function(r3) {
    return { h: n2(r3.h), s: n2(r3.s), l: n2(r3.l), a: n2(r3.a, 3) };
  };
  var f = function(r3) {
    return b2((n4 = (t5 = r3).s, { h: t5.h, s: (n4 *= ((e4 = t5.l) < 50 ? e4 : 100 - e4) / 100) > 0 ? 2 * n4 / (e4 + n4) * 100 : 0, v: e4 + n4, a: t5.a }));
    var t5, n4, e4;
  };
  var c2 = function(r3) {
    return { h: (t5 = h2(r3)).h, s: (u4 = (200 - (n4 = t5.s)) * (e4 = t5.v) / 100) > 0 && u4 < 200 ? n4 * e4 / 100 / (u4 <= 100 ? u4 : 200 - u4) * 100 : 0, l: u4 / 2, a: t5.a };
    var t5, n4, e4, u4;
  };
  var l2 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var p2 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var y = { string: [[function(r3) {
    var t5 = i2.exec(r3);
    return t5 ? (r3 = t5[1]).length <= 4 ? { r: parseInt(r3[0] + r3[0], 16), g: parseInt(r3[1] + r3[1], 16), b: parseInt(r3[2] + r3[2], 16), a: 4 === r3.length ? n2(parseInt(r3[3] + r3[3], 16) / 255, 2) : 1 } : 6 === r3.length || 8 === r3.length ? { r: parseInt(r3.substr(0, 2), 16), g: parseInt(r3.substr(2, 2), 16), b: parseInt(r3.substr(4, 2), 16), a: 8 === r3.length ? n2(parseInt(r3.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
  }, "hex"], [function(r3) {
    var t5 = v.exec(r3) || m.exec(r3);
    return t5 ? t5[2] !== t5[4] || t5[4] !== t5[6] ? null : a2({ r: Number(t5[1]) / (t5[2] ? 100 / 255 : 1), g: Number(t5[3]) / (t5[4] ? 100 / 255 : 1), b: Number(t5[5]) / (t5[6] ? 100 / 255 : 1), a: void 0 === t5[7] ? 1 : Number(t5[7]) / (t5[8] ? 100 : 1) }) : null;
  }, "rgb"], [function(t5) {
    var n4 = l2.exec(t5) || p2.exec(t5);
    if (!n4) return null;
    var e4, u4, a4 = g({ h: (e4 = n4[1], u4 = n4[2], void 0 === u4 && (u4 = "deg"), Number(e4) * (r[u4] || 1)), s: Number(n4[3]), l: Number(n4[4]), a: void 0 === n4[5] ? 1 : Number(n4[5]) / (n4[6] ? 100 : 1) });
    return f(a4);
  }, "hsl"]], object: [[function(r3) {
    var n4 = r3.r, e4 = r3.g, u4 = r3.b, o4 = r3.a, i4 = void 0 === o4 ? 1 : o4;
    return t3(n4) && t3(e4) && t3(u4) ? a2({ r: Number(n4), g: Number(e4), b: Number(u4), a: Number(i4) }) : null;
  }, "rgb"], [function(r3) {
    var n4 = r3.h, e4 = r3.s, u4 = r3.l, a4 = r3.a, o4 = void 0 === a4 ? 1 : a4;
    if (!t3(n4) || !t3(e4) || !t3(u4)) return null;
    var i4 = g({ h: Number(n4), s: Number(e4), l: Number(u4), a: Number(o4) });
    return f(i4);
  }, "hsl"], [function(r3) {
    var n4 = r3.h, a4 = r3.s, o4 = r3.v, i4 = r3.a, s4 = void 0 === i4 ? 1 : i4;
    if (!t3(n4) || !t3(a4) || !t3(o4)) return null;
    var h4 = function(r4) {
      return { h: u2(r4.h), s: e2(r4.s, 0, 100), v: e2(r4.v, 0, 100), a: e2(r4.a) };
    }({ h: Number(n4), s: Number(a4), v: Number(o4), a: Number(s4) });
    return b2(h4);
  }, "hsv"]] };
  var N = function(r3, t5) {
    for (var n4 = 0; n4 < t5.length; n4++) {
      var e4 = t5[n4][0](r3);
      if (e4) return [e4, t5[n4][1]];
    }
    return [null, void 0];
  };
  var x = function(r3) {
    return "string" == typeof r3 ? N(r3.trim(), y.string) : "object" == typeof r3 && null !== r3 ? N(r3, y.object) : [null, void 0];
  };
  var M = function(r3, t5) {
    var n4 = c2(r3);
    return { h: n4.h, s: e2(n4.s + 100 * t5, 0, 100), l: n4.l, a: n4.a };
  };
  var H = function(r3) {
    return (299 * r3.r + 587 * r3.g + 114 * r3.b) / 1e3 / 255;
  };
  var $ = function(r3, t5) {
    var n4 = c2(r3);
    return { h: n4.h, s: n4.s, l: e2(n4.l + 100 * t5, 0, 100), a: n4.a };
  };
  var j = function() {
    function r3(r4) {
      this.parsed = x(r4)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
    }
    return r3.prototype.isValid = function() {
      return null !== this.parsed;
    }, r3.prototype.brightness = function() {
      return n2(H(this.rgba), 2);
    }, r3.prototype.isDark = function() {
      return H(this.rgba) < 0.5;
    }, r3.prototype.isLight = function() {
      return H(this.rgba) >= 0.5;
    }, r3.prototype.toHex = function() {
      return r4 = o2(this.rgba), t5 = r4.r, e4 = r4.g, u4 = r4.b, i4 = (a4 = r4.a) < 1 ? s2(n2(255 * a4)) : "", "#" + s2(t5) + s2(e4) + s2(u4) + i4;
      var r4, t5, e4, u4, a4, i4;
    }, r3.prototype.toRgb = function() {
      return o2(this.rgba);
    }, r3.prototype.toRgbString = function() {
      return r4 = o2(this.rgba), t5 = r4.r, n4 = r4.g, e4 = r4.b, (u4 = r4.a) < 1 ? "rgba(" + t5 + ", " + n4 + ", " + e4 + ", " + u4 + ")" : "rgb(" + t5 + ", " + n4 + ", " + e4 + ")";
      var r4, t5, n4, e4, u4;
    }, r3.prototype.toHsl = function() {
      return d(c2(this.rgba));
    }, r3.prototype.toHslString = function() {
      return r4 = d(c2(this.rgba)), t5 = r4.h, n4 = r4.s, e4 = r4.l, (u4 = r4.a) < 1 ? "hsla(" + t5 + ", " + n4 + "%, " + e4 + "%, " + u4 + ")" : "hsl(" + t5 + ", " + n4 + "%, " + e4 + "%)";
      var r4, t5, n4, e4, u4;
    }, r3.prototype.toHsv = function() {
      return r4 = h2(this.rgba), { h: n2(r4.h), s: n2(r4.s), v: n2(r4.v), a: n2(r4.a, 3) };
      var r4;
    }, r3.prototype.invert = function() {
      return w({ r: 255 - (r4 = this.rgba).r, g: 255 - r4.g, b: 255 - r4.b, a: r4.a });
      var r4;
    }, r3.prototype.saturate = function(r4) {
      return void 0 === r4 && (r4 = 0.1), w(M(this.rgba, r4));
    }, r3.prototype.desaturate = function(r4) {
      return void 0 === r4 && (r4 = 0.1), w(M(this.rgba, -r4));
    }, r3.prototype.grayscale = function() {
      return w(M(this.rgba, -1));
    }, r3.prototype.lighten = function(r4) {
      return void 0 === r4 && (r4 = 0.1), w($(this.rgba, r4));
    }, r3.prototype.darken = function(r4) {
      return void 0 === r4 && (r4 = 0.1), w($(this.rgba, -r4));
    }, r3.prototype.rotate = function(r4) {
      return void 0 === r4 && (r4 = 15), this.hue(this.hue() + r4);
    }, r3.prototype.alpha = function(r4) {
      return "number" == typeof r4 ? w({ r: (t5 = this.rgba).r, g: t5.g, b: t5.b, a: r4 }) : n2(this.rgba.a, 3);
      var t5;
    }, r3.prototype.hue = function(r4) {
      var t5 = c2(this.rgba);
      return "number" == typeof r4 ? w({ h: r4, s: t5.s, l: t5.l, a: t5.a }) : n2(t5.h);
    }, r3.prototype.isEqual = function(r4) {
      return this.toHex() === w(r4).toHex();
    }, r3;
  }();
  var w = function(r3) {
    return r3 instanceof j ? r3 : new j(r3);
  };

  // src/scripts/components/color-picker.tsx
  var import_react15 = __toESM(require_react(), 1);

  // node_modules/.pnpm/react-colorful@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-colorful/dist/index.mjs
  var import_react14 = __toESM(require_react(), 1);
  function u3() {
    return (u3 = Object.assign || function(e4) {
      for (var r3 = 1; r3 < arguments.length; r3++) {
        var t5 = arguments[r3];
        for (var n4 in t5) Object.prototype.hasOwnProperty.call(t5, n4) && (e4[n4] = t5[n4]);
      }
      return e4;
    }).apply(this, arguments);
  }
  function c3(e4, r3) {
    if (null == e4) return {};
    var t5, n4, o4 = {}, a4 = Object.keys(e4);
    for (n4 = 0; n4 < a4.length; n4++) r3.indexOf(t5 = a4[n4]) >= 0 || (o4[t5] = e4[t5]);
    return o4;
  }
  function i3(e4) {
    var t5 = (0, import_react14.useRef)(e4), n4 = (0, import_react14.useRef)(function(e5) {
      t5.current && t5.current(e5);
    });
    return t5.current = e4, n4.current;
  }
  var s3 = function(e4, r3, t5) {
    return void 0 === r3 && (r3 = 0), void 0 === t5 && (t5 = 1), e4 > t5 ? t5 : e4 < r3 ? r3 : e4;
  };
  var f2 = function(e4) {
    return "touches" in e4;
  };
  var v2 = function(e4) {
    return e4 && e4.ownerDocument.defaultView || self;
  };
  var d2 = function(e4, r3, t5) {
    var n4 = e4.getBoundingClientRect(), o4 = f2(r3) ? function(e5, r4) {
      for (var t6 = 0; t6 < e5.length; t6++) if (e5[t6].identifier === r4) return e5[t6];
      return e5[0];
    }(r3.touches, t5) : r3;
    return { left: s3((o4.pageX - (n4.left + v2(e4).pageXOffset)) / n4.width), top: s3((o4.pageY - (n4.top + v2(e4).pageYOffset)) / n4.height) };
  };
  var h3 = function(e4) {
    !f2(e4) && e4.preventDefault();
  };
  var m2 = import_react14.default.memo(function(o4) {
    var a4 = o4.onMove, l4 = o4.onKey, s4 = c3(o4, ["onMove", "onKey"]), m3 = (0, import_react14.useRef)(null), g3 = i3(a4), p4 = i3(l4), b4 = (0, import_react14.useRef)(null), _2 = (0, import_react14.useRef)(false), x2 = (0, import_react14.useMemo)(function() {
      var e4 = function(e5) {
        h3(e5), (f2(e5) ? e5.touches.length > 0 : e5.buttons > 0) && m3.current ? g3(d2(m3.current, e5, b4.current)) : t5(false);
      }, r3 = function() {
        return t5(false);
      };
      function t5(t6) {
        var n4 = _2.current, o5 = v2(m3.current), a5 = t6 ? o5.addEventListener : o5.removeEventListener;
        a5(n4 ? "touchmove" : "mousemove", e4), a5(n4 ? "touchend" : "mouseup", r3);
      }
      return [function(e5) {
        var r4 = e5.nativeEvent, n4 = m3.current;
        if (n4 && (h3(r4), !function(e6, r5) {
          return r5 && !f2(e6);
        }(r4, _2.current) && n4)) {
          if (f2(r4)) {
            _2.current = true;
            var o5 = r4.changedTouches || [];
            o5.length && (b4.current = o5[0].identifier);
          }
          n4.focus(), g3(d2(n4, r4, b4.current)), t5(true);
        }
      }, function(e5) {
        var r4 = e5.which || e5.keyCode;
        r4 < 37 || r4 > 40 || (e5.preventDefault(), p4({ left: 39 === r4 ? 0.05 : 37 === r4 ? -0.05 : 0, top: 40 === r4 ? 0.05 : 38 === r4 ? -0.05 : 0 }));
      }, t5];
    }, [p4, g3]), C2 = x2[0], E = x2[1], H2 = x2[2];
    return (0, import_react14.useEffect)(function() {
      return H2;
    }, [H2]), import_react14.default.createElement("div", u3({}, s4, { onTouchStart: C2, onMouseDown: C2, className: "react-colorful__interactive", ref: m3, onKeyDown: E, tabIndex: 0, role: "slider" }));
  });
  var g2 = function(e4) {
    return e4.filter(Boolean).join(" ");
  };
  var p3 = function(r3) {
    var t5 = r3.color, n4 = r3.left, o4 = r3.top, a4 = void 0 === o4 ? 0.5 : o4, l4 = g2(["react-colorful__pointer", r3.className]);
    return import_react14.default.createElement("div", { className: l4, style: { top: 100 * a4 + "%", left: 100 * n4 + "%" } }, import_react14.default.createElement("div", { className: "react-colorful__pointer-fill", style: { backgroundColor: t5 } }));
  };
  var b3 = function(e4, r3, t5) {
    return void 0 === r3 && (r3 = 0), void 0 === t5 && (t5 = Math.pow(10, r3)), Math.round(t5 * e4) / t5;
  };
  var _ = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
  var y2 = function(e4) {
    var r3 = e4.s, t5 = e4.v, n4 = e4.a, o4 = (200 - r3) * t5 / 100;
    return { h: b3(e4.h), s: b3(o4 > 0 && o4 < 200 ? r3 * t5 / 100 / (o4 <= 100 ? o4 : 200 - o4) * 100 : 0), l: b3(o4 / 2), a: b3(n4, 2) };
  };
  var q = function(e4) {
    var r3 = y2(e4);
    return "hsl(" + r3.h + ", " + r3.s + "%, " + r3.l + "%)";
  };
  var k = function(e4) {
    var r3 = y2(e4);
    return "hsla(" + r3.h + ", " + r3.s + "%, " + r3.l + "%, " + r3.a + ")";
  };
  var I = function(e4) {
    var r3 = e4.h, t5 = e4.s, n4 = e4.v, o4 = e4.a;
    r3 = r3 / 360 * 6, t5 /= 100, n4 /= 100;
    var a4 = Math.floor(r3), l4 = n4 * (1 - t5), u4 = n4 * (1 - (r3 - a4) * t5), c4 = n4 * (1 - (1 - r3 + a4) * t5), i4 = a4 % 6;
    return { r: b3(255 * [n4, u4, l4, l4, c4, n4][i4]), g: b3(255 * [c4, n4, n4, u4, l4, l4][i4]), b: b3(255 * [l4, l4, c4, n4, n4, u4][i4]), a: b3(o4, 2) };
  };
  var L = function(e4) {
    var r3 = e4.r, t5 = e4.g, n4 = e4.b, o4 = e4.a, a4 = Math.max(r3, t5, n4), l4 = a4 - Math.min(r3, t5, n4), u4 = l4 ? a4 === r3 ? (t5 - n4) / l4 : a4 === t5 ? 2 + (n4 - r3) / l4 : 4 + (r3 - t5) / l4 : 0;
    return { h: b3(60 * (u4 < 0 ? u4 + 6 : u4)), s: b3(a4 ? l4 / a4 * 100 : 0), v: b3(a4 / 255 * 100), a: o4 };
  };
  var S = import_react14.default.memo(function(r3) {
    var t5 = r3.hue, n4 = r3.onChange, o4 = g2(["react-colorful__hue", r3.className]);
    return import_react14.default.createElement("div", { className: o4 }, import_react14.default.createElement(m2, { onMove: function(e4) {
      n4({ h: 360 * e4.left });
    }, onKey: function(e4) {
      n4({ h: s3(t5 + 360 * e4.left, 0, 360) });
    }, "aria-label": "Hue", "aria-valuenow": b3(t5), "aria-valuemax": "360", "aria-valuemin": "0" }, import_react14.default.createElement(p3, { className: "react-colorful__hue-pointer", left: t5 / 360, color: q({ h: t5, s: 100, v: 100, a: 1 }) })));
  });
  var T = import_react14.default.memo(function(r3) {
    var t5 = r3.hsva, n4 = r3.onChange, o4 = { backgroundColor: q({ h: t5.h, s: 100, v: 100, a: 1 }) };
    return import_react14.default.createElement("div", { className: "react-colorful__saturation", style: o4 }, import_react14.default.createElement(m2, { onMove: function(e4) {
      n4({ s: 100 * e4.left, v: 100 - 100 * e4.top });
    }, onKey: function(e4) {
      n4({ s: s3(t5.s + 100 * e4.left, 0, 100), v: s3(t5.v - 100 * e4.top, 0, 100) });
    }, "aria-label": "Color", "aria-valuetext": "Saturation " + b3(t5.s) + "%, Brightness " + b3(t5.v) + "%" }, import_react14.default.createElement(p3, { className: "react-colorful__saturation-pointer", top: 1 - t5.v / 100, left: t5.s / 100, color: q(t5) })));
  });
  var F = function(e4, r3) {
    if (e4 === r3) return true;
    for (var t5 in e4) if (e4[t5] !== r3[t5]) return false;
    return true;
  };
  function Y(e4, t5, l4) {
    var u4 = i3(l4), c4 = (0, import_react14.useState)(function() {
      return e4.toHsva(t5);
    }), s4 = c4[0], f3 = c4[1], v3 = (0, import_react14.useRef)({ color: t5, hsva: s4 });
    (0, import_react14.useEffect)(function() {
      if (!e4.equal(t5, v3.current.color)) {
        var r3 = e4.toHsva(t5);
        v3.current = { hsva: r3, color: t5 }, f3(r3);
      }
    }, [t5, e4]), (0, import_react14.useEffect)(function() {
      var r3;
      F(s4, v3.current.hsva) || e4.equal(r3 = e4.fromHsva(s4), v3.current.color) || (v3.current = { hsva: s4, color: r3 }, u4(r3));
    }, [s4, e4, u4]);
    var d3 = (0, import_react14.useCallback)(function(e5) {
      f3(function(r3) {
        return Object.assign({}, r3, e5);
      });
    }, []);
    return [s4, d3];
  }
  var R;
  var V = "undefined" != typeof window ? import_react14.useLayoutEffect : import_react14.useEffect;
  var $2 = function() {
    return R || ("undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : void 0);
  };
  var J = /* @__PURE__ */ new Map();
  var Q = function(e4) {
    V(function() {
      var r3 = e4.current ? e4.current.ownerDocument : document;
      if (void 0 !== r3 && !J.has(r3)) {
        var t5 = r3.createElement("style");
        t5.innerHTML = `.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}`, J.set(r3, t5);
        var n4 = $2();
        n4 && t5.setAttribute("nonce", n4), r3.head.appendChild(t5);
      }
    }, []);
  };
  var ee = function(r3) {
    var t5 = r3.className, n4 = r3.hsva, o4 = r3.onChange, a4 = { backgroundImage: "linear-gradient(90deg, " + k(Object.assign({}, n4, { a: 0 })) + ", " + k(Object.assign({}, n4, { a: 1 })) + ")" }, l4 = g2(["react-colorful__alpha", t5]), u4 = b3(100 * n4.a);
    return import_react14.default.createElement("div", { className: l4 }, import_react14.default.createElement("div", { className: "react-colorful__alpha-gradient", style: a4 }), import_react14.default.createElement(m2, { onMove: function(e4) {
      o4({ a: e4.left });
    }, onKey: function(e4) {
      o4({ a: s3(n4.a + e4.left) });
    }, "aria-label": "Alpha", "aria-valuetext": u4 + "%", "aria-valuenow": u4, "aria-valuemin": "0", "aria-valuemax": "100" }, import_react14.default.createElement(p3, { className: "react-colorful__alpha-pointer", left: n4.a, color: k(n4) })));
  };
  var re = function(t5) {
    var n4 = t5.className, o4 = t5.colorModel, a4 = t5.color, l4 = void 0 === a4 ? o4.defaultColor : a4, i4 = t5.onChange, s4 = c3(t5, ["className", "colorModel", "color", "onChange"]), f3 = (0, import_react14.useRef)(null);
    Q(f3);
    var v3 = Y(o4, l4, i4), d3 = v3[0], h4 = v3[1], m3 = g2(["react-colorful", n4]);
    return import_react14.default.createElement("div", u3({}, s4, { ref: f3, className: m3 }), import_react14.default.createElement(T, { hsva: d3, onChange: h4 }), import_react14.default.createElement(S, { hue: d3.h, onChange: h4 }), import_react14.default.createElement(ee, { hsva: d3, onChange: h4, className: "react-colorful__last-control" }));
  };
  var xe = { defaultColor: { r: 0, g: 0, b: 0, a: 1 }, toHsva: L, fromHsva: I, equal: F };
  var Ce = function(r3) {
    return import_react14.default.createElement(re, u3({}, r3, { colorModel: xe }));
  };
  var qe = /^#?([0-9A-F]{3,8})$/i;
  var ke = function(r3) {
    var t5 = r3.color, l4 = void 0 === t5 ? "" : t5, s4 = r3.onChange, f3 = r3.onBlur, v3 = r3.escape, d3 = r3.validate, h4 = r3.format, m3 = r3.process, g3 = c3(r3, ["color", "onChange", "onBlur", "escape", "validate", "format", "process"]), p4 = (0, import_react14.useState)(function() {
      return v3(l4);
    }), b4 = p4[0], _2 = p4[1], x2 = i3(s4), C2 = i3(f3), E = (0, import_react14.useCallback)(function(e4) {
      var r4 = v3(e4.target.value);
      _2(r4), d3(r4) && x2(m3 ? m3(r4) : r4);
    }, [v3, m3, d3, x2]), H2 = (0, import_react14.useCallback)(function(e4) {
      d3(e4.target.value) || _2(v3(l4)), C2(e4);
    }, [l4, v3, d3, C2]);
    return (0, import_react14.useEffect)(function() {
      _2(v3(l4));
    }, [l4, v3]), import_react14.default.createElement("input", u3({}, g3, { value: h4 ? h4(b4) : b4, spellCheck: "false", onChange: E, onBlur: H2 }));
  };
  var Ie = function(e4) {
    return "#" + e4;
  };
  var Oe = function(r3) {
    var t5 = r3.prefixed, n4 = r3.alpha, o4 = c3(r3, ["prefixed", "alpha"]), l4 = (0, import_react14.useCallback)(function(e4) {
      return e4.replace(/([^0-9A-F]+)/gi, "").substring(0, n4 ? 8 : 6);
    }, [n4]), i4 = (0, import_react14.useCallback)(function(e4) {
      return function(e5, r4) {
        var t6 = qe.exec(e5), n5 = t6 ? t6[1].length : 0;
        return 3 === n5 || 6 === n5 || !!r4 && 4 === n5 || !!r4 && 8 === n5;
      }(e4, n4);
    }, [n4]);
    return import_react14.default.createElement(ke, u3({}, o4, { escape: l4, format: t5 ? Ie : void 0, process: Ie, validate: i4 }));
  };

  // src/scripts/components/color-picker.tsx
  var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
  var ColorPicker = import_react15.default.forwardRef(function ColorPicker2({ disabled = false, value, onChange, ...props }, ref) {
    const [open, setOpen] = (0, import_react15.useState)(false);
    const swatchRef = useInnerRef(ref);
    const popoverRef = (0, import_react15.useRef)(null);
    (0, import_react15.useLayoutEffect)(() => {
      if (open) {
        popoverRef.current?.focus();
      }
    }, [open]);
    const pickerClassName = useClassName(
      () => ({
        height: "36px",
        outline: "none",
        position: "relative",
        width: "36px"
      }),
      []
    );
    const swatchClassName = useClassName(
      (theme2) => ({
        border: `solid 2px ${theme2.colorPicker.border}`,
        borderRadius: "25%",
        cursor: disabled ? "default" : "pointer",
        height: "36px",
        opacity: disabled ? DISABLED_OPACITY : 1,
        outline: "none",
        padding: 0,
        width: "36px",
        "&:focus": {
          boxShadow: `0 0 0 2px ${theme2.focus.shadow}`
        },
        "&:focus:not(:focus-visible)": {
          boxShadow: "none"
        },
        "&:focus:not(:-moz-focusring)": {
          boxShadow: "none"
        }
      }),
      [disabled]
    );
    const popoverClassName = useClassName(
      (theme2) => ({
        backgroundColor: theme2.colorPicker.popoverBackground,
        borderRadius: "8px",
        boxShadow: "rgba(0, 0, 0, 0.3) 0px 1px 2px 0px, rgba(0, 0, 0, 0.15) 0px 3px 6px 2px",
        display: open ? "block" : "none",
        outline: "none",
        padding: "0.75em",
        position: "absolute",
        top: "100%",
        right: 0,
        zIndex: COLOR_PICKER_Z_INDEX
      }),
      [open]
    );
    const inputClassName = useClassName(
      (theme2) => ({
        background: "transparent",
        border: `solid 1px ${theme2.input.border}`,
        borderRadius: "4px",
        color: theme2.text.primary,
        display: "block",
        font: "inherit",
        height: "2.5em",
        lineHeight: "1.5",
        margin: "0.75em auto 0",
        padding: "0.5em 0.625em",
        textAlign: "center",
        width: "8em",
        "&:focus": {
          boxShadow: `0 0 0 2px ${theme2.focus.shadow}`,
          outline: "none"
        }
      }),
      []
    );
    return /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(
      "div",
      {
        className: pickerClassName,
        tabIndex: -1,
        onBlurCapture: (e4) => {
          if (!e4.currentTarget.contains(e4.relatedTarget)) {
            setOpen(false);
          }
        },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
            "button",
            {
              ...applyClassName(props, swatchClassName),
              "aria-expanded": open,
              "aria-haspopup": "dialog",
              ref: swatchRef,
              style: { backgroundColor: value },
              type: "button",
              onClick: () => setOpen(!open)
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(
            "div",
            {
              className: popoverClassName,
              ref: popoverRef,
              role: "dialog",
              tabIndex: -1,
              onKeyDown: (e4) => {
                if (e4.key === "Escape") {
                  e4.preventDefault();
                  setOpen(false);
                  swatchRef.current?.focus();
                }
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
                  Ce,
                  {
                    color: w(value).toRgb(),
                    onChange: (value2) => onChange(w(value2).toHex())
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
                  Oe,
                  {
                    alpha: true,
                    className: inputClassName,
                    color: w(value).toHex(),
                    prefixed: true,
                    onChange
                  }
                )
              ]
            }
          )
        ]
      }
    );
  });

  // src/scripts/components/icon-button.tsx
  var import_react16 = __toESM(require_react(), 1);
  var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
  var IconButton = import_react16.default.forwardRef(
    function IconButton2({ iconURL, ...props }, ref) {
      const theme2 = useTheme();
      const wrapperClassName = useClassName(
        () => ({
          position: "relative"
        }),
        []
      );
      const buttonClassName = useClassName(
        () => ({
          background: "transparent",
          border: "none",
          cursor: "pointer",
          display: "block",
          height: "36px",
          padding: "6px",
          width: "36px",
          "&:disabled": {
            cursor: "default",
            opacity: DISABLED_OPACITY
          },
          "&:focus": {
            outline: "none"
          }
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: wrapperClassName, children: [
        /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("button", { ...applyClassName(props, buttonClassName), ref, children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
          TemplateIcon,
          {
            color: theme2.iconButton,
            iconSize: "24px",
            url: iconURL
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(FocusCircle, {})
      ] });
    }
  );

  // src/scripts/components/list.tsx
  var import_react17 = __toESM(require_react(), 1);
  var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
  var List = import_react17.default.forwardRef(
    function List2(props, ref) {
      const className = useClassName(
        () => ({
          listStyleType: "none",
          margin: 0,
          padding: 0
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("ul", { ...applyClassName(props, className), ref });
    }
  );
  var ListItem = import_react17.default.forwardRef(
    function ListItem2(props, ref) {
      const className = useClassName(
        (theme2) => ({
          padding: "0.75em 0",
          "&:not(:first-child)": {
            borderTop: `solid 1px ${theme2.separator}`
          }
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("li", { ...applyClassName(props, className), ref });
    }
  );

  // src/scripts/components/radio-button.tsx
  var import_react18 = __toESM(require_react(), 1);
  var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
  var RadioButton = import_react18.default.forwardRef(
    function RadioButton2(props, ref) {
      const wrapperClassName = useClassName(
        () => ({
          height: "16px",
          position: "relative",
          width: "16px"
        }),
        []
      );
      const inputClassName = useClassName(
        () => ({
          cursor: "pointer",
          height: "100%",
          margin: 0,
          opacity: 0,
          position: "absolute",
          width: "100%",
          zIndex: INPUT_Z_INDEX,
          "&:disabled": {
            cursor: "default"
          }
        }),
        []
      );
      const imageClassName = useClassName(
        () => ({
          ":disabled + &": {
            opacity: DISABLED_OPACITY
          }
        }),
        []
      );
      const circleClassName = useClassName(
        (theme2) => ({
          border: `solid 2px ${theme2.radioButton.unchecked}`,
          borderRadius: "50%",
          height: "16px",
          left: 0,
          position: "absolute",
          top: 0,
          width: "16px",
          ":checked + * > &": {
            borderColor: theme2.radioButton.checked
          }
        }),
        []
      );
      const dotClassName = useClassName(
        (theme2) => ({
          borderRadius: "50%",
          height: "8px",
          left: "4px",
          position: "absolute",
          top: "4px",
          width: "8px",
          ":checked + * > &": {
            backgroundColor: theme2.radioButton.checked
          }
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: wrapperClassName, children: [
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
          "input",
          {
            ...applyClassName(props, inputClassName),
            ref,
            type: "radio"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: imageClassName, children: [
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: circleClassName }),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: dotClassName }),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(FocusCircle, { depth: 1 })
        ] })
      ] });
    }
  );

  // src/scripts/messages.ts
  async function sendMessage(type2, ...args) {
    return await browser.runtime.sendMessage({ type: type2, args });
  }
  function invokeListener(listener, args, sendResponse) {
    const response = listener(...args);
    if (response instanceof Promise) {
      void response.then(sendResponse);
      return true;
    }
    sendResponse(response);
  }
  function addMessageListeners(listeners) {
    const listener = (message, _sender, sendResponse) => {
      const { type: type2, args } = message;
      if (listeners[type2]) {
        return invokeListener(
          listeners[type2],
          args,
          sendResponse
        );
      }
    };
    browser.runtime.onMessage.addListener(listener);
    return () => {
      browser.runtime.onMessage.removeListener(listener);
    };
  }

  // src/scripts/local-storage.ts
  var defaultLocalStorageItems = {
    ruleset: false,
    blacklist: "",
    compiledRules: false,
    skipBlockDialog: false,
    hideBlockLinks: false,
    hideControl: false,
    enablePathDepth: false,
    blockWholeSite: false,
    linkColor: "default",
    blockColor: "default",
    highlightColors: ["#ddeeff"],
    dialogTheme: "default",
    syncCloudId: false,
    syncBlocklist: true,
    syncGeneral: false,
    syncAppearance: false,
    syncSubscriptions: false,
    syncResult: false,
    syncInterval: 15,
    subscriptions: {},
    updateInterval: 120
  };
  function loadAllFromLocalStorage() {
    return browser.storage.local.get(
      defaultLocalStorageItems
    );
  }
  function saveToLocalStorage(items, source) {
    return sendMessage("save-to-local-storage", items, source);
  }

  // src/scripts/options/options-context.tsx
  var import_react19 = __toESM(require_react(), 1);
  var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
  var OptionsContext = import_react19.default.createContext(null);
  var OptionsContextProvider = (props) => {
    const [value, setValue] = (0, import_react19.useState)(null);
    (0, import_react19.useEffect)(() => {
      void (async () => {
        const [initialItems, platformInfo] = await Promise.all([
          loadAllFromLocalStorage(),
          browser.runtime.getPlatformInfo()
        ]);
        const searchParams = new URL(window.location.href).searchParams;
        const query = {
          addSubscriptionName: searchParams.get("addSubscriptionName"),
          addSubscriptionURL: searchParams.get("addSubscriptionURL")
        };
        setValue({ initialItems, platformInfo, query });
      })();
    }, []);
    return value && /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(OptionsContext.Provider, { value, children: props.children });
  };
  function useOptionsContext() {
    const value = (0, import_react19.useContext)(OptionsContext);
    if (!value) {
      throw new Error("useOptionsContext: no matching provider");
    }
    return value;
  }

  // src/scripts/options/appearance-section.tsx
  var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
  var SetColorItem = ({ initialColor, itemKey, label }) => {
    const {
      initialItems: { [itemKey]: initialItem }
    } = useOptionsContext();
    const [specifyColor, setSpecifyColor] = (0, import_react20.useState)(initialItem !== "default");
    const [color, setColor] = (0, import_react20.useState)(
      initialItem === "default" ? initialColor : initialItem
    );
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(SectionItem, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(Row, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(LabelWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(Label, { children: label }) }) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(Row, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(Indent, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          RadioButton,
          {
            checked: !specifyColor,
            id: `${itemKey}UseDefault`,
            name: itemKey,
            onChange: (e4) => {
              if (e4.currentTarget.checked) {
                setSpecifyColor(false);
                void saveToLocalStorage(
                  { [itemKey]: "default" },
                  "options"
                );
              }
            }
          }
        ) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(LabelWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ControlLabel, { for: `${itemKey}UseDefault`, children: translate("options_colorUseDefault") }) }) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(Row, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(Indent, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          RadioButton,
          {
            checked: specifyColor,
            id: `${itemKey}Specify`,
            name: itemKey,
            onChange: (e4) => {
              if (e4.currentTarget.checked) {
                setSpecifyColor(true);
                void saveToLocalStorage(
                  { [itemKey]: color },
                  "options"
                );
              }
            }
          }
        ) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(LabelWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ControlLabel, { for: `${itemKey}Specify`, children: translate("options_colorSpecify") }) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          ColorPicker,
          {
            "aria-label": label,
            value: color,
            onChange: (value) => {
              setSpecifyColor(true);
              setColor(value);
              void saveToLocalStorage(
                { [itemKey]: value },
                "options"
              );
            }
          }
        ) })
      ] })
    ] });
  };
  var SetHighlightColors = () => {
    const {
      initialItems: { highlightColors: initialHighlightColors }
    } = useOptionsContext();
    const [colorsAndKeys, setColorsAndKeys] = (0, import_react20.useState)(
      initialHighlightColors.map((color, index) => [color, index])
    );
    const nextKey = (0, import_react20.useRef)(initialHighlightColors.length);
    const spacerClass = useClassName(
      () => ({
        height: "36px",
        width: "36px"
      }),
      []
    );
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(SectionItem, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(Row, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(LabelWrapper, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(Label, { children: translate("options_highlightColors") }),
          /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(SubLabel, { children: translate("options_highlightDescription") }),
          /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(SubLabel, { children: translate("options_blacklistExample", "@1*://*.example.com/*") })
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          IconButton,
          {
            "aria-label": translate("options_highlightColorAdd"),
            iconURL: svgToDataURL(plus_default),
            onClick: () => {
              colorsAndKeys.push(["#ddeeff", nextKey.current++]);
              setColorsAndKeys([...colorsAndKeys]);
              void saveToLocalStorage(
                { highlightColors: colorsAndKeys.map(([color]) => color) },
                "options"
              );
            }
          }
        ) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(Row, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(Indent, {}) }),
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(List, { children: colorsAndKeys.map(([color, key], index) => /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ListItem, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(Row, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(LabelWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(Label, { id: `highlightColor${index}`, children: translate(
            "options_highlightColorNth",
            String(index + 1)
          ) }) }) }),
          /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
            ColorPicker,
            {
              "aria-labelledby": `highlightColor${index}`,
              value: color,
              onChange: (value) => {
                colorsAndKeys[index] = [value, colorsAndKeys[index][1]];
                setColorsAndKeys([...colorsAndKeys]);
                void saveToLocalStorage(
                  {
                    highlightColors: colorsAndKeys.map(
                      ([color2]) => color2
                    )
                  },
                  "options"
                );
              }
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { children: index === colorsAndKeys.length - 1 ? /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
            IconButton,
            {
              "aria-label": translate("options_highlightColorAdd"),
              iconURL: svgToDataURL(delete_default),
              onClick: () => {
                colorsAndKeys.pop();
                setColorsAndKeys([...colorsAndKeys]);
                void saveToLocalStorage(
                  {
                    highlightColors: colorsAndKeys.map(
                      ([color2]) => color2
                    )
                  },
                  "options"
                );
              }
            }
          ) : /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("div", { className: spacerClass }) })
        ] }) }, key)) }) })
      ] })
    ] });
  };
  var SetDialogTheme = () => {
    const {
      initialItems: { dialogTheme: initialDialogTheme }
    } = useOptionsContext();
    const [dialogTheme, setDialogTheme] = (0, import_react20.useState)(initialDialogTheme);
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(SectionItem, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(Row, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(LabelWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(Label, { children: translate("options_dialogTheme") }) }) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(Row, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(Indent, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          RadioButton,
          {
            checked: dialogTheme === "default",
            id: "dialogThemeDefault",
            name: "dialogTheme",
            onChange: (e4) => {
              if (e4.currentTarget.checked) {
                setDialogTheme("default");
                void saveToLocalStorage(
                  { dialogTheme: "default" },
                  "options"
                );
              }
            }
          }
        ) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(LabelWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ControlLabel, { for: "dialogThemeDefault", children: translate("options_dialogThemeDefault") }) }) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(Row, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(Indent, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          RadioButton,
          {
            checked: dialogTheme === "light",
            id: "dialogThemeLight",
            name: "dialogTheme",
            onChange: (e4) => {
              if (e4.currentTarget.checked) {
                setDialogTheme("light");
                void saveToLocalStorage({ dialogTheme: "light" }, "options");
              }
            }
          }
        ) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(LabelWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ControlLabel, { for: "dialogThemeLight", children: translate("options_dialogThemeLight") }) }) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(Row, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(Indent, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          RadioButton,
          {
            checked: dialogTheme === "dark",
            id: "dialogThemeDark",
            name: "dialogTheme",
            onChange: (e4) => {
              if (e4.currentTarget.checked) {
                setDialogTheme("dark");
                void saveToLocalStorage({ dialogTheme: "dark" }, "options");
              }
            }
          }
        ) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(LabelWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ControlLabel, { for: "dialogThemeDark", children: translate("options_dialogThemeDark") }) }) })
      ] })
    ] });
  };
  var AppearanceSection = () => /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(Section, { "aria-labelledby": "appearanceSectionTitle", id: "appearance", children: [
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(SectionHeader, { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(SectionTitle, { id: "appearanceSectionTitle", children: translate("options_appearanceTitle") }) }),
    /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(SectionBody, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        SetColorItem,
        {
          initialColor: "#1a0dab",
          itemKey: "linkColor",
          label: translate("options_linkColor")
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        SetColorItem,
        {
          initialColor: "#ffe0e0",
          itemKey: "blockColor",
          label: translate("options_blockColor")
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(SetHighlightColors, {}),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(SetDialogTheme, {})
    ] })
  ] });

  // src/scripts/options/backup-restore-section.tsx
  var import_react22 = __toESM(require_react(), 1);

  // src/scripts/components/button.tsx
  var import_react21 = __toESM(require_react(), 1);
  var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
  var Button = import_react21.default.forwardRef(
    function Button2({ primary = false, ...props }, ref) {
      const className = useClassName(
        (theme2) => {
          const buttonTheme = primary ? theme2.button.primary : theme2.button.secondary;
          return {
            background: buttonTheme.background,
            border: primary ? "none" : `solid 1px ${theme2.button.secondary.border}`,
            borderRadius: "4px",
            color: buttonTheme.text,
            cursor: "pointer",
            font: "inherit",
            height: "2.5em",
            outline: "none",
            padding: primary ? "0.5em 1em" : "calc(0.5em - 1px) 1em",
            "&:active": {
              background: buttonTheme.backgroundActive
            },
            "&:disabled": {
              background: buttonTheme.backgroundDisabled,
              color: buttonTheme.textDisabled,
              cursor: "default"
            },
            "&:focus": {
              boxShadow: `0 0 0 2px ${theme2.focus.shadow}`
            },
            "&:focus:not(:focus-visible)": {
              boxShadow: "none"
            },
            "&:focus:not(:-moz-focusring)": {
              boxShadow: "none"
            },
            "&:hover:not(:active):not(:disabled)": {
              background: buttonTheme.backgroundHovered
            }
          };
        },
        [primary]
      );
      return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("button", { ...applyClassName(props, className), ref, type: "button" });
    }
  );
  var LinkButton = import_react21.default.forwardRef(function LinkButton2(props, ref) {
    const className = useClassName(
      (theme2) => ({
        background: "transparent",
        border: "none",
        color: theme2.link.text,
        cursor: "pointer",
        display: "inline",
        font: "inherit",
        outline: "none",
        padding: 0,
        "&:disabled": {
          cursor: "default"
        },
        "&:focus": {
          boxShadow: `0 0 0 2px ${theme2.focus.shadow}`
        },
        "&:focus:not(:focus-visible)": {
          boxShadow: "none"
        },
        "&:focus:not(:-moz-focusring)": {
          boxShadow: "none"
        }
      }),
      []
    );
    return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("button", { ...applyClassName(props, className), ref });
  });

  // src/scripts/options/backup-restore-section.tsx
  var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
  var BackupRestoreSection = () => {
    const [fileInvalid, setFileInvalid] = (0, import_react22.useState)(false);
    return /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)(Section, { "aria-labelledby": "backupRestoreSectionTitle", id: "backupRestore", children: [
      /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(SectionHeader, { children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(SectionTitle, { id: "backupRestoreSectionTitle", children: translate("options_backupRestoreTitle") }) }),
      /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)(SectionBody, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(SectionItem, { children: /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)(Row, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(LabelWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(Label, { children: translate("options_backupSettingsLabel") }) }) }),
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
            Button,
            {
              onClick: async () => {
                const items = await sendMessage("backup-settings");
                downloadTextFile(
                  "ublacklist-settings.json",
                  "application/json",
                  JSON.stringify(
                    {
                      ...items,
                      version: browser.runtime.getManifest().version
                    },
                    null,
                    2
                  )
                );
              },
              children: translate("options_backupSettingsButton")
            }
          ) })
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(SectionItem, { children: /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)(Row, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)(LabelWrapper, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(Label, { children: translate("options_restoreSettingsLabel") }),
            fileInvalid && /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(SubLabel, { children: translate(
              "error",
              translate("options_restoreSettingsInvalidFile")
            ) })
          ] }) }),
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
            Button,
            {
              onClick: async () => {
                const text = await uploadTextFile("application/json");
                if (text == null) {
                  return;
                }
                const parseResult = z.object({
                  blacklist: z.string().optional(),
                  blockWholeSite: z.boolean().optional(),
                  skipBlockDialog: z.boolean().optional(),
                  hideBlockLinks: z.boolean().optional(),
                  hideControl: z.boolean().optional(),
                  enablePathDepth: z.boolean().optional(),
                  linkColor: z.string().optional(),
                  blockColor: z.string().optional(),
                  highlightColors: z.string().array().optional(),
                  dialogTheme: z.enum(["light", "dark", "default"]).optional(),
                  syncBlocklist: z.boolean().optional(),
                  syncGeneral: z.boolean().optional(),
                  syncAppearance: z.boolean().optional(),
                  syncSubscriptions: z.boolean().optional(),
                  syncInterval: z.number().optional(),
                  subscriptions: z.object({
                    name: z.string(),
                    url: z.string(),
                    enabled: z.boolean()
                  }).array().optional(),
                  updateInterval: z.number().optional(),
                  version: z.string().optional()
                }).safeParse(parseJSON(text));
                setFileInvalid(!parseResult.success);
                if (!parseResult.success) {
                  return;
                }
                await sendMessage(
                  "restore-settings",
                  parseResult.data
                );
                window.location.assign(window.location.pathname);
              },
              children: translate("options_restoreSettingsButton")
            }
          ) })
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(SectionItem, { children: /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)(Row, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(LabelWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(Label, { children: translate("options_initializeSettingsLabel") }) }) }),
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
            Button,
            {
              onClick: async () => {
                const confirmed = window.confirm(
                  translate("options_initializeSettingsConfirmation")
                );
                if (!confirmed) {
                  return;
                }
                await sendMessage("initialize-settings");
                window.location.assign(window.location.pathname);
              },
              children: translate("options_initializeSettingsButton")
            }
          ) })
        ] }) })
      ] })
    ] });
  };

  // src/scripts/options/general-section.tsx
  var import_react31 = __toESM(require_react(), 1);

  // src/common/search-engines.ts
  var SEARCH_ENGINES = {
    google: {
      contentScripts: [
        {
          matches: [
            "https://www.google.com/search?*",
            "https://www.google.ad/search?*",
            "https://www.google.ae/search?*",
            "https://www.google.com.af/search?*",
            "https://www.google.com.ag/search?*",
            "https://www.google.com.ai/search?*",
            "https://www.google.al/search?*",
            "https://www.google.am/search?*",
            "https://www.google.co.ao/search?*",
            "https://www.google.com.ar/search?*",
            "https://www.google.as/search?*",
            "https://www.google.at/search?*",
            "https://www.google.com.au/search?*",
            "https://www.google.az/search?*",
            "https://www.google.ba/search?*",
            "https://www.google.com.bd/search?*",
            "https://www.google.be/search?*",
            "https://www.google.bf/search?*",
            "https://www.google.bg/search?*",
            "https://www.google.com.bh/search?*",
            "https://www.google.bi/search?*",
            "https://www.google.bj/search?*",
            "https://www.google.com.bn/search?*",
            "https://www.google.com.bo/search?*",
            "https://www.google.com.br/search?*",
            "https://www.google.bs/search?*",
            "https://www.google.bt/search?*",
            "https://www.google.co.bw/search?*",
            "https://www.google.by/search?*",
            "https://www.google.com.bz/search?*",
            "https://www.google.ca/search?*",
            "https://www.google.cd/search?*",
            "https://www.google.cf/search?*",
            "https://www.google.cg/search?*",
            "https://www.google.ch/search?*",
            "https://www.google.ci/search?*",
            "https://www.google.co.ck/search?*",
            "https://www.google.cl/search?*",
            "https://www.google.cm/search?*",
            "https://www.google.cn/search?*",
            "https://www.google.com.co/search?*",
            "https://www.google.co.cr/search?*",
            "https://www.google.com.cu/search?*",
            "https://www.google.cv/search?*",
            "https://www.google.com.cy/search?*",
            "https://www.google.cz/search?*",
            "https://www.google.de/search?*",
            "https://www.google.dj/search?*",
            "https://www.google.dk/search?*",
            "https://www.google.dm/search?*",
            "https://www.google.com.do/search?*",
            "https://www.google.dz/search?*",
            "https://www.google.com.ec/search?*",
            "https://www.google.ee/search?*",
            "https://www.google.com.eg/search?*",
            "https://www.google.es/search?*",
            "https://www.google.com.et/search?*",
            "https://www.google.fi/search?*",
            "https://www.google.com.fj/search?*",
            "https://www.google.fm/search?*",
            "https://www.google.fr/search?*",
            "https://www.google.ga/search?*",
            "https://www.google.ge/search?*",
            "https://www.google.gg/search?*",
            "https://www.google.com.gh/search?*",
            "https://www.google.com.gi/search?*",
            "https://www.google.gl/search?*",
            "https://www.google.gm/search?*",
            "https://www.google.gp/search?*",
            "https://www.google.gr/search?*",
            "https://www.google.com.gt/search?*",
            "https://www.google.gy/search?*",
            "https://www.google.com.hk/search?*",
            "https://www.google.hn/search?*",
            "https://www.google.hr/search?*",
            "https://www.google.ht/search?*",
            "https://www.google.hu/search?*",
            "https://www.google.co.id/search?*",
            "https://www.google.ie/search?*",
            "https://www.google.co.il/search?*",
            "https://www.google.im/search?*",
            "https://www.google.co.in/search?*",
            "https://www.google.iq/search?*",
            "https://www.google.is/search?*",
            "https://www.google.it/search?*",
            "https://www.google.je/search?*",
            "https://www.google.com.jm/search?*",
            "https://www.google.jo/search?*",
            "https://www.google.co.jp/search?*",
            "https://www.google.co.ke/search?*",
            "https://www.google.com.kh/search?*",
            "https://www.google.ki/search?*",
            "https://www.google.kg/search?*",
            "https://www.google.co.kr/search?*",
            "https://www.google.com.kw/search?*",
            "https://www.google.kz/search?*",
            "https://www.google.la/search?*",
            "https://www.google.com.lb/search?*",
            "https://www.google.li/search?*",
            "https://www.google.lk/search?*",
            "https://www.google.co.ls/search?*",
            "https://www.google.lt/search?*",
            "https://www.google.lu/search?*",
            "https://www.google.lv/search?*",
            "https://www.google.com.ly/search?*",
            "https://www.google.co.ma/search?*",
            "https://www.google.md/search?*",
            "https://www.google.me/search?*",
            "https://www.google.mg/search?*",
            "https://www.google.mk/search?*",
            "https://www.google.ml/search?*",
            "https://www.google.com.mm/search?*",
            "https://www.google.mn/search?*",
            "https://www.google.ms/search?*",
            "https://www.google.com.mt/search?*",
            "https://www.google.mu/search?*",
            "https://www.google.mv/search?*",
            "https://www.google.mw/search?*",
            "https://www.google.com.mx/search?*",
            "https://www.google.com.my/search?*",
            "https://www.google.co.mz/search?*",
            "https://www.google.com.na/search?*",
            "https://www.google.com.nf/search?*",
            "https://www.google.com.ng/search?*",
            "https://www.google.com.ni/search?*",
            "https://www.google.ne/search?*",
            "https://www.google.nl/search?*",
            "https://www.google.no/search?*",
            "https://www.google.com.np/search?*",
            "https://www.google.nr/search?*",
            "https://www.google.nu/search?*",
            "https://www.google.co.nz/search?*",
            "https://www.google.com.om/search?*",
            "https://www.google.com.pa/search?*",
            "https://www.google.com.pe/search?*",
            "https://www.google.com.pg/search?*",
            "https://www.google.com.ph/search?*",
            "https://www.google.com.pk/search?*",
            "https://www.google.pl/search?*",
            "https://www.google.pn/search?*",
            "https://www.google.com.pr/search?*",
            "https://www.google.ps/search?*",
            "https://www.google.pt/search?*",
            "https://www.google.com.py/search?*",
            "https://www.google.com.qa/search?*",
            "https://www.google.ro/search?*",
            "https://www.google.ru/search?*",
            "https://www.google.rw/search?*",
            "https://www.google.com.sa/search?*",
            "https://www.google.com.sb/search?*",
            "https://www.google.sc/search?*",
            "https://www.google.se/search?*",
            "https://www.google.com.sg/search?*",
            "https://www.google.sh/search?*",
            "https://www.google.si/search?*",
            "https://www.google.sk/search?*",
            "https://www.google.com.sl/search?*",
            "https://www.google.sn/search?*",
            "https://www.google.so/search?*",
            "https://www.google.sm/search?*",
            "https://www.google.sr/search?*",
            "https://www.google.st/search?*",
            "https://www.google.com.sv/search?*",
            "https://www.google.td/search?*",
            "https://www.google.tg/search?*",
            "https://www.google.co.th/search?*",
            "https://www.google.com.tj/search?*",
            "https://www.google.tk/search?*",
            "https://www.google.tl/search?*",
            "https://www.google.tm/search?*",
            "https://www.google.tn/search?*",
            "https://www.google.to/search?*",
            "https://www.google.com.tr/search?*",
            "https://www.google.tt/search?*",
            "https://www.google.com.tw/search?*",
            "https://www.google.co.tz/search?*",
            "https://www.google.com.ua/search?*",
            "https://www.google.co.ug/search?*",
            "https://www.google.co.uk/search?*",
            "https://www.google.com.uy/search?*",
            "https://www.google.co.uz/search?*",
            "https://www.google.com.vc/search?*",
            "https://www.google.co.ve/search?*",
            "https://www.google.vg/search?*",
            "https://www.google.co.vi/search?*",
            "https://www.google.com.vn/search?*",
            "https://www.google.vu/search?*",
            "https://www.google.ws/search?*",
            "https://www.google.rs/search?*",
            "https://www.google.co.za/search?*",
            "https://www.google.co.zm/search?*",
            "https://www.google.co.zw/search?*",
            "https://www.google.cat/search?*"
          ],
          runAt: "document_start"
        }
      ],
      messageNames: {
        name: "searchEngines_googleName"
      }
    },
    bing: {
      contentScripts: [
        {
          matches: [
            "https://www.bing.com/search?*",
            "https://www.bing.com/images/search?*",
            "https://www.bing.com/videos/search?*",
            "https://www.bing.com/news/search?*",
            "https://cn.bing.com/search?*",
            "https://cn.bing.com/images/search?*",
            "https://cn.bing.com/videos/search?*",
            "https://cn.bing.com/news/search?*",
            "https://www2.bing.com/search?*",
            "https://www2.bing.com/images/search?*",
            "https://www2.bing.com/videos/search?*",
            "https://www2.bing.com/news/search?*",
            "https://www4.bing.com/search?*",
            "https://www4.bing.com/images/search?*",
            "https://www4.bing.com/videos/search?*",
            "https://www4.bing.com/news/search?*"
          ],
          runAt: "document_start"
        }
      ],
      messageNames: {
        name: "searchEngines_bingName"
      }
    },
    brave: {
      contentScripts: [
        {
          matches: [
            "https://search.brave.com/search?*",
            "https://search.brave.com/images?*",
            "https://search.brave.com/news?*",
            "https://search.brave.com/videos?*",
            "https://search.brave.com/goggles?*"
          ],
          runAt: "document_idle"
        }
      ],
      messageNames: {
        name: "searchEngines_braveName"
      }
    },
    duckduckgo: {
      contentScripts: [
        {
          matches: [
            "*://duckduckgo.com/",
            "*://duckduckgo.com/?*",
            ...false ? [
              "*://html.duckduckgo.com/html/",
              "*://html.duckduckgo.com/html/?*",
              "*://lite.duckduckgo.com/lite/",
              "*://lite.duckduckgo.com/lite/?*"
            ] : [],
            "*://safe.duckduckgo.com/",
            "*://safe.duckduckgo.com/?*",
            "*://start.duckduckgo.com/",
            "*://start.duckduckgo.com/?*"
          ],
          runAt: "document_start"
        }
      ],
      messageNames: {
        name: "searchEngines_duckduckgoName"
      }
    },
    ecosia: {
      contentScripts: [
        {
          matches: ["https://www.ecosia.org/search?*"],
          runAt: "document_idle"
        }
      ],
      messageNames: {
        name: "searchEngines_ecosiaName"
      }
    },
    kagi: {
      contentScripts: [
        {
          matches: [
            "https://kagi.com/search?*",
            "https://kagi.com/images?*",
            "https://kagi.com/videos?*",
            "https://kagi.com/news?*",
            "https://kagi.com/podcasts?*"
          ],
          runAt: "document_idle"
        }
      ],
      messageNames: {
        name: "searchEngines_kagiName"
      }
    },
    qwant: {
      contentScripts: [
        {
          matches: ["https://www.qwant.com/?*"],
          // https://github.com/iorate/ublacklist/pull/179
          runAt: "document_idle"
        },
        {
          matches: ["https://lite.qwant.com/?*"],
          runAt: "document_start"
        }
      ],
      messageNames: {
        name: "searchEngines_qwantName",
        description: "searchEngines_qwantDescription"
      }
    },
    searx: {
      contentScripts: [
        {
          matches: [
            "*://searx.be/search*",
            "*://searx.fmac.xyz/search*",
            "*://search.unlocked.link/search*",
            "*://search.ononoki.org/search*",
            "*://northboot.xyz/search*",
            "*://searx.tiekoetter.com/search*",
            "*://searx.work/search*",
            "*://paulgo.io/search*",
            "*://search.rhscz.eu/search*",
            "*://search.rabbit-company.com/search*",
            "*://priv.au/search*",
            "*://search.sapti.me/search*",
            "*://searxng.nicfab.eu/searxng/search*",
            "*://search.smnz.de/search*",
            "*://notsearch.uk/search*",
            "*://search.bus-hit.me/search*",
            "*://xo.wtf/search*",
            "*://searx.mha.fi/search*",
            "*://searx.prvcy.eu/search*",
            "*://search.chemicals-in-the-water.eu/search*",
            "*://searx.baczek.me/search*",
            "*://search.rowie.at/search*",
            "*://searx.ericaftereric.top/search*",
            "*://sh0.it/search*",
            "*://s.frlt.one/search*",
            "*://search.gcomm.ch/searx/search*",
            "*://ooglester.com/search*",
            "*://searx.priv.pw/search*",
            "*://swag.pw/search*",
            "*://search.projectsegfau.lt/search*",
            "*://searx.xyz/search*",
            "*://opnxng.com/search*",
            "*://s.zhaocloud.net/search*",
            "*://searx.catfluori.de/search*",
            "*://searx.cthd.icu/search*",
            "*://intelwinds.com/search*",
            "*://search.drivet.xyz/search*",
            "*://spot.murena.io/search*",
            "*://search.leptons.xyz/searxng/search*",
            "*://searx.si/search*",
            "*://baresearch.org/search*",
            "*://searx.oakleycord.dev/search*",
            "*://search.zzls.xyz/search*",
            "*://searx.sev.monster/search*",
            "*://gsch.eu/search*",
            "*://search.us.projectsegfau.lt/search*",
            "*://searx.rasp.fr/search*",
            "*://s.trung.fun/searxng/search*",
            "*://searxng.bandarawela.net/search*",
            "*://searx.chocoflan.net/searx/search*",
            "*://search.cronobox.one/search*",
            "*://search.charleseroop.com/search*",
            "*://sx.fukt.lol/search*",
            "*://searx.juancord.xyz/searxng/search*",
            "*://searx.delicta.pp.ua/search*",
            "*://searx.esmailelbob.xyz/search*",
            "*://search.privacyguides.net/search*",
            "*://searxng.fingerbib.xyz/searxng/search*",
            "*://search.affusio.com/search*",
            "*://search.suenram.us/searxng/search*",
            "*://searxng.au/search*",
            "*://search.disroot.org/search*",
            "*://searx.fi/search*",
            "*://searx.netzspielplatz.de/search*",
            "*://search.mpx.wtf/search*",
            "*://jackgoss.xyz/search*",
            "*://etsi.me/search*",
            "*://search.uspersec.com/search*",
            "*://search.kiwitalk.de/search*",
            "*://search.0relay.com/search*",
            "*://srx.cosmohub.io/search*",
            "*://privatus.live/search*",
            "*://search.kvj.ovh/search*",
            "*://searx.becomesovran.com/search*",
            "*://searx.gnous.eu/search*",
            "*://searx.orion-hub.fr/search*",
            "*://searx.slipfox.xyz/searx/search*",
            "*://privatesearch.dev/search*",
            "*://searx.ru/search*",
            "*://searx.mastodontech.de/search*",
            "*://searx.dresden.network/search*",
            "*://searx.stuehieyr.com/search*",
            "*://searx.webheberg.info/search*",
            "*://searx.win/search*",
            "*://searx.gnu.style/search*",
            "*://searx.roflcopter.fr/search*",
            "*://sx.catgirl.cloud/search*",
            "*://suche.tromdienste.de/search*",
            "*://search.trom.tf/search*",
            "*://searx.mxchange.org/search*",
            "*://searx.tyil.nl/search*",
            "*://searx.divided-by-zero.eu/search*",
            "*://searx.nakhan.net/search*",
            "*://searx.nixnet.services/search*",
            "*://searx.zapashcanon.fr/search*",
            "*://darmarit.org/searx/search*",
            "*://jsearch.pw/searx/search*",
            "*://gruble.de/search*",
            "*://search.inetol.net/search*",
            "*://search.demoniac.ch/search*",
            "*://search.lvkaszus.pl/search*",
            "*://searxng.diadz.de/search*",
            "*://searx.namejeff.xyz/search*",
            "*://searx.dofpot.nl/search*",
            "*://search.modalogi.com/search*",
            "*://searxng.xcxc.eu/search*",
            "*://searx.tuxcloud.net/search*",
            "*://search.whateveritworks.org/search*",
            "*://copp.gg/search*",
            "*://sarch.im-in.space/search*",
            "*://searxng.se/search*",
            "*://search.laksith.dev/search*",
            "*://searx.ox2.fr/search*",
            "*://search.0xgingi.com/search*",
            "*://search.dojoro.de/search*",
            "*://jabber-germany.de/searx/search*",
            "*://myprivatesrx.us/search*",
            "*://search.bowlman.org/search*",
            "*://search.fascinated.cc/search*",
            "*://stalk.antelope.day/search*",
            "*://searxng.no-logs.com/search*",
            "*://searx.kutay.dev/search*",
            "*://searx.daetalytica.io/search*",
            "*://searx.bissisoft.com/search*",
            "*://search.neet.works/search*",
            "*://offtheradar.info/search*",
            "*://search.shinglea.dev/search*",
            "*://search.listi.me/search*",
            "*://search.serginho.dev/search*",
            "*://searx.netzspielplatz.de/search*",
            "*://searx.thefloatinglab.world/search*",
            "*://search.whatever.social/searxng/search*",
            "*://freesearch.club/search*",
            "*://northboot.xyz/search*",
            "*://nyc1.sx.ggtyler.dev/search*",
            "*://priv.au/search*",
            "*://s.mble.dk/search*",
            "*://s.trung.fun/search*",
            "*://search.broker/search*",
            "*://search.datura.network/search*",
            "*://search.demoniak.ch/search*",
            "*://search.gcomm.ch/search*",
            "*://search.hbubli.cc/search*",
            "*://search.im-in.space/search*",
            "*://search.in.projectsegfau.lt/search*",
            "*://search.inetol.net/search*",
            "*://search.leptons.xyz/search*",
            "*://search.mdosch.de/search*",
            "*://search.nadeko.net/search*",
            "*://search.ononoki.org/search*",
            "*://search.privacyredirect.com/search*",
            "*://search.projectsegfau.lt/search*",
            "*://search.wush.cc/search*",
            "*://search.iswsh.com/search*",
            "*://search.starless.one/search*",
            "*://search.upinmars.com/search*",
            "*://searx.aleteoryx.me/search*",
            "*://searx.ankha.ac/search*",
            "*://searx.ari.lt/search*",
            "*://searx.cthd.icu/search*",
            "*://searx.ee/search*",
            "*://searx.headpat.exchange/search*",
            "*://searx.juancord.xyz/search*",
            "*://searx.lunar.icu/search*",
            "*://searx.nobulart.com/search*",
            "*://searx.perennialte.ch/search*",
            "*://searx.rhscz.eu/search*",
            "*://searx.techsaviours.org/search*",
            "*://searx.zhenyapav.com/search*",
            "*://searxng.brihx.fr/search*",
            "*://searxng.ca/search*",
            "*://searxng.ch/search*",
            "*://searxng.site/search*",
            "*://sex.finaltek.net/search*",
            "*://sx.thatxtreme.dev/search*",
            "*://twinkpad.pl/search*",
            "*://www.gruble.de/search*",
            "*://www.jabber-germany.de/searx/search*"
          ],
          runAt: "document_start"
        }
      ],
      messageNames: {
        name: "searchEngines_searxName"
      }
    },
    startpage: {
      contentScripts: [
        {
          matches: [
            "https://*.startpage.com/do/*",
            "https://*.startpage.com/rvd/*",
            "https://*.startpage.com/sp/*"
          ],
          runAt: "document_idle"
        }
      ],
      messageNames: {
        name: "searchEngines_startpageName"
      }
    },
    yahooJapan: {
      contentScripts: [
        {
          matches: ["https://search.yahoo.co.jp/search?*"],
          runAt: "document_idle"
        }
      ],
      messageNames: {
        name: "searchEngines_yahooJapanName"
      }
    },
    yandex: {
      contentScripts: [
        {
          matches: [
            // Web
            "https://ya.ru/search*",
            "https://yandex.com/search*",
            "https://yandex.ua/search*",
            "https://yandex.by/search*",
            "https://yandex.kz/search*",
            "https://yandex.uz/search*",
            "https://yandex.com.tr/search*",
            "https://yandex.fr/search*",
            "https://yandex.az/search*",
            "https://yandex.com.ge/search*",
            "https://yandex.com.am/search*",
            "https://yandex.co.il/search*",
            "https://yandex.lv/search*",
            "https://yandex.lt/search*",
            "https://yandex.ee/search*",
            "https://yandex.md/search*",
            "https://yandex.tm/search*",
            "https://yandex.tj/search*"
          ],
          runAt: "document_idle"
        }
      ],
      messageNames: {
        name: "searchEngines_yandexName"
      }
    }
  };

  // src/scripts/components/checkbox.tsx
  var import_react23 = __toESM(require_react(), 1);
  var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
  var CheckBox = import_react23.default.forwardRef(
    function CheckBox2({ indeterminate = false, ...props }, ref) {
      const innerRef = useInnerRef(ref);
      (0, import_react23.useLayoutEffect)(() => {
        if (innerRef.current) {
          innerRef.current.indeterminate = indeterminate;
        }
      });
      const wrapperClassName = useClassName(
        () => ({
          height: "16px",
          position: "relative",
          width: "16px"
        }),
        []
      );
      const inputClassName = useClassName(
        () => ({
          cursor: "pointer",
          height: "100%",
          margin: 0,
          opacity: 0,
          position: "absolute",
          width: "100%",
          zIndex: INPUT_Z_INDEX,
          "&:disabled": {
            cursor: "default"
          }
        }),
        []
      );
      const imageClassName = useClassName(
        () => ({
          ":disabled + &": {
            opacity: DISABLED_OPACITY
          }
        }),
        []
      );
      const boxClassNmae = useClassName(
        (theme2) => ({
          border: `solid 2px ${theme2.checkBox.border}`,
          borderRadius: "2px",
          height: "16px",
          left: 0,
          position: "absolute",
          top: 0,
          width: "16px",
          ":checked + * > &, :indeterminate + * > &": {
            background: theme2.checkBox.box,
            border: "none"
          }
        }),
        []
      );
      const checkMarkClassName = useClassName(
        (theme2) => ({
          borderColor: "transparent",
          borderStyle: "solid",
          borderWidth: "0 0 3px 3px",
          height: "8px",
          left: 0,
          position: "absolute",
          top: "3px",
          transform: "rotate(-45deg) scale(0.75)",
          width: "16px",
          ":checked:not(:indeterminate) + * > &": {
            borderColor: theme2.checkBox.checkMark
          }
        }),
        []
      );
      const indeterminateClassName = useClassName(
        (theme2) => ({
          height: "2px",
          left: "3px",
          position: "absolute",
          top: "7px",
          width: "10px",
          ":indeterminate + * > &": {
            backgroundColor: theme2.checkBox.checkMark
          }
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)("div", { className: wrapperClassName, children: [
        /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
          "input",
          {
            ...applyClassName(props, inputClassName),
            ref: innerRef,
            type: "checkbox"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)("div", { className: imageClassName, children: [
          /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("div", { className: boxClassNmae }),
          /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("div", { className: checkMarkClassName }),
          /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("div", { className: indeterminateClassName }),
          /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(FocusCircle, { depth: 1 })
        ] })
      ] });
    }
  );

  // src/scripts/components/dialog.tsx
  var import_react24 = __toESM(require_react(), 1);
  var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
  function getFocusedElement(dialog) {
    return dialog.getRootNode().activeElement;
  }
  function focusDefaultOrStart(dialog) {
    const defaultOrStart = dialog.querySelector(`.${FOCUS_DEFAULT_CLASS}`) || dialog.querySelector(`.${FOCUS_START_CLASS}`);
    if (defaultOrStart instanceof HTMLElement || defaultOrStart instanceof SVGElement) {
      defaultOrStart.focus();
      if (getFocusedElement(dialog) !== defaultOrStart) {
        dialog.focus();
      }
    } else {
      dialog.focus();
    }
  }
  function handleKeyDown(e4, dialog, close) {
    if (e4.nativeEvent.isComposing) {
      return;
    }
    if (e4.key === "Escape") {
      e4.preventDefault();
      close();
    } else if (e4.key === "Tab") {
      if (e4.shiftKey) {
        if (e4.target === dialog || e4.target instanceof HTMLElement && e4.target.matches(`.${FOCUS_START_CLASS}`)) {
          e4.preventDefault();
          dialog.querySelector(`.${FOCUS_END_CLASS}`)?.focus();
        }
      } else {
        if (e4.target instanceof HTMLElement && e4.target.matches(`.${FOCUS_END_CLASS}`)) {
          e4.preventDefault();
          dialog.querySelector(`.${FOCUS_START_CLASS}`)?.focus();
        }
      }
    }
  }
  var Dialog = import_react24.default.forwardRef(
    function Dialog2({ close, open, width = "480px", ...props }, ref) {
      const prevFocus = (0, import_react24.useRef)(null);
      const innerRef = useInnerRef(ref);
      const rootClassName = (0, import_react24.useMemo)(
        () => u.bind({ target: document.head })({
          overflow: "hidden !important"
        }),
        []
      );
      (0, import_react24.useLayoutEffect)(() => {
        if (open) {
          document.documentElement.classList.add(rootClassName);
          prevFocus.current = document.activeElement;
          if (innerRef.current) {
            focusDefaultOrStart(innerRef.current);
          }
        } else {
          if (prevFocus.current instanceof HTMLElement || prevFocus.current instanceof SVGElement) {
            prevFocus.current.focus();
          }
          document.documentElement.classList.remove(rootClassName);
        }
      }, [open]);
      (0, import_react24.useLayoutEffect)(() => {
        if (open && innerRef.current) {
          if (!innerRef.current.contains(getFocusedElement(innerRef.current))) {
            innerRef.current.focus();
          }
        }
      });
      const wrapperClassName = useClassName(
        () => ({
          alignItems: "center",
          background: "rgba(0, 0, 0, 0.6)",
          display: open ? "flex" : "none",
          justifyContent: "center",
          height: "100%",
          left: 0,
          position: "fixed",
          top: 0,
          width: "100%",
          zIndex: DIALOG_Z_INDEX
        }),
        [open]
      );
      const dialogClassName = useClassName(
        (theme2) => ({
          background: theme2.dialog.background,
          borderRadius: "8px",
          boxShadow: "0 0 16px rgba(0, 0, 0, 0.12), 0 16px 16px rgba(0, 0, 0, 0.24)",
          maxHeight: "100%",
          maxWidth: "100%",
          outline: "none",
          overflowY: "auto",
          padding: "1.5em",
          position: "relative",
          width
        }),
        [width]
      );
      return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
        "div",
        {
          className: wrapperClassName,
          tabIndex: -1,
          onPointerDown: (e4) => {
            if (e4.target === e4.currentTarget) {
              close();
            }
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
            "div",
            {
              ...applyClassName(props, dialogClassName),
              "aria-modal": open,
              ref: innerRef,
              role: "dialog",
              tabIndex: -1,
              onKeyDown: (e4) => {
                e4.stopPropagation();
                if (innerRef.current) {
                  handleKeyDown(e4, innerRef.current, close);
                }
              },
              onKeyPress: (e4) => e4.stopPropagation(),
              onKeyUp: (e4) => e4.stopPropagation()
            }
          )
        }
      );
    }
  );
  var DialogHeader = import_react24.default.forwardRef(
    function DialogHeader2(props, ref) {
      const className = useClassName(
        () => ({
          marginBottom: "1em"
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("div", { ...applyClassName(props, className), ref });
    }
  );
  var DialogTitle = import_react24.default.forwardRef(function DialogTitle2({ children, ...props }, ref) {
    const className = useClassName(
      () => ({
        fontSize: "1.125em",
        fontWeight: "normal",
        margin: 0,
        overflowWrap: "break-word"
      }),
      []
    );
    return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("h1", { ...applyClassName(props, className), ref, children });
  });
  var DialogBody = import_react24.default.forwardRef(
    function DialogBody2(props, ref) {
      return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("div", { ...props, ref });
    }
  );
  var DialogFooter = import_react24.default.forwardRef(
    function DialogFooter2(props, ref) {
      const className = useClassName(
        () => ({
          marginTop: "2em"
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("div", { ...applyClassName(props, className), ref });
    }
  );
  var EmbeddedDialog = import_react24.default.forwardRef(function EmbeddedDialog2({ close, width, ...props }, ref) {
    const innerRef = useInnerRef(ref);
    (0, import_react24.useLayoutEffect)(() => {
      if (innerRef.current) {
        focusDefaultOrStart(innerRef.current);
      }
    }, []);
    const className = useClassName(
      (theme2) => ({
        background: theme2.dialog.background,
        outline: "none",
        padding: "1.5em",
        ...false ? {
          [`@media (min-device-width: ${width})`]: {
            minWidth: width
          }
        } : {
          maxWidth: "100%",
          width
        }
      }),
      [width]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
      "div",
      {
        ...applyClassName(props, className),
        ref: innerRef,
        tabIndex: -1,
        onKeyDown: (e4) => {
          if (innerRef.current) {
            handleKeyDown(e4, innerRef.current, close);
          }
        }
      }
    );
  });

  // src/scripts/components/portal.tsx
  var import_react_dom = __toESM(require_react_dom(), 1);
  var Portal = ({ children, id: id2 }) => {
    let root = document.getElementById(id2);
    if (!root) {
      root = document.body.appendChild(document.createElement("div"));
      root.id = id2;
    }
    return import_react_dom.default.createPortal(children, root);
  };

  // src/scripts/components/text.tsx
  var import_react25 = __toESM(require_react(), 1);
  var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
  var Text2 = import_react25.default.forwardRef(function Text3({ primary = false, ...props }, ref) {
    const className = useClassName(
      (theme2) => ({
        color: primary ? theme2.text.primary : theme2.text.secondary
      }),
      [primary]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("span", { ...applyClassName(props, className), ref });
  });

  // src/scripts/components/textarea.tsx
  var import_react26 = __toESM(require_react(), 1);
  var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
  var TextArea = import_react26.default.forwardRef(
    function TextArea2({ breakAll = false, ...props }, ref) {
      const className = useClassName(
        (theme2) => ({
          background: "transparent",
          border: `solid 1px ${theme2.textArea.border}`,
          borderRadius: "4px",
          color: theme2.text.primary,
          display: "block",
          font: "inherit",
          height: props.rows != null ? `calc(1.5em * ${props.rows} + 1em + 2px)` : "auto",
          lineHeight: "1.5",
          padding: "0.5em 0.625em",
          resize: "none",
          width: "100%",
          wordBreak: breakAll ? "break-all" : "normal",
          "&:disabled": {
            opacity: DISABLED_OPACITY
          },
          "&:focus": {
            boxShadow: `0 0 0 2px ${theme2.focus.shadow}`,
            outline: "none"
          },
          "&:read-only": {
            color: theme2.text.secondary
          }
        }),
        [breakAll, props.rows]
      );
      return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("textarea", { ...applyClassName(props, className), ref });
    }
  );

  // node_modules/.pnpm/@codemirror+commands@6.6.0/node_modules/@codemirror/commands/dist/index.js
  var fromHistory = /* @__PURE__ */ Annotation.define();
  var isolateHistory = /* @__PURE__ */ Annotation.define();
  var invertedEffects = /* @__PURE__ */ Facet.define();
  var historyConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        minDepth: 100,
        newGroupDelay: 500,
        joinToEvent: (_t, isAdjacent2) => isAdjacent2
      }, {
        minDepth: Math.max,
        newGroupDelay: Math.min,
        joinToEvent: (a4, b4) => (tr, adj) => a4(tr, adj) || b4(tr, adj)
      });
    }
  });
  var historyField_ = /* @__PURE__ */ StateField.define({
    create() {
      return HistoryState.empty;
    },
    update(state, tr) {
      let config = tr.state.facet(historyConfig);
      let fromHist = tr.annotation(fromHistory);
      if (fromHist) {
        let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;
        let other = from == 0 ? state.undone : state.done;
        if (item)
          other = updateBranch(other, other.length, config.minDepth, item);
        else
          other = addSelection(other, tr.startState.selection);
        return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
      }
      let isolate = tr.annotation(isolateHistory);
      if (isolate == "full" || isolate == "before")
        state = state.isolate();
      if (tr.annotation(Transaction.addToHistory) === false)
        return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
      let event = HistEvent.fromTransaction(tr);
      let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
      if (event)
        state = state.addChanges(event, time, userEvent, config, tr);
      else if (tr.selection)
        state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);
      if (isolate == "full" || isolate == "after")
        state = state.isolate();
      return state;
    },
    toJSON(value) {
      return { done: value.done.map((e4) => e4.toJSON()), undone: value.undone.map((e4) => e4.toJSON()) };
    },
    fromJSON(json2) {
      return new HistoryState(json2.done.map(HistEvent.fromJSON), json2.undone.map(HistEvent.fromJSON));
    }
  });
  function history(config = {}) {
    return [
      historyField_,
      historyConfig.of(config),
      EditorView.domEventHandlers({
        beforeinput(e4, view) {
          let command = e4.inputType == "historyUndo" ? undo : e4.inputType == "historyRedo" ? redo : null;
          if (!command)
            return false;
          e4.preventDefault();
          return command(view);
        }
      })
    ];
  }
  function cmd(side, selection) {
    return function({ state, dispatch }) {
      if (!selection && state.readOnly)
        return false;
      let historyState = state.field(historyField_, false);
      if (!historyState)
        return false;
      let tr = historyState.pop(side, state, selection);
      if (!tr)
        return false;
      dispatch(tr);
      return true;
    };
  }
  var undo = /* @__PURE__ */ cmd(0, false);
  var redo = /* @__PURE__ */ cmd(1, false);
  var undoSelection = /* @__PURE__ */ cmd(0, true);
  var redoSelection = /* @__PURE__ */ cmd(1, true);
  var HistEvent = class _HistEvent {
    constructor(changes, effects, mapped, startSelection, selectionsAfter) {
      this.changes = changes;
      this.effects = effects;
      this.mapped = mapped;
      this.startSelection = startSelection;
      this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
      return new _HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
      var _a2, _b, _c;
      return {
        changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
        mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
        startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
        selectionsAfter: this.selectionsAfter.map((s4) => s4.toJSON())
      };
    }
    static fromJSON(json2) {
      return new _HistEvent(json2.changes && ChangeSet.fromJSON(json2.changes), [], json2.mapped && ChangeDesc.fromJSON(json2.mapped), json2.startSelection && EditorSelection.fromJSON(json2.startSelection), json2.selectionsAfter.map(EditorSelection.fromJSON));
    }
    // This does not check `addToHistory` and such, it assumes the
    // transaction needs to be converted to an item. Returns null when
    // there are no changes or effects in the transaction.
    static fromTransaction(tr, selection) {
      let effects = none2;
      for (let invert of tr.startState.facet(invertedEffects)) {
        let result = invert(tr);
        if (result.length)
          effects = effects.concat(result);
      }
      if (!effects.length && tr.changes.empty)
        return null;
      return new _HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection || tr.startState.selection, none2);
    }
    static selection(selections) {
      return new _HistEvent(void 0, none2, void 0, void 0, selections);
    }
  };
  function updateBranch(branch, to, maxLen, newEvent) {
    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    let newBranch = branch.slice(start, to);
    newBranch.push(newEvent);
    return newBranch;
  }
  function isAdjacent(a4, b4) {
    let ranges = [], isAdjacent2 = false;
    a4.iterChangedRanges((f3, t5) => ranges.push(f3, t5));
    b4.iterChangedRanges((_f, _t, f3, t5) => {
      for (let i4 = 0; i4 < ranges.length; ) {
        let from = ranges[i4++], to = ranges[i4++];
        if (t5 >= from && f3 <= to)
          isAdjacent2 = true;
      }
    });
    return isAdjacent2;
  }
  function eqSelectionShape(a4, b4) {
    return a4.ranges.length == b4.ranges.length && a4.ranges.filter((r3, i4) => r3.empty != b4.ranges[i4].empty).length === 0;
  }
  function conc(a4, b4) {
    return !a4.length ? b4 : !b4.length ? a4 : a4.concat(b4);
  }
  var none2 = [];
  var MaxSelectionsPerEvent = 200;
  function addSelection(branch, selection) {
    if (!branch.length) {
      return [HistEvent.selection([selection])];
    } else {
      let lastEvent = branch[branch.length - 1];
      let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
      if (sels.length && sels[sels.length - 1].eq(selection))
        return branch;
      sels.push(selection);
      return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
  }
  function popSelection(branch) {
    let last = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
    return newBranch;
  }
  function addMappingToBranch(branch, mapping) {
    if (!branch.length)
      return branch;
    let length = branch.length, selections = none2;
    while (length) {
      let event = mapEvent(branch[length - 1], mapping, selections);
      if (event.changes && !event.changes.empty || event.effects.length) {
        let result = branch.slice(0, length);
        result[length - 1] = event;
        return result;
      } else {
        mapping = event.mapped;
        length--;
        selections = event.selectionsAfter;
      }
    }
    return selections.length ? [HistEvent.selection(selections)] : none2;
  }
  function mapEvent(event, mapping, extraSelections) {
    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s4) => s4.map(mapping)) : none2, extraSelections);
    if (!event.changes)
      return HistEvent.selection(selections);
    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
  }
  var joinableUserEvent = /^(input\.type|delete)($|\.)/;
  var HistoryState = class _HistoryState {
    constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
      this.done = done;
      this.undone = undone;
      this.prevTime = prevTime;
      this.prevUserEvent = prevUserEvent;
    }
    isolate() {
      return this.prevTime ? new _HistoryState(this.done, this.undone) : this;
    }
    addChanges(event, time, userEvent, config, tr) {
      let done = this.done, lastEvent = done[done.length - 1];
      if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event
      userEvent == "input.type.compose")) {
        done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none2));
      } else {
        done = updateBranch(done, done.length, config.minDepth, event);
      }
      return new _HistoryState(done, none2, time, userEvent);
    }
    addSelection(selection, time, userEvent, newGroupDelay) {
      let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none2;
      if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection))
        return this;
      return new _HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
    }
    addMapping(mapping) {
      return new _HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state, onlySelection) {
      let branch = side == 0 ? this.done : this.undone;
      if (branch.length == 0)
        return null;
      let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;
      if (onlySelection && event.selectionsAfter.length) {
        return state.update({
          selection: event.selectionsAfter[event.selectionsAfter.length - 1],
          annotations: fromHistory.of({ side, rest: popSelection(branch), selection }),
          userEvent: side == 0 ? "select.undo" : "select.redo",
          scrollIntoView: true
        });
      } else if (!event.changes) {
        return null;
      } else {
        let rest = branch.length == 1 ? none2 : branch.slice(0, branch.length - 1);
        if (event.mapped)
          rest = addMappingToBranch(rest, event.mapped);
        return state.update({
          changes: event.changes,
          selection: event.startSelection,
          effects: event.effects,
          annotations: fromHistory.of({ side, rest, selection }),
          filter: false,
          userEvent: side == 0 ? "undo" : "redo",
          scrollIntoView: true
        });
      }
    }
  };
  HistoryState.empty = /* @__PURE__ */ new HistoryState(none2, none2);
  var historyKeymap = [
    { key: "Mod-z", run: undo, preventDefault: true },
    { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
    { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
    { key: "Mod-u", run: undoSelection, preventDefault: true },
    { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
  ];
  function updateSel(sel, by) {
    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
  }
  function setSel(state, selection) {
    return state.update({ selection, scrollIntoView: true, userEvent: "select" });
  }
  function moveSel({ state, dispatch }, how) {
    let selection = updateSel(state.selection, how);
    if (selection.eq(state.selection, true))
      return false;
    dispatch(setSel(state, selection));
    return true;
  }
  function rangeEnd(range, forward) {
    return EditorSelection.cursor(forward ? range.to : range.from);
  }
  function cursorByChar(view, forward) {
    return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
  }
  function ltrAtCursor(view) {
    return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
  }
  var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
  var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
  function cursorByGroup(view, forward) {
    return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
  }
  var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
  var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
  var segmenter = typeof Intl != "undefined" && Intl.Segmenter ? /* @__PURE__ */ new Intl.Segmenter(void 0, { granularity: "word" }) : null;
  function cursorByLine(view, forward) {
    return moveSel(view, (range) => {
      if (!range.empty)
        return rangeEnd(range, forward);
      let moved = view.moveVertically(range, forward);
      return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
    });
  }
  var cursorLineUp = (view) => cursorByLine(view, false);
  var cursorLineDown = (view) => cursorByLine(view, true);
  function pageInfo(view) {
    let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
    let marginTop = 0, marginBottom = 0, height;
    if (selfScroll) {
      for (let source of view.state.facet(EditorView.scrollMargins)) {
        let margins = source(view);
        if (margins === null || margins === void 0 ? void 0 : margins.top)
          marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
        if (margins === null || margins === void 0 ? void 0 : margins.bottom)
          marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
      }
      height = view.scrollDOM.clientHeight - marginTop - marginBottom;
    } else {
      height = (view.dom.ownerDocument.defaultView || window).innerHeight;
    }
    return {
      marginTop,
      marginBottom,
      selfScroll,
      height: Math.max(view.defaultLineHeight, height - 5)
    };
  }
  function cursorByPage(view, forward) {
    let page = pageInfo(view);
    let { state } = view, selection = updateSel(state.selection, (range) => {
      return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
    });
    if (selection.eq(state.selection))
      return false;
    let effect;
    if (page.selfScroll) {
      let startPos = view.coordsAtPos(state.selection.main.head);
      let scrollRect = view.scrollDOM.getBoundingClientRect();
      let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
      if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
        effect = EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollTop });
    }
    view.dispatch(setSel(state, selection), { effects: effect });
    return true;
  }
  var cursorPageUp = (view) => cursorByPage(view, false);
  var cursorPageDown = (view) => cursorByPage(view, true);
  function moveByLineBoundary(view, start, forward) {
    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
      moved = view.moveToLineBoundary(start, forward, false);
    if (!forward && moved.head == line.from && line.length) {
      let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
      if (space && start.head != line.from + space)
        moved = EditorSelection.cursor(line.from + space);
    }
    return moved;
  }
  var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
  var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
  var cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
  var cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
  var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
  var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
  function extendSel(view, how) {
    let selection = updateSel(view.state.selection, (range) => {
      let head = how(range);
      return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
    });
    if (selection.eq(view.state.selection))
      return false;
    view.dispatch(setSel(view.state, selection));
    return true;
  }
  function selectByChar(view, forward) {
    return extendSel(view, (range) => view.moveByChar(range, forward));
  }
  var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
  var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
  function selectByGroup(view, forward) {
    return extendSel(view, (range) => view.moveByGroup(range, forward));
  }
  var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
  var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
  function selectByLine(view, forward) {
    return extendSel(view, (range) => view.moveVertically(range, forward));
  }
  var selectLineUp = (view) => selectByLine(view, false);
  var selectLineDown = (view) => selectByLine(view, true);
  function selectByPage(view, forward) {
    return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
  }
  var selectPageUp = (view) => selectByPage(view, false);
  var selectPageDown = (view) => selectByPage(view, true);
  var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
  var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
  var selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
  var selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
  var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
  var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
  var cursorDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: 0 }));
    return true;
  };
  var cursorDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.doc.length }));
    return true;
  };
  var selectDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
    return true;
  };
  var selectDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
    return true;
  };
  var selectAll = ({ state, dispatch }) => {
    dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
    return true;
  };
  function deleteBy(target, by) {
    if (target.state.readOnly)
      return false;
    let event = "delete.selection", { state } = target;
    let changes = state.changeByRange((range) => {
      let { from, to } = range;
      if (from == to) {
        let towards = by(range);
        if (towards < from) {
          event = "delete.backward";
          towards = skipAtomic(target, towards, false);
        } else if (towards > from) {
          event = "delete.forward";
          towards = skipAtomic(target, towards, true);
        }
        from = Math.min(from, towards);
        to = Math.max(to, towards);
      } else {
        from = skipAtomic(target, from, false);
        to = skipAtomic(target, to, true);
      }
      return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from, from < range.head ? -1 : 1) };
    });
    if (changes.changes.empty)
      return false;
    target.dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: event,
      effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
    }));
    return true;
  }
  function skipAtomic(target, pos, forward) {
    if (target instanceof EditorView)
      for (let ranges of target.state.facet(EditorView.atomicRanges).map((f3) => f3(target)))
        ranges.between(pos, pos, (from, to) => {
          if (from < pos && to > pos)
            pos = forward ? to : from;
        });
    return pos;
  }
  var deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, (range) => {
    let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;
    if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
      if (before[before.length - 1] == "	")
        return pos - 1;
      let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
      for (let i4 = 0; i4 < drop && before[before.length - 1 - i4] == " "; i4++)
        pos--;
      targetPos = pos;
    } else {
      targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
      if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
        targetPos += forward ? 1 : -1;
      else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
        targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;
    }
    return targetPos;
  });
  var deleteCharBackward = (view) => deleteByChar(view, false, true);
  var deleteCharForward = (view) => deleteByChar(view, true, false);
  var deleteByGroup = (target, forward) => deleteBy(target, (range) => {
    let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
    let categorize = state.charCategorizer(pos);
    for (let cat = null; ; ) {
      if (pos == (forward ? line.to : line.from)) {
        if (pos == range.head && line.number != (forward ? state.doc.lines : 1))
          pos += forward ? 1 : -1;
        break;
      }
      let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
      let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
      let nextCat = categorize(nextChar);
      if (cat != null && nextCat != cat)
        break;
      if (nextChar != " " || pos != range.head)
        cat = nextCat;
      pos = next;
    }
    return pos;
  });
  var deleteGroupBackward = (target) => deleteByGroup(target, false);
  var deleteGroupForward = (target) => deleteByGroup(target, true);
  var deleteToLineEnd = (view) => deleteBy(view, (range) => {
    let lineEnd = view.lineBlockAt(range.head).to;
    return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);
  });
  var deleteLineBoundaryBackward = (view) => deleteBy(view, (range) => {
    let lineStart = view.moveToLineBoundary(range, false).head;
    return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
  });
  var deleteLineBoundaryForward = (view) => deleteBy(view, (range) => {
    let lineStart = view.moveToLineBoundary(range, true).head;
    return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
  });
  var splitLine = ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      return {
        changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
        range: EditorSelection.cursor(range.from)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
  var transposeChars = ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      if (!range.empty || range.from == 0 || range.from == state.doc.length)
        return { range };
      let pos = range.from, line = state.doc.lineAt(pos);
      let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
      let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
      return {
        changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
        range: EditorSelection.cursor(to)
      };
    });
    if (changes.changes.empty)
      return false;
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
    return true;
  };
  function isBetweenBrackets(state, pos) {
    if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
      return { from: pos, to: pos };
    let context = syntaxTree(state).resolveInner(pos);
    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from)))
      return { from: before.to, to: after.from };
    return null;
  }
  var insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
  function newlineAndIndent(atEof) {
    return ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      let changes = state.changeByRange((range) => {
        let { from, to } = range, line = state.doc.lineAt(from);
        let explode = !atEof && from == to && isBetweenBrackets(state, from);
        if (atEof)
          from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
        let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
        let indent = getIndentation(cx, from);
        if (indent == null)
          indent = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
        while (to < line.to && /\s/.test(line.text[to - line.from]))
          to++;
        if (explode)
          ({ from, to } = explode);
        else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
          from = line.from;
        let insert2 = ["", indentString(state, indent)];
        if (explode)
          insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
        return {
          changes: { from, to, insert: Text.of(insert2) },
          range: EditorSelection.cursor(from + 1 + insert2[1].length)
        };
      });
      dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
      return true;
    };
  }
  var emacsStyleKeymap = [
    { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
    { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
    { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
    { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
    { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
    { key: "Ctrl-d", run: deleteCharForward },
    { key: "Ctrl-h", run: deleteCharBackward },
    { key: "Ctrl-k", run: deleteToLineEnd },
    { key: "Ctrl-Alt-h", run: deleteGroupBackward },
    { key: "Ctrl-o", run: splitLine },
    { key: "Ctrl-t", run: transposeChars },
    { key: "Ctrl-v", run: cursorPageDown }
  ];
  var standardKeymap = /* @__PURE__ */ [
    { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
    { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
    { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
    { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
    { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
    { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
    { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
    { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
    { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
    { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
    { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
    { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
    { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
    { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
    { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
    { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
    { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
    { key: "Enter", run: insertNewlineAndIndent },
    { key: "Mod-a", run: selectAll },
    { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
    { key: "Delete", run: deleteCharForward },
    { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
    { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
    { mac: "Mod-Backspace", run: deleteLineBoundaryBackward },
    { mac: "Mod-Delete", run: deleteLineBoundaryForward }
  ].concat(/* @__PURE__ */ emacsStyleKeymap.map((b4) => ({ mac: b4.key, run: b4.run, shift: b4.shift })));

  // src/scripts/components/editor.tsx
  var import_react27 = __toESM(require_react(), 1);
  var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
  var darkColorScheme = {
    background: "#202124",
    foreground: "#e8e8d3",
    selectionBackground: "#2e2e2e",
    lineNumberForeground: "#858585",
    activeLineNumberForeground: "#fabb6e",
    comment: "#888888",
    name: "#fabb6e",
    literal: "#cf6a4c",
    string: "#99ad6a",
    keyword: "#8197bf",
    operator: "#ffe2a9",
    meta: "#8fbfdc"
  };
  var lightColorScheme = {
    background: "#f8f9fa",
    foreground: "#000",
    selectionBackground: "#bcbcbc",
    lineNumberForeground: "#bcbcbc",
    activeLineNumberForeground: "#5f5f00",
    comment: "#5f5f5f",
    name: "#875f00",
    literal: "#5f0000",
    string: "#005f00",
    keyword: "#00005f",
    operator: "#8abeb7",
    meta: "#005f5f"
  };
  var Editor = ({
    focusStart = false,
    focusEnd = false,
    height = "200px",
    language: lang,
    readOnly: readOnly2 = false,
    resizable = false,
    value = "",
    onChange
  }) => {
    const view = (0, import_react27.useRef)(null);
    const resizeObserver = (0, import_react27.useRef)(null);
    const highlightStyleCompartment = (0, import_react27.useRef)(new Compartment());
    const languageCompartment = (0, import_react27.useRef)(new Compartment());
    const readOnlyCompartment = (0, import_react27.useRef)(new Compartment());
    const themeCompartment = (0, import_react27.useRef)(new Compartment());
    const updateListenerCompartment = (0, import_react27.useRef)(new Compartment());
    const parentCallback = (0, import_react27.useCallback)((parent) => {
      if (parent) {
        view.current = new EditorView({
          state: EditorState.create({
            doc: value,
            // Set the initial value to prevent undo from going back to empty
            extensions: [
              keymap.of([...standardKeymap, ...historyKeymap]),
              history(),
              lintGutter(),
              lineNumbers(),
              highlightActiveLineGutter(),
              highlightSpecialChars(),
              highlightStyleCompartment.current.of([]),
              languageCompartment.current.of([]),
              readOnlyCompartment.current.of([]),
              themeCompartment.current.of([]),
              updateListenerCompartment.current.of([])
            ]
          }),
          parent
        });
        resizeObserver.current = new ResizeObserver(() => {
          view.current?.requestMeasure();
        });
        resizeObserver.current.observe(view.current.dom);
      } else {
        resizeObserver.current?.disconnect();
        view.current?.destroy();
      }
    }, []);
    (0, import_react27.useLayoutEffect)(() => {
      view.current?.contentDOM.classList.toggle(FOCUS_START_CLASS, focusStart);
    }, [focusStart]);
    (0, import_react27.useLayoutEffect)(() => {
      view.current?.contentDOM.classList.toggle(FOCUS_END_CLASS, focusEnd);
    }, [focusEnd]);
    const theme2 = useTheme();
    (0, import_react27.useLayoutEffect)(() => {
      const colorScheme = theme2.name === "dark" ? darkColorScheme : lightColorScheme;
      view.current?.dispatch({
        effects: highlightStyleCompartment.current.reconfigure(
          syntaxHighlighting(
            HighlightStyle.define([
              { tag: tags.comment, color: colorScheme.comment },
              { tag: tags.name, color: colorScheme.name },
              { tag: tags.literal, color: colorScheme.literal },
              { tag: tags.string, color: colorScheme.string },
              { tag: tags.regexp, color: colorScheme.string },
              { tag: tags.keyword, color: colorScheme.keyword },
              { tag: tags.operator, color: colorScheme.operator },
              { tag: tags.meta, color: colorScheme.meta }
            ])
          )
        )
      });
    }, [theme2]);
    (0, import_react27.useLayoutEffect)(() => {
      view.current?.dispatch({
        effects: languageCompartment.current.reconfigure(lang || [])
      });
    }, [lang]);
    (0, import_react27.useLayoutEffect)(() => {
      view.current?.dispatch({
        effects: readOnlyCompartment.current.reconfigure(
          EditorState.readOnly.of(readOnly2)
        )
      });
    }, [readOnly2]);
    (0, import_react27.useLayoutEffect)(() => {
      const colorScheme = theme2.name === "dark" ? darkColorScheme : lightColorScheme;
      view.current?.dispatch({
        effects: themeCompartment.current.reconfigure(
          EditorView.theme(
            {
              "&": {
                backgroundColor: colorScheme.background,
                border: `1px solid ${theme2.editor.border}`,
                color: colorScheme.foreground,
                height,
                overflow: "hidden",
                resize: resizable ? "vertical" : "none"
              },
              "&.cm-editor.cm-focused": {
                boxShadow: `0 0 0 2px ${theme2.focus.shadow}`,
                outline: "none"
              },
              ".cm-scroller": {
                fontFamily: 'ui-monospace,SFMono-Regular,"SF Mono",Menlo,Consolas,"Liberation Mono",monospace',
                overflow: "auto"
              },
              ".cm-gutters": {
                backgroundColor: "transparent",
                border: "none",
                color: colorScheme.lineNumberForeground
              },
              ".cm-activeLineGutter": {
                backgroundColor: "transparent"
              },
              "&.cm-focused .cm-activeLineGutter": {
                color: colorScheme.activeLineNumberForeground
              },
              ".cm-lineNumbers .cm-gutterElement": {
                padding: "0 8px"
              },
              ".cm-content ::selection": {
                backgroundColor: colorScheme.selectionBackground
              }
            },
            { dark: theme2.name === "dark" }
          )
        )
      });
    }, [height, resizable, theme2]);
    (0, import_react27.useLayoutEffect)(() => {
      view.current?.dispatch({
        effects: updateListenerCompartment.current.reconfigure(
          onChange ? EditorView.updateListener.of((viewUpdate) => {
            if (viewUpdate.docChanged && viewUpdate.transactions.some(
              (transaction) => transaction.annotation(Transaction.userEvent) != null
            )) {
              onChange(viewUpdate.state.doc.toString());
            }
          }) : []
        )
      });
    }, [onChange]);
    (0, import_react27.useEffect)(() => {
      if (view.current) {
        const currentValue = view.current.state.doc.toString();
        if (value !== currentValue) {
          view.current.dispatch(
            view.current.state.update({
              changes: {
                from: 0,
                to: currentValue.length,
                insert: value
              }
            })
          );
        }
      }
    }, [value]);
    return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("div", { ref: parentCallback });
  };

  // src/scripts/options/ruleset-editor.tsx
  var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
  var RulesetEditor = (props) => /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(Editor, { language: ruleset(), ...props });

  // node_modules/.pnpm/@mdi+svg@7.4.47/node_modules/@mdi/svg/svg/menu-down.svg
  var menu_down_default = '<svg xmlns="http://www.w3.org/2000/svg" id="mdi-menu-down" viewBox="0 0 24 24"><path d="M7,10L12,15L17,10H7Z" /></svg>';

  // src/scripts/components/select.tsx
  var import_react28 = __toESM(require_react(), 1);
  var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
  var SelectContext = import_react28.default.createContext(null);
  function useSelectContext() {
    const value = (0, import_react28.useContext)(SelectContext);
    if (!value) {
      throw new Error("useSelectContext: no matching provider");
    }
    return value;
  }
  var Select = import_react28.default.forwardRef(
    function Select2({ native = false, ...props }, ref) {
      const theme2 = useTheme();
      const wrapperClassName = useClassName(
        () => ({
          position: "relative"
        }),
        []
      );
      const selectClassName = useClassName(
        (theme3) => ({
          appearance: "none",
          WebkitAppearance: "none",
          background: "transparent",
          border: `solid 1px ${theme3.select.border}`,
          borderRadius: "4px",
          color: theme3.text.primary,
          cursor: "pointer",
          display: "block",
          font: "inherit",
          lineHeight: "1.5",
          padding: "0.5em calc(0.625em + 24px) 0.5em 0.625em",
          width: "15em",
          "&:disabled": {
            cursor: "default",
            opacity: DISABLED_OPACITY
          },
          "&:focus": {
            boxShadow: `0 0 0 2px ${theme3.focus.shadow}`,
            outline: "none"
          }
        }),
        []
      );
      const arrowClassName = useClassName(
        () => ({
          pointerEvents: "none",
          position: "absolute",
          right: "1px",
          top: "calc((100% - 24px) / 2)"
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(SelectContext.Provider, { value: { native }, children: /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)("div", { className: wrapperClassName, children: [
        /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("select", { ...applyClassName(props, selectClassName), ref }),
        /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("div", { className: arrowClassName, children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
          TemplateIcon,
          {
            color: theme2.select.arrow,
            iconSize: "24px",
            url: svgToDataURL(menu_down_default)
          }
        ) })
      ] }) });
    }
  );
  var SelectOption = import_react28.default.forwardRef(function SelectOption2(props, ref) {
    const { native } = useSelectContext();
    const className = useClassName(
      (theme2) => ({
        background: native ? "transparent" : theme2.select.optionBackground,
        color: native ? "initial" : "inherit"
      }),
      [native]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("option", { ...applyClassName(props, className), ref });
  });

  // src/scripts/options/select.tsx
  var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
  var Select3 = (props) => {
    const {
      platformInfo: { os }
    } = useOptionsContext();
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Select, { ...props, native: os !== "win" });
  };

  // src/scripts/options/set-boolean-item.tsx
  var import_react30 = __toESM(require_react(), 1);

  // src/scripts/components/switch.tsx
  var import_react29 = __toESM(require_react(), 1);
  var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
  var Switch = import_react29.default.forwardRef(
    function Switch2(props, ref) {
      const wrapperClassName = useClassName(
        () => ({
          height: "16px",
          position: "relative",
          width: "34px"
        }),
        []
      );
      const inputClassName = useClassName(
        () => ({
          cursor: "pointer",
          height: "100%",
          margin: 0,
          opacity: 0,
          position: "absolute",
          width: "100%",
          zIndex: INPUT_Z_INDEX,
          "&:disabled": {
            cursor: "default"
          }
        }),
        []
      );
      const backgroundClassName = useClassName(
        () => ({
          ":disabled + &": {
            opacity: DISABLED_OPACITY
          }
        }),
        []
      );
      const barClassName = useClassName(
        (theme2) => ({
          background: theme2.switch.bar,
          borderRadius: "8px",
          height: "12px",
          left: "3px",
          position: "absolute",
          top: "2px",
          transition: "background-color linear 80ms",
          width: "28px",
          ":checked + * > &": {
            background: theme2.switch.barChecked
          }
        }),
        []
      );
      const knobMoverClassName = useClassName(
        () => ({
          left: 0,
          position: "absolute",
          top: 0,
          transition: "left linear 80ms",
          ":checked + * > &": {
            left: "18px"
          }
        }),
        []
      );
      const knobClassName = useClassName(
        (theme2) => ({
          background: theme2.switch.knob,
          border: theme2.switch.knobBorder != null ? `solid 1px ${theme2.switch.knobBorder}` : "none",
          borderRadius: "50%",
          height: "16px",
          transition: "background linear 80ms, border linear 80ms",
          width: "16px",
          ":checked + * > * > &": {
            background: theme2.switch.knobChecked,
            border: "none"
          }
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("div", { className: wrapperClassName, children: [
        /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
          "input",
          {
            ...applyClassName(props, inputClassName),
            ref,
            type: "checkbox"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("div", { className: backgroundClassName, children: [
          /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("div", { className: barClassName }),
          /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("div", { className: knobMoverClassName, children: [
            /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("div", { className: knobClassName }),
            /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(FocusCircle, { depth: 2 })
          ] })
        ] })
      ] });
    }
  );

  // src/scripts/options/set-boolean-item.tsx
  var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
  var SetBooleanItem = ({ disabled = false, itemKey, label, subLabels = [] }) => {
    const {
      initialItems: { [itemKey]: initialItem }
    } = useOptionsContext();
    const [item, setItem] = (0, import_react30.useState)(initialItem);
    const css = useCSS();
    const rowClass = (0, import_react30.useMemo)(
      () => css({
        "&&": {
          minHeight: "2.5em"
        }
      }),
      [css]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(Row, { className: rowClass, children: [
      /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(LabelWrapper, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(ControlLabel, { for: itemKey, children: label }),
        subLabels.map((subLabel) => /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(SubLabel, { children: subLabel }, subLabel))
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
        Switch,
        {
          checked: item,
          disabled,
          id: itemKey,
          onChange: (e4) => {
            const value = e4.currentTarget.checked;
            void saveToLocalStorage(
              { [itemKey]: value },
              "options"
            );
            setItem(value);
          }
        }
      ) })
    ] });
  };

  // src/scripts/options/general-section.tsx
  var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
  var ImportBlacklistDialog = ({ close, open, setBlacklist, setBlacklistDirty }) => {
    const [state, setState] = (0, import_react31.useState)({
      source: "file",
      pb: "",
      append: false
    });
    const prevOpen = usePrevious(open);
    if (open && !prevOpen) {
      state.source = "file";
      state.pb = "";
      state.append = false;
    }
    const replaceOrAppend = (newBlacklist) => {
      if (state.append) {
        setBlacklist(
          (oldBlacklist) => `${oldBlacklist}${oldBlacklist && newBlacklist ? "\n" : ""}${newBlacklist}`
        );
      } else {
        setBlacklist(() => newBlacklist);
      }
      setBlacklistDirty(true);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(
      Dialog,
      {
        "aria-labelledby": "importBlacklistDialogTitle",
        close,
        open,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(DialogHeader, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(DialogTitle, { id: "importBlacklistDialogTitle", children: translate("options_importBlacklistDialog_title") }) }),
          /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(DialogBody, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Row, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(
              Select3,
              {
                className: FOCUS_START_CLASS,
                value: state.source,
                onChange: (e4) => {
                  const { value } = e4.currentTarget;
                  setState((s4) => ({
                    ...s4,
                    source: value
                  }));
                },
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SelectOption, { value: "file", children: translate("options_importBlacklistDialog_fromFile") }),
                  /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SelectOption, { value: "pb", children: translate("options_importBlacklistDialog_fromPB") })
                ]
              }
            ) }) }),
            state.source === "pb" && /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Row, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(RowItem, { expanded: true, children: [
              /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(LabelWrapper, { fullWidth: true, children: [
                /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SubLabel, { children: translate("options_importBlacklistDialog_helper") }),
                /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SubLabel, { children: translate("options_blacklistExample", "example.com") })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
                TextArea,
                {
                  "aria-label": translate("options_importBlacklistDialog_pbLabel"),
                  rows: 5,
                  spellCheck: "false",
                  value: state.pb,
                  wrap: "off",
                  onChange: (e4) => {
                    const { value } = e4.currentTarget;
                    setState((s4) => ({ ...s4, pb: value }));
                  }
                }
              )
            ] }) }),
            /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(Row, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Indent, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
                CheckBox,
                {
                  checked: state.append,
                  id: "append",
                  onChange: (e4) => {
                    const { checked } = e4.currentTarget;
                    setState((s4) => ({ ...s4, append: checked }));
                  }
                }
              ) }) }),
              /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(LabelWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(ControlLabel, { for: "append", children: translate("options_importBlacklistDialog_append") }) }) })
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(DialogFooter, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(Row, { right: true, children: [
            /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
              Button,
              {
                className: state.source === "pb" && !state.pb ? FOCUS_END_CLASS : "",
                onClick: close,
                children: translate("cancelButton")
              }
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RowItem, { children: state.source === "file" ? /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
              Button,
              {
                className: FOCUS_END_CLASS,
                primary: true,
                onClick: async () => {
                  const text = await uploadTextFile("text/plain");
                  if (text == null) {
                    return;
                  }
                  replaceOrAppend(text);
                  close();
                },
                children: translate("options_importBlacklistDialog_selectFile")
              }
            ) : /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
              Button,
              {
                className: state.pb ? FOCUS_END_CLASS : "",
                disabled: !state.pb,
                primary: true,
                onClick: () => {
                  let newBlacklist = "";
                  for (const domain of lines(state.pb)) {
                    if (/^([A-Za-z0-9-]+\.)*[A-Za-z0-9-]+$/.test(domain)) {
                      newBlacklist = `${newBlacklist}${newBlacklist ? "\n" : ""}*://*.${domain}/*`;
                    }
                  }
                  replaceOrAppend(newBlacklist);
                  close();
                },
                children: translate("options_importBlacklistDialog_importButton")
              }
            ) })
          ] }) })
        ]
      }
    );
  };
  var RegisterSearchEnginesDialog = ({
    close,
    open
  }) => {
    const ids = (0, import_react31.useMemo)(
      () => stringKeys(SEARCH_ENGINES).filter(
        (id2) => id2 !== "google"
      ),
      []
    );
    const matches = (0, import_react31.useMemo)(
      () => Object.fromEntries(
        ids.map((id2) => [
          id2,
          SEARCH_ENGINES[id2].contentScripts.flatMap(
            (contentScript) => contentScript.matches
          )
        ])
      ),
      [ids]
    );
    const defaultStates = (0, import_react31.useMemo)(
      () => Object.fromEntries(ids.map((id2) => [id2, "none"])),
      [ids]
    );
    const [states, setStates] = (0, import_react31.useState)(defaultStates);
    const prevOpen = usePrevious(open);
    (0, import_react31.useEffect)(() => {
      if (open && !prevOpen) {
        void (async () => {
          const regitrationEntries = await Promise.all(
            ids.map(async (id2) => {
              const permissions = await Promise.all(
                matches[id2].map(
                  (match) => browser.permissions.contains({ origins: [match] })
                )
              );
              const [allowed, denied] = permissions.reduce(
                ([a4, d3], p4) => [a4 || p4, d3 || !p4],
                [false, false]
              );
              return [
                id2,
                allowed ? !denied ? "full" : "partial" : "none"
              ];
            })
          );
          setStates(Object.fromEntries(regitrationEntries));
        })();
      }
    }, [open, prevOpen, ids, matches]);
    return /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(
      Dialog,
      {
        "aria-labelledby": "registerSearchEnginesDialogTitle",
        close,
        open,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(DialogHeader, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(DialogTitle, { id: "registerSearchEnginesDialogTitle", children: translate("options_otherSearchEngines") }) }),
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(DialogBody, { children: ids.map((id2, index) => /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(Row, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Indent, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
              CheckBox,
              {
                checked: states[id2] === "full",
                className: index === 0 ? FOCUS_START_CLASS : "",
                id: id2,
                indeterminate: states[id2] === "partial",
                onChange: (e4) => {
                  const { checked } = e4.currentTarget;
                  setStates((states2) => ({
                    ...states2,
                    [id2]: checked ? "full" : "none"
                  }));
                }
              }
            ) }) }),
            /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(LabelWrapper, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(ControlLabel, { for: id2, children: translate(SEARCH_ENGINES[id2].messageNames.name) }),
              SEARCH_ENGINES[id2].messageNames.description && /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SubLabel, { children: translate(SEARCH_ENGINES[id2].messageNames.description) })
            ] }) })
          ] }, id2)) }),
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(DialogFooter, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(Row, { right: true, children: [
            /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Button, { onClick: close, children: translate("cancelButton") }) }),
            /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
              Button,
              {
                className: FOCUS_END_CLASS,
                primary: true,
                onClick: async () => {
                  const originsToRequest = ids.flatMap(
                    (id2) => states[id2] === "full" ? matches[id2] : []
                  );
                  if (originsToRequest.length) {
                    const granted = await browser.permissions.request({
                      origins: originsToRequest
                    });
                    if (!granted) {
                      return;
                    }
                  }
                  const originsToRemove = ids.flatMap(
                    (id2) => states[id2] === "none" ? matches[id2] : []
                  );
                  if (originsToRemove.length) {
                    await browser.permissions.remove({
                      origins: originsToRemove
                    });
                  }
                  await sendMessage("register-content-scripts");
                  close();
                },
                children: translate("options_registerSearchEngine")
              }
            ) })
          ] }) })
        ]
      }
    );
  };
  var SetBlacklist = () => {
    const {
      initialItems: { blacklist: initialBlacklist }
    } = useOptionsContext();
    const [blacklist, setBlacklist] = (0, import_react31.useState)(initialBlacklist);
    const [blacklistDirty, setBlacklistDirty] = (0, import_react31.useState)(false);
    const [latestBlacklist, setLatestBlacklist] = (0, import_react31.useState)(null);
    const [importBlacklistDialogOpen, setImportBlacklistDialogOpen] = (0, import_react31.useState)(false);
    (0, import_react31.useEffect)(
      () => addMessageListeners({
        "blocklist-saved": (latestBlacklist2, source) => {
          if (source !== "options") {
            setLatestBlacklist(latestBlacklist2);
          }
        }
      }),
      []
    );
    return /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(SectionItem, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Row, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(RowItem, { expanded: true, children: [
        /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(LabelWrapper, { fullWidth: true, children: [
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Label, { children: translate("options_blacklistLabel") }),
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SubLabel, { children: expandLinks(translate("options_blacklistHelper")) }),
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SubLabel, { children: translate("options_blockByTitle") }),
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SubLabel, { children: translate("options_blacklistExample", "*://*.example.com/*") }),
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SubLabel, { children: translate("options_blacklistExample", "/example\\.(net|org)/") }),
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SubLabel, { children: translate("options_blacklistExample", "title/Example Domain/") })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
          RulesetEditor,
          {
            height: "300px",
            resizable: true,
            value: blacklist,
            onChange: (value) => {
              setBlacklist(value);
              setBlacklistDirty(true);
            }
          }
        )
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(Row, { multiline: true, right: true, children: [
        latestBlacklist != null && /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(Text2, { children: [
          translate("options_blacklistUpdated"),
          " ",
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
            LinkButton,
            {
              onClick: () => {
                setBlacklist(latestBlacklist);
                setBlacklistDirty(false);
                setLatestBlacklist(null);
              },
              children: translate("options_reloadBlacklistButton")
            }
          )
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(Row, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
            Button,
            {
              onClick: () => {
                setImportBlacklistDialogOpen(true);
              },
              children: translate("options_importBlacklistButton")
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
            Button,
            {
              onClick: () => {
                downloadTextFile(
                  "uBlacklist.txt",
                  "text/plain;charset=UTF-8",
                  blacklist
                );
              },
              children: translate("options_exportBlacklistButton")
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
            Button,
            {
              disabled: !blacklistDirty,
              primary: true,
              onClick: () => {
                void saveToLocalStorage({ blacklist }, "options");
                setBlacklistDirty(false);
                setLatestBlacklist(null);
              },
              children: translate("options_saveBlacklistButton")
            }
          ) })
        ] }) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Portal, { id: "importBlacklistDialogPortal", children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
        ImportBlacklistDialog,
        {
          close: () => setImportBlacklistDialogOpen(false),
          open: importBlacklistDialogOpen,
          setBlacklist,
          setBlacklistDirty
        }
      ) })
    ] });
  };
  var RegisterSearchEngines = () => {
    if (false) {
      return null;
    }
    const [dialogOpen, setDialogOpen] = (0, import_react31.useState)(false);
    return /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(SectionItem, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(Row, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(LabelWrapper, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Label, { children: translate("options_otherSearchEngines") }),
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SubLabel, { children: translate("options_otherSearchEnginesDescription") })
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Button, { onClick: () => setDialogOpen(true), children: translate("options_registerSearchEngine") }) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Portal, { id: "registerSearchEnginesDialogPortal", children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
        RegisterSearchEnginesDialog,
        {
          close: () => setDialogOpen(false),
          open: dialogOpen
        }
      ) })
    ] });
  };
  var GeneralSection = () => /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(Section, { "aria-labelledby": "generalSectionTitle", id: "general", children: [
    /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SectionHeader, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SectionTitle, { id: "generalSectionTitle", children: translate("options_generalTitle") }) }),
    /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(SectionBody, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SetBlacklist, {}),
      /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(RegisterSearchEngines, {}),
      /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SectionItem, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
        SetBooleanItem,
        {
          itemKey: "blockWholeSite",
          label: translate("options_blockWholeSiteLabel"),
          subLabels: [translate("options_blockWholeSiteDescription")]
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SectionItem, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
        SetBooleanItem,
        {
          itemKey: "skipBlockDialog",
          label: translate("options_skipBlockDialogLabel")
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SectionItem, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
        SetBooleanItem,
        {
          itemKey: "hideBlockLinks",
          label: translate("options_hideBlockLinksLabel")
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(SectionItem, { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
        SetBooleanItem,
        {
          itemKey: "hideControl",
          label: translate("options_hideControlLabel")
        }
      ) })
    ] })
  ] });

  // src/scripts/options/subscription-section.tsx
  var import_dayjs4 = __toESM(require_dayjs_min(), 1);
  var import_react37 = __toESM(require_react(), 1);

  // src/scripts/components/input.tsx
  var import_react32 = __toESM(require_react(), 1);
  var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
  var Input = import_react32.default.forwardRef(
    function Input2(props, ref) {
      const className = useClassName(
        (theme2) => ({
          background: "transparent",
          border: `solid 1px ${theme2.input.border}`,
          borderRadius: "4px",
          color: theme2.text.primary,
          display: "block",
          font: "inherit",
          lineHeight: "1.5",
          padding: "0.5em 0.625em",
          width: "100%",
          "&:disabled": {
            opacity: DISABLED_OPACITY
          },
          "&:focus": {
            boxShadow: `0 0 0 2px ${theme2.focus.shadow}`,
            outline: "none"
          }
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("input", { ...applyClassName(props, className), ref });
    }
  );

  // node_modules/.pnpm/@mdi+svg@7.4.47/node_modules/@mdi/svg/svg/dots-vertical.svg
  var dots_vertical_default = '<svg xmlns="http://www.w3.org/2000/svg" id="mdi-dots-vertical" viewBox="0 0 24 24"><path d="M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z" /></svg>';

  // src/scripts/components/menu.tsx
  var import_react33 = __toESM(require_react(), 1);
  var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
  function moveFocus(body, key) {
    const items = [
      ...body.querySelectorAll(`.${MENU_ITEM_CLASS}:not(:disabled)`)
    ];
    if (!items.length) {
      return;
    }
    const currentIndex = items.indexOf(
      document.activeElement
    );
    let nextIndex;
    if (key === "ArrowUp") {
      nextIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;
    } else if (key === "ArrowDown") {
      nextIndex = currentIndex < items.length - 1 ? currentIndex + 1 : 0;
    } else if (key === "Home") {
      nextIndex = 0;
    } else {
      nextIndex = items.length - 1;
    }
    const nextItem = items[nextIndex];
    nextItem.focus();
  }
  var Menu = import_react33.default.forwardRef(
    function Menu2({ children, disabled = false, ...props }, ref) {
      const [open, setOpen] = (0, import_react33.useState)(false);
      const buttonRef = useInnerRef(ref);
      const bodyRef = (0, import_react33.useRef)(null);
      (0, import_react33.useLayoutEffect)(() => {
        if (open) {
          bodyRef.current?.focus();
        }
      }, [open]);
      const menuClassName = useClassName(
        () => ({
          outline: "none",
          position: "relative"
        }),
        []
      );
      const bodyClassName = useClassName(
        (theme2) => ({
          background: theme2.menu.itemListBackground,
          boxShadow: "rgba(0, 0, 0, 0.3) 0px 1px 2px 0px, rgba(0, 0, 0, 0.15) 0px 3px 6px 2px",
          display: open ? "block" : "none",
          minWidth: "10em",
          outline: "none",
          padding: "0.75em 0",
          position: "absolute",
          top: "100%",
          right: 0,
          zIndex: MENU_Z_INDEX
        }),
        [open]
      );
      return /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)(
        "div",
        {
          className: menuClassName,
          tabIndex: -1,
          onBlurCapture: (e4) => {
            if (!e4.currentTarget.contains(e4.relatedTarget)) {
              setOpen(false);
            }
          },
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
              IconButton,
              {
                ...props,
                "aria-expanded": open,
                "aria-haspopup": "menu",
                disabled,
                iconURL: svgToDataURL(dots_vertical_default),
                ref: buttonRef,
                onClick: () => setOpen(!open)
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
              "div",
              {
                className: bodyClassName,
                ref: bodyRef,
                role: "menu",
                tabIndex: -1,
                onClick: (e4) => {
                  if (e4.target instanceof HTMLElement && e4.target.matches(`.${MENU_ITEM_CLASS}`)) {
                    setOpen(false);
                    buttonRef.current?.focus();
                  }
                },
                onKeyDown: (e4) => {
                  if (e4.key === "Escape") {
                    e4.preventDefault();
                    setOpen(false);
                    buttonRef.current?.focus();
                  } else if (e4.key === "ArrowUp" || e4.key === "ArrowDown" || e4.key === "Home" || e4.key === "End") {
                    e4.preventDefault();
                    moveFocus(e4.currentTarget, e4.key);
                  }
                },
                children
              }
            )
          ]
        }
      );
    }
  );
  var MenuItem = import_react33.default.forwardRef(
    function MenuItem2(props, ref) {
      const className = useClassName(
        (theme2) => ({
          background: "transparent",
          border: "none",
          color: theme2.text.primary,
          cursor: "pointer",
          display: "block",
          font: "inherit",
          height: "2.5em",
          padding: "0 2em",
          textAlign: "start",
          width: "100%",
          "&:disabled": {
            cursor: "default",
            opacity: 0.65
          },
          "&:focus": {
            background: theme2.menu.itemBackgroundFocused,
            outline: "none"
          },
          "&:hover:not(:disabled):not(:focus)": {
            background: theme2.menu.itemBackgroundHovered
          }
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
        "button",
        {
          ...applyClassName(props, `${MENU_ITEM_CLASS} ${className}`),
          ref,
          role: "menuitem"
        }
      );
    }
  );

  // src/scripts/components/table.tsx
  var import_react34 = __toESM(require_react(), 1);
  var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
  var Table = import_react34.default.forwardRef(
    function Table2(props, ref) {
      const className = useClassName(
        () => ({
          borderSpacing: 0,
          tableLayout: "fixed",
          width: "100%"
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)("table", { ...applyClassName(props, className), ref });
    }
  );
  var TableHeader = import_react34.default.forwardRef(function TableHeader2(props, ref) {
    return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)("thead", { ...props, ref });
  });
  var TableHeaderRow = import_react34.default.forwardRef(function TableHeaderRow2(props, ref) {
    return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)("tr", { ...props, ref });
  });
  var TableHeaderCell = import_react34.default.forwardRef(function TableHeaderCell2({ width = "auto", ...props }, ref) {
    const className = useClassName(
      (theme2) => ({
        color: theme2.text.secondary,
        fontWeight: "normal",
        overflowWrap: "break-word",
        padding: "0.75em 0",
        textAlign: "start",
        verticalAlign: "middle",
        width,
        "&:not(:first-child)": {
          paddingLeft: "0.75em"
        }
      }),
      [width]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)("th", { ...applyClassName(props, className), ref });
  });
  var TableBody = import_react34.default.forwardRef(function TableBody2(props, ref) {
    return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)("tbody", { ...props, ref });
  });
  var TableRow = import_react34.default.forwardRef(
    function TableRow2(props, ref) {
      return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)("tr", { ...props, ref });
    }
  );
  var TableCell = import_react34.default.forwardRef(
    function TableCell2(props, ref) {
      const className = useClassName(
        (theme2) => ({
          borderTop: `solid 1px ${theme2.separator}`,
          overflowWrap: "break-word",
          padding: "0.75em 0",
          verticalAlign: "middle",
          "&:not(:first-child)": {
            paddingLeft: "0.75em"
          }
        }),
        []
      );
      return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)("td", { ...applyClassName(props, className), ref });
    }
  );

  // src/scripts/options/from-now.tsx
  var import_dayjs2 = __toESM(require_dayjs_min(), 1);
  var import_relativeTime = __toESM(require_relativeTime(), 1);
  var import_react35 = __toESM(require_react(), 1);

  // src/scripts/dayjs-locales.ts
  var import_de = __toESM(require_de(), 1);
  var import_es = __toESM(require_es(), 1);
  var import_fr = __toESM(require_fr(), 1);
  var import_ja = __toESM(require_ja(), 1);
  var import_ko = __toESM(require_ko(), 1);
  var import_pl = __toESM(require_pl(), 1);
  var import_pt_br = __toESM(require_pt_br(), 1);
  var import_ru = __toESM(require_ru(), 1);
  var import_tr = __toESM(require_tr(), 1);
  var import_uk = __toESM(require_uk(), 1);
  var import_zh_cn = __toESM(require_zh_cn(), 1);
  var import_zh_tw = __toESM(require_zh_tw(), 1);

  // src/scripts/options/from-now.tsx
  var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
  import_dayjs2.default.extend(import_relativeTime.default);
  var FromNow = ({ time }) => {
    const [, setState] = (0, import_react35.useState)(0);
    (0, import_react35.useEffect)(() => {
      const intervalId = setInterval(() => {
        setState((state) => state + 1);
      }, 5e3);
      return () => clearInterval(intervalId);
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)("time", { dateTime: time.toISOString(), children: time.locale(translate("lang")).fromNow() });
  };

  // src/scripts/options/set-interval-item.tsx
  var import_dayjs3 = __toESM(require_dayjs_min(), 1);
  var import_react36 = __toESM(require_react(), 1);
  var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
  var SetIntervalItem = ({ disabled = false, itemKey, label, valueOptions }) => {
    const {
      initialItems: { [itemKey]: initialItem }
    } = useOptionsContext();
    const [item, setItem] = (0, import_react36.useState)(initialItem);
    valueOptions = [.../* @__PURE__ */ new Set([...valueOptions, initialItem])].sort(
      (a4, b4) => a4 - b4
    );
    const rowClass = useClassName(
      () => ({
        "&&": {
          minHeight: "2.5em"
        }
      }),
      []
    );
    return /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)(Row, { className: rowClass, children: [
      /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(LabelWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(ControlLabel, { for: itemKey, children: label }) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
        Select3,
        {
          disabled,
          id: itemKey,
          value: item,
          onChange: (e4) => {
            const value = Number(e4.currentTarget.value);
            void saveToLocalStorage(
              { [itemKey]: value },
              "options"
            );
            setItem(value);
          },
          children: valueOptions.map((value) => /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(SelectOption, { value, children: import_dayjs3.default.duration({ minutes: value }).locale(translate("lang")).humanize(false) }, value))
        }
      ) })
    ] });
  };

  // src/scripts/options/subscription-section.tsx
  var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
  function getName(subscription) {
    const name2 = subscription.ruleset?.metadata.name;
    return typeof name2 === "string" ? name2 : subscription.name || subscription.url;
  }
  var PERMISSION_PASSLIST = [
    "*://*.githubusercontent.com/*",
    // A third-party CDN service supporting GitHub, GitLab and BitBucket
    "*://cdn.statically.io/*"
  ];
  async function requestPermission(urls) {
    const origins = [];
    const map2 = new MatchPatternMap();
    for (const pass of PERMISSION_PASSLIST) {
      map2.set(pass, null);
    }
    for (const url of urls) {
      if (map2.get(url).length) {
        continue;
      }
      const u4 = new AltURL(url);
      origins.push(`${u4.scheme}://${u4.host}/*`);
    }
    return origins.length ? browser.permissions.request({ origins }) : true;
  }
  var AddSubscriptionDialog = ({ close, open, initialName, initialURL, setSubscriptions }) => {
    const [state, setState] = (0, import_react37.useState)(() => ({
      url: initialURL,
      urlValid: (() => {
        if (!initialURL || !/^https?:/.test(initialURL)) {
          return false;
        }
        try {
          new URL(initialURL);
        } catch {
          return false;
        }
        return true;
      })(),
      name: initialName
    }));
    const prevOpen = usePrevious(open);
    if (open && prevOpen === false) {
      state.url = "";
      state.urlValid = false;
      state.name = "";
    }
    const ok = state.urlValid;
    return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(
      Dialog,
      {
        "aria-labelledby": "addSubscriptionDialogTitle",
        close,
        open,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DialogHeader, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DialogTitle, { id: "addSubscriptionDialogTitle", children: translate("options_addSubscriptionDialog_title") }) }),
          /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(DialogBody, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Row, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(RowItem, { expanded: true, children: [
              /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(LabelWrapper, { fullWidth: true, children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ControlLabel, { for: "subscriptionURL", children: translate("options_addSubscriptionDialog_urlLabel") }) }),
              /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
                Input,
                {
                  className: FOCUS_START_CLASS,
                  id: "subscriptionURL",
                  pattern: "https?:.*",
                  required: true,
                  type: "url",
                  value: state.url,
                  onChange: (e4) => {
                    const {
                      value: url,
                      validity: { valid: urlValid }
                    } = e4.currentTarget;
                    setState((s4) => ({ ...s4, url, urlValid }));
                  }
                }
              )
            ] }) }),
            /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Row, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(RowItem, { expanded: true, children: [
              /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(LabelWrapper, { fullWidth: true, children: [
                /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ControlLabel, { for: "subscriptionName", children: translate("options_addSubscriptionDialog_altNameLabel") }),
                /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(SubLabel, { children: translate("options_addSubscriptionDialog_altNameDescription") })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
                Input,
                {
                  id: "subscriptionName",
                  required: true,
                  value: state.name,
                  onChange: (e4) => {
                    const name2 = e4.currentTarget.value;
                    setState((s4) => {
                      return { ...s4, name: name2 };
                    });
                  }
                }
              )
            ] }) })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DialogFooter, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(Row, { right: true, children: [
            /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Button, { className: !ok ? FOCUS_END_CLASS : "", onClick: close, children: translate("cancelButton") }) }),
            /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
              Button,
              {
                className: ok ? FOCUS_END_CLASS : "",
                disabled: !ok,
                primary: true,
                onClick: async () => {
                  if (!await requestPermission([state.url])) {
                    return;
                  }
                  const subscription = {
                    name: state.name,
                    url: state.url,
                    blacklist: "",
                    updateResult: null,
                    enabled: true
                  };
                  const id2 = await sendMessage("add-subscription", subscription);
                  setSubscriptions((subscriptions) => ({
                    ...subscriptions,
                    [id2]: subscription
                  }));
                  close();
                },
                children: translate("options_addSubscriptionDialog_addButton")
              }
            ) })
          ] }) })
        ]
      }
    );
  };
  var ShowSubscriptionDialog = ({ close, open, subscription }) => {
    const urlClassName = useClassName(
      () => ({
        wordBreak: "break-all"
      }),
      []
    );
    return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(
      Dialog,
      {
        "aria-labelledby": "showSubscriptionDialogTitle",
        close,
        open,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DialogHeader, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DialogTitle, { id: "showSubscriptionDialogTitle", children: subscription ? getName(subscription) : "" }) }),
          /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(DialogBody, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Row, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { className: urlClassName, children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Link, { className: FOCUS_START_CLASS, href: subscription?.url, children: subscription?.url }) }) }) }),
            /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Row, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(RowItem, { expanded: true, children: open && /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
              RulesetEditor,
              {
                height: "200px",
                readOnly: true,
                resizable: true,
                value: subscription?.blacklist ?? ""
              }
            ) }) })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DialogFooter, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Row, { right: true, children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Button, { className: FOCUS_END_CLASS, primary: true, onClick: close, children: translate("okButton") }) }) }) })
        ]
      }
    );
  };
  var ManageSubscription = ({
    id: id2,
    setSubscriptions,
    setShowSubscriptionDialogOpen,
    setShowSubscriptionDialogSubscription,
    subscription,
    updating
  }) => {
    const checkboxId = `enableSubscription${id2}`;
    return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(TableRow, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(TableCell, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
        CheckBox,
        {
          "aria-label": translate("options_subscriptionCheckBoxLabel"),
          checked: subscription.enabled ?? true,
          id: checkboxId,
          onChange: async (e4) => {
            const enabled = e4.currentTarget.checked;
            await sendMessage("enable-subscription", id2, enabled);
            setSubscriptions((subscriptions) => {
              const newSubscriptions = { ...subscriptions };
              if (subscriptions[id2]) {
                newSubscriptions[id2] = { ...subscriptions[id2], enabled };
              }
              return newSubscriptions;
            });
          }
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(TableCell, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(LabelWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(ControlLabel, { for: checkboxId, children: getName(subscription) }) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(TableCell, { children: updating ? translate("options_subscriptionUpdateRunning") : !subscription.updateResult ? "" : isErrorResult(subscription.updateResult) ? translate("error", subscription.updateResult.message) : /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(FromNow, { time: (0, import_dayjs4.default)(subscription.updateResult.timestamp) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(TableCell, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(Menu, { "aria-label": translate("options_subscriptionMenuButtonLabel"), children: [
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          MenuItem,
          {
            onClick: () => {
              requestAnimationFrame(() => {
                setShowSubscriptionDialogOpen(true);
                setShowSubscriptionDialogSubscription(subscription);
              });
            },
            children: translate("options_showSubscriptionMenu")
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          MenuItem,
          {
            disabled: !(subscription.enabled ?? true),
            onClick: async () => {
              if (!await requestPermission([subscription.url])) {
                return;
              }
              await sendMessage("update-subscription", id2);
            },
            children: translate("options_updateSubscriptionNowMenu")
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          MenuItem,
          {
            onClick: async () => {
              await sendMessage("remove-subscription", id2);
              setSubscriptions((subscriptions) => {
                const newSubscriptions = { ...subscriptions };
                delete newSubscriptions[id2];
                return newSubscriptions;
              });
            },
            children: translate("options_removeSubscriptionMenu")
          }
        )
      ] }) })
    ] });
  };
  var ManageSubscriptions = ({ subscriptions, setSubscriptions }) => {
    const { query } = useOptionsContext();
    const [updating, setUpdating] = (0, import_react37.useState)({});
    const [addSubscriptionDialogOpen, setAddSubscriptionDialogOpen] = (0, import_react37.useState)(
      query.addSubscriptionName != null || query.addSubscriptionURL != null
    );
    const [showSubscriptionDialogOpen, setShowSubscriptionDialogOpen] = (0, import_react37.useState)(false);
    const [
      showSubscriptionDialogSubscription,
      setShowSubscriptionDialogSubscription
    ] = (0, import_react37.useState)(null);
    (0, import_react37.useEffect)(
      () => addMessageListeners({
        "subscription-updating": (id2) => {
          setUpdating((updating2) => ({ ...updating2, [id2]: true }));
        },
        "subscription-updated": (id2, subscription) => {
          setSubscriptions(
            (subscriptions2) => subscriptions2[id2] ? { ...subscriptions2, [id2]: subscription } : subscriptions2
          );
          setUpdating((updating2) => ({ ...updating2, [id2]: false }));
        }
      }),
      [setSubscriptions]
    );
    const emptyClass = useClassName(
      () => ({
        minHeight: "3em",
        textAlign: "center"
      }),
      []
    );
    return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(SectionItem, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(Row, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(LabelWrapper, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Label, { children: translate("options_subscriptionFeature") }),
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(SubLabel, { children: translate("options_subscriptionFeatureDescription") })
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          Button,
          {
            primary: true,
            onClick: () => {
              setAddSubscriptionDialogOpen(true);
            },
            children: translate("options_addSubscriptionButton")
          }
        ) })
      ] }),
      numberKeys(subscriptions).length ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Row, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(Table, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(TableHeader, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(TableHeaderRow, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(TableHeaderCell, { width: "2.25em" }),
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(TableHeaderCell, { children: translate("options_subscriptionNameHeader") }),
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(TableHeaderCell, { width: "20%", children: translate("options_subscriptionUpdateResultHeader") }),
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(TableHeaderCell, { width: "calc(0.75em + 36px)" })
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(TableBody, { children: numberEntries(subscriptions).sort(([id1], [id2]) => id1 - id2).map(([id2, subscription]) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          ManageSubscription,
          {
            id: id2,
            setShowSubscriptionDialogOpen,
            setShowSubscriptionDialogSubscription,
            setSubscriptions,
            subscription,
            updating: updating[id2] ?? false
          },
          id2
        )) })
      ] }) }) }) : /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Row, { className: emptyClass, children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(RowItem, { expanded: true, children: translate("options_noSubscriptionsAdded") }) }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Row, { right: true, children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
        Button,
        {
          disabled: !Object.values(subscriptions).filter(
            (subscription) => subscription.enabled ?? true
          ).length,
          onClick: async () => {
            if (!await requestPermission(
              Object.values(subscriptions).map((s4) => s4.url)
            )) {
              return;
            }
            await sendMessage("update-all-subscriptions");
          },
          children: translate("options_updateAllSubscriptionsNowButton")
        }
      ) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Portal, { id: "addSubscriptionDialogPortal", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
        AddSubscriptionDialog,
        {
          close: () => setAddSubscriptionDialogOpen(false),
          initialName: query.addSubscriptionName ?? "",
          initialURL: query.addSubscriptionURL ?? "",
          open: addSubscriptionDialogOpen,
          setSubscriptions
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Portal, { id: "showSubscriptionDialogPortal", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
        ShowSubscriptionDialog,
        {
          close: () => setShowSubscriptionDialogOpen(false),
          open: showSubscriptionDialogOpen,
          subscription: showSubscriptionDialogSubscription
        }
      ) })
    ] });
  };
  var SubscriptionSection = () => {
    const {
      initialItems: { subscriptions: initialSubscriptions }
    } = useOptionsContext();
    const [subscriptions, setSubscriptions] = (0, import_react37.useState)(initialSubscriptions);
    return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(Section, { "aria-labelledby": "subscriptionSectionTitle", id: "subscription", children: [
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(SectionHeader, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(SectionTitle, { id: "subscriptionSectionTitle", children: translate("options_subscriptionTitle") }) }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(SectionBody, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          ManageSubscriptions,
          {
            setSubscriptions,
            subscriptions
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(SectionItem, { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          SetIntervalItem,
          {
            disabled: !Object.values(subscriptions).filter(
              (subscription) => subscription.enabled ?? true
            ).length,
            itemKey: "updateInterval",
            label: translate("options_updateInterval"),
            valueOptions: [60, 120, 180, 360, 720, 1440]
          }
        ) })
      ] })
    ] });
  };

  // src/scripts/options/sync-section.tsx
  var import_dayjs7 = __toESM(require_dayjs_min(), 1);
  var import_duration = __toESM(require_duration(), 1);
  var import_react38 = __toESM(require_react(), 1);

  // src/scripts/clouds/dropbox.ts
  var import_dayjs5 = __toESM(require_dayjs_min(), 1);
  var import_utc = __toESM(require_utc(), 1);

  // src/scripts/clouds/helpers.ts
  function shouldUseAltFlow() {
    return (os) => {
      if (false) {
        return false;
      }
      if (true) {
        return os === "android";
      }
      return true;
    };
  }
  var altFlowRedirectURL = getWebsiteURL("/callback");
  async function launchAltFlow(params) {
    const [{ id: openerTabId }] = await browser.tabs.query({
      active: true,
      currentWindow: true
    });
    if (openerTabId == null) {
      throw new Error("failed to get the current tab");
    }
    const { id: authorizationTabId } = await browser.tabs.create(
      (await browser.runtime.getPlatformInfo()).os === "android" ? { url: params.url } : { openerTabId, url: params.url }
    );
    if (authorizationTabId == null) {
      throw new Error("failed to open the authorization tab");
    }
    return new Promise((resolve, reject) => {
      const [onUpdated, onRemoved] = [
        (tabId, _changeInfo, tab) => {
          if (tabId === authorizationTabId && tab.url?.startsWith(altFlowRedirectURL)) {
            resolve(tab.url);
            browser.tabs.onUpdated.removeListener(onUpdated);
            browser.tabs.onRemoved.removeListener(onRemoved);
            void browser.tabs.update(openerTabId, { active: true }).then(() => browser.tabs.remove(tabId));
          }
        },
        (tabId) => {
          if (tabId === authorizationTabId) {
            reject(new Error("the authorization tab was closed"));
            browser.tabs.onUpdated.removeListener(onUpdated);
            browser.tabs.onRemoved.removeListener(onRemoved);
            void browser.tabs.update(openerTabId, { active: true });
          }
        }
      ];
      browser.tabs.onUpdated.addListener(onUpdated);
      browser.tabs.onRemoved.addListener(onRemoved);
    });
  }
  function authorize(url, params) {
    return async (useAltFlow) => {
      const authorizationURL = new URL(url);
      authorizationURL.search = new URLSearchParams({
        response_type: "code",
        redirect_uri: useAltFlow ? altFlowRedirectURL : browser.identity.getRedirectURL(),
        ...params
      }).toString();
      const redirectURL = await (useAltFlow ? launchAltFlow({ url: authorizationURL.toString() }) : browser.identity.launchWebAuthFlow({
        url: authorizationURL.toString(),
        interactive: true
      }));
      const redirectParams = Object.fromEntries(
        new URL(redirectURL).searchParams.entries()
      );
      if (redirectParams.code != null) {
        return { authorizationCode: redirectParams.code };
      }
      if (redirectParams.error != null) {
        throw new Error(redirectParams.error);
      }
      throw new UnexpectedResponse(redirectParams);
    };
  }
  function getAccessToken(url, params) {
    return async (authorizationCode, useAltFlow) => {
      const response = await fetch(url, {
        method: "POST",
        body: new URLSearchParams({
          grant_type: "authorization_code",
          code: authorizationCode,
          redirect_uri: useAltFlow ? altFlowRedirectURL : browser.identity.getRedirectURL(),
          ...params
        })
      });
      if (response.ok) {
        const responseBody = await response.json();
        const parseResult = z.object({
          access_token: z.string(),
          expires_in: z.number(),
          refresh_token: z.string()
        }).safeParse(responseBody);
        if (!parseResult.success) {
          throw new UnexpectedResponse(responseBody);
        }
        return {
          accessToken: parseResult.data.access_token,
          expiresIn: parseResult.data.expires_in,
          refreshToken: parseResult.data.refresh_token
        };
      }
      throw new HTTPError(response.status, response.statusText);
    };
  }
  function refreshAccessToken(url, params) {
    return async (refreshToken) => {
      const response = await fetch(url, {
        method: "POST",
        body: new URLSearchParams({
          grant_type: "refresh_token",
          refresh_token: refreshToken,
          ...params
        })
      });
      if (response.ok) {
        const responseBody = await response.json();
        const parseResult = z.object({ access_token: z.string(), expires_in: z.number() }).safeParse(responseBody);
        if (!parseResult.success) {
          throw new UnexpectedResponse(responseBody);
        }
        return {
          accessToken: parseResult.data.access_token,
          expiresIn: parseResult.data.expires_in
        };
      }
      throw new HTTPError(response.status, response.statusText);
    };
  }

  // src/scripts/clouds/dropbox.ts
  import_dayjs5.default.extend(import_utc.default);
  var APP_KEY = "kgkleqa3m2hxwqu";
  var APP_SECRET = "p5it3m3oxqqcaw8";
  function toISOStringSecond(time) {
    return time.utc().format("YYYY-MM-DDTHH:mm:ss[Z]");
  }
  var dropbox = {
    hostPermissions: [],
    messageNames: {
      sync: "clouds_dropboxSync",
      syncDescription: "clouds_dropboxSyncDescription",
      syncTurnedOn: "clouds_dropboxSyncTurnedOn"
    },
    modifiedTimePrecision: "second",
    shouldUseAltFlow: shouldUseAltFlow(),
    // https://www.dropbox.com/developers/documentation/http/documentation
    authorize: authorize("https://www.dropbox.com/oauth2/authorize", {
      client_id: APP_KEY,
      token_access_type: "offline",
      force_reapprove: "true"
    }),
    getAccessToken: getAccessToken(
      "https://api.dropboxapi.com/oauth2/token",
      {
        client_id: APP_KEY,
        client_secret: APP_SECRET
      }
    ),
    refreshAccessToken: refreshAccessToken(
      "https://api.dropboxapi.com/oauth2/token",
      {
        client_id: APP_KEY,
        client_secret: APP_SECRET
      }
    ),
    // https://www.dropbox.com/developers/documentation/http/documentation#files-upload
    async createFile(accessToken, filename, content2, modifiedTime) {
      const urlBuilder = new URL("https://content.dropboxapi.com/2/files/upload");
      urlBuilder.search = new URLSearchParams({
        authorization: `Bearer ${accessToken}`,
        arg: JSON.stringify({
          path: `/${filename}`,
          mode: "add",
          autorename: false,
          client_modified: toISOStringSecond(modifiedTime),
          mute: true,
          strict_conflict: false
        })
      }).toString();
      const response = await fetch(urlBuilder.toString(), {
        method: "POST",
        headers: {
          "Content-Type": "text/plain; charset=dropbox-cors-hack"
        },
        body: content2
      });
      if (response.ok) {
        return;
      }
      throw new HTTPError(response.status, response.statusText);
    },
    // https://www.dropbox.com/developers/documentation/http/documentation#files-get_metadata
    async findFile(accessToken, filename) {
      const urlBuilder = new URL(
        "https://api.dropboxapi.com/2/files/get_metadata"
      );
      urlBuilder.search = new URLSearchParams({
        authorization: `Bearer ${accessToken}`
      }).toString();
      const response = await fetch(urlBuilder.toString(), {
        method: "POST",
        headers: {
          "Content-Type": "text/plain; charset=dropbox-cors-hack"
        },
        body: JSON.stringify({
          path: `/${filename}`,
          include_media_info: false,
          include_deleted: false,
          include_has_explicit_shared_members: false
        })
      });
      if (response.ok) {
        const responseBody = await response.json();
        const parseResult = z.object({ id: z.string(), client_modified: z.string() }).safeParse(responseBody);
        if (!parseResult.success) {
          throw new UnexpectedResponse(responseBody);
        }
        return {
          id: parseResult.data.id,
          modifiedTime: (0, import_dayjs5.default)(parseResult.data.client_modified)
        };
      }
      if (response.status === 409) {
        const responseBody = await response.json();
        const parseResult = z.object({
          error: z.object({
            ".tag": z.literal("path"),
            path: z.object({ ".tag": z.string() })
          })
        }).safeParse(responseBody);
        if (!parseResult.success) {
          throw new UnexpectedResponse(responseBody);
        }
        if (parseResult.data.error.path[".tag"] === "not_found") {
          return null;
        }
        throw new Error(parseResult.data.error[".tag"]);
      }
      throw new HTTPError(response.status, response.statusText);
    },
    // https://www.dropbox.com/developers/documentation/http/documentation#files-download
    async readFile(accessToken, id2) {
      const urlBuilder = new URL(
        "https://content.dropboxapi.com/2/files/download"
      );
      urlBuilder.search = new URLSearchParams({
        authorization: `Bearer ${accessToken}`,
        arg: JSON.stringify({
          path: id2
        })
      }).toString();
      const response = await fetch(urlBuilder.toString(), {
        method: "POST"
      });
      if (response.ok) {
        const responseBody = await response.text();
        return { content: responseBody };
      }
      throw new HTTPError(response.status, response.statusText);
    },
    // https://www.dropbox.com/developers/documentation/http/documentation#files-upload
    async writeFile(accessToken, id2, content2, modifiedTime) {
      const urlBuilder = new URL("https://content.dropboxapi.com/2/files/upload");
      urlBuilder.search = new URLSearchParams({
        authorization: `Bearer ${accessToken}`,
        arg: JSON.stringify({
          path: id2,
          mode: "overwrite",
          autorename: false,
          client_modified: toISOStringSecond(modifiedTime),
          mute: true,
          strict_conflict: false
        })
      }).toString();
      const response = await fetch(urlBuilder.toString(), {
        method: "POST",
        headers: {
          "Content-Type": "text/plain; charset=dropbox-cors-hack"
        },
        body: content2
      });
      if (response.ok) {
        return;
      }
      throw new HTTPError(response.status, response.statusText);
    }
  };

  // src/scripts/clouds/google-drive.ts
  var import_dayjs6 = __toESM(require_dayjs_min(), 1);
  var CLIENT_ID = "304167046827-45h8no7j0s38akv999nivvb7i17ckqeh.apps.googleusercontent.com";
  var CLIENT_SECRET = "1QcFpNjHoAf3_XczYwhYicTl";
  var MULTIPART_RELATED_BOUNDARY = "----------uBlacklistMultipartRelatedBoundaryJMPRhmg2VV4JBuua";
  var googleDrive = {
    hostPermissions: true ? ["https://www.googleapis.com/*"] : [],
    messageNames: {
      sync: "clouds_googleDriveSync",
      syncDescription: "clouds_googleDriveSyncDescription",
      syncTurnedOn: "clouds_googleDriveSyncTurnedOn"
    },
    modifiedTimePrecision: "millisecond",
    shouldUseAltFlow: shouldUseAltFlow(),
    // https://developers.google.com/identity/protocols/oauth2/web-server
    authorize: authorize("https://accounts.google.com/o/oauth2/v2/auth", {
      client_id: CLIENT_ID,
      scope: "https://www.googleapis.com/auth/drive.appdata",
      access_type: "offline",
      prompt: "consent select_account"
    }),
    getAccessToken: getAccessToken(
      "https://oauth2.googleapis.com/token",
      {
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      }
    ),
    refreshAccessToken: refreshAccessToken(
      "https://oauth2.googleapis.com/token",
      {
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      }
    ),
    // https://developers.google.com/drive/api/v3/reference/files/create
    // https://developers.google.com/drive/api/v3/manage-uploads#multipart
    // https://developers.google.com/drive/api/v3/appdata
    async createFile(accessToken, filename, content2, modifiedTime) {
      const requestURL = new URL(
        "https://www.googleapis.com/upload/drive/v3/files"
      );
      requestURL.search = new URLSearchParams({
        uploadType: "multipart"
      }).toString();
      const response = await fetch(requestURL.toString(), {
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": `multipart/related; boundary=${MULTIPART_RELATED_BOUNDARY}`
        },
        body: `--${MULTIPART_RELATED_BOUNDARY}\r
Content-Type: application/json; charset=UTF-8\r
\r
${JSON.stringify({
          modifiedTime: modifiedTime.toISOString(),
          name: filename,
          parents: ["appDataFolder"]
        })}\r
--${MULTIPART_RELATED_BOUNDARY}\r
Content-Type: text/plain; charset=UTF-8\r
\r
${content2}\r
--${MULTIPART_RELATED_BOUNDARY}--`
      });
      if (response.ok) {
        return;
      }
      throw new HTTPError(response.status, response.statusText);
    },
    // https://developers.google.com/drive/api/v3/reference/files/list
    // https://developers.google.com/drive/api/v3/appdata
    async findFile(accessToken, filename) {
      const requestURL = new URL("https://www.googleapis.com/drive/v3/files");
      requestURL.search = new URLSearchParams({
        // Move authorization from the 'Authorization' header to avoid preflight requests.
        access_token: accessToken,
        fields: "files(id, modifiedTime)",
        q: `name = '${filename}'`,
        spaces: "appDataFolder"
      }).toString();
      const response = await fetch(requestURL.toString());
      if (response.ok) {
        const responseBody = await response.json();
        const parseResult = z.object({
          files: z.object({
            id: z.string(),
            modifiedTime: z.string()
          }).array()
        }).safeParse(responseBody);
        if (!parseResult.success) {
          throw new UnexpectedResponse(responseBody);
        }
        if (!parseResult.data.files.length) {
          return null;
        }
        return {
          id: parseResult.data.files[0].id,
          modifiedTime: (0, import_dayjs6.default)(parseResult.data.files[0].modifiedTime)
        };
      }
      throw new HTTPError(response.status, response.statusText);
    },
    // https://developers.google.com/drive/api/v3/reference/files/get
    // https://developers.google.com/drive/api/v3/manage-downloads
    async readFile(accessToken, id2) {
      const requestURL = new URL(
        `https://www.googleapis.com/drive/v3/files/${id2}`
      );
      requestURL.search = new URLSearchParams({
        alt: "media"
      }).toString();
      const response = await fetch(requestURL.toString(), {
        headers: {
          // We cannot move authorization from the 'Authorization' header to avoid preflight requests:
          // https://cloud.google.com/blog/products/application-development/upcoming-changes-to-the-google-drive-api-and-google-picker-api
          Authorization: `Bearer ${accessToken}`
        }
      });
      if (response.ok) {
        const responseBody = await response.text();
        return { content: responseBody };
      }
      throw new HTTPError(response.status, response.statusText);
    },
    // https://developers.google.com/drive/api/v3/reference/files/update
    // https://developers.google.com/drive/api/v3/manage-uploads#multipart
    async writeFile(accessToken, id2, content2, modifiedTime) {
      const requestURL = new URL(
        `https://www.googleapis.com/upload/drive/v3/files/${id2}`
      );
      requestURL.search = new URLSearchParams({
        access_token: accessToken,
        uploadType: "multipart"
      }).toString();
      const response = await fetch(requestURL.toString(), {
        method: "PATCH",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": `multipart/related; boundary=${MULTIPART_RELATED_BOUNDARY}`
        },
        body: `--${MULTIPART_RELATED_BOUNDARY}\r
Content-Type: application/json; charset=UTF-8\r
\r
${JSON.stringify({
          modifiedTime: modifiedTime.toISOString()
        })}\r
--${MULTIPART_RELATED_BOUNDARY}\r
Content-Type: text/plain; charset=UTF-8\r
\r
${content2}\r
--${MULTIPART_RELATED_BOUNDARY}--`
      });
      if (response.ok) {
        return;
      }
      throw new HTTPError(response.status, response.statusText);
    }
  };

  // src/scripts/supported-clouds.ts
  var supportedClouds = {
    googleDrive,
    dropbox
  };

  // src/scripts/options/sync-section.tsx
  var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
  import_dayjs7.default.extend(import_duration.default);
  var altFlowRedirectURL2 = getWebsiteURL("/callback");
  var TurnOnSyncDialog = ({ close, open, setSyncCloudId }) => {
    const {
      platformInfo: { os }
    } = useOptionsContext();
    const [state, setState] = (0, import_react38.useState)({
      phase: "none",
      selectedCloudId: "googleDrive",
      useAltFlow: false,
      authCode: ""
    });
    const prevOpen = usePrevious(open);
    if (open && !prevOpen) {
      state.phase = "none";
      state.selectedCloudId = "googleDrive";
      state.useAltFlow = false;
      state.authCode = "";
    }
    const forceAltFlow = supportedClouds[state.selectedCloudId].shouldUseAltFlow(os);
    return /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(Dialog, { "aria-labelledby": "turnOnSyncDialogTitle", close, open, children: [
      /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DialogHeader, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DialogTitle, { id: "turnOnSyncDialogTitle", children: translate("options_turnOnSyncDialog_title") }) }),
      /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(DialogBody, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Row, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
          Select3,
          {
            className: state.phase === "none" ? FOCUS_START_CLASS : "",
            disabled: state.phase !== "none",
            value: state.selectedCloudId,
            onChange: (e4) => {
              const { value } = e4.currentTarget;
              setState((s4) => ({
                ...s4,
                selectedCloudId: value
              }));
            },
            children: stringEntries(supportedClouds).map(([id2, cloud]) => /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(SelectOption, { value: id2, children: translate(cloud.messageNames.sync) }, id2))
          }
        ) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Row, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Text2, { children: translate(
          supportedClouds[state.selectedCloudId].messageNames.syncDescription
        ) }) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(Row, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Indent, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
            CheckBox,
            {
              checked: forceAltFlow || state.useAltFlow,
              disabled: state.phase !== "none" || forceAltFlow,
              id: "useAltFlow",
              onChange: (e4) => {
                const { checked } = e4.currentTarget;
                setState((s4) => ({
                  ...s4,
                  useAltFlow: checked
                }));
              }
            }
          ) }) }),
          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(LabelWrapper, { disabled: state.phase !== "none" || forceAltFlow, children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(ControlLabel, { for: "useAltFlow", children: translate("options_turnOnSyncDialog_useAltFlow") }) }) })
        ] }),
        (forceAltFlow || state.useAltFlow) && /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Row, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Text2, { children: translate(
          "options_turnOnSyncDialog_altFlowDescription",
          new AltURL(altFlowRedirectURL2).host
        ) }) }) }),
        state.phase === "auth-alt" || state.phase === "conn-alt" ? /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Row, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(RowItem, { expanded: true, children: [
          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(LabelWrapper, { fullWidth: true, children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(ControlLabel, { for: "authCode", children: translate("options_turnOnSyncDialog_altFlowAuthCodeLabel") }) }),
          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
            TextArea,
            {
              breakAll: true,
              className: state.phase === "auth-alt" ? FOCUS_START_CLASS : "",
              disabled: state.phase !== "auth-alt",
              id: "authCode",
              rows: 2,
              value: state.authCode,
              onChange: (e4) => {
                const { value } = e4.currentTarget;
                setState((s4) => ({ ...s4, authCode: value }));
              }
            }
          )
        ] }) }) : null
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DialogFooter, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(Row, { right: true, children: [
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
          Button,
          {
            className: state.phase === "auth" || state.phase === "conn" || state.phase === "conn-alt" ? `${FOCUS_START_CLASS} ${FOCUS_END_CLASS}` : state.phase === "auth-alt" && !state.authCode ? FOCUS_END_CLASS : "",
            onClick: close,
            children: translate("cancelButton")
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
          Button,
          {
            className: state.phase === "none" || state.phase === "auth-alt" && state.authCode ? FOCUS_END_CLASS : "",
            disabled: !(state.phase === "none" || state.phase === "auth-alt" && state.authCode),
            primary: true,
            onClick: () => {
              void (async () => {
                let useAltFlow;
                let authCode;
                if (state.phase === "auth-alt") {
                  useAltFlow = true;
                  authCode = state.authCode;
                } else {
                  const cloud = supportedClouds[state.selectedCloudId];
                  useAltFlow = forceAltFlow || state.useAltFlow;
                  setState((s4) => ({
                    ...s4,
                    phase: useAltFlow ? "auth-alt" : "auth"
                  }));
                  try {
                    const granted = await browser.permissions.request({
                      origins: [
                        ...cloud.hostPermissions,
                        ...useAltFlow ? [altFlowRedirectURL2] : []
                      ]
                    });
                    if (!granted) {
                      throw new Error("Not granted");
                    }
                    authCode = (await cloud.authorize(useAltFlow)).authorizationCode;
                  } catch {
                    setState((s4) => ({ ...s4, phase: "none" }));
                    return;
                  }
                }
                setState((s4) => ({
                  ...s4,
                  phase: useAltFlow ? "conn-alt" : "conn"
                }));
                try {
                  const connected = await sendMessage(
                    "connect-to-cloud",
                    state.selectedCloudId,
                    authCode,
                    useAltFlow
                  );
                  if (!connected) {
                    throw new Error("Not connected");
                  }
                } catch {
                  return;
                } finally {
                  setState((s4) => ({ ...s4, phase: "none" }));
                }
                setSyncCloudId(state.selectedCloudId);
                close();
              })();
            },
            children: translate("options_turnOnSyncDialog_turnOnSyncButton")
          }
        ) })
      ] }) })
    ] });
  };
  var TurnOnSync = ({ syncCloudId, setSyncCloudId }) => {
    const [turnOnSyncDialogOpen, setTurnOnSyncDialogOpen] = (0, import_react38.useState)(false);
    return /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(SectionItem, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(Row, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(RowItem, { expanded: true, children: syncCloudId ? /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(LabelWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Label, { children: translate(
          supportedClouds[syncCloudId].messageNames.syncTurnedOn
        ) }) }) : /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(LabelWrapper, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Label, { children: translate("options_syncFeature") }),
          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(SubLabel, { children: translate("options_syncFeatureDescription") })
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(RowItem, { children: syncCloudId ? /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
          Button,
          {
            onClick: () => {
              void sendMessage("disconnect-from-cloud");
              setSyncCloudId(false);
            },
            children: translate("options_turnOffSync")
          }
        ) : /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
          Button,
          {
            primary: true,
            onClick: () => {
              setTurnOnSyncDialogOpen(true);
            },
            children: translate("options_turnOnSync")
          }
        ) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Portal, { id: "turnOnSyncDialogPortal", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
        TurnOnSyncDialog,
        {
          close: () => setTurnOnSyncDialogOpen(false),
          open: turnOnSyncDialogOpen,
          setSyncCloudId
        }
      ) })
    ] });
  };
  var SyncNow = (props) => {
    const {
      initialItems: { syncResult: initialSyncResult }
    } = useOptionsContext();
    const [syncResult, setSyncResult] = (0, import_react38.useState)(initialSyncResult);
    const [updated, setUpdated] = (0, import_react38.useState)(false);
    const [syncing, setSyncing] = (0, import_react38.useState)(false);
    (0, import_react38.useEffect)(
      () => addMessageListeners({
        syncing: (id2) => {
          if (id2 !== props.syncCloudId) {
            return;
          }
          setUpdated(false);
          setSyncing(true);
        },
        synced: (id2, result, updated2) => {
          if (id2 !== props.syncCloudId) {
            return;
          }
          setSyncResult(result);
          setUpdated(updated2);
          setSyncing(false);
        }
      }),
      [props.syncCloudId]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(SectionItem, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(Row, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(LabelWrapper, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Label, { children: translate("options_syncResult") }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(SubLabel, { children: [
          syncing ? translate("options_syncRunning") : !props.syncCloudId || !syncResult ? translate("options_syncNever") : isErrorResult(syncResult) ? translate("error", syncResult.message) : /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(FromNow, { time: (0, import_dayjs7.default)(syncResult.timestamp) }),
          updated ? /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(import_jsx_runtime38.Fragment, { children: [
            " ",
            /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
              LinkButton,
              {
                onClick: () => {
                  window.location.reload();
                },
                children: translate("options_syncReloadButton")
              }
            )
          ] }) : null
        ] })
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
        Button,
        {
          disabled: syncing || !props.syncCloudId,
          onClick: () => {
            void sendMessage("sync");
          },
          children: translate("options_syncNowButton")
        }
      ) })
    ] }) });
  };
  var SyncCategories = ({ disabled }) => /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(SectionItem, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Row, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(LabelWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Label, { children: translate("options_syncCategories") }) }) }) }),
    /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(Row, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(RowItem, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Indent, {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(RowItem, { expanded: true, children: /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(List, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(ListItem, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
          SetBooleanItem,
          {
            disabled,
            itemKey: "syncBlocklist",
            label: translate("options_syncBlocklist")
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(ListItem, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
          SetBooleanItem,
          {
            disabled,
            itemKey: "syncGeneral",
            label: translate("options_syncGeneral")
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(ListItem, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
          SetBooleanItem,
          {
            disabled,
            itemKey: "syncAppearance",
            label: translate("options_syncAppearance")
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(ListItem, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
          SetBooleanItem,
          {
            disabled,
            itemKey: "syncSubscriptions",
            label: translate("options_syncSubscriptions")
          }
        ) })
      ] }) })
    ] })
  ] });
  var SyncSection = () => {
    const {
      initialItems: { syncCloudId: initialSyncCloudId }
    } = useOptionsContext();
    const [syncCloudId, setSyncCloudId] = (0, import_react38.useState)(initialSyncCloudId);
    return /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(Section, { "aria-labelledby": "syncSectionTitle", id: "sync", children: [
      /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(SectionHeader, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(SectionTitle, { id: "syncSectionTitle", children: translate("options_syncTitle") }) }),
      /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(SectionBody, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(TurnOnSync, { setSyncCloudId, syncCloudId }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(SyncNow, { syncCloudId }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(SyncCategories, { disabled: !syncCloudId }),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(SectionItem, { children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
          SetIntervalItem,
          {
            disabled: !syncCloudId,
            itemKey: "syncInterval",
            label: translate("options_syncInterval"),
            valueOptions: [5, 10, 15, 30, 60, 120]
          }
        ) })
      ] })
    ] });
  };

  // src/scripts/options.tsx
  var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
  var Options = () => /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(AutoThemeProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Baseline, { children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(OptionsContextProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)(Container, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(GeneralSection, {}),
    /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(AppearanceSection, {}),
    /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(SyncSection, {}),
    /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(SubscriptionSection, {}),
    /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(BackupRestoreSection, {}),
    /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(AboutSection, {})
  ] }) }) }) });
  function main() {
    document.documentElement.lang = translate("lang");
    const root = (0, import_client.createRoot)(
      document.body.appendChild(document.createElement("div"))
    );
    root.render(/* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Options, {}));
  }
  main();
})();
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
