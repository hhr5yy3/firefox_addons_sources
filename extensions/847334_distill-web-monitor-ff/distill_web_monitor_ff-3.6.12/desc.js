const DATE_0 = new Date(0);
const DAYS = [0, 1, 2, 3, 4, 5, 6];
const DAY_NAMES = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];

ActionDescriptors = {};

ActionDescriptors[C.ACTION_EMAIL] = {
  descriptors: [{
    desc: 'Template for subject',
    name: 'subject',
    type: 'STRING_TEMPLATE',
  }, {
    desc: 'Template for email body',
    name: 'body',
    type: 'HTML_TEMPLATE',
  }],
  /**
   * Dispatches the alert.
   *
   * @action Configuration parameters. Must conform to descriptor.
   * @data Data generated by an alert.
   * @cb Callback to call when done.
   */
  act: function alert_email(action, context, cb) {
    ActionEmail.send(action, context, cb);
  },
},

ActionDescriptors[C.ACTION_LOCAL_POPUP] = {
  descriptors: [],
  act: function(action, context, cb) {
    if (Prefs.get('actions.popup', true)) {
      NotifyPopup.show(action, context);
    }
    cb();
  },
};

ActionDescriptors[C.ACTION_PUSH] = {
  descriptors: [],
  act: function(action, context, cb) {
    ActionPush.send(action, context, cb);
  },
};

ActionDescriptors[C.ACTION_SMS] = {
  descriptors: [{
  }],
  act: function(action, context, cb) {
    ActionSMS.send(action, context, cb);
  },
};

ActionDescriptors[C.ACTION_WEBHOOK] = {
  descriptors: [],
  act: function(action, context, cb) {
    ActionWebhook.send(action, context, cb);
  },
};

ActionDescriptors[C.ACTION_SLACK] = {
  descriptors: [],
  act: function(action, context, cb) {
    ActionSlack.send(action, context, cb);
  },
};

ActionDescriptors[C.ACTION_DISCORD] = {
  descriptors: [],
  act: function(action, context, cb) {
    ActionDiscord.send(action, context, cb);
  },
};

ActionDescriptors[C.ACTION_LOCAL_OPEN_TAB] = {
  descriptors: [],
  act: function(action, context, cb) {
    ActionTab.open(action, context, cb);
  },
};
ActionDescriptors[C.ACTION_LOCAL_AUDIO] = {
  descriptors: [{
    desc: 'Name or URL of the file to play audio',
    must: true,
    name: 'src',
    type: 'SRC',
  }, {
    desc: 'Playback duration',
    must: false,
    name: 'duration',
    type: 'DURATION',
  }],
  act: function(action, context, cb) {
    if (Prefs.get('actions.audio', true)) {
      NotifyAudio.play(action, context);
    }
    cb();
  },
};

ActionDescriptors[C.ACTION_MACRO] = {
  descriptors: [],
  act: function(action, context, cb) {
    ActionMacro.run(action, context, cb);
  },
};

ScheduleDescriptors = {
  undefined: {
    getSchedule: function(params, logs) {
      return -1;
    },
  },
  LIVE: {
    getSchedule: function() {
      return 0;
    },
  },
  INTERVAL: {
    getSchedule: function(params, logs) {
      let
        checkedOn; let lastCheckedOn;


      const interval = params.interval;
      // in sec

      const now = Date.now()/1000 | 0;

      if (_.isUndefined(interval)) {
        return -1;
      }

      if (interval >= C.TIME_INFINITE) {
        return -1;
      }

      checkedOn = _.map(logs, function(log) {
        return new Date(log.ts);
      });

      lastCheckedOn = (_.max(checkedOn) || DATE_0).valueOf()/1000 | 0;

      if (logs.length > 0 && logs[0].err) {
        // Previously there was an error. Reschedule after 120 secs
        const
          errs = _.pluck(logs, 'err');


        const indexNull = _.indexOf(errs, null);
        if (indexNull >= 0) {
          // Additionally perform quick check iff there has been atleast one
          // successful check in the log.
          return lastCheckedOn + Math.min(120, interval);
        }
      }

      return Math.max(now, lastCheckedOn + interval) + 1; // +1 offsets |0
    },
  },

  RANDOM: {
    getSchedule: function(params, logs) {
      let
        checkedOn; let lastCheckedOn;


      const min = params.min;


      const max = params.max;


      const now = Date.now()/1000 | 0;

      if (_.isUndefined(min) || _.isUndefined(max)) {
        return -1;
      }

      if (min >= C.TIME_INFINITE || max >= C.TIME_INFINITE) {
        return -1;
      }

      checkedOn = _.map(logs, function(log) {
        return new Date(log.ts);
      });

      lastCheckedOn = (_.max(checkedOn) || DATE_0).valueOf()/1000 | 0;

      if (logs.length > 0 && logs[0].err) {
        // Previously there was an error. Reschedule after 120 secs
        const
          errs = _.pluck(logs, 'err');


        const indexNull = _.indexOf(errs, null);
        if (indexNull >= 0) {
          // Additionally perform quick check iff there has been atleast one
          // successful check in the log.
          return lastCheckedOn + Math.min(120, max);
        }
      }

      return Math.max(now, lastCheckedOn + (Math.random()*(max-min)+min)) + 1;
    },
  },
};
