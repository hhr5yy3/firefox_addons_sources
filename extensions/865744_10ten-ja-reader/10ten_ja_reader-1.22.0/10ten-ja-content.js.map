{"version":3,"file":"10ten-ja-content.js","sources":["webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+json-equalish@1.1.2/node_modules/@birchill/json-equalish/src/index.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/webextension-polyfill@0.12.0/node_modules/webextension-polyfill/dist/browser-polyfill.js","webpack://10ten-ja-reader/./node_modules/.pnpm/superstruct@2.0.2/node_modules/superstruct/dist/index.mjs","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+discriminator@0.3.0_superstruct@2.0.2/node_modules/@birchill/discriminator/src/index.ts","webpack://10ten-ja-reader/./src/content/popup-state.ts","webpack://10ten-ja-reader/./src/background/background-message.ts","webpack://10ten-ja-reader/./src/common/copy-keys.ts","webpack://10ten-ja-reader/./src/utils/dom-utils.ts","webpack://10ten-ja-reader/./src/utils/geometry.ts","webpack://10ten-ja-reader/./src/utils/mod.ts","webpack://10ten-ja-reader/./src/utils/strip-fields.ts","webpack://10ten-ja-reader/./src/utils/ua-utils.ts","webpack://10ten-ja-reader/./src/utils/builder.ts","webpack://10ten-ja-reader/./src/content/clipboard.ts","webpack://10ten-ja-reader/./src/utils/device.ts","webpack://10ten-ja-reader/./src/content/content-config.ts","webpack://10ten-ja-reader/./src/common/priority-labels.ts","webpack://10ten-ja-reader/./src/common/refs.ts","webpack://10ten-ja-reader/./src/content/reference-value.ts","webpack://10ten-ja-reader/./src/content/copy-text.ts","webpack://10ten-ja-reader/./src/content/gdocs-canvas.ts","webpack://10ten-ja-reader/./src/content/get-copy-entry.ts","webpack://10ten-ja-reader/./src/utils/range.ts","webpack://10ten-ja-reader/./src/content/content-type.ts","webpack://10ten-ja-reader/./src/content/popup/popup-container.ts","webpack://10ten-ja-reader/./src/content/scroll-offset.ts","webpack://10ten-ja-reader/./src/content/get-cursor-position.ts","webpack://10ten-ja-reader/./src/utils/char-range.ts","webpack://10ten-ja-reader/./src/content/numbers.ts","webpack://10ten-ja-reader/./src/content/currency.ts","webpack://10ten-ja-reader/./src/content/measure.ts","webpack://10ten-ja-reader/./src/content/shogi.ts","webpack://10ten-ja-reader/./src/content/years.ts","webpack://10ten-ja-reader/./src/content/meta.ts","webpack://10ten-ja-reader/./src/content/scan-text.ts","webpack://10ten-ja-reader/./src/content/get-text.ts","webpack://10ten-ja-reader/./src/content/iframes.ts","webpack://10ten-ja-reader/./src/content/keyboard.ts","webpack://10ten-ja-reader/./src/content/popup/copy-state.ts","webpack://10ten-ja-reader/./src/utils/themes.ts","webpack://10ten-ja-reader/./src/utils/hash.ts","webpack://10ten-ja-reader/./src/content/svg.ts","webpack://10ten-ja-reader/./src/content/content-container.ts","webpack://10ten-ja-reader/./src/content/popup/font-styles.ts","webpack://10ten-ja-reader/./src/content/popup/popup.ts","webpack://10ten-ja-reader/./src/content/popup/popup-position.ts","webpack://10ten-ja-reader/./src/content/puck.ts","webpack://10ten-ja-reader/./src/content/popup/arrow.ts","webpack://10ten-ja-reader/./src/content/popup/icons.ts","webpack://10ten-ja-reader/./src/content/popup/close.ts","webpack://10ten-ja-reader/./src/content/popup/lang-tag.ts","webpack://10ten-ja-reader/./src/content/popup/copy-overlay.ts","webpack://10ten-ja-reader/./src/utils/round.ts","webpack://10ten-ja-reader/./src/content/popup/expandable.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/src/constants.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/src/util.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/src/options.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/src/create-element.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/src/component.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/src/diff/props.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/src/create-context.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/src/diff/children.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/src/diff/index.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/src/render.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/src/clone-element.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/src/diff/catch-error.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/hooks/src/index.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/compat/src/util.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/compat/src/PureComponent.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/compat/src/memo.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/compat/src/forwardRef.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/compat/src/Children.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/compat/src/suspense.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/compat/src/suspense-list.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/compat/src/portals.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/compat/src/render.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/compat/src/index.js","webpack://10ten-ja-reader/./node_modules/.pnpm/preact@10.24.2/node_modules/preact/jsx-runtime/src/index.js","webpack://10ten-ja-reader/./src/utils/classes.ts","webpack://10ten-ja-reader/./src/common/i18n.tsx","webpack://10ten-ja-reader/./src/content/popup/FrequencyIndicator.tsx","webpack://10ten-ja-reader/./src/content/popup/GradeIndicator.tsx","webpack://10ten-ja-reader/./src/content/popup/KanjiComponents.tsx","webpack://10ten-ja-reader/./src/content/popup/KanjiMeta.tsx","webpack://10ten-ja-reader/./src/content/popup/KanjiReadings.tsx","webpack://10ten-ja-reader/./src/content/popup/StrokeCount.tsx","webpack://10ten-ja-reader/./src/content/popup/KanjiInfo.tsx","webpack://10ten-ja-reader/./src/content/popup/KanjiReferencesTable.tsx","webpack://10ten-ja-reader/./src/content/popup/KanjiStrokeAnimation.tsx","webpack://10ten-ja-reader/./src/content/popup/options-context.tsx","webpack://10ten-ja-reader/./src/content/popup/selection.ts","webpack://10ten-ja-reader/./src/content/popup/KanjiEntry.tsx","webpack://10ten-ja-reader/./src/content/popup/selected-index.ts","webpack://10ten-ja-reader/./src/content/popup/kanji.ts","webpack://10ten-ja-reader/./src/content/popup/metadata.ts","webpack://10ten-ja-reader/./src/utils/age.ts","webpack://10ten-ja-reader/./src/content/popup/names.ts","webpack://10ten-ja-reader/./src/content/popup/status.ts","webpack://10ten-ja-reader/./src/content/popup/swipe.ts","webpack://10ten-ja-reader/./src/content/popup/tabs.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/idb@8.0.0/node_modules/idb/build/index.js","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+normal-jp@1.5.2/node_modules/@birchill/normal-jp/src/to-normalized.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+normal-jp@1.5.2/node_modules/@birchill/normal-jp/src/mora.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/abort-error.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/download-error.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/validation-helpers.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/download-version-info.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/download.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/quota-exceeded-error.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/download-types.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/grouping.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/offline-error.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/words.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/word-result-sorting.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/request-idle-callback.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/update-key.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/update-with-retry.ts","webpack://10ten-ja-reader/./src/utils/verb-tags.ts","webpack://10ten-ja-reader/./src/content/popup/words.ts","webpack://10ten-ja-reader/./src/content/popup/render-popup.ts","webpack://10ten-ja-reader/./src/content/popup/show-popup.ts","webpack://10ten-ja-reader/./src/content/query.ts","webpack://10ten-ja-reader/./src/content/safe-area-provider.ts","webpack://10ten-ja-reader/./src/content/target-props.ts","webpack://10ten-ja-reader/./src/content/text-highlighter.ts","webpack://10ten-ja-reader/./src/content/text-range.ts","webpack://10ten-ja-reader/./src/content/timer-precision.ts","webpack://10ten-ja-reader/./src/content/touch-click-tracker.ts","webpack://10ten-ja-reader/./src/content/content.ts"],"sourcesContent":["export function jsonEqualish(actual: any, expected: any) {\n  if (Object.is(actual, expected)) {\n    return true;\n  }\n\n  // For non-objects, use Object.is. This will cause 'undefined' and 'null' to\n  // be different, as desired.\n  if (\n    !actual ||\n    !expected ||\n    (typeof actual !== 'object' && typeof expected !== 'object')\n  ) {\n    // Except for numbers, since we want '-0' and '+0' to be equivalent\n    //\n    // (We should really just use JSON.stringify here. Might be slower but would\n    // it matter?)\n    return typeof actual === 'number'\n      ? actual === expected\n      : Object.is(actual, expected);\n  }\n\n  return objEquiv(actual, expected);\n}\n\nfunction objEquiv(a: any, b: any) {\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a instanceof Date) {\n    return b instanceof Date && a.getTime() == b.getTime();\n  }\n\n  if (Array.isArray(a) !== Array.isArray(b)) {\n    return false;\n  }\n\n  // We only deal with POD at the moment.\n  if (\n    (a.constructor && a.constructor !== Object && a.constructor !== Array) ||\n    (b.constructor && b.constructor !== Object && b.constructor !== Array)\n  ) {\n    throw new Error('Trying to compare something fancy');\n  }\n\n  const aKeys = definedKeys(a);\n  const bKeys = definedKeys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n\n  aKeys.sort();\n  bKeys.sort();\n\n  // Compare keys first\n  for (let i = 0; i < aKeys.length; ++i) {\n    if (aKeys[i] != bKeys[i]) {\n      return false;\n    }\n  }\n\n  // Compare values\n  for (const key of aKeys) {\n    if (!jsonEqualish(a[key], b[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction definedKeys(a: any) {\n  return Object.keys(a).filter(key => typeof a[key] !== 'undefined');\n}\n\nexport default jsonEqualish;\n","/* webextension-polyfill - v0.12.0 - Tue May 14 2024 18:01:29 */\n/* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */\n/* vim: set sts=2 sw=2 et tw=80: */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\"use strict\";\n\nif (!(globalThis.chrome && globalThis.chrome.runtime && globalThis.chrome.runtime.id)) {\n  throw new Error(\"This script should only be loaded in a browser extension.\");\n}\n\nif (!(globalThis.browser && globalThis.browser.runtime && globalThis.browser.runtime.id)) {\n  const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = \"The message port closed before a response was received.\";\n\n  // Wrapping the bulk of this polyfill in a one-time-use function is a minor\n  // optimization for Firefox. Since Spidermonkey does not fully parse the\n  // contents of a function until the first time it's called, and since it will\n  // never actually need to be called, this allows the polyfill to be included\n  // in Firefox nearly for free.\n  const wrapAPIs = extensionAPIs => {\n    // NOTE: apiMetadata is associated to the content of the api-metadata.json file\n    // at build time by replacing the following \"include\" with the content of the\n    // JSON file.\n    const apiMetadata = {\n      \"alarms\": {\n        \"clear\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"clearAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"get\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"bookmarks\": {\n        \"create\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"get\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getChildren\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getRecent\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getSubTree\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getTree\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"move\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        },\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeTree\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"search\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"update\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        }\n      },\n      \"browserAction\": {\n        \"disable\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"enable\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"getBadgeBackgroundColor\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getBadgeText\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getPopup\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getTitle\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"openPopup\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"setBadgeBackgroundColor\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"setBadgeText\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"setIcon\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"setPopup\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"setTitle\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        }\n      },\n      \"browsingData\": {\n        \"remove\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        },\n        \"removeCache\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeCookies\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeDownloads\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeFormData\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeHistory\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeLocalStorage\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removePasswords\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removePluginData\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"settings\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"commands\": {\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"contextMenus\": {\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"update\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        }\n      },\n      \"cookies\": {\n        \"get\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getAll\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getAllCookieStores\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"set\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"devtools\": {\n        \"inspectedWindow\": {\n          \"eval\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2,\n            \"singleCallbackArg\": false\n          }\n        },\n        \"panels\": {\n          \"create\": {\n            \"minArgs\": 3,\n            \"maxArgs\": 3,\n            \"singleCallbackArg\": true\n          },\n          \"elements\": {\n            \"createSidebarPane\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          }\n        }\n      },\n      \"downloads\": {\n        \"cancel\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"download\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"erase\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getFileIcon\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"open\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"pause\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeFile\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"resume\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"search\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"show\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        }\n      },\n      \"extension\": {\n        \"isAllowedFileSchemeAccess\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"isAllowedIncognitoAccess\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"history\": {\n        \"addUrl\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"deleteAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"deleteRange\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"deleteUrl\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getVisits\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"search\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"i18n\": {\n        \"detectLanguage\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getAcceptLanguages\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"identity\": {\n        \"launchWebAuthFlow\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"idle\": {\n        \"queryState\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"management\": {\n        \"get\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"getSelf\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"setEnabled\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        },\n        \"uninstallSelf\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        }\n      },\n      \"notifications\": {\n        \"clear\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"create\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"getPermissionLevel\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"update\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        }\n      },\n      \"pageAction\": {\n        \"getPopup\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getTitle\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"hide\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"setIcon\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"setPopup\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"setTitle\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"show\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        }\n      },\n      \"permissions\": {\n        \"contains\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"request\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"runtime\": {\n        \"getBackgroundPage\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"getPlatformInfo\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"openOptionsPage\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"requestUpdateCheck\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"sendMessage\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 3\n        },\n        \"sendNativeMessage\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        },\n        \"setUninstallURL\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"sessions\": {\n        \"getDevices\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"getRecentlyClosed\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"restore\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        }\n      },\n      \"storage\": {\n        \"local\": {\n          \"clear\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getBytesInUse\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"set\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"managed\": {\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getBytesInUse\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"sync\": {\n          \"clear\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getBytesInUse\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"set\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        }\n      },\n      \"tabs\": {\n        \"captureVisibleTab\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 2\n        },\n        \"create\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"detectLanguage\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"discard\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"duplicate\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"executeScript\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"get\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getCurrent\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"getZoom\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"getZoomSettings\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"goBack\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"goForward\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"highlight\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"insertCSS\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"move\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        },\n        \"query\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"reload\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 2\n        },\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeCSS\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"sendMessage\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 3\n        },\n        \"setZoom\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"setZoomSettings\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"update\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        }\n      },\n      \"topSites\": {\n        \"get\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"webNavigation\": {\n        \"getAllFrames\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getFrame\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"webRequest\": {\n        \"handlerBehaviorChanged\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"windows\": {\n        \"create\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"get\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"getCurrent\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"getLastFocused\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"update\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        }\n      }\n    };\n\n    if (Object.keys(apiMetadata).length === 0) {\n      throw new Error(\"api-metadata.json has not been included in browser-polyfill\");\n    }\n\n    /**\n     * A WeakMap subclass which creates and stores a value for any key which does\n     * not exist when accessed, but behaves exactly as an ordinary WeakMap\n     * otherwise.\n     *\n     * @param {function} createItem\n     *        A function which will be called in order to create the value for any\n     *        key which does not exist, the first time it is accessed. The\n     *        function receives, as its only argument, the key being created.\n     */\n    class DefaultWeakMap extends WeakMap {\n      constructor(createItem, items = undefined) {\n        super(items);\n        this.createItem = createItem;\n      }\n\n      get(key) {\n        if (!this.has(key)) {\n          this.set(key, this.createItem(key));\n        }\n\n        return super.get(key);\n      }\n    }\n\n    /**\n     * Returns true if the given object is an object with a `then` method, and can\n     * therefore be assumed to behave as a Promise.\n     *\n     * @param {*} value The value to test.\n     * @returns {boolean} True if the value is thenable.\n     */\n    const isThenable = value => {\n      return value && typeof value === \"object\" && typeof value.then === \"function\";\n    };\n\n    /**\n     * Creates and returns a function which, when called, will resolve or reject\n     * the given promise based on how it is called:\n     *\n     * - If, when called, `chrome.runtime.lastError` contains a non-null object,\n     *   the promise is rejected with that value.\n     * - If the function is called with exactly one argument, the promise is\n     *   resolved to that value.\n     * - Otherwise, the promise is resolved to an array containing all of the\n     *   function's arguments.\n     *\n     * @param {object} promise\n     *        An object containing the resolution and rejection functions of a\n     *        promise.\n     * @param {function} promise.resolve\n     *        The promise's resolution function.\n     * @param {function} promise.reject\n     *        The promise's rejection function.\n     * @param {object} metadata\n     *        Metadata about the wrapped method which has created the callback.\n     * @param {boolean} metadata.singleCallbackArg\n     *        Whether or not the promise is resolved with only the first\n     *        argument of the callback, alternatively an array of all the\n     *        callback arguments is resolved. By default, if the callback\n     *        function is invoked with only a single argument, that will be\n     *        resolved to the promise, while all arguments will be resolved as\n     *        an array if multiple are given.\n     *\n     * @returns {function}\n     *        The generated callback function.\n     */\n    const makeCallback = (promise, metadata) => {\n      return (...callbackArgs) => {\n        if (extensionAPIs.runtime.lastError) {\n          promise.reject(new Error(extensionAPIs.runtime.lastError.message));\n        } else if (metadata.singleCallbackArg ||\n                   (callbackArgs.length <= 1 && metadata.singleCallbackArg !== false)) {\n          promise.resolve(callbackArgs[0]);\n        } else {\n          promise.resolve(callbackArgs);\n        }\n      };\n    };\n\n    const pluralizeArguments = (numArgs) => numArgs == 1 ? \"argument\" : \"arguments\";\n\n    /**\n     * Creates a wrapper function for a method with the given name and metadata.\n     *\n     * @param {string} name\n     *        The name of the method which is being wrapped.\n     * @param {object} metadata\n     *        Metadata about the method being wrapped.\n     * @param {integer} metadata.minArgs\n     *        The minimum number of arguments which must be passed to the\n     *        function. If called with fewer than this number of arguments, the\n     *        wrapper will raise an exception.\n     * @param {integer} metadata.maxArgs\n     *        The maximum number of arguments which may be passed to the\n     *        function. If called with more than this number of arguments, the\n     *        wrapper will raise an exception.\n     * @param {boolean} metadata.singleCallbackArg\n     *        Whether or not the promise is resolved with only the first\n     *        argument of the callback, alternatively an array of all the\n     *        callback arguments is resolved. By default, if the callback\n     *        function is invoked with only a single argument, that will be\n     *        resolved to the promise, while all arguments will be resolved as\n     *        an array if multiple are given.\n     *\n     * @returns {function(object, ...*)}\n     *       The generated wrapper function.\n     */\n    const wrapAsyncFunction = (name, metadata) => {\n      return function asyncFunctionWrapper(target, ...args) {\n        if (args.length < metadata.minArgs) {\n          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n        }\n\n        if (args.length > metadata.maxArgs) {\n          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n        }\n\n        return new Promise((resolve, reject) => {\n          if (metadata.fallbackToNoCallback) {\n            // This API method has currently no callback on Chrome, but it return a promise on Firefox,\n            // and so the polyfill will try to call it with a callback first, and it will fallback\n            // to not passing the callback if the first call fails.\n            try {\n              target[name](...args, makeCallback({resolve, reject}, metadata));\n            } catch (cbError) {\n              console.warn(`${name} API method doesn't seem to support the callback parameter, ` +\n                           \"falling back to call it without a callback: \", cbError);\n\n              target[name](...args);\n\n              // Update the API method metadata, so that the next API calls will not try to\n              // use the unsupported callback anymore.\n              metadata.fallbackToNoCallback = false;\n              metadata.noCallback = true;\n\n              resolve();\n            }\n          } else if (metadata.noCallback) {\n            target[name](...args);\n            resolve();\n          } else {\n            target[name](...args, makeCallback({resolve, reject}, metadata));\n          }\n        });\n      };\n    };\n\n    /**\n     * Wraps an existing method of the target object, so that calls to it are\n     * intercepted by the given wrapper function. The wrapper function receives,\n     * as its first argument, the original `target` object, followed by each of\n     * the arguments passed to the original method.\n     *\n     * @param {object} target\n     *        The original target object that the wrapped method belongs to.\n     * @param {function} method\n     *        The method being wrapped. This is used as the target of the Proxy\n     *        object which is created to wrap the method.\n     * @param {function} wrapper\n     *        The wrapper function which is called in place of a direct invocation\n     *        of the wrapped method.\n     *\n     * @returns {Proxy<function>}\n     *        A Proxy object for the given method, which invokes the given wrapper\n     *        method in its place.\n     */\n    const wrapMethod = (target, method, wrapper) => {\n      return new Proxy(method, {\n        apply(targetMethod, thisObj, args) {\n          return wrapper.call(thisObj, target, ...args);\n        },\n      });\n    };\n\n    let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);\n\n    /**\n     * Wraps an object in a Proxy which intercepts and wraps certain methods\n     * based on the given `wrappers` and `metadata` objects.\n     *\n     * @param {object} target\n     *        The target object to wrap.\n     *\n     * @param {object} [wrappers = {}]\n     *        An object tree containing wrapper functions for special cases. Any\n     *        function present in this object tree is called in place of the\n     *        method in the same location in the `target` object tree. These\n     *        wrapper methods are invoked as described in {@see wrapMethod}.\n     *\n     * @param {object} [metadata = {}]\n     *        An object tree containing metadata used to automatically generate\n     *        Promise-based wrapper functions for asynchronous. Any function in\n     *        the `target` object tree which has a corresponding metadata object\n     *        in the same location in the `metadata` tree is replaced with an\n     *        automatically-generated wrapper function, as described in\n     *        {@see wrapAsyncFunction}\n     *\n     * @returns {Proxy<object>}\n     */\n    const wrapObject = (target, wrappers = {}, metadata = {}) => {\n      let cache = Object.create(null);\n      let handlers = {\n        has(proxyTarget, prop) {\n          return prop in target || prop in cache;\n        },\n\n        get(proxyTarget, prop, receiver) {\n          if (prop in cache) {\n            return cache[prop];\n          }\n\n          if (!(prop in target)) {\n            return undefined;\n          }\n\n          let value = target[prop];\n\n          if (typeof value === \"function\") {\n            // This is a method on the underlying object. Check if we need to do\n            // any wrapping.\n\n            if (typeof wrappers[prop] === \"function\") {\n              // We have a special-case wrapper for this method.\n              value = wrapMethod(target, target[prop], wrappers[prop]);\n            } else if (hasOwnProperty(metadata, prop)) {\n              // This is an async method that we have metadata for. Create a\n              // Promise wrapper for it.\n              let wrapper = wrapAsyncFunction(prop, metadata[prop]);\n              value = wrapMethod(target, target[prop], wrapper);\n            } else {\n              // This is a method that we don't know or care about. Return the\n              // original method, bound to the underlying object.\n              value = value.bind(target);\n            }\n          } else if (typeof value === \"object\" && value !== null &&\n                     (hasOwnProperty(wrappers, prop) ||\n                      hasOwnProperty(metadata, prop))) {\n            // This is an object that we need to do some wrapping for the children\n            // of. Create a sub-object wrapper for it with the appropriate child\n            // metadata.\n            value = wrapObject(value, wrappers[prop], metadata[prop]);\n          } else if (hasOwnProperty(metadata, \"*\")) {\n            // Wrap all properties in * namespace.\n            value = wrapObject(value, wrappers[prop], metadata[\"*\"]);\n          } else {\n            // We don't need to do any wrapping for this property,\n            // so just forward all access to the underlying object.\n            Object.defineProperty(cache, prop, {\n              configurable: true,\n              enumerable: true,\n              get() {\n                return target[prop];\n              },\n              set(value) {\n                target[prop] = value;\n              },\n            });\n\n            return value;\n          }\n\n          cache[prop] = value;\n          return value;\n        },\n\n        set(proxyTarget, prop, value, receiver) {\n          if (prop in cache) {\n            cache[prop] = value;\n          } else {\n            target[prop] = value;\n          }\n          return true;\n        },\n\n        defineProperty(proxyTarget, prop, desc) {\n          return Reflect.defineProperty(cache, prop, desc);\n        },\n\n        deleteProperty(proxyTarget, prop) {\n          return Reflect.deleteProperty(cache, prop);\n        },\n      };\n\n      // Per contract of the Proxy API, the \"get\" proxy handler must return the\n      // original value of the target if that value is declared read-only and\n      // non-configurable. For this reason, we create an object with the\n      // prototype set to `target` instead of using `target` directly.\n      // Otherwise we cannot return a custom object for APIs that\n      // are declared read-only and non-configurable, such as `chrome.devtools`.\n      //\n      // The proxy handlers themselves will still use the original `target`\n      // instead of the `proxyTarget`, so that the methods and properties are\n      // dereferenced via the original targets.\n      let proxyTarget = Object.create(target);\n      return new Proxy(proxyTarget, handlers);\n    };\n\n    /**\n     * Creates a set of wrapper functions for an event object, which handles\n     * wrapping of listener functions that those messages are passed.\n     *\n     * A single wrapper is created for each listener function, and stored in a\n     * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`\n     * retrieve the original wrapper, so that  attempts to remove a\n     * previously-added listener work as expected.\n     *\n     * @param {DefaultWeakMap<function, function>} wrapperMap\n     *        A DefaultWeakMap object which will create the appropriate wrapper\n     *        for a given listener function when one does not exist, and retrieve\n     *        an existing one when it does.\n     *\n     * @returns {object}\n     */\n    const wrapEvent = wrapperMap => ({\n      addListener(target, listener, ...args) {\n        target.addListener(wrapperMap.get(listener), ...args);\n      },\n\n      hasListener(target, listener) {\n        return target.hasListener(wrapperMap.get(listener));\n      },\n\n      removeListener(target, listener) {\n        target.removeListener(wrapperMap.get(listener));\n      },\n    });\n\n    const onRequestFinishedWrappers = new DefaultWeakMap(listener => {\n      if (typeof listener !== \"function\") {\n        return listener;\n      }\n\n      /**\n       * Wraps an onRequestFinished listener function so that it will return a\n       * `getContent()` property which returns a `Promise` rather than using a\n       * callback API.\n       *\n       * @param {object} req\n       *        The HAR entry object representing the network request.\n       */\n      return function onRequestFinished(req) {\n        const wrappedReq = wrapObject(req, {} /* wrappers */, {\n          getContent: {\n            minArgs: 0,\n            maxArgs: 0,\n          },\n        });\n        listener(wrappedReq);\n      };\n    });\n\n    const onMessageWrappers = new DefaultWeakMap(listener => {\n      if (typeof listener !== \"function\") {\n        return listener;\n      }\n\n      /**\n       * Wraps a message listener function so that it may send responses based on\n       * its return value, rather than by returning a sentinel value and calling a\n       * callback. If the listener function returns a Promise, the response is\n       * sent when the promise either resolves or rejects.\n       *\n       * @param {*} message\n       *        The message sent by the other end of the channel.\n       * @param {object} sender\n       *        Details about the sender of the message.\n       * @param {function(*)} sendResponse\n       *        A callback which, when called with an arbitrary argument, sends\n       *        that value as a response.\n       * @returns {boolean}\n       *        True if the wrapped listener returned a Promise, which will later\n       *        yield a response. False otherwise.\n       */\n      return function onMessage(message, sender, sendResponse) {\n        let didCallSendResponse = false;\n\n        let wrappedSendResponse;\n        let sendResponsePromise = new Promise(resolve => {\n          wrappedSendResponse = function(response) {\n            didCallSendResponse = true;\n            resolve(response);\n          };\n        });\n\n        let result;\n        try {\n          result = listener(message, sender, wrappedSendResponse);\n        } catch (err) {\n          result = Promise.reject(err);\n        }\n\n        const isResultThenable = result !== true && isThenable(result);\n\n        // If the listener didn't returned true or a Promise, or called\n        // wrappedSendResponse synchronously, we can exit earlier\n        // because there will be no response sent from this listener.\n        if (result !== true && !isResultThenable && !didCallSendResponse) {\n          return false;\n        }\n\n        // A small helper to send the message if the promise resolves\n        // and an error if the promise rejects (a wrapped sendMessage has\n        // to translate the message into a resolved promise or a rejected\n        // promise).\n        const sendPromisedResult = (promise) => {\n          promise.then(msg => {\n            // send the message value.\n            sendResponse(msg);\n          }, error => {\n            // Send a JSON representation of the error if the rejected value\n            // is an instance of error, or the object itself otherwise.\n            let message;\n            if (error && (error instanceof Error ||\n                typeof error.message === \"string\")) {\n              message = error.message;\n            } else {\n              message = \"An unexpected error occurred\";\n            }\n\n            sendResponse({\n              __mozWebExtensionPolyfillReject__: true,\n              message,\n            });\n          }).catch(err => {\n            // Print an error on the console if unable to send the response.\n            console.error(\"Failed to send onMessage rejected reply\", err);\n          });\n        };\n\n        // If the listener returned a Promise, send the resolved value as a\n        // result, otherwise wait the promise related to the wrappedSendResponse\n        // callback to resolve and send it as a response.\n        if (isResultThenable) {\n          sendPromisedResult(result);\n        } else {\n          sendPromisedResult(sendResponsePromise);\n        }\n\n        // Let Chrome know that the listener is replying.\n        return true;\n      };\n    });\n\n    const wrappedSendMessageCallback = ({reject, resolve}, reply) => {\n      if (extensionAPIs.runtime.lastError) {\n        // Detect when none of the listeners replied to the sendMessage call and resolve\n        // the promise to undefined as in Firefox.\n        // See https://github.com/mozilla/webextension-polyfill/issues/130\n        if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {\n          resolve();\n        } else {\n          reject(new Error(extensionAPIs.runtime.lastError.message));\n        }\n      } else if (reply && reply.__mozWebExtensionPolyfillReject__) {\n        // Convert back the JSON representation of the error into\n        // an Error instance.\n        reject(new Error(reply.message));\n      } else {\n        resolve(reply);\n      }\n    };\n\n    const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {\n      if (args.length < metadata.minArgs) {\n        throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n      }\n\n      if (args.length > metadata.maxArgs) {\n        throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n      }\n\n      return new Promise((resolve, reject) => {\n        const wrappedCb = wrappedSendMessageCallback.bind(null, {resolve, reject});\n        args.push(wrappedCb);\n        apiNamespaceObj.sendMessage(...args);\n      });\n    };\n\n    const staticWrappers = {\n      devtools: {\n        network: {\n          onRequestFinished: wrapEvent(onRequestFinishedWrappers),\n        },\n      },\n      runtime: {\n        onMessage: wrapEvent(onMessageWrappers),\n        onMessageExternal: wrapEvent(onMessageWrappers),\n        sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {minArgs: 1, maxArgs: 3}),\n      },\n      tabs: {\n        sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {minArgs: 2, maxArgs: 3}),\n      },\n    };\n    const settingMetadata = {\n      clear: {minArgs: 1, maxArgs: 1},\n      get: {minArgs: 1, maxArgs: 1},\n      set: {minArgs: 1, maxArgs: 1},\n    };\n    apiMetadata.privacy = {\n      network: {\"*\": settingMetadata},\n      services: {\"*\": settingMetadata},\n      websites: {\"*\": settingMetadata},\n    };\n\n    return wrapObject(extensionAPIs, staticWrappers, apiMetadata);\n  };\n\n  // The build process adds a UMD wrapper around this file, which makes the\n  // `module` variable available.\n  module.exports = wrapAPIs(chrome);\n} else {\n  module.exports = globalThis.browser;\n}\n","/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null)\n            this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isObject(x) {\n    return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a non-array object.\n */\nfunction isNonArrayObject(x) {\n    return isObject(x) && !Array.isArray(x);\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\nfunction print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\nfunction shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\nfunction toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    }\n    else if (result === false) {\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [result];\n    }\n    for (const r of result) {\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const ctx = { path, branch, mask };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, ctx)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)) {\n        const ts = run(v, s, {\n            path: k === undefined ? path : [...path, k],\n            branch: k === undefined ? branch : [...branch, v],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const t of ts) {\n            if (t[0]) {\n                status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n                yield [t[0], undefined];\n            }\n            else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                }\n                else if (value instanceof Map) {\n                    value.set(k, v);\n                }\n                else if (value instanceof Set) {\n                    value.add(v);\n                }\n                else if (isObject(value)) {\n                    if (v !== undefined || k in value)\n                        value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, ctx)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema. Masking applies recursively to\n     * props of `object` structs only.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `coerce` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful. Also, `mask` will turn on\n     * masking of the unknown `object` props recursively if passed.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\nfunction create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\nfunction mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */\nfunction is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\nfunction validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function* () {\n            for (const t of tuples) {\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    else {\n        const v = tuple[1];\n        return [undefined, v];\n    }\n}\n\nfunction assign(...Structs) {\n    const isType = Structs[0].type === 'type';\n    const schemas = Structs.map((s) => s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\nfunction define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\nfunction deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\nfunction dynamic(fn) {\n    return new Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\nfunction lazy(fn) {\n    let struct;\n    return new Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\nfunction omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\nfunction partial(struct) {\n    const isStruct = struct instanceof Struct;\n    const schema = isStruct ? { ...struct.schema } : { ...struct };\n    for (const key in schema) {\n        schema[key] = optional(schema[key]);\n    }\n    if (isStruct && struct.type === 'type') {\n        return type(schema);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\nfunction pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\nfunction struct(name, validator) {\n    console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n    return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\nfunction any() {\n    return define('any', () => true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()) {\n                    yield [i, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */\nfunction bigint() {\n    return define('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */\nfunction boolean() {\n    return define('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\nfunction date() {\n    return define('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v) => print(v)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n */\nfunction func() {\n    return define('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\nfunction instance(Class) {\n    return define('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */\nfunction integer() {\n    return define('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\nfunction intersection(Structs) {\n    return new Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, ctx) {\n            for (const S of Structs) {\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator(value, ctx) {\n            for (const S of Structs) {\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner(value, ctx) {\n            for (const S of Structs) {\n                yield* S.refiner(value, ctx);\n            }\n        },\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: 'literal',\n        schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()) {\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */\nfunction never() {\n    return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\nfunction nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n */\nfunction number() {\n    return define('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${print(value)}`);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: 'object',\n        schema: schema ? schema : null,\n        *entries(value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value, ctx) {\n            if (!isNonArrayObject(value)) {\n                return value;\n            }\n            const coerced = { ...value };\n            // The `object` struct has special behaviour enabled by the mask flag.\n            // When masking, properties that are not in the schema are deleted from\n            // the coerced object instead of eventually failing validaiton.\n            if (ctx.mask && schema) {\n                for (const key in coerced) {\n                    if (schema[key] === undefined) {\n                        delete coerced[key];\n                    }\n                }\n            }\n            return coerced;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\nfunction optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\nfunction record(Key, Value) {\n    return new Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k in value) {\n                    const v = value[k];\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isNonArrayObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\nfunction regexp() {\n    return define('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const v of value) {\n                    yield [v, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n */\nfunction string() {\n    return define('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\nfunction tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\nfunction type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isNonArrayObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\nfunction union(Structs) {\n    const description = Structs.map((s) => s.type).join(' | ');\n    return new Struct({\n        type: 'union',\n        schema: null,\n        coercer(value, ctx) {\n            for (const S of Structs) {\n                const [error, coerced] = S.validate(value, {\n                    coerce: true,\n                    mask: ctx.mask,\n                });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const S of Structs) {\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                }\n                else {\n                    for (const [failure] of tuples) {\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\nfunction unknown() {\n    return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return is(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x) => {\n        const f = typeof fallback === 'function' ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = { ...x };\n            let changed = false;\n            for (const key in f) {\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction trimmed(struct) {\n    return coerce(struct, string(), (x) => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\nfunction empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\nfunction max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\nfunction min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\nfunction nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\nfunction pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\nfunction size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((min <= value && value <= max) ||\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return ((min <= size && size <= max) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        else {\n            const { length } = value;\n            return ((min <= length && length <= max) ||\n                `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\nfunction refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };\n//# sourceMappingURL=index.mjs.map\n","import * as s from 'superstruct';\n\ntype ObjectSchema = Record<string, s.Struct<any, any>>;\n\nexport type DiscriminatorSchema<\n  FieldType extends string,\n  MappingType extends Record<string, s.Struct<any, any>>\n> = { field: FieldType; mapping: MappingType };\n\n// Similar to assign() but only takes two arguments and if the first argument\n// is a discriminator(), it merges the properties of an object() or type()\n// into the discriminator()'s various branches.\n//\n// Needed for supporting nested discriminator() types.\nfunction extend<\n  A extends\n    | ObjectSchema\n    | DiscriminatorSchema<any, Record<string, s.Struct<any, any>>>,\n  B extends ObjectSchema\n>(a: s.Struct<any, A>, b: s.Struct<any, B>): s.Struct<any, any> {\n  if (a.type === 'discriminator') {\n    const discriminatorSchema = a.schema as DiscriminatorSchema<\n      any,\n      Record<string, s.Struct<any, any>>\n    >;\n    const mapping: Record<string, s.Struct<any, any>> = {};\n    for (const [key, value] of Object.entries(discriminatorSchema.mapping)) {\n      mapping[key] = s.assign(value, b);\n    }\n    return discriminator(a.schema.field, mapping);\n  }\n\n  return s.assign(a as s.Struct<any, ObjectSchema>, b);\n}\n\n// Infer support for discriminator() objects\n\ntype ConvertToUnion<T> = T[keyof T];\n\ntype Flatten<T> = T extends object\n  ? {\n      [P in keyof T]: Flatten<T[P]>;\n    }\n  : T;\n\ntype DiscriminatorType<\n  FieldType extends string,\n  MappingType\n> = MappingType extends Record<string, any>\n  ? Flatten<\n      ConvertToUnion<\n        {\n          [K in keyof MappingType]: { [P in FieldType]: K } &\n            s.Infer<MappingType[K]>;\n        }\n      >\n    >\n  : never;\n\n// This is a slight tweak on what superstruct does because printing \"[Object\n// object]\" is rarely useful.\nfunction print(value: any): string {\n  // If the value is a string we use JSON.stringify for the quotes.\n  //\n  // For objects we use JSON.stringify as a cheap pretty-print function unless\n  // the object includes its own toString() method.\n  if (\n    typeof value === 'string' ||\n    (typeof value === 'object' && value.toString === Object.prototype.toString)\n  ) {\n    return JSON.stringify(value);\n  }\n  return `${value}`;\n}\n\nfunction isObject(a: unknown): a is Record<string, any> {\n  return typeof a === 'object' && a !== null && !Array.isArray(a);\n}\n\nexport const discriminator = <\n  FieldType extends string,\n  MappingType extends Record<string, s.Struct<any, any>>\n>(\n  field: FieldType,\n  mapping: MappingType\n) => {\n  const keys = Object.keys(mapping);\n\n  const getStructForValue = (\n    value: unknown\n  ): s.Struct<any, any> | undefined => {\n    if (\n      !isObject(value) ||\n      typeof value[field] !== 'string' ||\n      !keys.includes(value[field])\n    ) {\n      return undefined;\n    }\n\n    const branch = value[field];\n    const branchStruct = mapping[branch];\n    if (!branchStruct) {\n      return undefined;\n    }\n\n    return extend(branchStruct, s.object({ [field]: s.literal(branch) }));\n  };\n\n  return new s.Struct<\n    DiscriminatorType<FieldType, MappingType>,\n    DiscriminatorSchema<FieldType, MappingType>\n  >({\n    type: 'discriminator',\n    schema: { field, mapping },\n    *entries(value: unknown, context: s.Context) {\n      const struct = getStructForValue(value);\n      if (struct) {\n        yield* struct.entries(value, context);\n      }\n    },\n    validator(value: unknown, context: s.Context) {\n      if (!isObject(value)) {\n        return `Expected an object, but received: ${print(value)}`;\n      }\n\n      if (!(field in value) || typeof value[field] !== 'string') {\n        return `Expected an object with '${field}' property, but received: ${print(\n          value\n        )}`;\n      }\n\n      if (!keys.includes(value[field])) {\n        return `Expected '${field}' to be one of ${keys\n          .map((key) => `'${key}'`)\n          .join(', ')}, but received: '${value[field]}'`;\n      }\n\n      const struct = getStructForValue(value);\n      if (!struct) {\n        return true;\n      }\n\n      return struct.validator(value, context);\n    },\n  });\n};\n","import { discriminator } from '@birchill/discriminator';\nimport * as s from 'superstruct';\n\nexport const PopupStateSchema = s.type({\n  // Record the position of the window\n  pos: s.optional(\n    s.type({\n      // The frame to which the coordinates are relative.\n      frameId: s.number(),\n      // Page coordinates\n      x: s.number(),\n      y: s.number(),\n      width: s.number(),\n      height: s.number(),\n      direction: s.enums(['vertical', 'horizontal', 'disjoint']),\n      side: s.enums(['before', 'after', 'disjoint']),\n      // Whether or not the popup is allowed to overlap the lookup point.\n      allowOverlap: s.boolean(),\n      // Reference lookup point we should use for determining if a mouse move is\n      // \"between\" the lookup point and the popup.\n      lookupPoint: s.optional(\n        s.type({\n          // Page coordinates\n          x: s.number(),\n          y: s.number(),\n          // Area around the lookup point that should be treated as being \"on\"\n          // the point.\n          //\n          // For example, when the lookup point is the center of a text\n          // character, we want to treat the whole the bbox of the character as\n          // being part of the \"point'.\n          //\n          // This is only needed when the popup transitions from hover -> ghost\n          // display mode and hold-to-show keys are configured (but no longer\n          // pressed, hence the transition). Without this, we can easily get\n          // mousemove events that are outside the lookup point and not on the\n          // path to the popup but where we really don't want to close the\n          // popup since they're still in roughly the same place.\n          //\n          // When we _don't_ have hold-to-show keys configured this is not\n          // a problem because, provided the mouse is still inside the character\n          // that triggered the lookup, we'll keep showing the popup.\n          //\n          // This is expressed as a margin simply so that we don't have to\n          // convert it when transferring between frames.\n          marginX: s.number(),\n          marginY: s.number(),\n        })\n      ),\n    })\n  ),\n\n  // The type of content the popup is positioned relative to.\n  contentType: s.enums(['text', 'image']),\n\n  // The particular appearance and behavior of the popup\n  display: discriminator('mode', {\n    // static: no interactivity, small tabs, no close button etc.\n    static: s.type({}),\n    // ghost: not interactive yet, shows tabs etc. but has a dotted outline,\n    // has no pointer events, and no arrow. Used while scanning using the mouse\n    // before settling on a word to lookup.\n    ghost: discriminator('trigger', {\n      // Transition to hover when the timeout expires\n      timeout: s.type({ timeout: s.number() }),\n      // Transition to hover when the following keys are no longer held\n      keys: s.type({ keyType: s.number() }),\n    }),\n    // hover: interactive using the mouse by hovering over it. Shows an arrow\n    // to the lookup point.\n    hover: s.type({}),\n    // pinned: similar to hover but remains visible even if the mouse moves\n    // outside the popup.\n    pinned: s.type({}),\n    // touch: interactive using touch events. Has no arrow to the lookup point\n    // and does not allowing hovering over using the mouse.\n    touch: s.type({}),\n  }),\n});\n\nexport type PopupState = s.Infer<typeof PopupStateSchema>;\n\nexport type DisplayMode = PopupState['display']['mode'];\n\nexport function clearPopupTimeout(popupState?: PopupState) {\n  if (\n    popupState?.display.mode === 'ghost' &&\n    popupState.display.trigger === 'timeout'\n  ) {\n    window.clearTimeout(popupState.display.timeout);\n  }\n}\n","import { discriminator } from '@birchill/discriminator';\nimport * as s from 'superstruct';\n\nimport { PopupState, PopupStateSchema } from '../content/popup-state';\n\nexport const BackgroundMessageSchema = discriminator('type', {\n  disable: s.type({ frame: s.literal('*') }),\n  enable: s.type({\n    // We don't validate the contents of the config object yet\n    config: s.type({}),\n    id: s.optional(s.number()),\n    frame: s.literal('*'),\n  }),\n  dbUpdated: s.type({ frame: s.literal('*') }),\n  isTopMost: s.type({ frame: s.number() }),\n\n  //\n  // Relayed messages from other content scripts\n  //\n\n  // Popup showing status\n  popupShown: s.type({\n    frame: s.union([s.literal('children'), s.number()]),\n    state: PopupStateSchema,\n  }),\n  popupHidden: s.type({ frame: s.literal('children') }),\n  isPopupShowing: s.type({ frameId: s.number(), frame: s.literal('top') }),\n\n  // Text highlighting\n  highlightText: s.type({ length: s.number(), frame: s.number() }),\n  clearTextHighlight: s.type({ frame: s.number() }),\n\n  // Lookup-related messages\n  lookup: s.type({\n    dictMode: s.enums(['default', 'kanji']),\n    // We don't validate the contents of meta (yet)\n    meta: s.optional(s.type({})),\n    point: s.type({\n      x: s.number(),\n      y: s.number(),\n    }),\n    // Likewise, we don't validate target props (yet)\n    targetProps: s.type({}),\n    text: s.string(),\n    wordLookup: s.boolean(),\n    // Parameters for designating the iframe source\n    source: s.type({\n      frameId: s.number(),\n      initialSrc: s.optional(s.string()),\n      currentSrc: s.string(),\n      dimensions: s.type({\n        width: s.number(),\n        height: s.number(),\n      }),\n    }),\n    frame: s.literal('top'),\n  }),\n  pinPopup: s.type({ frame: s.literal('top') }),\n  unpinPopup: s.type({ frame: s.literal('top') }),\n  commitPopup: s.type({ frame: s.literal('top') }),\n  clearResult: s.type({ frame: s.literal('top') }),\n  nextDictionary: s.type({ frame: s.literal('top') }),\n  toggleDefinition: s.type({ frame: s.literal('top') }),\n  expandPopup: s.type({ frame: s.literal('top') }),\n  movePopup: s.type({\n    direction: s.enums(['up', 'down']),\n    frame: s.literal('top'),\n  }),\n\n  // Copy mode messages\n  enterCopyMode: s.type({ frame: s.literal('top') }),\n  exitCopyMode: s.type({ frame: s.literal('top') }),\n  nextCopyEntry: s.type({ frame: s.literal('top') }),\n  copyCurrentEntry: s.type({\n    copyType: s.enums(['entry', 'tab', 'word']),\n    frame: s.literal('top'),\n  }),\n});\n\nexport type BackgroundMessage = s.Infer<typeof BackgroundMessageSchema>;\n\nexport type IndividualFrameMessage =\n  | Extract<BackgroundMessage, { frame: number }>\n  | { type: 'popupShown'; frame: number | 'children'; state: PopupState };\n// ^ This last bit is because I'm terrible at TypeScript meta programming\n\nexport type TopFrameMessage = Extract<BackgroundMessage, { frame: 'top' }>;\n","// Various common definitions used for the keys supported in copy mode.\n\nexport type CopyType = 'entry' | 'tab' | 'word';\n\ninterface CopyKey {\n  type: CopyType;\n  key: string;\n  optionsString: string;\n  popupString: string;\n}\n\nexport const CopyKeys: Array<CopyKey> = [\n  {\n    type: 'entry',\n    key: 'e',\n    optionsString: 'options_popup_copy_entry',\n    popupString: 'content_copy_keys_entry_label',\n  },\n  {\n    type: 'tab',\n    key: 't',\n    optionsString: 'options_popup_copy_fields',\n    popupString: 'content_copy_keys_fields_label',\n  },\n  {\n    type: 'word',\n    key: 'w',\n    optionsString: 'options_popup_copy_word_kanji',\n    popupString: 'content_copy_keys_word_label',\n  },\n];\n\nexport const CopyKanjiKeyStrings: Pick<CopyKey, 'popupString'> = {\n  popupString: 'content_copy_keys_kanji_label',\n};\n\nexport const CopyNextKeyStrings: Pick<\n  CopyKey,\n  'optionsString' | 'popupString'\n> = {\n  optionsString: 'options_popup_copy_next',\n  popupString: 'content_copy_keys_next_label',\n};\n","export const SVG_NS = 'http://www.w3.org/2000/svg';\nexport const HTML_NS = 'http://www.w3.org/1999/xhtml';\n\nexport function empty(elem: Element) {\n  while (elem.firstChild) {\n    (elem.firstChild as any).remove();\n  }\n}\n\nexport function isContentEditableNode(node: Node | null): boolean {\n  if (!node) {\n    return false;\n  }\n\n  const nodeOrParent = nodeOrParentElement(node);\n  if (!(nodeOrParent instanceof HTMLElement)) {\n    return false;\n  }\n\n  let currentNode: HTMLElement | null = nodeOrParent as HTMLElement;\n  while (currentNode) {\n    if (currentNode.contentEditable === 'true') {\n      return true;\n    } else if (currentNode.contentEditable === 'false') {\n      return false;\n    }\n    currentNode = currentNode.parentElement;\n  }\n  return false;\n}\n\nfunction nodeOrParentElement(node: Node): Element | null {\n  return node.nodeType !== Node.ELEMENT_NODE\n    ? node.parentElement\n    : (node as Element);\n}\n\nexport function isEditableNode(node: Node | null): boolean {\n  return isTextInputNode(node) || isContentEditableNode(node);\n}\n\n/**\n * Tests whether an element is 'interactive', i.e. an element\n * that we should not do lookups on when tapped on mobile.\n */\nexport function isInteractiveElement(node: Node | null) {\n  return (\n    isContentEditableNode(node) ||\n    (isElement(node) &&\n      (node.tagName === 'A' ||\n        node.tagName === 'BUTTON' ||\n        node.tagName === 'INPUT' ||\n        node.tagName === 'TEXTAREA' ||\n        node.tagName === 'SELECT' ||\n        node.tagName === 'DATALIST' ||\n        node.tagName === 'OPTGROUP' ||\n        node.tagName === 'OPTION'))\n  );\n}\n\nexport interface Focusable {\n  focus(): void;\n}\n\n// Both HTMLElement and SVGElement interfaces have a focus() method but I guess\n// Edge doesn't currently support focus() on SVGElement so we just duck-type\n// this.\nexport function isFocusable(element?: any): element is Focusable {\n  return (\n    element && typeof element.focus === 'function' && element.focus.length === 0\n  );\n}\n\nexport function isTextInputNode(\n  node: Node | null | undefined\n): node is HTMLInputElement | HTMLTextAreaElement {\n  const allowedInputTypes = [\n    'button',\n    'email',\n    'search',\n    'submit',\n    'text',\n    'url',\n  ];\n  return (\n    !!node &&\n    node.nodeType === Node.ELEMENT_NODE &&\n    (((node as Element).tagName === 'INPUT' &&\n      allowedInputTypes.includes((node as HTMLInputElement).type)) ||\n      (node as Element).tagName === 'TEXTAREA')\n  );\n}\n\nexport const isTextNode = (node: Node | null | undefined): node is Text =>\n  !!node && node.nodeType === Node.TEXT_NODE;\n\nexport const isElement = (node: Node | null | undefined): node is Element =>\n  !!node && node.nodeType === Node.ELEMENT_NODE;\n\nexport function isSvg(node: Node): node is SVGElement {\n  return node.nodeType === Node.ELEMENT_NODE\n    ? node instanceof SVGElement\n    : node.parentElement instanceof SVGElement;\n}\n\nexport function isVerticalText(node: Node): boolean {\n  const element =\n    node.nodeType === Node.ELEMENT_NODE\n      ? (node as Element)\n      : node.parentElement;\n\n  return (\n    !!element &&\n    !!element.ownerDocument.defaultView\n      ?.getComputedStyle(element)\n      .writingMode.startsWith('vertical')\n  );\n}\n","import { isElement, isTextNode } from './dom-utils';\n\nexport type Rect = {\n  left: number;\n  top: number;\n  width: number;\n  height: number;\n};\n\nexport type Point = {\n  x: number;\n  y: number;\n};\n\nexport type Box = {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n};\n\n/// Measures from some box (or point) outwards\nexport type MarginBox = Box;\n\n/// Measures from some box inwards\nexport type PaddingBox = Box;\n\n// Conversion utilities\n\nexport function addMarginToPoint(margin: MarginBox, point: Point): Rect {\n  return {\n    left: point.x - margin.left,\n    top: point.y - margin.top,\n    width: margin.left + margin.right,\n    height: margin.top + margin.bottom,\n  };\n}\n\nexport function getMarginAroundPoint(point: Point, rect: Rect): MarginBox {\n  return {\n    left: Math.max(0, point.x - rect.left),\n    top: Math.max(0, point.y - rect.top),\n    right: Math.max(0, rect.left + rect.width - point.x),\n    bottom: Math.max(0, rect.top + rect.height - point.y),\n  };\n}\n\n// Geometry utils\n\nexport function union(a: Rect, b: Rect): Rect {\n  return {\n    left: Math.min(a.left, b.left),\n    top: Math.min(a.top, b.top),\n    width:\n      Math.max(a.left + a.width, b.left + b.width) - Math.min(a.left, b.left),\n    height:\n      Math.max(a.top + a.height, b.top + b.height) - Math.min(a.top, b.top),\n  };\n}\n\nexport function bboxIncludesPoint({\n  bbox,\n  margin = 0,\n  point,\n}: {\n  bbox: Rect;\n  margin?: number;\n  point: Point;\n}): boolean {\n  return (\n    bbox.left - margin <= point.x &&\n    bbox.left + bbox.width + margin >= point.x &&\n    bbox.top - margin <= point.y &&\n    bbox.top + bbox.height + margin >= point.y\n  );\n}\n\n// DOM geometry utils\n\nexport function getBboxForNodeList(nodes: NodeList): Rect | null {\n  return [...nodes].reduce<Rect | null>((bbox, child) => {\n    let thisBbox: Rect | null = null;\n    if (isTextNode(child)) {\n      const range = new Range();\n      range.selectNode(child);\n      thisBbox = range.getBoundingClientRect();\n    } else if (isElement(child)) {\n      if (getComputedStyle(child).display === 'none') {\n        thisBbox = getBboxForNodeList(child.childNodes);\n      } else {\n        thisBbox = child.getBoundingClientRect();\n      }\n    }\n\n    if (!thisBbox) {\n      return bbox;\n    }\n\n    return bbox ? union(bbox, thisBbox) : thisBbox;\n  }, null);\n}\n","// JS % operator is a _remainder_ operator\nexport function mod(a: number, n: number): number {\n  return ((a % n) + n) % n;\n}\n","/**\n * A helper to strip certain fields from an object.\n */\nexport function stripFields<T, K extends keyof T>(\n  o: T,\n  fields: K[]\n): Omit<T, K> {\n  const result: Partial<T> = { ...o };\n  for (const field of fields) {\n    delete result[field];\n  }\n  return result as Omit<T, K>;\n}\n","export function isFirefox(): boolean {\n  return navigator.userAgent.indexOf('Firefox/') !== -1;\n}\n\nexport function isFenix(): boolean {\n  return isFirefox() && navigator.userAgent.indexOf('Android') !== -1;\n}\n\nexport function isChromium(): boolean {\n  return (\n    navigator.userAgent.indexOf('Chrome/') !== -1 ||\n    navigator.userAgent.indexOf('Chromium/') !== -1\n  );\n}\n\nexport function isEdge(): boolean {\n  return navigator.userAgent.indexOf('Edg/') !== -1;\n}\n\nexport function isSafari(): boolean {\n  return navigator.userAgent.indexOf('Safari/') !== -1 && !isChromium();\n}\n\nexport function isMac(): boolean {\n  return /^Mac/i.test(navigator.platform);\n}\n\nexport function isIOS(): boolean {\n  return (\n    [\n      'iPad Simulator',\n      'iPhone Simulator',\n      'iPod Simulator',\n      'iPad',\n      'iPhone',\n      'iPod',\n    ].includes(navigator.platform) ||\n    // iPad on iOS 13 detection\n    (navigator.userAgent.includes('Mac') && 'ontouchend' in document)\n  );\n}\n\n/** @public */\nexport function isThunderbird(): boolean {\n  return navigator.userAgent.indexOf('Thunderbird/') !== -1;\n}\n","import { HTML_NS, SVG_NS } from './dom-utils';\n\n// Little helper to simplify creating HTML elements that takes care of:\n//\n// - Adding the HTML namespace (needed so the popup works in standalong SVG\n//   documents)\n// - Returning the correct type (TypeScript's lib.dom.d.ts has createElementNS\n//   returning an HTMLElement in all cases, unlike createElement).\n// - Setting attributes (for convenience)\nexport function html<K extends keyof HTMLElementTagNameMap>(\n  tagName: K,\n  attributes?: { [key: string]: string | undefined },\n  ...children: Array<Node | string>\n): HTMLElementTagNameMap[K] {\n  const elem = document.createElementNS(\n    HTML_NS,\n    tagName\n  ) as HTMLElementTagNameMap[K];\n\n  if (attributes) {\n    for (const key in attributes) {\n      const val = attributes[key];\n      if (typeof val !== 'undefined') {\n        elem.setAttribute(key, val);\n      }\n    }\n  }\n\n  if (children) {\n    elem.append(...children);\n  }\n\n  return elem;\n}\n\nexport function svg<K extends keyof SVGElementTagNameMap>(\n  tagName: K,\n  attributes?: { [key: string]: string | undefined },\n  ...children: Array<Node | string>\n): SVGElementTagNameMap[K] {\n  const elem = document.createElementNS(\n    SVG_NS,\n    tagName\n  ) as SVGElementTagNameMap[K];\n\n  if (attributes) {\n    for (const key in attributes) {\n      const val = attributes[key];\n      if (typeof val !== 'undefined') {\n        elem.setAttribute(key, val);\n      }\n    }\n  }\n\n  if (children) {\n    elem.append(...children);\n  }\n\n  return elem;\n}\n","import { html } from '../utils/builder';\n\nexport async function copyText(text: string): Promise<void> {\n  try {\n    await navigator.clipboard.writeText(text);\n  } catch {\n    // Fallback for non-HTTPS pages\n\n    // We generate a copy event and then fill in the data in the event handler\n    let callbackCalled = false;\n    const copy = function (event: ClipboardEvent) {\n      event.clipboardData!.setData('text/plain', text);\n      event.preventDefault();\n      callbackCalled = true;\n    };\n    document.addEventListener('copy', copy);\n    document.execCommand('copy');\n    document.removeEventListener('copy', copy);\n    if (callbackCalled) {\n      return;\n    }\n\n    // However, on Safari (of course it's Safari), if there is no current\n    // selection in the page, the copy event callback will not be fired.\n    //\n    // In that case, try generating a selection to copy instead.\n    const selection = document.getSelection();\n    if (!selection) {\n      throw new Error('No selection to work with');\n    }\n\n    // This isn't going to work if this is an SVG document but I'm quite happy\n    // to accept that you can't copy text from SVG documents served over\n    // insecure HTTP in Safari.\n    const span = html('span', {}, text);\n    (document.body || document.documentElement).append(span);\n\n    // We would like to build up a specific Range here so we can cleanly remove\n    // it later but Safari doesn't seem to handle `selection.addRange` properly.\n    //\n    // (From the console it works, but only if we use document.createRange,\n    // _not_ if we use the Range constructor. From code, however, it doesn't\n    // seem to work with either approach, possibly because the selection is\n    // updated async?)\n    //\n    // Given that we only expect this to occur when there's no selection _and_\n    // we're on an HTTP page it's probably not so bad if we end up moving the\n    // selection.\n    try {\n      selection.selectAllChildren(span);\n      document.execCommand('copy');\n    } finally {\n      // Tidy up\n      //\n      // It turns out Safari doesn't support Selection.removeRange anyway so we're\n      // stuck dropping all the ranges even if we could create them.\n      selection.removeAllRanges();\n      span.remove();\n    }\n  }\n}\n","import { isIOS } from './ua-utils';\n\nexport function isTouchDevice(): boolean {\n  if (window.PointerEvent && 'maxTouchPoints' in navigator) {\n    return navigator.maxTouchPoints > 0;\n  }\n\n  if (window.matchMedia && window.matchMedia('(any-pointer:coarse)').matches) {\n    return true;\n  }\n\n  // The following will give a false positive in Chrome desktop but hopefully\n  // one of the above checks will cover us there.\n  return 'TouchEvent' in window;\n}\n\nexport function possiblyHasPhysicalKeyboard(): boolean {\n  const desktopOsStrings = ['Windows', 'Win32', 'Win64', 'Mac', 'Linux'];\n\n  return (\n    // In general, if the device has a fine pointer (e.g. mouse) we assume\n    // it also has a keyboard.\n    window.matchMedia('(hover) and (pointer: fine)').matches ||\n    // However, we've encountered at least one notebook device which returns\n    // `any-pointer: coarse` and `any-hover: none` for its trackpad on Firefox.\n    //\n    // That seems to be a bug somewhere (at very least, a trackpad can hover)\n    // in either Firefox or the OS/device driver, we shouldn't prevent users of\n    // such a device from being able to configure the keyboard so we _also_\n    // assume we have a keyboard when we're on an OS that we know to be\n    // a desktop OS.\n    (desktopOsStrings.some(\n      (osString) => navigator.userAgent.indexOf(osString) !== -1\n    ) &&\n      // Exclude iOS, however, because the UA string there has \"like Mac OS X\"\n      !isIOS())\n  );\n}\n\n// Detect if the primary input means is capable of hovering. If it is NOT\n// we show the puck by default.\n//\n// e.g. if we're on a laptop device that has a touchpad or mouse we generally\n// _don't_ want to show the puck unless the user explicitly enables it.\n// For a smartphone or tablet, however, we want to show the puck by default.\nexport function getHoverCapabilityMql(): MediaQueryList | undefined {\n  // The undefined case here is just for the sake of our unit tests.\n  return window.matchMedia ? window.matchMedia('(hover: hover)') : undefined;\n}\n\nexport function getMouseCapabilityMql(): MediaQueryList | undefined {\n  return window.matchMedia\n    ? window.matchMedia('(hover: hover) and (pointer: fine)')\n    : undefined;\n}\n","import { ContentConfigParams } from '../common/content-config-params';\nimport { getHoverCapabilityMql, getMouseCapabilityMql } from '../utils/device';\nimport { Entries, Overwrite } from '../utils/type-helpers';\n\nexport type ContentConfigChange =\n  | Overwrite<\n      {\n        [K in keyof ContentConfigParams]: {\n          key: K;\n          value: ContentConfigParams[K];\n        };\n      },\n      { showPuck: { key: 'showPuck'; value: 'hide' | 'show' } }\n    >[keyof ContentConfigParams]\n  | { key: 'canHover'; value: boolean };\n\nexport type ContentConfigListener = (\n  changes: readonly ContentConfigChange[]\n) => void;\n\nexport class ContentConfig implements ContentConfigParams {\n  private params: ContentConfigParams;\n  private mouseCapabilityMql = getMouseCapabilityMql();\n  private hoverCapabilityMql = getHoverCapabilityMql();\n  listeners: Array<ContentConfigListener> = [];\n\n  constructor(params: Readonly<ContentConfigParams>) {\n    this.set(params);\n\n    this.onMouseCapabilityChange = this.onMouseCapabilityChange.bind(this);\n    this.onHoverCapabilityChange = this.onHoverCapabilityChange.bind(this);\n  }\n\n  set(params: Readonly<ContentConfigParams>) {\n    const before: Partial<ContentConfig> = {};\n    if (this.params) {\n      for (const key of Object.keys(params)) {\n        const contentKey = key as keyof ContentConfig;\n        if (typeof this[contentKey] === 'undefined') {\n          continue;\n        }\n        (before[contentKey] satisfies ContentConfig[typeof contentKey]) =\n          this[contentKey];\n      }\n    }\n\n    this.params = { ...params };\n\n    const changes: ContentConfigChange[] = [];\n    const objectKeysWeCareAbout = ['autoExpand', 'puckState'];\n    for (const [key, value] of Object.entries(\n      before\n    ) as Entries<ContentConfigParams>) {\n      // We don't care about changes to most object-typed settings\n      if (typeof value === 'object') {\n        if (\n          objectKeysWeCareAbout.includes(key) &&\n          JSON.stringify(value) !== JSON.stringify(this[key])\n        ) {\n          changes.push({ key, value: this[key] } as ContentConfigChange);\n        }\n        continue;\n      }\n\n      if (this[key] !== value) {\n        changes.push({ key, value: this[key] } as ContentConfigChange);\n      }\n    }\n\n    if (changes.length) {\n      this.notifyListeners(changes);\n    }\n  }\n\n  addListener(listener: ContentConfigListener) {\n    const hadListeners = this.listeners.length !== 0;\n\n    if (!this.listeners.includes(listener)) {\n      this.listeners.push(listener);\n    }\n\n    if (!hadListeners) {\n      this.mouseCapabilityMql?.addEventListener(\n        'change',\n        this.onMouseCapabilityChange\n      );\n      this.hoverCapabilityMql?.addEventListener(\n        'change',\n        this.onHoverCapabilityChange\n      );\n    }\n  }\n\n  removeListener(listener: ContentConfigListener) {\n    const hadListeners = this.listeners.length !== 0;\n\n    this.listeners = this.listeners.filter((l) => l !== listener);\n\n    if (hadListeners && this.listeners.length === 0) {\n      this.mouseCapabilityMql?.removeEventListener(\n        'change',\n        this.onMouseCapabilityChange\n      );\n      this.hoverCapabilityMql?.removeEventListener(\n        'change',\n        this.onHoverCapabilityChange\n      );\n    }\n  }\n\n  private notifyListeners(changes: readonly ContentConfigChange[]) {\n    const listenersCopy = this.listeners.slice();\n    for (const listener of listenersCopy) {\n      listener(changes);\n    }\n  }\n\n  get accentDisplay() {\n    return this.params.accentDisplay;\n  }\n  get autoExpand() {\n    return this.params.autoExpand;\n  }\n  get copyHeadwords() {\n    return this.params.copyHeadwords;\n  }\n  get copyPos() {\n    return this.params.copyPos;\n  }\n  get copySenses() {\n    return this.params.copySenses;\n  }\n  get bunproDisplay() {\n    return this.params.bunproDisplay;\n  }\n  get dictLang() {\n    return this.params.dictLang;\n  }\n  get enableTapLookup() {\n    return this.params.enableTapLookup;\n  }\n  get fx() {\n    return this.params.fx;\n  }\n  get fontFace() {\n    return this.params.fontFace;\n  }\n  get fontSize() {\n    return this.params.fontSize;\n  }\n  get highlightStyle() {\n    return this.params.highlightStyle;\n  }\n  get holdToShowKeys() {\n    return this.params.holdToShowKeys;\n  }\n  get holdToShowImageKeys() {\n    return this.params.holdToShowImageKeys;\n  }\n  get kanjiReferences() {\n    return this.params.kanjiReferences;\n  }\n  get keys() {\n    return this.params.keys;\n  }\n  get noTextHighlight() {\n    return this.params.noTextHighlight;\n  }\n  get popupInteractive() {\n    // Even if `this.params.popupInteractive` is false, if there's no mouse we\n    // should force it to true.\n    return this.params.popupInteractive || !this.mouseCapabilityMql;\n  }\n  get popupStyle() {\n    return this.params.popupStyle;\n  }\n  get posDisplay() {\n    return this.params.posDisplay;\n  }\n  get preferredUnits() {\n    return this.params.preferredUnits;\n  }\n  get puckState() {\n    return this.params.puckState;\n  }\n  get readingOnly() {\n    return this.params.readingOnly;\n  }\n  set readingOnly(value: boolean) {\n    this.params.readingOnly = value;\n  }\n  get showKanjiComponents() {\n    return this.params.showKanjiComponents;\n  }\n  get showPriority() {\n    return this.params.showPriority;\n  }\n  get showPuck(): 'show' | 'hide' {\n    return this.params.showPuck === 'auto'\n      ? this.canHover\n        ? 'hide'\n        : 'show'\n      : this.params.showPuck;\n  }\n  get showRomaji() {\n    return this.params.showRomaji;\n  }\n  get tabDisplay() {\n    return this.params.tabDisplay;\n  }\n  get toolbarIcon() {\n    return this.params.toolbarIcon;\n  }\n  get waniKaniVocabDisplay() {\n    return this.params.waniKaniVocabDisplay;\n  }\n\n  // Extra computed properties\n  get canHover() {\n    return !!this.hoverCapabilityMql?.matches;\n  }\n\n  private onMouseCapabilityChange() {\n    // If this.params.popupInteractive is false then any change to the\n    // mouseCapabilityMql will cause the computed value of `popupInteractive` to\n    // change.\n    if (!this.params.popupInteractive) {\n      this.notifyListeners([\n        { key: 'popupInteractive', value: this.popupInteractive },\n      ]);\n    }\n  }\n\n  private onHoverCapabilityChange(event: MediaQueryListEvent) {\n    if (this.params.showPuck === 'auto') {\n      this.notifyListeners([\n        { key: 'showPuck', value: this.showPuck },\n        { key: 'canHover', value: event.matches },\n      ]);\n    }\n  }\n}\n","export const highPriorityLabels = ['i1', 'n1', 's1', 's2', 'g1'];\n","import { DbLanguageId } from './db-languages';\nimport { TranslateFunctionType } from './i18n';\n\nconst SUPPORTED_REFERENCES = [\n  // The radical for the kanji (number and character, from rad field)\n  'radical',\n  // Nelson radical (from rad field)\n  'nelson_r',\n  // Kanji kentei (from misc field)\n  'kk',\n  // WaniKani level (from misc field)\n  'wk',\n  // Pinyin reading\n  'py',\n  // JLPT level (from misc field)\n  'jlpt',\n  // Unicode codepoint (generated)\n  'unicode',\n  // Conning, The Kodansha Kanji Learner's Course\n  'conning',\n  // New Japanese-English Character Dictionary\n  'halpern_njecd',\n  // Learners Dictionary 2nd ed.\n  'halpern_kkld_2ed',\n  // Remembering the Kanji (6th ed.)\n  'heisig6',\n  // A Guide To Remembering Japanese Characters\n  'henshall',\n  // Kanji and Kana (2011 edition)\n  'sh_kk2',\n  // Japanese For Busy People vols I-III\n  'busy_people',\n  // Kanji in Context by Nishiguchi and Kono\n  'kanji_in_context',\n  // the Kodansha Compact Kanji Guide\n  'kodansha_compact',\n  // Yves Maniette's \"Les Kanjis dans la tete\" French adaptation of Heisig\n  // (Only included for lang:fr)\n  'maniette',\n  // \"Classic\" Nelson - Modern Reader's Japanese-English Character Dictionary\n  'nelson_c',\n  // The New Nelson Japanese-English Character Dictionary\n  'nelson_n',\n  // Halpern's SKIP (System of Kanji Indexing by Patterns)\n  'skip',\n  // Descriptor codes for The Kanji Dictionary\n  'sh_desc',\n] as const;\n\nexport type ReferenceAbbreviation = (typeof SUPPORTED_REFERENCES)[number];\n\nexport function getReferencesForLang(lang: DbLanguageId) {\n  if (lang !== 'fr') {\n    return SUPPORTED_REFERENCES.filter((ref) => ref !== 'maniette');\n  }\n  return SUPPORTED_REFERENCES;\n}\n\nconst REFERENCE_ABBREV_MAPPING: {\n  [key: string]: ReferenceAbbreviation;\n} = {\n  CO: 'conning',\n  H: 'halpern_njecd',\n  L: 'heisig6',\n  E: 'henshall',\n  KK: 'kk',\n  DK: 'halpern_kkld_2ed',\n  N: 'nelson_c',\n  NR: 'nelson_r',\n  V: 'nelson_n',\n  P: 'skip',\n  IN: 'sh_kk2',\n  I: 'sh_desc',\n  U: 'unicode',\n  Y: 'py',\n  WK: 'wk',\n} as const;\n\nexport function convertLegacyReference(\n  ref: string\n): ReferenceAbbreviation | undefined {\n  return REFERENCE_ABBREV_MAPPING.hasOwnProperty(ref)\n    ? REFERENCE_ABBREV_MAPPING[ref]\n    : undefined;\n}\n\ntype LocalizedReferences = 'radical' | 'nelson_r' | 'kk' | 'jlpt' | 'unicode';\ntype NotLocalizedReferences = Exclude<\n  ReferenceAbbreviation,\n  LocalizedReferences\n>;\ntype ReferenceLabel = { full: string; short?: string; lang: string };\n\n// Note that when adding or modifying labels here, it is important that the full\n// and short versions sort roughly the same so that they appear to be in\n// alphabetical order in both the popup (where we use the short form) and\n// options page (where we use the long form).\n//\n// We sort by the short label, where available, which enables, for example,\n// showing an initial \"The\" in the long label but still sorting by the short\n// label (which does not include the \"The\"). Such exceptions aside, however, the\n// full and short versions should generally start with the same first few words.\nconst REFERENCE_LABELS: {\n  [key in NotLocalizedReferences]: ReferenceLabel;\n} = {\n  conning: {\n    full: \"Conning - Kodansha Kanji Learner's Course\",\n    short: 'Conning',\n    lang: 'en',\n  },\n  sh_kk2: {\n    full: 'Kanji & Kana (Hadamitzky, Tuttle, 2011)',\n    short: 'Kanji & Kana',\n    lang: 'en',\n  },\n  halpern_njecd: {\n    full: 'Halpern - New Japanese-English Character Dictionary',\n    short: 'Halpern',\n    lang: 'en',\n  },\n  halpern_kkld_2ed: {\n    full: \"Kanji Learner's Dictionary (Halpbern, Kodansha, 2nd ed.)\",\n    short: \"Kanji Learner's Dictionary\",\n    lang: 'en',\n  },\n  heisig6: {\n    full: 'Heisig - Rembering the Kanji (6th ed.)',\n    short: 'Heisig',\n    lang: 'en',\n  },\n  henshall: {\n    full: 'Henshall - A Guide to Remembering Japanese Characters',\n    short: 'Henshall',\n    lang: 'en',\n  },\n  busy_people: { full: 'Japanese for Busy People', lang: 'en' },\n  kanji_in_context: { full: 'Kanji in Context', lang: 'en' },\n  kodansha_compact: {\n    full: 'Compact Kanji Guide (Kodansha)',\n    short: 'Compact Kanji Guide',\n    lang: 'en',\n  },\n  maniette: { full: 'Les Kanjis dans la tete', lang: 'fr' },\n  nelson_c: {\n    full: \"Classic Nelson - Modern Reader's Japanese-English Character Dictionary\",\n    short: 'Classic Nelson',\n    lang: 'en',\n  },\n  nelson_n: {\n    full: 'New Nelson Japanese-English Character Dictionary',\n    short: 'New Nelson',\n    lang: 'en',\n  },\n  py: { full: 'Pinyin', lang: 'en' },\n  skip: { full: 'SKIP', lang: 'en' },\n  sh_desc: {\n    full: 'The Kanji Dictionary (Spahn)',\n    short: 'Kanji Dictionary',\n    lang: 'en',\n  },\n  wk: {\n    full: 'WaniKani level',\n    short: 'WaniKani',\n    lang: 'en',\n  },\n} as const;\n\n// Get an array matching reference abbreviations to suitable names.\n//\n// These two methods return an array, not a map or object, since we try to\n// preserve the same order of references everywhere we present them.\n//\n// For the localized ones (radical, JLPT, kk, unicode), we look up the\n// appropriate string. For the others, we return a fixed string. (This way we\n// keep complete string keys--not concatenated strings--in the source so we can\n// readily determine which strings are in use.)\n\ntype ReferenceAndLabel = { ref: ReferenceAbbreviation } & ReferenceLabel;\n\nexport function getReferenceLabelsForLang(\n  lang: string,\n  t: TranslateFunctionType\n): Array<ReferenceAndLabel> {\n  const result: Array<ReferenceAndLabel> = [];\n\n  for (const ref of SUPPORTED_REFERENCES) {\n    if (lang !== 'fr' && ref === 'maniette') {\n      continue;\n    }\n    result.push({ ref, ...getLabelForReference(ref, t) });\n  }\n\n  // Sort by short version first since this is what will be shown in the pop-up.\n  result.sort((a, b) => (a.short || a.full).localeCompare(b.short || b.full));\n\n  return result;\n}\n\nexport function getSelectedReferenceLabels(\n  selectedRefs: ReadonlyArray<ReferenceAbbreviation>,\n  t: TranslateFunctionType\n): Array<ReferenceAndLabel> {\n  const result: Array<ReferenceAndLabel> = [];\n  const selectedRefsSet = new Set<ReferenceAbbreviation>(selectedRefs);\n\n  for (const ref of SUPPORTED_REFERENCES) {\n    if (!selectedRefsSet.has(ref)) {\n      continue;\n    }\n    result.push({ ref, ...getLabelForReference(ref, t) });\n  }\n\n  // Sort by short version first since this is what will be shown in the pop-up.\n  result.sort((a, b) => (a.short || a.full).localeCompare(b.short || b.full));\n\n  return result;\n}\n\nfunction getLabelForReference(\n  ref: ReferenceAbbreviation,\n  t: TranslateFunctionType\n): ReferenceLabel {\n  const lang = t('lang_tag');\n\n  switch (ref) {\n    case 'radical':\n      return { full: t('ref_label_radical'), lang };\n\n    case 'nelson_r':\n      return { full: t('ref_label_nelson_r'), lang };\n\n    case 'kk':\n      return { full: t('ref_label_kk'), lang };\n\n    case 'jlpt':\n      return { full: t('ref_label_jlpt'), lang };\n\n    case 'py':\n      return { full: t('ref_label_py'), lang };\n\n    case 'unicode':\n      return { full: t('ref_label_unicode'), lang };\n\n    default:\n      return REFERENCE_LABELS[ref];\n  }\n}\n","import type { KanjiResult } from '@birchill/jpdict-idb';\n\nimport type { TranslateFunctionType } from '../common/i18n';\nimport type { ReferenceAbbreviation } from '../common/refs';\n\nexport function getReferenceValue(\n  entry: KanjiResult,\n  ref: ReferenceAbbreviation,\n  t: TranslateFunctionType\n): string {\n  switch (ref) {\n    case 'nelson_r': {\n      // If the Nelson radical is empty, it means it's the same as the regular\n      // radical so we should fall through to that branch.\n      if (entry.rad.nelson) {\n        return `${entry.rad.nelson} ${String.fromCodePoint(\n          entry.rad.nelson + 0x2eff\n        )}`;\n      }\n      // Fall through\n    }\n\n    case 'radical': {\n      const { rad } = entry;\n      const radChar = rad.base ? rad.base.b || rad.base.k : rad.b || rad.k;\n      return `${rad.x} ${radChar}`;\n    }\n\n    case 'kk':\n      return renderKanKen(entry.misc.kk, t);\n\n    case 'jlpt':\n      return entry.misc.jlpt ? String(entry.misc.jlpt) : '';\n\n    case 'py':\n      return entry.r.py ? entry.r.py.join(', ') : '';\n\n    case 'unicode':\n      return `U+${entry.c.codePointAt(0)!.toString(16).toUpperCase()}`;\n\n    case 'wk':\n      return entry.misc.wk ? String(entry.misc.wk) : '';\n\n    default:\n      return entry.refs[ref] ? String(entry.refs[ref]) : '';\n  }\n}\n\nfunction renderKanKen(\n  level: number | undefined,\n  t: TranslateFunctionType\n): string {\n  if (!level) {\n    return '—';\n  }\n  if (level === 15) {\n    return t('content_kanji_kentei_level_pre', ['1']);\n  }\n  if (level === 25) {\n    return t('content_kanji_kentei_level_pre', ['2']);\n  }\n  return t('content_kanji_kentei_level', [String(level)]);\n}\n","import { Dialect, KanjiResult, LangSource } from '@birchill/jpdict-idb';\n\nimport type {\n  NameResult,\n  Sense,\n  WordResult,\n} from '../background/search-result';\nimport type { CopyType } from '../common/copy-keys';\nimport type { TranslateFunctionType } from '../common/i18n';\nimport { highPriorityLabels } from '../common/priority-labels';\nimport {\n  ReferenceAbbreviation,\n  getSelectedReferenceLabels,\n} from '../common/refs';\n\nimport { getReferenceValue } from './reference-value';\n\nexport type CopyEntry =\n  | { type: 'word'; data: WordResult }\n  | { type: 'name'; data: NameResult }\n  | { type: 'kanji'; data: KanjiResult };\n\nexport function getTextToCopy({\n  entry,\n  copyType,\n  getMessage,\n  includeAllSenses = true,\n  includeLessCommonHeadwords = true,\n  includePartOfSpeech = true,\n  kanjiReferences = [] as Array<ReferenceAbbreviation>,\n  showKanjiComponents = true,\n}: {\n  entry: CopyEntry;\n  copyType: CopyType;\n  getMessage: TranslateFunctionType;\n  includeAllSenses?: boolean;\n  includeLessCommonHeadwords?: boolean;\n  includePartOfSpeech?: boolean;\n  kanjiReferences?: Array<ReferenceAbbreviation>;\n  showKanjiComponents?: boolean;\n}): string {\n  switch (copyType) {\n    case 'entry':\n      return getEntryToCopy(entry, {\n        getMessage,\n        includeAllSenses,\n        includeLessCommonHeadwords,\n        includePartOfSpeech,\n        kanjiReferences,\n        showKanjiComponents,\n      });\n\n    case 'tab':\n      return getFieldsToCopy(entry, {\n        getMessage,\n        includeAllSenses,\n        includeLessCommonHeadwords,\n        includePartOfSpeech,\n        kanjiReferences,\n        showKanjiComponents,\n      });\n\n    case 'word':\n      return getWordToCopy(entry);\n  }\n}\n\nexport function getWordToCopy(entry: CopyEntry): string {\n  let result: string;\n\n  switch (entry.type) {\n    case 'word':\n      {\n        let headwords = entry.data.k?.length\n          ? entry.data.k.filter((k) => !k.i?.includes('sK'))\n          : entry.data.r.filter((r) => !r.i?.includes('sk'));\n\n        // Only show matches -- unless our only matches were search-only\n        // terms -- in which case we want to include all headwords.\n        if (headwords.some((h) => h.match)) {\n          headwords = headwords.filter((entry) => entry.match);\n        }\n\n        result = headwords.map((entry) => entry.ent).join(', ');\n      }\n      break;\n\n    case 'name':\n      result = (entry.data.k || entry.data.r).join(', ');\n      break;\n\n    case 'kanji':\n      result = entry.data.c;\n      break;\n  }\n\n  return result!;\n}\n\nexport function getEntryToCopy(\n  entry: CopyEntry,\n  {\n    getMessage,\n    includeAllSenses = true,\n    includeLessCommonHeadwords = true,\n    includePartOfSpeech = true,\n    kanjiReferences = [] as Array<ReferenceAbbreviation>,\n    showKanjiComponents = true,\n  }: {\n    getMessage: TranslateFunctionType;\n    includeAllSenses?: boolean;\n    includeLessCommonHeadwords?: boolean;\n    includePartOfSpeech?: boolean;\n    kanjiReferences?: Array<ReferenceAbbreviation>;\n    showKanjiComponents?: boolean;\n  }\n): string {\n  let result: string;\n\n  switch (entry.type) {\n    case 'word':\n      {\n        const kanjiHeadwords = entry.data.k\n          ? filterRelevantKanjiHeadwords(entry.data.k, {\n              includeLessCommonHeadwords,\n            }).map((k) => k.ent)\n          : [];\n        const kanaHeadwords = filterRelevantKanaHeadwords(entry.data.r, {\n          includeLessCommonHeadwords,\n        }).map((r) => r.ent);\n\n        result = kanjiHeadwords.length\n          ? `${kanjiHeadwords.join(', ')} [${kanaHeadwords.join(', ')}]`\n          : kanaHeadwords.join(', ');\n        if (entry.data.romaji?.length) {\n          result += ` (${entry.data.romaji.join(', ')})`;\n        }\n\n        result +=\n          (includeAllSenses ? '\\n' : ' ') +\n          serializeDefinition(entry.data, {\n            getMessage,\n            includeAllSenses,\n            includePartOfSpeech,\n            oneSensePerLine: true,\n          });\n      }\n      break;\n\n    case 'name':\n      result = entry.data.k\n        ? `${entry.data.k.join(', ')} [${entry.data.r.join(', ')}]${includeAllSenses ? '\\n' : ' '}`\n        : entry.data.r.join(', ') + (includeAllSenses ? '\\n' : ' ');\n\n      for (const [i, tr] of entry.data.tr.entries()) {\n        if (i) {\n          result += '; ';\n        }\n        if (includePartOfSpeech && tr.type) {\n          result += `(${tr.type.join(', ')}) `;\n        }\n        result += tr.det.join(', ');\n      }\n      break;\n\n    case 'kanji':\n      {\n        const { c, r, m, rad, comp } = entry.data;\n\n        result = c;\n        const readings = getKanjiReadings(entry.data);\n        if (readings) {\n          result += ` [${readings}]`;\n        }\n        if (r.na && r.na.length) {\n          result += ` (${r.na.join('、')})`;\n        }\n        result += ` ${m.join(', ')}`;\n        const radicalLabel = getMessage('content_kanji_radical_label');\n        result += `; ${radicalLabel}: ${rad.b || rad.k}（${rad.na.join(\n          '、'\n        )}）`;\n        if (rad.base) {\n          const baseChar = (rad.base.b || rad.base.k)!;\n          const baseReadings = rad.base.na.join('、');\n          result +=\n            ' ' +\n            getMessage('content_kanji_base_radical', [baseChar, baseReadings]);\n        }\n        if (showKanjiComponents && comp.length) {\n          const componentsLabel = getMessage('content_kanji_components_label');\n          const components: Array<string> = [];\n          for (const component of comp) {\n            components.push(\n              `${component.c} (${\n                component.na.length ? component.na[0] + ', ' : ''\n              }${component.m.length ? component.m[0] : ''})`\n            );\n          }\n          result += `; ${componentsLabel}: ${components.join(', ')}`;\n        }\n\n        if (kanjiReferences.length) {\n          const labels = getSelectedReferenceLabels(\n            kanjiReferences,\n            getMessage\n          );\n          for (const label of labels) {\n            if (\n              label.ref === 'nelson_r' &&\n              !rad.nelson &&\n              kanjiReferences.includes('radical')\n            ) {\n              continue;\n            }\n            result += `; ${label.short || label.full} ${\n              getReferenceValue(entry.data, label.ref, getMessage) || '-'\n            }`;\n          }\n        }\n      }\n      break;\n  }\n\n  return result!;\n}\n\ntype KanjiHeadword = WordResult['k'][number];\n\nconst highPriorityLabelsSet = new Set(highPriorityLabels);\n\nfunction filterRelevantKanjiHeadwords(\n  headwords: Array<KanjiHeadword>,\n  {\n    includeLessCommonHeadwords,\n  }: {\n    includeLessCommonHeadwords: boolean;\n  }\n) {\n  if (includeLessCommonHeadwords) {\n    return headwords.filter((k) => !k.i?.includes('sK'));\n  }\n\n  const commonHeadwords = headwords.filter(\n    (k) => !k.i?.includes('sK') && !k.i?.includes('rK')\n  );\n\n  const highPriorityHeadwords = commonHeadwords.filter((k) =>\n    k.p?.some((p) => highPriorityLabelsSet.has(p))\n  );\n  if (highPriorityHeadwords.length) {\n    return highPriorityHeadwords;\n  }\n\n  const hasPriorityHeadwords = commonHeadwords.filter((k) => k.p?.length);\n  if (hasPriorityHeadwords.length) {\n    return hasPriorityHeadwords;\n  }\n\n  return commonHeadwords;\n}\n\ntype KanaHeadword = WordResult['r'][number];\n\nfunction filterRelevantKanaHeadwords(\n  headwords: Array<KanaHeadword>,\n  {\n    includeLessCommonHeadwords,\n  }: {\n    includeLessCommonHeadwords: boolean;\n  }\n) {\n  if (includeLessCommonHeadwords) {\n    return headwords.filter((k) => !k.i?.includes('sk'));\n  }\n\n  const commonHeadwords = headwords.filter(\n    (k) => !k.i?.includes('sk') && !k.i?.includes('rk')\n  );\n\n  const highPriorityHeadwords = commonHeadwords.filter((k) =>\n    k.p?.some((p) => highPriorityLabelsSet.has(p))\n  );\n  if (highPriorityHeadwords.length) {\n    return highPriorityHeadwords;\n  }\n\n  const hasPriorityHeadwords = commonHeadwords.filter((k) => k.p?.length);\n  if (hasPriorityHeadwords.length) {\n    return hasPriorityHeadwords;\n  }\n\n  return commonHeadwords;\n}\n\nfunction serializeDefinition(\n  entry: WordResult,\n  {\n    getMessage,\n    includeAllSenses = true,\n    includePartOfSpeech = true,\n    oneSensePerLine = false,\n  }: {\n    getMessage: TranslateFunctionType;\n    includeAllSenses?: boolean;\n    includePartOfSpeech?: boolean;\n    oneSensePerLine?: boolean;\n  }\n): string {\n  const senses = entry.s;\n  if (senses.length > 1 && includeAllSenses) {\n    const nativeSenses = senses\n      .filter((s) => s.lang && s.lang !== 'en')\n      .map(\n        (s) => `• ${serializeSense(s, { getMessage, includePartOfSpeech })}`\n      );\n    const enSenses = senses\n      .filter((s) => !s.lang || s.lang === 'en')\n      .map(\n        (s, index) =>\n          `(${index + 1}) ${serializeSense(s, { getMessage, includePartOfSpeech })}`\n      );\n\n    return [...nativeSenses, ...enSenses].join(oneSensePerLine ? '\\n' : ' ');\n  } else {\n    return serializeSense(senses[0], { getMessage, includePartOfSpeech });\n  }\n}\n\n// Match the formatting in Edict\nconst dialects: { [dial in Dialect]: string } = {\n  bra: 'bra:',\n  ho: 'hob:',\n  tsug: 'tsug:',\n  th: 'thb:',\n  na: 'nab:',\n  kt: 'ktb:',\n  ks: 'ksb:',\n  ky: 'kyb:',\n  os: 'osb:',\n  ts: 'tsb:',\n  '9s': 'kyu:',\n  ok: 'rkb:',\n};\n\nfunction serializeSense(\n  sense: Sense,\n  {\n    getMessage,\n    includePartOfSpeech = true,\n  }: { getMessage: TranslateFunctionType; includePartOfSpeech?: boolean }\n): string {\n  let result = '';\n\n  if (includePartOfSpeech && sense.pos) {\n    result += `(${sense.pos.join(',')}) `;\n  }\n  result += sense.field ? `(${sense.field.join(',')}) ` : '';\n  result += sense.misc ? `(${sense.misc.join(',')}) ` : '';\n  result += sense.dial\n    ? `(${sense.dial\n        .map((dial) => (dial in dialects ? dialects[dial as Dialect] : dial))\n        .join(',')}) `\n    : '';\n\n  const glosses: Array<string> = [];\n  for (const g of sense.g) {\n    let gloss = '';\n    if (g.type && g.type !== 'tm' && g.type !== 'none') {\n      const glossTypeStr = getMessage(`gloss_type_short_${g.type}`);\n      if (glossTypeStr) {\n        gloss = `(${glossTypeStr}) `;\n      }\n    }\n    gloss += g.str;\n    if (g.type === 'tm') {\n      gloss += '™';\n    }\n    glosses.push(gloss);\n  }\n  result += glosses.join('; ');\n\n  result += sense.lsrc\n    ? ` (${sense.lsrc.map(serializeLangSrc).join(', ')})`\n    : '';\n  result += sense.inf ? ` (${sense.inf})` : '';\n\n  return result;\n}\n\nfunction serializeLangSrc(lsrc: LangSource) {\n  const lang = lsrc.wasei ? 'wasei' : lsrc.lang;\n  const parts = [];\n  if (lang) {\n    parts.push(lang);\n  }\n  if (lsrc.src) {\n    parts.push(lsrc.src);\n  }\n  return parts.join(': ');\n}\n\nexport function getFieldsToCopy(\n  entry: CopyEntry,\n  {\n    getMessage,\n    includeAllSenses = true,\n    includeLessCommonHeadwords = true,\n    includePartOfSpeech = true,\n    kanjiReferences = [] as Array<ReferenceAbbreviation>,\n    showKanjiComponents = true,\n  }: {\n    getMessage: TranslateFunctionType;\n    includeAllSenses?: boolean;\n    includeLessCommonHeadwords?: boolean;\n    includePartOfSpeech?: boolean;\n    kanjiReferences?: Array<ReferenceAbbreviation>;\n    showKanjiComponents?: boolean;\n  }\n): string {\n  let result: string;\n\n  switch (entry.type) {\n    case 'word':\n      result = entry.data.k\n        ? filterRelevantKanjiHeadwords(entry.data.k, {\n            includeLessCommonHeadwords,\n          })\n            .map((k) => k.ent)\n            .join('; ')\n        : '';\n      result +=\n        '\\t' +\n        filterRelevantKanaHeadwords(entry.data.r, {\n          includeLessCommonHeadwords,\n        })\n          .map((r) => r.ent)\n          .join('; ');\n      if (entry.data.romaji?.length) {\n        result += '\\t' + entry.data.romaji.join('; ');\n      }\n\n      result +=\n        '\\t' +\n        serializeDefinition(entry.data, {\n          getMessage,\n          includeAllSenses,\n          includePartOfSpeech,\n        });\n      break;\n\n    case 'name':\n      {\n        let definition = '';\n        for (const [i, tr] of entry.data.tr.entries()) {\n          if (i) {\n            definition += '; ';\n          }\n          if (includePartOfSpeech && tr.type) {\n            definition += `(${tr.type.join(', ')}) `;\n          }\n          definition += tr.det.join(', ');\n        }\n\n        // Split each kanji name out into a separate row\n        result = '';\n        for (const [i, kanji] of (entry.data.k || ['']).entries()) {\n          if (i) {\n            result += '\\n';\n          }\n          result += `${kanji}\\t${entry.data.r.join(', ')}\\t${definition}`;\n        }\n      }\n      break;\n\n    case 'kanji':\n      {\n        const { c, r, m, comp } = entry.data;\n\n        result = c;\n        const readings = getKanjiReadings(entry.data);\n        result += `\\t${readings}`;\n        result += `\\t${(r.na || []).join('、')}`;\n        result += `\\t${m.join(', ')}`;\n        if (showKanjiComponents) {\n          const components = comp.map((comp) => comp.c).join('');\n          result += `\\t${components}`;\n        }\n        if (kanjiReferences.length) {\n          const labels = getSelectedReferenceLabels(\n            kanjiReferences,\n            getMessage\n          );\n          for (const label of labels) {\n            // For some common types we don't produce the label\n            switch (label.ref) {\n              case 'radical':\n              case 'unicode':\n              case 'nelson_r':\n                // All the above types also either always exist (radical,\n                // unicode) or if they don't exist we want to produce an empty\n                // value (not '-') hence why we don't include the ... || '-'\n                // from the next block.\n                result +=\n                  '\\t' + getReferenceValue(entry.data, label.ref, getMessage);\n                break;\n\n              default:\n                result += `\\t${label.short || label.full} ${\n                  getReferenceValue(entry.data, label.ref, getMessage) || '-'\n                }`;\n                break;\n            }\n          }\n        }\n      }\n      break;\n  }\n\n  return result!;\n}\n\nfunction getKanjiReadings(kanji: KanjiResult): string {\n  return [\n    ...(kanji.r.on ? kanji.r.on : []),\n    ...(kanji.r.kun ? kanji.r.kun : []),\n  ].join('、');\n}\n","import { HighlightStyle } from '../common/content-config-params';\nimport { SVG_NS, empty } from '../utils/dom-utils';\nimport { Point, Rect } from '../utils/geometry';\n\nimport { CursorPosition } from './get-cursor-position';\n\nexport function injectGdocsStyles() {\n  removeGdocsStyles();\n\n  const style = document.createElement('style');\n  style.id = 'tenten-gdocs-styles';\n  style.textContent = `.kix-canvas-tile-selection { pointer-events: none }\n.kix-canvas-tile-content g rect[aria-label] { pointer-events: all }\n#tenten-gdocs-highlight {\n  position: absolute;\n  left: 0;\n  top: 0;\n  z-index: 100;\n  opacity: 0.3;\n}\n#tenten-gdocs-highlight .box {\n  position: absolute;\n  pointer-events: none;\n  background-color: yellow;\n}\n#tenten-gdocs-highlight .box.blue {\n  background-color: #2698fb;\n}`;\n  (document.head || document.documentElement).appendChild(style);\n}\n\nexport function removeGdocsStyles() {\n  document.getElementById('tenten-gdocs-styles')?.remove();\n}\n\nexport function getTextFromAnnotatedCanvas({\n  maxLength,\n  point,\n}: {\n  maxLength?: number;\n  point: Point;\n}): {\n  position: CursorPosition | null;\n  text: string;\n} {\n  const elem = document.elementFromPoint(point.x, point.y);\n  if (!elem || !isGdocsSpan(elem)) {\n    return { position: null, text: '' };\n  }\n\n  let text = elem.getAttribute('aria-label');\n  if (!text) {\n    return { position: null, text: '' };\n  }\n\n  const font = elem.getAttribute('data-font-css');\n  if (!font) {\n    return { position: null, text: '' };\n  }\n\n  const ctx = document.createElement('canvas').getContext('2d');\n  if (!ctx) {\n    return { position: null, text: '' };\n  }\n\n  const docScale = getDocScale(elem);\n\n  // Do a binary search to find the start of the string\n  const xPos = point.x - elem.getBoundingClientRect().left;\n  ctx.font = font;\n\n  let start = 0;\n  let end = text.length;\n  while (start < end && Math.abs(end - start) > 1) {\n    const mid = Math.floor((start + end) / 2);\n    const width = ctx.measureText(text.substring(0, mid)).width * docScale;\n    if (width > xPos) {\n      end = mid;\n    } else if (width < xPos) {\n      start = mid;\n    } else {\n      start = mid;\n      break;\n    }\n  }\n\n  // If maxLength is not set, we just stop at the end of the current span.\n  //\n  // If it _is_ set and we don't have enough characters, look up subsequent\n  // spans.\n  let currentSpan = elem;\n  while (maxLength && text.substring(start).length < maxLength) {\n    const nextSpan = currentSpan.nextSibling;\n    if (!isGdocsSpan(nextSpan)) {\n      break;\n    }\n\n    const remainingLength = maxLength - text.substring(start).length;\n    text +=\n      nextSpan.getAttribute('aria-label')?.substring(0, remainingLength) || '';\n    currentSpan = nextSpan;\n  }\n\n  return {\n    position: {\n      offset: start,\n      offsetNode: elem,\n    },\n    text,\n  };\n}\n\nfunction getDocScale(gdocsSpanElem: SVGElement) {\n  const transform = gdocsSpanElem.getAttribute('transform');\n  if (!transform) {\n    return 1;\n  }\n\n  const matches = transform.match(/matrix\\((.*)\\)\\s?/);\n  if (!matches) {\n    return 1;\n  }\n\n  const [, inner] = matches;\n  const parts = inner.split(/\\s*,\\s*/);\n\n  // We expect the document scale to be uniform (i.e. a =~ d) but we also happen\n  // to know we only ever scale width (horizontal) values so we can just fetch\n  // the horizontal scale value.\n  if (!parts.length) {\n    return 1;\n  }\n  const a = parseFloat(parts[0]);\n\n  return a > 0 ? a : 1;\n}\n\nexport function isGdocsSpan(node: Node | null): node is SVGRectElement {\n  return (\n    !!node &&\n    node.nodeType === Node.ELEMENT_NODE &&\n    (node as Element).namespaceURI === SVG_NS &&\n    (node as SVGElement).tagName === 'rect' &&\n    (node as SVGElement).hasAttribute('aria-label')\n  );\n}\n\nexport function isGdocsOverlayElem(node: Node | null): node is SVGElement {\n  return (\n    !!node &&\n    node.nodeType === Node.ELEMENT_NODE &&\n    (node as Element).namespaceURI === SVG_NS &&\n    ((node as SVGElement).tagName === 'g' ||\n      (node as SVGElement).tagName === 'rect')\n  );\n}\n\nexport function getGdocsRangeBboxes({\n  startSpan,\n  offset,\n  length,\n}: {\n  startSpan: SVGRectElement;\n  offset: number;\n  length: number;\n}): Array<Rect> {\n  const boxes: Array<Rect> = [];\n\n  const text = startSpan.getAttribute('aria-label');\n  if (!text) {\n    return boxes;\n  }\n\n  const font = startSpan.getAttribute('data-font-css');\n  if (!font) {\n    return boxes;\n  }\n\n  const ctx = document.createElement('canvas').getContext('2d');\n  if (!ctx) {\n    return boxes;\n  }\n\n  const docScale = getDocScale(startSpan);\n\n  const { x, y: top, height } = startSpan.getBoundingClientRect();\n\n  ctx.font = font;\n  const leadingWidth = offset\n    ? ctx.measureText(text.substring(0, offset)).width * docScale\n    : 0;\n  const width =\n    ctx.measureText(text.substring(offset, offset + length)).width * docScale;\n\n  boxes.push({ left: x + leadingWidth, top, width, height });\n\n  let currentSpan = startSpan;\n  let accumulatedLength = text.length - offset;\n  while (accumulatedLength < length) {\n    if (!isGdocsSpan(currentSpan.nextSibling)) {\n      break;\n    }\n    currentSpan = currentSpan.nextSibling;\n\n    const text = currentSpan.getAttribute('aria-label');\n    const font = currentSpan.getAttribute('data-font-css');\n    if (!text || !font) {\n      continue;\n    }\n\n    const lengthToMeasure = Math.min(length - accumulatedLength, text.length);\n    accumulatedLength += lengthToMeasure;\n\n    const { x: left, y: top, height } = currentSpan.getBoundingClientRect();\n    ctx.font = font;\n    const width =\n      ctx.measureText(text.substring(0, lengthToMeasure)).width * docScale;\n\n    boxes.push({ left, top, width, height });\n  }\n\n  return boxes;\n}\n\nexport function highlightGdocsRange({\n  startSpan,\n  offset,\n  length,\n  style,\n}: {\n  startSpan: SVGRectElement;\n  offset: number;\n  length: number;\n  style?: HighlightStyle;\n}) {\n  let highlightContainer = document.getElementById('tenten-gdocs-highlight');\n  if (highlightContainer) {\n    empty(highlightContainer);\n  }\n\n  const boxes = getGdocsRangeBboxes({ startSpan, offset, length });\n  if (!boxes.length) {\n    return;\n  }\n\n  if (!highlightContainer) {\n    highlightContainer = document.createElement('div');\n    highlightContainer.id = 'tenten-gdocs-highlight';\n    const parent =\n      document.querySelector('.kix-appview-editor') || document.body;\n    parent.append(highlightContainer);\n  }\n\n  const containerBbox = highlightContainer.getBoundingClientRect();\n\n  for (const box of boxes) {\n    const boxElem = document.createElement('div');\n    boxElem.classList.add('box');\n    boxElem.classList.toggle('blue', style === 'blue');\n    boxElem.style.left = `${box.left - containerBbox.left}px`;\n    boxElem.style.top = `${box.top - containerBbox.top}px`;\n    boxElem.style.width = `${box.width}px`;\n    boxElem.style.height = `${box.height}px`;\n    highlightContainer.append(boxElem);\n  }\n}\n\nexport function clearGdocsHighlight() {\n  document.getElementById('tenten-gdocs-highlight')?.remove();\n}\n","import { MajorDataSeries } from '@birchill/jpdict-idb';\n\nimport { CopyEntry } from './copy-text';\nimport { QueryResult } from './query';\n\nexport function getCopyEntryFromResult({\n  series,\n  result,\n  index,\n}: {\n  series: MajorDataSeries;\n  result: QueryResult;\n  index: number;\n}): CopyEntry | null {\n  // Get the actual index to use.\n  let numberOfCopyableEntries;\n  if (series === 'words') {\n    const { namePreview } = result;\n    numberOfCopyableEntries =\n      (namePreview?.names.length ?? 0) + (result.words?.data.length ?? 0);\n  } else if (series === 'names') {\n    numberOfCopyableEntries = result.names?.data.length ?? 0;\n  } else if (series === 'kanji') {\n    numberOfCopyableEntries = result.kanji?.data.length ?? 0;\n  }\n\n  if (!numberOfCopyableEntries) {\n    return null;\n  }\n\n  const wrappedIndex = index % numberOfCopyableEntries;\n\n  // Find the corresponding entry\n  if (series === 'words') {\n    const { namePreview } = result;\n    const namesLength = namePreview?.names.length ?? 0;\n    const inNamePreviewRange = wrappedIndex < namesLength;\n\n    if (inNamePreviewRange) {\n      return { type: 'name', data: namePreview!.names[wrappedIndex] };\n    }\n\n    return result.words\n      ? { type: 'word', data: result.words.data[wrappedIndex - namesLength] }\n      : null;\n  } else if (series === 'names') {\n    return result.names\n      ? { type: 'name', data: result.names.data[wrappedIndex] }\n      : null;\n  } else if (series === 'kanji') {\n    return result.kanji\n      ? { type: 'kanji', data: result.kanji.data[wrappedIndex] }\n      : null;\n  }\n\n  return null;\n}\n","/**\n * Gets a Range for a single codepoint given a character offset and optional\n * direction.\n */\nexport function getRangeForSingleCodepoint({\n  source,\n  offset,\n  direction = 'forwards',\n}: {\n  source: Text;\n  offset: number;\n  direction?: 'forwards' | 'backwards';\n}): Range {\n  // Adjust the offset if it's in the middle of a surrogate pair.\n  if (\n    direction === 'forwards' &&\n    offset < source.data.length &&\n    isLowSurrogate(source.data.charCodeAt(offset))\n  ) {\n    if (offset < source.data.length - 1) {\n      offset++;\n    } else {\n      offset--;\n    }\n  } else if (\n    direction === 'backwards' &&\n    offset > 0 &&\n    isHighSurrogate(source.data.charCodeAt(offset - 1))\n  ) {\n    offset++;\n  }\n\n  let end: number;\n  if (direction === 'forwards') {\n    // If the offset is at the start of a surrogate pair, we need to include\n    // the low surrogate as well.\n    if (offset >= source.data.length) {\n      end = offset;\n    } else if (isHighSurrogate(source.data.charCodeAt(offset))) {\n      end = offset + 2;\n    } else {\n      end = offset + 1;\n    }\n  } else {\n    if (offset <= 0) {\n      end = offset;\n    } else if (isLowSurrogate(source.data.charCodeAt(offset - 1))) {\n      end = offset - 2;\n    } else {\n      end = offset - 1;\n    }\n  }\n\n  const range = new Range();\n  range.setStart(\n    source,\n    Math.max(Math.min(offset, end, source.data.length), 0)\n  );\n  range.setEnd(source, Math.min(Math.max(offset, end, 0), source.data.length));\n\n  return range;\n}\n\nfunction isLowSurrogate(codepoint: number): boolean {\n  return codepoint >= 0xdc00 && codepoint <= 0xdfff;\n}\n\nfunction isHighSurrogate(codepoint: number): boolean {\n  return codepoint >= 0xd800 && codepoint <= 0xdbff;\n}\n\nexport function getBboxForSingleCodepointRange(\n  range: Range\n): DOMRect | undefined {\n  // In Safari when a range is at the start of a line, getClientRects()\n  // returns two bounding boxes: an empty (zero-width) one at the end of the\n  // line and a non-empty one for the first character at the start of the line.\n  //\n  // Worse still, getBoundingClientRect() returns the union of the two producing\n  // a massive (and very wrong) bounding box.\n  //\n  // Here we get the individual client rects and then return the widest one.\n  return [...range.getClientRects()].reduce<DOMRect | undefined>(\n    (result, bbox) => ((result?.width || 0) >= bbox.width ? result : bbox),\n    undefined\n  );\n}\n","export type ContentType = 'text' | 'image';\n\nexport function getContentType(elem: Element): ContentType {\n  return ['IMG', 'PICTURE', 'VIDEO'].includes(elem.tagName) ? 'image' : 'text';\n}\n","export function getPopupContainer(): HTMLElement | null {\n  const hostElem = document.getElementById('tenten-ja-window');\n  return hostElem && hostElem.shadowRoot\n    ? hostElem.shadowRoot.querySelector('.container')\n    : null;\n}\n\nexport function isPopupWindowHostElem(\n  target: EventTarget | Node | null\n): boolean {\n  return target instanceof HTMLElement && target.id === 'tenten-ja-window';\n}\n","import { Point, Rect } from '../utils/geometry';\n\nexport type ScrollOffset = { scrollX: number; scrollY: number };\n\nexport function getScrollOffset(): ScrollOffset {\n  // If we're in full screen mode, we should use the scroll position of the\n  // full-screen element (which is always zero?).\n  if (document.fullscreenElement) {\n    return {\n      scrollX: document.fullscreenElement.scrollLeft,\n      scrollY: document.fullscreenElement.scrollTop,\n    };\n  }\n\n  const { scrollX, scrollY } = document.defaultView!;\n  return { scrollX, scrollY };\n}\n\nexport function toPageCoords(\n  screen: Readonly<Point>,\n  scrollOffset?: ScrollOffset\n): Point;\nexport function toPageCoords(\n  screen: Readonly<Rect>,\n  scrollOffset?: ScrollOffset\n): Rect;\n\nexport function toPageCoords<T extends Point | Rect>(\n  screen: Readonly<T>,\n  scrollOffset?: ScrollOffset\n): T {\n  const { scrollX, scrollY } = scrollOffset || getScrollOffset();\n\n  // The following is a mess because Typescript doesn't do narrow for generics\n  // yet: https://github.com/microsoft/TypeScript/issues/33014\n  if (isPoint(screen)) {\n    return {\n      x: screen.x + scrollX,\n      y: screen.y + scrollY,\n    } as unknown as Readonly<T>;\n  } else {\n    return {\n      left: (screen as Readonly<Rect>).left + scrollX,\n      top: (screen as Readonly<Rect>).top + scrollY,\n      width: (screen as Readonly<Rect>).width,\n      height: (screen as Readonly<Rect>).height,\n    } as unknown as Readonly<T>;\n  }\n}\n\nexport function toScreenCoords(\n  page: Readonly<Point>,\n  scrollOffset?: ScrollOffset\n): Point;\nexport function toScreenCoords(\n  page: Readonly<Rect>,\n  scrollOffset?: ScrollOffset\n): Rect;\n\nexport function toScreenCoords<T extends Point | Rect>(\n  page: Readonly<T>,\n  scrollOffset?: ScrollOffset\n): T {\n  const { scrollX, scrollY } = scrollOffset || getScrollOffset();\n\n  if (isPoint(page)) {\n    return {\n      x: page.x - scrollX,\n      y: page.y - scrollY,\n    } as unknown as Readonly<T>;\n  } else {\n    return {\n      left: (page as Readonly<Rect>).left - scrollX,\n      top: (page as Readonly<Rect>).top - scrollY,\n      width: (page as Readonly<Rect>).width,\n      height: (page as Readonly<Rect>).height,\n    } as unknown as Readonly<T>;\n  }\n}\n\nfunction isPoint(\n  pointOrRect: Readonly<Point | Rect>\n): pointOrRect is Readonly<Point> {\n  // Sometimes we get Rect-like things that have an 'x' and 'y' member on them\n  // so it's better to test the input is _not_ a rect.\n  return typeof (pointOrRect as Readonly<Rect>).width !== 'number';\n}\n","import { html } from '../utils/builder';\nimport {\n  SVG_NS,\n  isElement,\n  isTextInputNode,\n  isTextNode,\n} from '../utils/dom-utils';\nimport {\n  Point,\n  Rect,\n  bboxIncludesPoint,\n  getBboxForNodeList,\n} from '../utils/geometry';\nimport {\n  getBboxForSingleCodepointRange,\n  getRangeForSingleCodepoint,\n} from '../utils/range';\nimport { isChromium } from '../utils/ua-utils';\n\nimport { isGdocsOverlayElem } from './gdocs-canvas';\nimport { isPopupWindowHostElem } from './popup/popup-container';\nimport { toPageCoords } from './scroll-offset';\n\ndeclare global {\n  // The following definitions were dropped from lib.dom.d.ts in TypeScript 4.4\n  // since only Firefox supports them.\n  interface CaretPosition {\n    readonly offsetNode: Node;\n    readonly offset: number;\n    getClientRect(): DOMRect | null;\n  }\n\n  type CaretPositionFromPointOptions = {\n    shadowRoots?: Array<ShadowRoot>;\n  };\n\n  interface Document {\n    caretPositionFromPoint?: (\n      x: number,\n      y: number,\n      options?: CaretPositionFromPointOptions\n    ) => CaretPosition | null;\n  }\n}\n\nexport type CursorPosition<T extends Node = Node> = {\n  offset: number;\n  offsetNode: T;\n};\n\n/**\n * Wrapper around document.caretPositionFromPoint / document.caretRangeFromPoint\n * that works around browser inconsistencies and bugs and digs into elements\n * that otherwise would be hidden or unselectable.\n */\nexport function getCursorPosition({\n  point,\n  elements: initialElements,\n}: {\n  point: Point;\n  elements: readonly Element[];\n}): CursorPosition | null {\n  if (!initialElements.length) {\n    return null;\n  }\n\n  // Do an initial lookup\n  const initialResult = getCursorPositionForElement({\n    point,\n    element: initialElements[0],\n  });\n\n  // Check if our initial result is good enough\n  if (\n    isTextNodePosition(initialResult) ||\n    isTextInputPosition(initialResult) ||\n    isGdocsOverlayPosition(initialResult)\n  ) {\n    return initialResult;\n  }\n\n  // Otherwise see if we can get a better result by disabling pointer-events on\n  // any transparent elements from the hit list and checking again.\n  const stylesToRestore = new Map<Element, string | null>();\n\n  try {\n    const elements = [...initialElements];\n    let firstElement = true;\n\n    for (\n      let element = elements.shift();\n      element;\n      element = elements.shift(), firstElement = false\n    ) {\n      // Skip elements without a style attribute (since we have no easy way to\n      // toggle their pointer-events state).\n      if (\n        !(element instanceof HTMLElement) &&\n        !(element instanceof SVGElement)\n      ) {\n        continue;\n      }\n\n      // Skip elements that are already visible\n      //\n      // We need special handling here to account for \"covering links\".\n      //\n      // Normally we can just check if the current element is invisible or not\n      // but for asahi.com we have a special case where it effectively makes the\n      // covering content invisible by setting the dimensions of a _child_\n      // element to 1x1.\n      //\n      // To detect that case we check for a non-auto z-index since that has\n      // proven to be the most reliable indicator of this pattern. If we simply\n      // decide to treat the element as invisible whenever its bounding box\n      // doesn't line up, we'll run this too often and cause a performance\n      // regression when the the cursor is moving around empty space on the Web\n      // page.\n      //\n      // We only do this for the initial lookup for now because so far that's\n      // proved sufficient (and is probably cheaper than trying to perform this\n      // check on every element in the hit list).\n      const treatElementAsInvisible =\n        firstElement && getComputedStyle(element).zIndex !== 'auto';\n      if (!treatElementAsInvisible && isVisible(element)) {\n        continue;\n      }\n\n      // Temporarily turn off pointer-events on the (invisible) element\n      stylesToRestore.set(element, element.getAttribute('style'));\n      element.style.setProperty('pointer-events', 'none', 'important');\n\n      // See if we get a better result now\n      const result = getCursorPositionForElement({ point, element });\n      if (isTextNodePosition(result) || isTextInputPosition(result)) {\n        return result;\n      }\n    }\n  } finally {\n    restoreStyles(stylesToRestore);\n  }\n\n  // We didn't find anything better by toggling pointer-events, so use the\n  // original result.\n  return initialResult;\n}\n\nexport function isTextNodePosition(\n  position: CursorPosition | null | undefined\n): position is CursorPosition<Text> {\n  return !!position && isTextNode(position.offsetNode);\n}\n\nexport function isTextInputPosition(\n  position: CursorPosition | null | undefined\n): position is CursorPosition<HTMLInputElement | HTMLTextAreaElement> {\n  return !!position && isTextInputNode(position.offsetNode);\n}\n\nexport function isGdocsOverlayPosition(\n  position: CursorPosition | null | undefined\n): position is CursorPosition<SVGElement> {\n  return (\n    !!position &&\n    document.location.host === 'docs.google.com' &&\n    isGdocsOverlayElem(position.offsetNode)\n  );\n}\n\nfunction getElementForPosition(\n  position: CursorPosition | null | undefined\n): Element | null {\n  return position?.offsetNode?.nodeType === Node.ELEMENT_NODE\n    ? (position.offsetNode as Element)\n    : position?.offsetNode?.parentElement || null;\n}\n\nfunction getCursorPositionForElement({\n  point,\n  element,\n}: {\n  point: Point;\n  element: Element;\n}): CursorPosition | null {\n  // Lookup point\n  let position = lookupPoint({ point, element });\n\n  // If the position is in a text input element or Google Docs element return it\n  // immediately.\n  if (isTextInputPosition(position)) {\n    // For a textarea we still need to check it overlaps since at least in\n    // Firefox, if it is display: block, caretPositionFromPoint might return it\n    // even when the point is outside the element.\n    //\n    // And although we've never encountered such a case, we should probably\n    // check that the element is visible too.\n    return positionIntersectsPoint(position, point) &&\n      isVisible(position.offsetNode)\n      ? position\n      : null;\n  }\n\n  // For Google Docs, presumably the element is overlapping and visible.\n  if (isGdocsOverlayPosition(position)) {\n    return position;\n  }\n\n  // If we have any other kind of node, see if we need to override the\n  // user-select style to get a better result.\n  //\n  // This addresses two issues:\n  //\n  // 1. In Firefox, content with `user-select: all` will cause\n  //    caretPositionFromPoint to return the parent element.\n  //\n  // 2. In Safari, content with `-webkit-user-select: none` will not be found by\n  //    caretRangeFromPoint.\n  //\n  if (!isTextNodePosition(position)) {\n    const userSelectResult = lookupPointWithNormalizedUserSelect({\n      point,\n      element,\n    });\n\n    // If we got back a text node, prefer it to our previous result\n    if (isTextNodePosition(userSelectResult)) {\n      position = userSelectResult;\n    }\n  }\n\n  // Check that the element intersects the point\n  //\n  // This can happen when the Web page sets the geometry of the element we\n  // picked up in a way that hides it (see the extended comment before\n  // `positionIntersectsPoint` for details).\n  if (position && !positionIntersectsPoint(position, point)) {\n    return null;\n  }\n\n  // Check that the position is close to the lookup point since sometimes\n  // due to line-wrapping etc. caretPositionFromPoint can return a point far\n  // away from the cursor.\n  if (isTextNodePosition(position) && !isResultCloseToPoint(position, point)) {\n    return null;\n  }\n\n  // Check that the element is visible\n  const positionElement = getElementForPosition(position);\n  if (positionElement && !isVisible(positionElement)) {\n    return null;\n  }\n\n  return position;\n}\n\nfunction isVisible(element: Element) {\n  // Use the checkVisibility API when available\n  if ('checkVisibility' in element) {\n    return element.checkVisibility({\n      checkOpacity: true,\n      checkVisibilityCSS: true,\n    });\n  }\n\n  const { opacity, visibility } = getComputedStyle(element);\n  return opacity !== '0' && visibility !== 'hidden';\n}\n\nfunction lookupPoint({\n  point,\n  element,\n}: {\n  point: Point;\n  element: Element;\n}): CursorPosition | null {\n  const position = getCaretPosition({ point, element });\n  if (!position) {\n    return null;\n  }\n\n  if (isTextNodePosition(position) && position.offset) {\n    position.offset = getVisualOffset({ position, point });\n  }\n\n  return position;\n}\n\nfunction getCaretPosition({\n  point,\n  element,\n}: {\n  point: Point;\n  element: Element;\n}): CursorPosition | null {\n  if (typeof document.caretPositionFromPoint === 'function') {\n    const shadowRoots = getDescendantShadowRoots(element);\n    const position = document.caretPositionFromPoint(point.x, point.y, {\n      shadowRoots,\n    });\n    return position?.offsetNode\n      ? { offset: position.offset, offsetNode: position.offsetNode }\n      : null;\n  }\n\n  return caretRangeFromPoint({ point, element });\n}\n\n// If the cursor is more than half way across a character,\n// caretPositionFromPoint will choose the _next_ character since that's where\n// the cursor would be placed if you clicked there and started editing the\n// text.\n//\n// (Or something like that, it looks like when editing it's more like if the\n// character is 70% or so of the way across the character it inserts before\n// the next character. In any case, caretPositionFromPoint et. al appear to\n// consistently choose the next character after about the 50% mark in at least\n// Firefox and Chromium.)\n//\n// For _looking up_ text, however, it's more intuitive if we look up starting\n// from the character you're pointing at.\n//\n// Here we see if the point is within the bounding box of the _previous_\n// character in the inline direction and, if it is, start from there instead.\nfunction getVisualOffset({\n  position,\n  point,\n}: {\n  position: CursorPosition<Text>;\n  point: Point;\n}): number {\n  const range = getRangeForSingleCodepoint({\n    source: position.offsetNode,\n    offset: position.offset,\n    direction: 'backwards',\n  });\n\n  const previousCharacterBbox = getBboxForSingleCodepointRange(range);\n  return previousCharacterBbox &&\n    bboxIncludesPoint({ bbox: previousCharacterBbox, point })\n    ? range.startOffset\n    : position.offset;\n}\n\nfunction lookupPointWithNormalizedUserSelect({\n  point,\n  element,\n}: {\n  point: Point;\n  element: Element;\n}): CursorPosition | null {\n  const stylesToRestore = new Map<Element, string | null>();\n  let currentElem: Element | null = element;\n  while (currentElem) {\n    // If the element doesn't have a style attribute we can't override it\n    if (\n      !(currentElem instanceof HTMLElement) &&\n      !(currentElem instanceof SVGElement)\n    ) {\n      currentElem = currentElem.parentElement;\n      continue;\n    }\n\n    const { userSelect, webkitUserSelect } = getComputedStyle(currentElem);\n    const ok = ['auto', 'text', ''];\n    if (!ok.includes(userSelect) || !ok.includes(webkitUserSelect)) {\n      stylesToRestore.set(currentElem, currentElem.getAttribute('style'));\n      // We set the styles directly on the element (as opposed to temporarily\n      // installing a stylesheet) since this should work better on shadow DOM\n      // elements.\n      currentElem.style.setProperty('user-select', 'text', 'important');\n      currentElem.style.setProperty('-webkit-user-select', 'text', 'important');\n    }\n\n    currentElem = currentElem.parentElement;\n  }\n\n  if (!stylesToRestore.size) {\n    return null;\n  }\n\n  // Look up again\n  const result = lookupPoint({ point, element });\n\n  restoreStyles(stylesToRestore);\n\n  return result;\n}\n\nfunction restoreStyles(styles: Map<Element, string | null>) {\n  for (const [elem, style] of styles) {\n    if (style) {\n      elem.setAttribute('style', style);\n    } else {\n      elem.removeAttribute('style');\n    }\n  }\n}\n\n// --------------------------------------------------------------------------\n//\n// Intersection checking\n//\n// --------------------------------------------------------------------------\n\n// Check that the element's bounding box encapsulates the point, roughly.\n//\n// This is needed for at least two cases:\n//\n// 1) When the cursor is between two paragraphs. In that case the distance\n//    check below is not sufficient since we'll still be fairly close to the\n//    text we picked up (perhaps we should make the distance check based on\n//    the writing mode?).\n//\n// 2) For the \"covering link\" case found on sites like asahi.com which have\n//    a structure like the following:\n//\n//    <div>\n//      <a href=\"/articles/\" style=\"position: absolute; top: 0; bottom: 0; left: 0; right: 0; z-index: 1\">\n//        <span aria-hidden=\"true\" style=\"display: block; width: 1px; height: 1px; overflow: hidden\">\n//          あいうえお\n//        </span>\n//      </a>\n//    </div>\n//    <div>\n//      <div style=\"position: relative; width: 100%\">\n//        <h2 style=\"z-index: auto\">\n//          <a href=\"/articles/\" id=\"innerLink\">\n//            あいうえお\n//          </a>\n//        </h2>\n//      </div>\n//    </div>\n//\n//    In this case caretPositionFromPoint will return a position inside the\n//    first <span> (inside the \"covering link\") but that span is effectively\n//    made invisible by giving it a width and height of 1px.\n//\n//    We need to reject that result so we have a chance to look for the text\n//    in the covered <div> (the second <a> element).\nfunction positionIntersectsPoint(\n  position: CursorPosition,\n  point: Point\n): boolean {\n  const bbox = getBboxForPosition(position);\n  return !bbox || bboxIncludesPoint({ bbox, margin: 5, point });\n}\n\nfunction getBboxForPosition(position: CursorPosition): Rect | null {\n  const node = position.offsetNode;\n  if (isTextNode(node)) {\n    const range = new Range();\n    range.selectNode(node);\n    return range.getBoundingClientRect();\n  }\n\n  if (isElement(node)) {\n    if (getComputedStyle(node).display === 'contents') {\n      return getBboxForNodeList(node.childNodes);\n    }\n    return node.getBoundingClientRect();\n  }\n\n  return null;\n}\n\n// --------------------------------------------------------------------------\n//\n// Distance checking\n//\n// --------------------------------------------------------------------------\n\nfunction isResultCloseToPoint(\n  position: { offsetNode: Text; offset: number },\n  point: Point\n): boolean {\n  const distanceResult = getDistanceFromTextNode(position, point);\n\n  // We should be within the space of about three characters\n  return (\n    !distanceResult || distanceResult.distance <= distanceResult.glyphExtent * 3\n  );\n}\n\nfunction getDistanceFromTextNode(\n  position: { offsetNode: Text; offset: number },\n  point: Point\n): { distance: number; glyphExtent: number } | null {\n  const { offsetNode: node, offset } = position;\n\n  if (!node.parentElement) {\n    return null;\n  }\n\n  // Ignore SVG content (it doesn't normally need distance checking).\n  if (node.parentElement.namespaceURI === SVG_NS) {\n    return null;\n  }\n\n  // Get bbox of first character in range (since that's where we select from).\n  const range = getRangeForSingleCodepoint({ source: node, offset });\n  const bbox = getBboxForSingleCodepointRange(range);\n  if (!bbox) {\n    return null;\n  }\n\n  // Find the distance from the cursor to the closest edge of that character\n  // since if we have a large font size the two distances could be quite\n  // different.\n  const xDist = Math.min(\n    Math.abs(point.x - bbox.left),\n    Math.abs(point.x - bbox.right)\n  );\n  const yDist = Math.min(\n    Math.abs(point.y - bbox.top),\n    Math.abs(point.y - bbox.bottom)\n  );\n\n  const distance = Math.sqrt(xDist * xDist + yDist * yDist);\n  const glyphExtent = Math.sqrt(\n    bbox.width * bbox.width + bbox.height * bbox.height\n  );\n\n  return { distance, glyphExtent };\n}\n\n// --------------------------------------------------------------------------\n//\n// caretRangeFromPoint helpers\n//\n// --------------------------------------------------------------------------\n\n/**\n * Wrapper for document.caretRangeFromPoint that fixes some deficiencies when\n * compared with caretPositionFromPoint (at least with regards to the Firefox\n * implementation of caretPositionFromPoint).\n */\nfunction caretRangeFromPoint({\n  point,\n  element,\n  limitToDescendants = false,\n}: {\n  point: Point;\n  element: Element;\n  limitToDescendants?: boolean;\n}): CursorPosition | null {\n  // Special handling for text boxes.\n  //\n  // 1. In Chromium, caretRangeFromPoint doesn't return text input elements.\n  //    Instead it returns one of their ancestors.\n  //\n  // 2. In WebKit, caretRangeFromPoint returns text input elements, but always\n  //    sets the offset to 0.\n  if (isTextInputNode(element)) {\n    return getCursorPositionFromTextInput({ input: element, point });\n  }\n\n  let range = document.caretRangeFromPoint(point.x, point.y);\n\n  if (\n    !range ||\n    // Normally we don't perform a lookup if we detect a pointermove event over\n    // the popup window, but when using the puck we allow it as otherwise when\n    // the puck pointer passes over the window, we'll fail to dismiss it.\n    isPopupWindowHostElem(range.startContainer) ||\n    (limitToDescendants && !element.contains(range.startContainer))\n  ) {\n    return null;\n  }\n\n  // Unlike `document.caretPositionFromPoint` in Gecko,\n  // `document.caretRangeFromPoint` in Blink/WebKit doesn't dig into shadow DOM\n  // so we need to do it manually.\n  range = expandShadowDomInRange({ range, point });\n\n  // Check if we are now pointing at an input text node.\n  if (isTextInputNode(range.startContainer)) {\n    return getCursorPositionFromTextInput({\n      input: range!.startContainer,\n      point,\n    });\n  }\n\n  // Range adjustment for Safari\n  range = adjustForRangeBoundary({ range, point });\n\n  return range\n    ? {\n        offsetNode: range.startContainer,\n        offset: range.startOffset,\n      }\n    : null;\n}\n\n/**\n * Helper for caretRangeFromPoint to look up text input elements.\n */\nfunction getCursorPositionFromTextInput({\n  input,\n  point,\n}: {\n  input: HTMLInputElement | HTMLTextAreaElement;\n  point: Point;\n}): CursorPosition | null {\n  // Empty input elements\n  if (!input.value.trim().length) {\n    return null;\n  }\n\n  // This is only called when the platform APIs failed to give us the correct\n  // result so we need to synthesize an element with the same layout as the\n  // text area, read the text position, then drop it.\n  //\n  // We currently only expect to use it together with caretRangeFromPoint since\n  // caretPositionFromPoint should look up text inputs correctly.\n  if (!('caretRangeFromPoint' in document)) {\n    throw new Error('caretRangeFromPoint not available');\n  }\n\n  // Create the element\n  const mirrorElement = createMirrorElement(input, input.value);\n\n  // Read the offset\n  //\n  // We need to be careful not to allow caretRangeFromPoint to visit elements\n  // outside the mirror element or else we can end up in a case of infinite\n  // recursion where we pick up the same input element all over again.\n  //\n  // We _could_ just call `document.caretRangeFromPoint` here which would avoid\n  // recursion but then we'd miss out on the position adjustment we do in\n  // `caretRangeFromPoint` (which maybe would be ok? It's what we do for shadow\n  // DOM after all?).\n  const result = caretRangeFromPoint({\n    point,\n    element: mirrorElement,\n    limitToDescendants: true,\n  });\n  if (result) {\n    // Adjust the offset before we drop the mirror element\n    if (isTextNodePosition(result)) {\n      result.offset = getVisualOffset({ position: result, point });\n    }\n\n    result.offsetNode = input;\n  }\n\n  // Drop the element\n  mirrorElement.remove();\n\n  return result;\n}\n\nfunction createMirrorElement(source: HTMLElement, text?: string): HTMLElement {\n  // Create the element\n  const mirrorElement = html('div');\n\n  // Fill in the text/child content\n  if (text !== undefined) {\n    mirrorElement.append(text);\n  } else {\n    // If we don't have a specific string to use, we duplicate all the source\n    // element's children.\n    //\n    // Often we'll know which `Text` child of the source element we're\n    // interested in but unfortunately it's not enough to duplicate that one\n    // `Text` child in isolation since it could appear amongst other inline\n    // siblings and if we don't duplicate them, it won't get the correct\n    // position.\n    //\n    // We _can_ get the position of the text node, but it might wrap over\n    // several lines and we need to duplicate that wrapping too in order to get\n    // the correct positioning.\n    //\n    // We can get the bbox for each line via getClientRects() but we don't know\n    // what _characters_ are in each box.\n    //\n    // In order to do that we'd probably need to make up many ranges and bisect\n    // them until we could assign characters to boxes but that's quite involved\n    // so currently we just duplicate all the descendant elements.\n    //\n    // That has some limitations such as not being able to reproduce\n    // pseudo-elements so in future we probably should attempt to get just the\n    // text and bounding box for the range we're interested in and reproducing\n    // that.\n    //\n    // For now, however, this approach of duplicating all the descendants works\n    // for all the content we've encountered.\n    const childNodes = source.shadowRoot\n      ? source.shadowRoot.childNodes\n      : source.childNodes;\n    for (const child of childNodes) {\n      mirrorElement.append(cloneNodeWithStyles(child));\n    }\n  }\n\n  // Set its styles to be the same\n  const cs = document.defaultView!.getComputedStyle(source);\n  const stylesToSet: Record<string, string> = {};\n  for (let i = 0; i < cs.length; i++) {\n    const prop = cs.item(i);\n    stylesToSet[prop] = cs.getPropertyValue(prop);\n  }\n\n  for (const [name, value] of Object.entries(stylesToSet)) {\n    mirrorElement.style.setProperty(name, value);\n  }\n\n  // Special handling for Chromium which does _not_ include the scrollbars in\n  // the width/height when box-sizing is 'content-box'.\n  if (isChromium() && cs.boxSizing === 'content-box') {\n    const { paddingLeft, paddingRight, paddingTop, paddingBottom } = cs;\n    const {\n      borderLeftWidth,\n      borderRightWidth,\n      borderTopWidth,\n      borderBottomWidth,\n    } = cs;\n\n    const width =\n      source.offsetWidth -\n      parseFloat(paddingLeft) -\n      parseFloat(paddingRight) -\n      parseFloat(borderLeftWidth) -\n      parseFloat(borderRightWidth);\n    if (Number.isFinite(width)) {\n      mirrorElement.style.width = `${width}px`;\n    }\n\n    const height =\n      source.offsetHeight -\n      parseFloat(paddingTop) -\n      parseFloat(paddingBottom) -\n      parseFloat(borderTopWidth) -\n      parseFloat(borderBottomWidth);\n    if (Number.isFinite(height)) {\n      mirrorElement.style.height = `${height}px`;\n    }\n  }\n\n  // Set its position in the document to be to be the same\n  mirrorElement.style.position = 'absolute';\n  const bbox = source.getBoundingClientRect();\n\n  // Fetch the top/left coordinates, bearing in mind that the bbox returned by\n  // getBoundingClientRect is the position exclusive of margins and is in screen\n  // coordinates.\n  const marginTop = parseFloat(cs.marginTop);\n  const marginLeft = parseFloat(cs.marginLeft);\n  const screenPoint = { x: bbox.left - marginLeft, y: bbox.top - marginTop };\n  const { x: left, y: top } = toPageCoords(screenPoint);\n\n  mirrorElement.style.top = top + 'px';\n  mirrorElement.style.left = left + 'px';\n\n  // Finally, make sure our element is on top\n  mirrorElement.style.zIndex = '2147483647';\n\n  // Append the element to the document. We need to do this before adjusting\n  // the scroll offset or else it won't update.\n  document.documentElement.appendChild(mirrorElement);\n\n  // Match the scroll position\n  const { scrollLeft, scrollTop } = source;\n  mirrorElement.scrollTo(scrollLeft, scrollTop);\n\n  return mirrorElement;\n}\n\nfunction cloneNodeWithStyles(node: Node): Node {\n  if (\n    !isElement(node) ||\n    (!(node instanceof HTMLElement) && !(node instanceof SVGElement))\n  ) {\n    return node.cloneNode(true);\n  }\n\n  const clone = node.cloneNode(false) as HTMLElement | SVGElement;\n  const cs = document.defaultView!.getComputedStyle(node);\n  const stylesToSet: Record<string, string> = {};\n  for (let i = 0; i < cs.length; i++) {\n    const prop = cs.item(i);\n    stylesToSet[prop] = cs.getPropertyValue(prop);\n  }\n\n  for (const [name, value] of Object.entries(stylesToSet)) {\n    clone.style.setProperty(name, value);\n  }\n\n  for (const child of node.childNodes) {\n    clone.appendChild(cloneNodeWithStyles(child));\n  }\n\n  return clone;\n}\n\n// --------------------------------------------------------------------------\n//\n// Shadow DOM helpers\n//\n// --------------------------------------------------------------------------\n\nfunction expandShadowDomInRange({\n  range,\n  point,\n}: {\n  range: Range;\n  point: Point;\n}): Range {\n  if (!isElement(range.startContainer)) {\n    return range;\n  }\n\n  // Get the shadowRoot at the given point, if any.\n  //\n  // (This is complicated by the fact in Blink, `caretRangeFromPoint` seems to\n  // return the _parent_ of elements with a shadow root.)\n  const shadowRoot = getShadowRoot({ element: range.startContainer, point });\n  if (!shadowRoot) {\n    return range;\n  }\n\n  // See if we can find a shadow element at the given point\n  const shadowNode = getShadowNodeAtPoint({ shadowRoot, point });\n  if (!shadowNode || shadowNode === range.startContainer) {\n    return range;\n  }\n\n  // If we got a text input element, return it as a range\n  if (isTextInputNode(shadowNode)) {\n    const range = new Range();\n    range.setStart(shadowNode, 0);\n    range.setEnd(shadowNode, 0);\n    return range;\n  }\n\n  // Text nodes require special handling since we want to use the styles from\n  // the host with the text from the shadow DOM.\n  if (isTextNode(shadowNode)) {\n    // We should only get a text node if it's the direct child of a shadow root\n    // (but that might not be the same shadow root as `shadowRoot` above).\n    const localShadowRoot = shadowNode.getRootNode();\n    const host =\n      localShadowRoot instanceof ShadowRoot ? localShadowRoot.host : null;\n    if (!(host instanceof HTMLElement)) {\n      return range;\n    }\n\n    const shadowRange = getRangeForShadowTextNode({\n      shadowContainer: host,\n      text: shadowNode,\n      point,\n    });\n    return shadowRange || range;\n  }\n\n  const shadowRange = getRangeForShadowElement({\n    shadowElement: shadowNode,\n    point,\n  });\n  return shadowRange || range;\n}\n\n// In Chrome, `caretRangeFromPoint` will return the _parent_ element of a shadow\n// DOM host so we need to dig down to find the _child_ node with the shadowRoot,\n// if any.\nfunction getShadowRoot({\n  element,\n  point,\n}: {\n  element: Element;\n  point: Point;\n}): ShadowRoot | null {\n  if (element.shadowRoot) {\n    return element.shadowRoot;\n  }\n\n  for (const child of element.children) {\n    const { shadowRoot } = child;\n    if (!shadowRoot) {\n      continue;\n    }\n\n    // Get the bbox of the child to check that it overlaps the point but bear in\n    // mind that custom elements are often marked as display: contents.\n    const bbox = getBboxForShadowHost(child);\n    if (!bbox) {\n      continue;\n    }\n\n    // Only return a child shadowRoot if it actually overlaps the point\n    if (shadowRoot && bboxIncludesPoint({ bbox, point })) {\n      return shadowRoot;\n    }\n  }\n\n  return null;\n}\n\nfunction getDescendantShadowRoots(root: Element): Array<ShadowRoot> {\n  const shadowRoots: Array<ShadowRoot> = [];\n\n  function traverse(element: Element) {\n    if (element.shadowRoot) {\n      shadowRoots.push(element.shadowRoot);\n\n      for (const child of element.shadowRoot.children) {\n        traverse(child);\n      }\n    }\n\n    for (const child of element.children) {\n      traverse(child);\n    }\n  }\n\n  traverse(root);\n\n  return shadowRoots;\n}\n\nfunction getBboxForShadowHost(element: Element): Rect | null {\n  // For display: contents, `getBoundingClientRect()` will return an empty\n  // bounding box so we need to return the contents of the shadow root instead.\n  if (getComputedStyle(element).display === 'contents') {\n    return getBboxForNodeList(element.shadowRoot!.childNodes);\n  }\n\n  return element.getBoundingClientRect();\n}\n\nfunction getShadowNodeAtPoint({\n  shadowRoot,\n  point,\n}: {\n  shadowRoot: ShadowRoot;\n  point: Point;\n}): Element | Text | null {\n  // elementsFromPoint can only detect _elements_ but shadow roots can have Text\n  // nodes as children so first look for any direct Text children whose tight\n  // bounding box fits.\n  const textChildren = [...shadowRoot.childNodes].filter(isTextNode);\n  for (const child of textChildren) {\n    const range = new Range();\n    range.selectNode(child);\n    const bboxes = range.getClientRects();\n    if ([...bboxes].some((bbox) => bboxIncludesPoint({ bbox, point }))) {\n      return child;\n    }\n  }\n\n  // Find the first visible element in the shadow tree under the cursor\n  const hitElements = shadowRoot.elementsFromPoint(point.x, point.y);\n  const hitElement = hitElements.find(\n    (elem) =>\n      (getComputedStyle(elem).display === 'contents' || isVisible(elem)) &&\n      shadowRoot.contains(elem)\n  );\n\n  // Recursively visit shadow roots\n  const nestedShadowRoot = hitElement\n    ? getShadowRoot({ element: hitElement, point })\n    : null;\n  if (nestedShadowRoot) {\n    return getShadowNodeAtPoint({ shadowRoot: nestedShadowRoot, point });\n  }\n\n  return hitElement || null;\n}\n\nfunction getRangeForShadowTextNode({\n  shadowContainer,\n  text,\n  point,\n}: {\n  shadowContainer: HTMLElement;\n  text: Text;\n  point: Point;\n}): Range | null {\n  if (!text.data.trim().length) {\n    return null;\n  }\n\n  // Make up a mirror element in the light DOM that we can run\n  // `document.caretRangeFromPoint` on.\n  const mirrorElement = createMirrorElement(shadowContainer);\n  const newRange = document.caretRangeFromPoint(point.x, point.y);\n  if (!newRange || !mirrorElement.contains(newRange.startContainer)) {\n    mirrorElement.remove();\n    return null;\n  }\n\n  // We need to store the offset before removing the mirror element or else\n  // the range will be updated\n  const offset = newRange.startOffset;\n  mirrorElement.remove();\n\n  const shadowRange = new Range();\n  shadowRange.setStart(text, offset);\n  shadowRange.setEnd(text, offset);\n  return shadowRange;\n}\n\nfunction getRangeForShadowElement({\n  shadowElement,\n  point,\n}: {\n  shadowElement: Element;\n  point: Point;\n}): Range | null {\n  // Check if the element has text\n  if (\n    !(shadowElement instanceof HTMLElement) ||\n    !(shadowElement.textContent || '').trim().length\n  ) {\n    return null;\n  }\n\n  // Get the block ancestor, since inline children might be split over several\n  // lines.\n  let blockAncestor = shadowElement;\n  while (\n    blockAncestor &&\n    blockAncestor.parentElement &&\n    ['inline', 'ruby', 'contents', 'inline flow'].includes(\n      getComputedStyle(blockAncestor).display\n    )\n  ) {\n    blockAncestor = blockAncestor.parentElement;\n  }\n\n  // Make up a mirror element in the light DOM that we can run\n  // `document.caretRangeFromPoint` on.\n  const mirrorElement = createMirrorElement(blockAncestor);\n  const newRange = document.caretRangeFromPoint(point.x, point.y);\n  if (!newRange || !mirrorElement.contains(newRange.startContainer)) {\n    mirrorElement.remove();\n    return null;\n  }\n\n  // Translate the range in the light DOM to the one in the shadow DOM\n  const path: number[] = [];\n  for (\n    let node = newRange.startContainer, depth = 0;\n    node.parentElement && node !== mirrorElement && depth < 10;\n    node = node.parentElement, depth++\n  ) {\n    const index = [...node.parentElement.childNodes].indexOf(node as ChildNode);\n    path.unshift(index);\n  }\n\n  // We need to store the offset before removing the mirror element or else\n  // the range will be updated\n  const offset = newRange.startOffset;\n  mirrorElement.remove();\n\n  let shadowTarget: Node | undefined = blockAncestor;\n  while (shadowTarget && path.length) {\n    shadowTarget = shadowTarget.childNodes[path.shift()!];\n  }\n\n  if (!isTextNode(shadowTarget)) {\n    return null;\n  }\n\n  const shadowRange = new Range();\n  shadowRange.setStart(shadowTarget, offset);\n  shadowRange.setEnd(shadowTarget, offset);\n  return shadowRange;\n}\n\n// --------------------------------------------------------------------------\n//\n// More caretRangeFromPoint helpers\n//\n// --------------------------------------------------------------------------\n\n// On Safari, if you pass a point into caretRangeFromPoint that is less than\n// about 60~70% of the way across the first character in a text node it will\n// return the previous text node instead.\n//\n// Here we try to detect that situation and return the \"next\" text node instead.\nfunction adjustForRangeBoundary({\n  range,\n  point,\n}: {\n  range: Range | null;\n  point: Point;\n}): Range | null {\n  // Check we got a range with the offset set to the end of a text node\n  if (\n    !range ||\n    !range.startOffset ||\n    range.startContainer.nodeType !== Node.TEXT_NODE ||\n    range.startOffset !== range.startContainer.textContent?.length\n  ) {\n    return range;\n  }\n\n  // Check there is a _different_ text node under the cursor\n  const elemFromPoint = document.elementFromPoint(point.x, point.y);\n  if (\n    !(elemFromPoint instanceof HTMLElement) ||\n    elemFromPoint === range.startContainer ||\n    !elemFromPoint.innerText.length\n  ) {\n    return range;\n  }\n\n  // Check the first character in the new element is actually the one under the\n  // cursor.\n  const firstNonEmptyTextNode = Array.from(elemFromPoint.childNodes).find(\n    (elem): elem is Text =>\n      elem.nodeType === Node.TEXT_NODE && !!(elem as Text).length\n  );\n  if (!firstNonEmptyTextNode) {\n    return range;\n  }\n\n  const firstCharRange = getRangeForSingleCodepoint({\n    source: firstNonEmptyTextNode,\n    offset: 0,\n  });\n\n  const firstCharBbox = getBboxForSingleCodepointRange(firstCharRange);\n  if (!firstCharBbox || !bboxIncludesPoint({ bbox: firstCharBbox, point })) {\n    return range;\n  }\n\n  firstCharRange.setEnd(firstNonEmptyTextNode, 0);\n  return firstCharRange;\n}\n","/** @public */\nexport const halfWidthNumbers = /[0-9]/;\n\n// U+FF01~U+FF5E is for full-width alphanumerics (includes some punctuation\n// like ＆ and ～ because they appear in the kanji headwords for some entries)\n//\n// Note that U+FF5E is full-width tilde ～ (not 〜 which is a wave dash).\n//\n// U+FF61~U+FF65 is some halfwidth ideographic symbols, e.g. ｡ but we skip them\n// (although previous rikai-tachi included them) since they're mostly going to\n// be delimiters\n/** @public */\nexport const fullWidthAlphanumerics = /[\\uff01-\\uff5e]/;\n\n// On some platforms, Google Docs puts zero-width joiner characters between\n// _all_ the characters so we need to match on them in order to match runs of\n// characters.\n/** @public */\nexport const zeroWidthNonJoiner = /[\\u200c]/;\n\n// * U+25CB is 'white circle' often used to represent a blank\n//   (U+3007 is an ideographic zero that is also sometimes used for this\n//   purpose, but this is included in the U+3001~U+30FF range.)\n/** @public */\nexport const whiteCircle = /[\\u25cb]/;\n\n// U+2E80~U+2EF3 is the CJK radicals supplement block\n// U+2F00~U+2FD5 is the Kangxi radicals block\n/** @public */\nexport const radicals = /[\\u2e80-\\u2ef3\\u2f00-\\u2fd5]/u;\n\n// * U+3000~U+3039 is ideographic punctuation but we skip:\n//\n//    U+3000 (ideographic space),\n//    U+3001 (、 ideographic comma),\n//    U+3002 (。 ideographic full stop),\n//    U+3003 (〃 ditto mark),\n//    U+3008,U+3009 (〈〉),\n//    U+300A,U+300B (《》),\n//    U+300C,U+300D (「」 corner brackets for quotations),\n//                  [ENAMDICT actually uses this in one entry,\n//                  \"ウィリアム「バッファロービル」コーディ\", but I think we\n//                  can live without being able to recognize that)\n//    U+300E,U+300F (『 』), and\n//    U+3010,U+3011 (【 】),\n//\n//   since these are typically only going to delimit words.\n/** @public */\nexport const nonDelimitingIdeographicPunctuation =\n  /[\\u3004-\\u3007\\u3012-\\u3039]/;\n\n// U+3041~U+309F is the hiragana range\n/** @public */\nexport const hiragana = /[\\u3041-\\u309f\\u{1b001}]/u;\n\n// U+30A0~U+30FF is the katakana range\n/** @public */\nexport const katakana = /[\\u30a0-\\u30ff\\u{1b000}]/u;\n\n// * U+3220~U+3247 is various enclosed characters like ㈵\n// * U+3280~U+32B0 is various enclosed characters like ㊞\n// * U+32D0~U+32FF is various enclosed characters like ㋐ and ㋿.\nconst enclosedChars = /[\\u3220-\\u3247\\u3280-\\u32b0\\u32d0-\\u32ff]/;\n\n// U+3300~U+3357 is various shorthand characters from the CJK compatibility\n// block like ㍍\nconst shorthandChars = /[\\u3300-\\u3357]/;\n\n// U+3358~U+3370 is numbers composed with 点 e.g. ㍘\nconst tenChars = /[\\u3358-\\u3370]/;\n\n// U+337B~U+337E is various era names e.g. ㍻\nconst eraChars = /[\\u337B-\\u337E]/;\n\n// U+337F is ㍿\nconst kabushikiGaisha = /[\\u337F]/;\n\n// U+4E00~U+9FFF is the CJK Unified Ideographs block (\"the kanji\")\n/** @public */\nexport const kanji = /[\\u4e00-\\u9fff]/;\n\n// * U+3400~U+4DBF is the CJK Unified Ideographs Extension A block (rare\n//   kanji)\n// * U+F900~U+FAFF is the CJK Compatibility Ideographs block (random odd\n//   kanji, because standards)\n// * U+20000~U+2A6DF is CJK Unified Ideographs Extension B (more rare kanji)\n/** @public */\nexport const rareKanji = /[\\u3400-\\u4dbf\\uf900-\\ufaff\\u{20000}-\\u{2a6df}]/u;\n\n// U+FF66~U+FF9F is halfwidth katakana\n/** @public */\nexport const halfwidthKatakanaChar = /[\\uff66-\\uff9f]/;\n\n// U+1B002-U+1B0FF is hentaigana\n/** @public */\nexport const hentaigana = /[\\u{1b002}-\\u{1b0ff}]/u;\n\nexport function getCombinedCharRange(ranges: Array<RegExp>): RegExp {\n  let source = '[';\n  let flags = '';\n\n  for (const range of ranges) {\n    // Check we have a character class\n    if (!isCharacterClassRange(range)) {\n      throw new Error(`Expected a character class range, got: ${range.source}`);\n    }\n\n    // Check it is not negated\n    if (range.source[1] === '^') {\n      throw new Error(\n        `Expected a non-negated character class range, got ${range.source}`\n      );\n    }\n\n    source += range.source.substring(1, range.source.length - 1);\n    if (range.flags.indexOf('u') !== -1) {\n      flags = 'u';\n    }\n  }\n\n  source += ']';\n\n  return new RegExp(source, flags);\n}\n\n// This is far from complete but all the RegExps we deal with are ones we've\n// written so hopefully it's a good-enough sanity check.\nfunction isCharacterClassRange(re: RegExp): boolean {\n  return (\n    re.source.length >= 2 &&\n    re.source.startsWith('[') &&\n    re.source.endsWith(']')\n  );\n}\n\n// \"Japanese\" here simply means any character we treat as worth attempting to\n// translate, including full-width alphanumerics etc. but NOT characters that\n// typically delimit words.\n/** @public */\nexport const japaneseChar = getCombinedCharRange([\n  // We include half-width numbers so we can recognize things like 小1\n  halfWidthNumbers,\n  fullWidthAlphanumerics,\n  zeroWidthNonJoiner,\n  whiteCircle,\n  radicals,\n  nonDelimitingIdeographicPunctuation,\n  hiragana,\n  katakana,\n  enclosedChars,\n  shorthandChars,\n  tenChars,\n  eraChars,\n  kabushikiGaisha,\n  kanji,\n  rareKanji,\n  halfwidthKatakanaChar,\n  hentaigana,\n]);\n\nexport function getNegatedCharRange(range: RegExp): RegExp {\n  // Check if we got a character class range\n  if (!isCharacterClassRange(range)) {\n    throw new Error(`Expected a character class range, got: ${range.source}`);\n  }\n\n  const negated = range.source[1] === '^';\n\n  const source = `[${negated ? '' : '^'}${range.source.substring(\n    negated ? 2 : 1,\n    range.source.length - 1\n  )}]`;\n\n  return new RegExp(source, range.flags);\n}\n\nexport const nonJapaneseChar = getNegatedCharRange(japaneseChar);\n\nexport function hasKatakana(text: string): boolean {\n  return katakana.test(text);\n}\n\nexport function startsWithDigit(input: string): boolean {\n  const c = input.length ? input.charCodeAt(0) : 0;\n  return (c >= 48 && c <= 57) || (c >= 65296 && c <= 65305);\n}\n\nconst kanjiNumerals = [\n  '〇',\n  '一',\n  '二',\n  '三',\n  '四',\n  '五',\n  '六',\n  '七',\n  '八',\n  '九',\n  '十',\n  '百',\n  '千',\n  '万',\n  '億',\n  '兆',\n  '京',\n];\n\nexport function startsWithNumeral(input: string): boolean {\n  return (\n    startsWithDigit(input) ||\n    (!!input.length && kanjiNumerals.includes(input[0]))\n  );\n}\n\nconst onlyDigits = /^[0-9０-９,，、.．]+$/;\n\nexport function isOnlyDigits(input: string): boolean {\n  return onlyDigits.test(input);\n}\n","// The following is based heavily on:\n//\n// http://ginstrom.com/scribbles/2009/04/28/converting-kanji-numbers-to-integers-with-python/\n\n// Following are the digits we recognize for numbers specified as a series of\n// digits e.g. 五六. We call this a transliterated number.\nconst transliterateMap = new Map([\n  ['〇', 0],\n  ['一', 1],\n  ['二', 2],\n  ['三', 3],\n  ['四', 4],\n  ['五', 5],\n  ['六', 6],\n  ['七', 7],\n  ['八', 8],\n  ['九', 9],\n  ['０', 0],\n  ['１', 1],\n  ['２', 2],\n  ['３', 3],\n  ['４', 4],\n  ['５', 5],\n  ['６', 6],\n  ['７', 7],\n  ['８', 8],\n  ['９', 9],\n  ['0', 0],\n  ['1', 1],\n  ['2', 2],\n  ['3', 3],\n  ['4', 4],\n  ['5', 5],\n  ['6', 6],\n  ['7', 7],\n  ['8', 8],\n  ['9', 9],\n  ['.', -1],\n  ['。', -1],\n  ['．', -1],\n]);\n\n// Following are the digits we recognize for numbers that specify powers of 10,\n// e.g. 五十六.\nconst kanjiToNumberMap = new Map<string, number>([\n  ['〇', 0],\n  ['一', 1],\n  ['二', 2],\n  ['三', 3],\n  ['四', 4],\n  ['五', 5],\n  ['六', 6],\n  ['七', 7],\n  ['八', 8],\n  ['九', 9],\n  ['０', 0],\n  ['１', 1],\n  ['２', 2],\n  ['３', 3],\n  ['４', 4],\n  ['５', 5],\n  ['６', 6],\n  ['７', 7],\n  ['８', 8],\n  ['９', 9],\n  ['0', 0],\n  ['1', 1],\n  ['2', 2],\n  ['3', 3],\n  ['4', 4],\n  ['5', 5],\n  ['6', 6],\n  ['7', 7],\n  ['8', 8],\n  ['9', 9],\n  ['十', 10],\n  ['百', 100],\n  ['千', 1000],\n  ['万', 10000],\n  ['億', 100000000],\n  ['兆', 1000000000000],\n  ['.', -1],\n  ['。', -1],\n  ['．', -1],\n]);\n\nexport function parseNumber(inputText: string): number | null {\n  // Drop any commas in the string first\n  const text = inputText.replace(/[,、]/g, '');\n\n  // Try a transliterated number first since inputs like 二二一 would also be\n  // found in kanjiToNumberMap.\n  let digits = [...text].map((ch) => transliterateMap.get(ch));\n  if (digits.length && !digits.some((digit) => typeof digit === 'undefined')) {\n    if (digits.indexOf(-1) === -1) {\n      return parseInt(digits.join(''), 10);\n    } else {\n      return parseFloat(\n        digits.map((digit) => (digit === -1 ? '.' : digit)).join('')\n      );\n    }\n  }\n\n  // Otherwise, try processing as a number with powers of ten.\n  digits = [...text].map((ch) => kanjiToNumberMap.get(ch));\n  if (!digits.length || digits.some((ch) => typeof ch === 'undefined')) {\n    // If that failed, it's not something we know how to parse as a number.\n    return null;\n  }\n\n  let numbers = digits as Array<number>;\n\n  // Special case where we have a series of digits followed by a power of ten,\n  // e.g. 39,800万円 and 11,786百万. These don't follow the usual rules of\n  // numbers so we treat them separately.\n  const digitsAndPowersOfTen = getDigitsAndPowersOfTen(numbers);\n  if (digitsAndPowersOfTen) {\n    const [digits, powersOfTen] = digitsAndPowersOfTen;\n    const multiplier = digits.reduce((acc, d) => acc * 10 + d, 0);\n    const base = powersOfTen.reduce((acc, p) => acc * p, 1);\n    return multiplier * base;\n  }\n\n  let result = 0;\n\n  while (numbers.length > 1) {\n    const [first, second, ...rest] = numbers;\n\n    // Detect strings of digits and combine them\n    if (first < 10 && second < 10) {\n      let decimal = 0;\n      while (numbers.length > 1 && numbers[1] < 10) {\n        if (numbers[1] === -1) {\n          if (decimal) {\n            return null;\n          }\n          decimal = 1;\n          numbers = [numbers[0], ...numbers.slice(2)];\n        } else if (decimal) {\n          numbers = [\n            numbers[0] + numbers[1] * Math.pow(10, -decimal++),\n            ...numbers.slice(2),\n          ];\n        } else {\n          numbers = [numbers[0] * 10 + numbers[1], ...numbers.slice(2)];\n        }\n      }\n      continue;\n    }\n\n    if (!validSequence(first, second)) {\n      return null;\n    }\n\n    if (second < first) {\n      // Detected a step down, check if there are any multipliers on what we\n      // currently have.\n      if (rest.some((x) => x > first)) {\n        numbers = breakDownNumbers(numbers);\n      } else {\n        // No multipliers on what we currently have accumualated so store what\n        // we have and process the remainder.\n        result += first;\n        numbers = [second, ...rest];\n      }\n    } else {\n      numbers = [first * second, ...rest];\n    }\n  }\n\n  return result + (numbers.length ? numbers[0] : 0);\n}\n\nfunction getDigitsAndPowersOfTen(\n  arr: Array<number>\n): [Array<number>, Array<number>] | null {\n  let lastPowerOfTen = arr.length;\n  while (lastPowerOfTen && arr[lastPowerOfTen - 1] >= 100) {\n    --lastPowerOfTen;\n  }\n\n  if (lastPowerOfTen === 0 || lastPowerOfTen === arr.length) {\n    return null;\n  }\n\n  const digits = arr.slice(0, lastPowerOfTen);\n  if (!digits.every((d) => d >= 0 && d < 10)) {\n    return null;\n  }\n\n  return [digits, arr.slice(lastPowerOfTen)];\n}\n\nfunction validSequence(c1: number, c2: number): boolean {\n  // If we have xxx万, xxx億, xxx兆 then the only requirement is that xxx is less\n  // than the 'base'.\n  if (c2 >= 10000 && c1 < c2) {\n    return true;\n  }\n  if (c1 >= 10000 && c2 <= 1000) {\n    return true;\n  }\n  if (c1 >= 100 && c2 < c1 && c2 >= 10 && c2 <= 1000) {\n    return true;\n  }\n\n  // Don't allow 一十 or 一百\n  if (c1 === 1 && (c2 === 10 || c2 === 100)) {\n    return false;\n  }\n\n  return c1 < 10 !== c2 < 10;\n}\n\nfunction breakDownNumbers(numbers: Array<number>): Array<number> {\n  // If this is called, we already know that second < first.\n  //\n  // Furthermore, we know that there is something after 'second' that is\n  // greater than 'first'.\n  //\n  // Most often, the second value will be the 'unit' (i.e. value < 10) and the\n  // third value will be the base-10 multiplier.\n  //\n  // e.g. [300, 2, 10, 10000], i.e. 3,200,000\n  //\n  // In this case we want to multiply the second and third values together\n  //\n  // i.e. [300, 20, 10000]\n  //\n  // There are two cases where we can't do this:\n  //\n  // (a) When the third value is actually a multiplier not just on the second\n  //     value, but on everything we've accumulated in the first value.\n  //\n  //     In this case it will be greater than the first value.\n  //\n  //     e.g. [300, 2, 10000], i.e. 3,020,000\n  //\n  //     Here we can add the first two together and proceed.\n  //\n  //     i.e. [302, 10000]\n  //\n  // (b) When the third value is less than the second, i.e. is _not_ a\n  //     multiplier on it.\n  //\n  //     This mostly happens when lining up powers of 10 since they we don't\n  //     need a 'unit' in this case.\n  //\n  //     e.g. [1000, 100, 10, 10000], i.e. 11,100,000\n  //\n  //     Here too we can just add the first two together and proceed.\n  //\n  //     i.e. [1100, 10, 10000]\n\n  const [first, second, third, ...rest] = numbers;\n  if (first < third || third < second) {\n    return [first + second, third, ...rest];\n  } else {\n    return [first, second * third, ...rest];\n  }\n}\n\nexport interface NumberMeta {\n  type: 'number';\n  value: number;\n  src: string;\n  matchLen: number;\n}\n\n// This very long regex is really just trying to say: only recognize a number\n// that\n//\n// - is at least two digits long, and\n// - has at least one kanji digit\n//\nconst numberRegex =\n  /^([一二三四五六七八九十百千万億兆京][0-9.,０-９。．、〇一二三四五六七八九十百千万億兆京]+)|([0-9,０-９、]+([.。．][0-9０-９]+)?[〇一二三四五六七八九十百千万億兆京][0-9.,０-９。．、〇一二三四五六七八九十百千万億兆京]*)/;\n\nexport function extractNumberMetadata(text: string): NumberMeta | undefined {\n  const matches = numberRegex.exec(text);\n  if (!matches || matches.index !== 0) {\n    return undefined;\n  }\n\n  const valueStr = matches[0];\n  if (!valueStr) {\n    return undefined;\n  }\n\n  const value = parseNumber(valueStr);\n  if (!value) {\n    return undefined;\n  }\n\n  return { type: 'number', value, src: valueStr, matchLen: valueStr.length };\n}\n","import {\n  getCombinedCharRange,\n  getNegatedCharRange,\n  startsWithNumeral,\n} from '../utils/char-range';\n\nimport { parseNumber } from './numbers';\n\nexport type CurrencyMeta = {\n  type: 'currency';\n  value: number;\n  matchLen: number;\n};\n\nexport function lookForCurrency({\n  currentText,\n  nodeText,\n  textDelimiter: originalTextDelimiter,\n}: {\n  currentText: string;\n  nodeText: string;\n  textDelimiter: RegExp;\n}): {\n  textDelimiter: RegExp;\n  textEnd: number;\n} | null {\n  // If the source text might be a currency, expand our text delimiter to allow\n  // extra symbols that would normally be ignored.\n  const sourceText = currentText + nodeText;\n  const mightBeCurrency =\n    sourceText[0] === '¥' ||\n    sourceText[0] === '￥' ||\n    sourceText.startsWith('JPY') ||\n    (startsWithNumeral(sourceText) &&\n      (sourceText.indexOf('円') > 0 ||\n        sourceText.toLowerCase().indexOf('yen') > 0));\n  if (!mightBeCurrency) {\n    return null;\n  }\n\n  const japaneseOrPrice = getCombinedCharRange([\n    getNegatedCharRange(originalTextDelimiter),\n    /[¥￥\\s,、.．。kKmMbBtTyYeEnNJPY]/,\n  ]);\n  const textDelimiter = getNegatedCharRange(japaneseOrPrice);\n\n  return {\n    textDelimiter,\n    textEnd: nodeText.search(textDelimiter),\n  };\n}\n\nconst currencyRegex =\n  /((?:[￥¥]|JPY)\\s*([0-9.,０-９。．、〇一二三四五六七八九十百千万億兆京]+)([kKmMbBtT]\\b)?)|(([0-9.,０-９。．、〇一二三四五六七八九十百千万億兆京]+)([kKmMbBtT])?\\s*(?:円|(?:[yY][eE][nN]\\b)))/;\n\nexport function extractCurrencyMetadata(\n  text: string\n): CurrencyMeta | undefined {\n  const matches = currencyRegex.exec(text);\n  if (!matches || matches.index !== 0) {\n    return undefined;\n  }\n\n  const valueStr = matches[2] ?? matches[5];\n\n  if (!valueStr) {\n    return undefined;\n  }\n\n  let value = parseNumber(valueStr);\n  if (value === null) {\n    return undefined;\n  }\n\n  // Handle metric suffixes---we handle them here instead of in parseNumber\n  // because we only support them when they are part of a currency.\n  const metricSuffix = matches[2] ? matches[3] : matches[6];\n  switch (metricSuffix) {\n    case 'k':\n    case 'K':\n      value *= 1_000;\n      break;\n    case 'm':\n    case 'M':\n      value *= 1_000_000;\n      break;\n    case 'b':\n    case 'B':\n      value *= 1_000_000_000;\n      break;\n    case 't':\n    case 'T':\n      value *= 1_000_000_000_000;\n      break;\n  }\n\n  return { type: 'currency', value, matchLen: matches[0].length };\n}\n","import {\n  getCombinedCharRange,\n  getNegatedCharRange,\n  startsWithDigit,\n  startsWithNumeral,\n} from '../utils/char-range';\n\nimport { parseNumber } from './numbers';\n\nexport function lookForMeasure({\n  nodeText,\n  textDelimiter: originalTextDelimiter,\n}: {\n  nodeText: string;\n  textDelimiter: RegExp;\n}): {\n  textDelimiter: RegExp;\n  textEnd: number;\n} | null {\n  if (!startsWithNumeral(nodeText)) {\n    return null;\n  }\n\n  const includeSeparators = startsWithDigit(nodeText);\n  const japaneseOrUnit = getCombinedCharRange([\n    getNegatedCharRange(originalTextDelimiter),\n    includeSeparators ? /[\\sm2㎡²,、.．]/ : /[\\sm2㎡²]/,\n  ]);\n  const textDelimiter = getNegatedCharRange(japaneseOrUnit);\n\n  return {\n    textDelimiter,\n    textEnd: nodeText.search(textDelimiter),\n  };\n}\n\nexport type MeasureMeta = {\n  type: 'measure';\n  unit: '帖' | '畳' | 'm2' | 'sq ft';\n  value: number;\n  matchLen: number;\n};\n\nconst jouRegex = /([0-9.０-９。．〇一二三四五六七八九十百]+)\\s*(畳|帖)(半?)/;\nconst squareMeterRegex =\n  /([0-9.０-９。．〇一二三四五六七八九十百千万]+)\\s*(㎡|(?:m2)|(?:m²)|(?:平方メートル)|(?:平方ﾒｰﾄﾙ)|(?:平方㍍)|(?:平㍍)|(?:平米)|(?:平方米))/;\n\nexport function extractMeasureMetadata(text: string): MeasureMeta | undefined {\n  let type: 'jou' | 'm2';\n\n  // Try either of our regexs\n  let matches = jouRegex.exec(text);\n  if (matches && matches.index === 0 && matches.length === 4) {\n    type = 'jou';\n  } else {\n    matches = squareMeterRegex.exec(text);\n    if (!matches || matches.index !== 0 || matches.length !== 3) {\n      return undefined;\n    }\n    type = 'm2';\n  }\n\n  // Parse value\n  if (typeof matches[1] !== 'string') {\n    return undefined;\n  }\n\n  const valueStr = matches[1];\n  let value = parseNumber(valueStr);\n\n  if (value === null) {\n    return undefined;\n  }\n\n  // Parse unit\n  let unit: MeasureMeta['unit'];\n  if (type === 'jou') {\n    if (matches[2] !== '畳' && matches[2] !== '帖') {\n      return undefined;\n    }\n    unit = matches[2];\n  } else {\n    unit = type;\n  }\n\n  // Add final 半\n  if (type === 'jou' && matches[3] === '半') {\n    value += 0.5;\n  }\n\n  return {\n    type: 'measure',\n    unit,\n    value,\n    matchLen: matches[0].length,\n  };\n}\n\nexport type ConvertedMeasure = {\n  unit: '帖' | '畳' | 'm2' | 'sq ft';\n  value: number;\n  alt?: Array<AlternateMeasure>;\n};\n\nexport type AlternateMeasure = {\n  type: 'kyouma' | 'chuukyouma' | 'edoma' | 'danchima';\n  label?: string;\n  unit: '畳' | 'm2' | 'sq ft';\n  value: number;\n};\n\nconst alternateJouSizes: Array<{\n  type: AlternateMeasure['type'];\n  label: string;\n  ratio: number;\n}> = [\n  { type: 'kyouma', label: '京間', ratio: 1.82405 },\n  { type: 'chuukyouma', label: '中京間', ratio: 1.6562 },\n  { type: 'edoma', label: '江戸間', ratio: 1.5488 },\n  { type: 'danchima', label: '団地間', ratio: 1.445 },\n];\n\nexport function convertMeasure(\n  measure: MeasureMeta,\n  preferredUnits: 'metric' | 'imperial'\n): ConvertedMeasure {\n  if (measure.unit === 'm2') {\n    return {\n      unit: '帖',\n      value: measure.value / 1.62,\n      alt: alternateJouSizes.map((size) => ({\n        type: size.type,\n        label: size.label,\n        unit: '畳',\n        value: measure.value / size.ratio,\n      })),\n    };\n  }\n\n  const m2Conversion: ConvertedMeasure = {\n    unit: 'm2',\n    value: measure.value * 1.62,\n    alt:\n      // Only show alternative sizes of the unit is 畳. If it's 帖 it\n      // means 1.62m2.\n      measure.unit === '畳'\n        ? alternateJouSizes.map((size) => ({\n            type: size.type,\n            label: size.label,\n            unit: 'm2',\n            value: measure.value * size.ratio,\n          }))\n        : undefined,\n  };\n\n  // Since feet are defined in terms of meters,\n  // we can do the conversion from the metric one.\n  if (preferredUnits === 'imperial') {\n    const m2f = 10.763915;\n    return {\n      unit: 'sq ft',\n      value: m2Conversion.value * m2f,\n      alt: m2Conversion.alt\n        ? m2Conversion.alt.map(({ type, label, value }) => ({\n            type,\n            label,\n            unit: 'sq ft',\n            value: value * m2f,\n          }))\n        : undefined,\n    };\n  }\n\n  return m2Conversion;\n}\n","import { getCombinedCharRange, getNegatedCharRange } from '../utils/char-range';\n\nimport { parseNumber } from './numbers';\n\n// ---------------------------------------------------------------------------\n//\n// Data types\n//\n// ---------------------------------------------------------------------------\n\n// It feels a little imperialist to force these values into a more Western\n// notation but by doing so we hope it's easier to map to localization keys\n//\n// (Safari in particular will probably have trouble with full-width string\n// keys--it already has enough trouble with case sensitive keys.)\n\nexport type ShogiSideType = 'black' | 'white';\n\n// If the third member of the tuple is defined, it indicates that the position\n// is specified AND marked as being the same as the last move (e.g. ☖２四同歩).\nexport type ShogiDestType = [number, number] | [number, number, 1];\n\nexport type ShogiPieceType =\n  | 'p'\n  | 'l'\n  | 'n'\n  | 's'\n  | 'b'\n  | 'r'\n  | 'g'\n  | 'pro_p'\n  | 'pro_l'\n  | 'pro_n'\n  | 'pro_s'\n  | 'pro_b'\n  | 'pro_r'\n  | 'k';\n\nexport type ShogiMovementType =\n  | 'drop'\n  | 'down'\n  | 'horiz'\n  | 'up'\n  | 'right'\n  | 'left'\n  | 'vert';\n\nexport type ShogiMeta = {\n  type: 'shogi';\n  matchLen: number;\n  side?: ShogiSideType;\n  // An undefined destination indicates that destination is the same as the\n  // position of the last move. (If the position is specified AND marked as\n  // being the same as the last move, e.g. ☖２四同歩, then a 3 element tuple\n  // is used, with the last element being set to 1.)\n  dest?: ShogiDestType;\n  piece: ShogiPieceType;\n  movement?: ShogiMovementType;\n  promotion?: boolean;\n};\n\n// ---------------------------------------------------------------------------\n//\n// Parsing\n//\n// ---------------------------------------------------------------------------\n\nexport function lookForShogi({\n  nodeText,\n  textDelimiter: originalTextDelimiter,\n}: {\n  nodeText: string;\n  textDelimiter: RegExp;\n}): {\n  textDelimiter: RegExp;\n  textEnd: number;\n} | null {\n  if (!nodeText.length) {\n    return null;\n  }\n\n  // If the test starts with one of the shogi side indicators, then we assume\n  // that the text is a shogi move and we can use the shogi delimiter.\n  if (['▲', '△', '☗', '☖'].includes(nodeText[0])) {\n    return {\n      textDelimiter: shogiDelimiter,\n      textEnd: nodeText.search(shogiDelimiter),\n    };\n  }\n\n  // Otherwise, if it starts with an Arabic number followed by a kanji number\n  // OR it starts with one of the characters meaning \"same position\" then\n  // expand the delimiter range to include all the shogi characters.\n  if (!unprefixedShogiStart.test(nodeText)) {\n    return null;\n  }\n\n  const expandedDelimiter = getCombinedCharRange([\n    getNegatedCharRange(originalTextDelimiter),\n    /[↑]/,\n    // All the other characters such as 𠔼丶フゝ・○ etc. should already be\n    // covered by `japaneseChar` so we don't need to add them here.\n  ]);\n  const textDelimiter = getNegatedCharRange(expandedDelimiter);\n\n  return {\n    textDelimiter,\n    textEnd: nodeText.search(textDelimiter),\n  };\n}\n\n// This needs to be kept in sync with the regexes below.\nconst shogiDelimiter =\n  /[^▲△☗☖1-9１-９一二三四五六七八九同仝－𠔼ド歩兵丶フゝ・香禾キ↑桂土銀ヨ角ク飛ヒ乙金人と成ナ馬マウ龍竜立リ玉王○打引寄上行入右左直行入不生]/u;\nconst unprefixedShogiStart = /^[1-9１-９][一二三四五六七八九]|[同仝－𠔼ド]/u;\n\n// Based on https://devurandom.xyz/shogi_parser.html by @devurandom\n// which in turn is based on the description at\n// https://en.wikipedia.org/wiki/Shogi_notation#Japanese_notation\nconst shogiRegex =\n  /([▲△☗☖])([1-9１-９一二三四五六七八九][1-9１-９一二三四五六七八九][同仝－𠔼ド]?|[同仝－𠔼ド])(歩|兵|丶|フ|ゝ|・|香|禾|キ|↑|桂|土|銀|ヨ|角|ク|飛|ヒ|乙|金|人|と|成香|成禾|成キ|成↑|ナ香|ナ禾|ナキ|ナ↑|成桂|成土|ナ桂|ナ土|成銀|成ヨ|ナ銀|ナヨ|馬|マ|ウ|龍|竜|立|リ|玉|王|○)([打引寄上行入右左直行入]?)(成|ナ|不成|生|フナ|不ナ)?/u;\nconst shogiWithoutPrefixRegex =\n  /([1-9１-９][一二三四五六七八九][同仝－𠔼ド]?|[同仝－𠔼ド])(歩|兵|丶|フ|ゝ|・|香|禾|キ|↑|桂|土|銀|ヨ|角|ク|飛|ヒ|乙|金|人|と|成香|成禾|成キ|成↑|ナ香|ナ禾|ナキ|ナ↑|成桂|成土|ナ桂|ナ土|成銀|成ヨ|ナ銀|ナヨ|馬|マ|ウ|龍|竜|立|リ|玉|王|○)([打引寄上行入右左直行入]?)(成|ナ|不成|生|フナ|不ナ)?/u;\n\nconst sides = new Map<string, ShogiSideType>([\n  ['▲', 'black'],\n  ['△', 'white'],\n  ['☗', 'black'],\n  ['☖', 'white'],\n]);\n\nconst sameDest = new Set(['同', '仝', '－', '𠔼', 'ド']);\n\nconst pieces = new Map<string, ShogiPieceType>([\n  ['歩', 'p'],\n  ['兵', 'p'],\n  ['丶', 'p'], // shorthand\n  ['フ', 'p'], // shorthand\n  ['ゝ', 'p'], // shorthand\n  ['・', 'p'], // shorthand\n  ['香', 'l'],\n  ['禾', 'l'], // shorthand\n  ['キ', 'l'], // shorthand\n  ['↑', 'l'], // shorthand\n  ['桂', 'n'],\n  ['土', 'n'], // shorthand\n  ['銀', 's'],\n  ['ヨ', 's'], // shorthand\n  ['角', 'b'],\n  ['ク', 'b'], // shorthand\n  ['飛', 'r'],\n  ['ヒ', 'r'], // shorthand\n  ['乙', 'r'], // shorthand\n  ['金', 'g'],\n  ['人', 'g'], // shorthand\n  ['と', 'pro_p'],\n  ['成香', 'pro_l'],\n  ['成禾', 'pro_l'], // shorthand\n  ['成キ', 'pro_l'], // shorthand\n  ['成↑', 'pro_l'], // shorthand\n  ['ナ香', 'pro_l'], // shorthand\n  ['ナ禾', 'pro_l'], // shorthand\n  ['ナキ', 'pro_l'], // shorthand\n  ['ナ↑', 'pro_l'], // shorthand\n  ['成桂', 'pro_n'],\n  ['成土', 'pro_n'], // shorthand\n  ['ナ桂', 'pro_n'], // shorthand\n  ['ナ土', 'pro_n'], // shorthand\n  ['成銀', 'pro_s'],\n  ['成ヨ', 'pro_s'], // shorthand\n  ['ナ銀', 'pro_s'], // shorthand\n  ['ナヨ', 'pro_s'], // shorthand\n  ['馬', 'pro_b'],\n  ['マ', 'pro_b'], // shorthand\n  ['ウ', 'pro_b'], // shorthand\n  ['龍', 'pro_r'],\n  ['竜', 'pro_r'],\n  ['立', 'pro_r'], // shorthand\n  ['リ', 'pro_r'], // shorthand\n  ['玉', 'k'],\n  ['王', 'k'],\n  ['○', 'k'], // shorthand\n]);\n\nconst movements = new Map<string, ShogiMovementType>([\n  ['打', 'drop'],\n  ['引', 'down'],\n  ['寄', 'horiz'],\n  ['上', 'up'],\n  ['行', 'up'],\n  ['入', 'up'],\n  ['右', 'right'],\n  ['左', 'left'],\n  ['直', 'vert'],\n]);\n\nconst promotions = new Set(['成', 'ナ']);\nconst nonPromotions = new Set(['不成', '生', 'フナ', '不ナ']);\n\nexport function extractShogiMetadata(text: string): ShogiMeta | undefined {\n  let matches = shogiRegex.exec(text);\n  if (!matches || matches.index !== 0) {\n    matches = shogiWithoutPrefixRegex.exec(text);\n    if (!matches || matches.index !== 0) {\n      return undefined;\n    }\n    // Lined up the match indices line up between the two regexes\n    matches.splice(1, 0, '');\n  }\n\n  const [src, sideStr, destStr, pieceStr, movementStr, promotionStr] = matches;\n\n  // Side\n  const side = sideStr ? sides.get(sideStr) : undefined;\n\n  // Destination\n  let dest: [number, number] | undefined;\n  if (!sameDest.has(destStr)) {\n    const parts = destStr.split('');\n    dest = parts.slice(0, 2).map(parseNumber) as [number, number];\n    // Check for a \"same\" indication (we need to check for > 2 instead of === 3\n    // because if the \"same\" character is 𠔼 the string will have length 4 since\n    // that charater is non-BMP).\n    if (parts.length > 2) {\n      dest.push(1);\n    }\n  }\n\n  // Piece\n  const piece = pieces.get(pieceStr)!;\n\n  // Movement\n  const movement = movements.get(movementStr);\n\n  // Promotion\n  let promotion: boolean | undefined;\n  if (promotions.has(promotionStr)) {\n    promotion = true;\n  } else if (nonPromotions.has(promotionStr)) {\n    promotion = false;\n  }\n\n  return {\n    type: 'shogi',\n    matchLen: src.length,\n    side,\n    dest,\n    piece,\n    movement,\n    promotion,\n  };\n}\n\n// ---------------------------------------------------------------------------\n//\n// Serialization\n//\n// ---------------------------------------------------------------------------\n\nconst standardPieceNotation: Record<ShogiPieceType, string> = {\n  p: '歩',\n  l: '香',\n  n: '桂',\n  s: '銀',\n  b: '角',\n  r: '飛',\n  g: '金',\n  pro_p: 'と',\n  pro_l: '成香',\n  pro_n: '成桂',\n  pro_s: '成銀',\n  pro_b: '馬',\n  pro_r: '龍',\n  k: '王',\n};\n\nconst standardMovementNotation: Record<ShogiMovementType, string> = {\n  drop: '打',\n  down: '引',\n  horiz: '寄',\n  up: '上',\n  right: '右',\n  left: '左',\n  vert: '直',\n};\n\nexport function serializeShogi({\n  side,\n  dest,\n  piece,\n  movement,\n  promotion,\n}: {\n  side?: ShogiSideType;\n  dest?: ShogiDestType;\n  piece: ShogiPieceType;\n  movement?: ShogiMovementType;\n  promotion?: boolean;\n}): string {\n  let result = '';\n  if (side) {\n    result += side === 'black' ? '☗' : '☖';\n  }\n\n  if (dest) {\n    result += serializeShogiDest(dest);\n  }\n  if (!dest || dest.length === 3) {\n    result += '同';\n  }\n\n  result += standardPieceNotation[piece];\n\n  if (movement) {\n    result += standardMovementNotation[movement];\n  }\n\n  if (typeof promotion === 'boolean') {\n    result += promotion ? '成' : '不成';\n  }\n\n  return result;\n}\n\nconst numberToKanji = [\n  '〇',\n  '一',\n  '二',\n  '三',\n  '四',\n  '五',\n  '六',\n  '七',\n  '八',\n  '九',\n];\n\nexport function serializeShogiDest(dest: ShogiDestType): string {\n  return `${String.fromCodePoint(dest[0] + 0xff10)}${numberToKanji[dest[1]]}`;\n}\n","import { getCombinedCharRange, getNegatedCharRange } from '../utils/char-range';\n\nimport { parseNumber } from './numbers';\n\nexport function lookForEra({\n  currentText,\n  nodeText,\n  textDelimiter: originalTextDelimiter,\n  textEnd,\n}: {\n  currentText: string;\n  nodeText: string;\n  textDelimiter: RegExp;\n  textEnd: number;\n}): {\n  textDelimiter: RegExp;\n  textEnd: number;\n} | null {\n  // We only want to _extend_ the current range so if `textEnd` is already -1\n  // (i.e. end of the text) then we don't need to do anything.\n  if (textEnd < 0 || !startsWithEraName(currentText)) {\n    return null;\n  }\n\n  // The original text delimiter should include all the characters needed to\n  // match Japanese years except spaces between the era and the year, and\n  // spaces between the year and the final 年 character, if any.\n  const japaneseOrSpace = getCombinedCharRange([\n    getNegatedCharRange(originalTextDelimiter),\n    /[\\s]/,\n  ]);\n  const textDelimiter = getNegatedCharRange(japaneseOrSpace);\n\n  const endOfEra = nodeText.substring(textEnd).search(textDelimiter);\n\n  return {\n    textDelimiter,\n    textEnd: endOfEra === -1 ? -1 : textEnd + endOfEra,\n  };\n}\n\nexport function startsWithEraName(text: string): boolean {\n  const maxEraLength = Math.max(\n    ...Array.from(yearMap.keys()).map((key) => key.length)\n  );\n\n  for (let i = 1; i <= text.length && i <= maxEraLength; i++) {\n    if (yearMap.has(text.substring(0, i))) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport type EraInfo = {\n  reading: string;\n  start: number;\n  yomi: string;\n};\n\nconst yearMap = new Map<string, EraInfo>([\n  ['大化', { reading: 'たいか', start: 645, yomi: 'Taika' }],\n  ['白雉', { reading: 'はくち', start: 650, yomi: 'Hakuchi' }],\n  ['朱鳥', { reading: 'しゅちょう', start: 686, yomi: 'Shuchō' }],\n  ['大宝', { reading: 'たいほう', start: 701, yomi: 'Taihō' }],\n  ['慶雲', { reading: 'けいうん', start: 704, yomi: 'Keiun' }],\n  ['和銅', { reading: 'わどう', start: 708, yomi: 'Wadō' }],\n  ['霊亀', { reading: 'れいき', start: 715, yomi: 'Reiki' }],\n  ['養老', { reading: 'ようろう', start: 717, yomi: 'Yōrō' }],\n  ['神亀', { reading: 'じんき', start: 724, yomi: 'Jinki' }],\n  ['天平', { reading: 'てんぴょう', start: 729, yomi: 'Tempyō' }],\n  [\n    '天平感宝',\n    { reading: 'てんぴょうかんぽう', start: 749, yomi: 'Tempyōkampō' },\n  ],\n  [\n    '天平勝宝',\n    { reading: 'てんぴょうしょうほう', start: 749, yomi: 'Tempyōshōhō' },\n  ],\n  [\n    '天平宝字',\n    { reading: 'てんぴょうじょうじ', start: 757, yomi: 'Tempyōjōji' },\n  ],\n  [\n    '天平神護',\n    { reading: 'てんぴょうじんご', start: 765, yomi: 'Tempyōjingo' },\n  ],\n  ['神護景雲', { reading: 'じんごけいうん', start: 767, yomi: 'Jingokeiun' }],\n  ['宝亀', { reading: 'ほうき', start: 770, yomi: 'Hōki' }],\n  ['天応', { reading: 'てんおう', start: 781, yomi: \"Ten'ō\" }],\n  ['延暦', { reading: 'えんりゃく', start: 782, yomi: 'Enryaku' }],\n  ['大同', { reading: 'だいどう', start: 806, yomi: 'Daidō' }],\n  ['弘仁', { reading: 'こうにん', start: 810, yomi: 'Kōnin' }],\n  ['天長', { reading: 'てんちょう', start: 823, yomi: 'Tenchō' }],\n  ['承和', { reading: 'じょうわ', start: 834, yomi: 'Jōwa' }],\n  ['嘉祥', { reading: 'かしょう', start: 848, yomi: 'Kashō' }],\n  ['仁寿', { reading: 'にんじゅ', start: 851, yomi: 'Ninju' }],\n  ['斉衡', { reading: 'さいこう', start: 855, yomi: 'Saikō' }],\n  ['天安', { reading: 'てんあん', start: 857, yomi: \"Ten'an\" }],\n  ['貞観', { reading: 'じょうがん', start: 859, yomi: 'Jōgan' }],\n  ['元慶', { reading: 'がんぎょう', start: 877, yomi: 'Gangyō' }],\n  ['仁和', { reading: 'にんな', start: 885, yomi: 'Ninna' }],\n  ['寛平', { reading: 'かんぴょう', start: 889, yomi: 'Kampyō' }],\n  ['昌泰', { reading: 'しょうたい', start: 898, yomi: 'Shōtai' }],\n  ['延喜', { reading: 'えんぎ', start: 901, yomi: 'Engi' }],\n  ['延長', { reading: 'えんちょう', start: 923, yomi: 'Enchō' }],\n  ['承平', { reading: 'じょうへい', start: 931, yomi: 'Jōhei' }],\n  ['天慶', { reading: 'てんぎょう', start: 938, yomi: 'Tengyō' }],\n  ['天暦', { reading: 'てんりゃく', start: 947, yomi: 'Tenryaku' }],\n  ['天徳', { reading: 'てんとく', start: 957, yomi: 'Tentoku' }],\n  ['応和', { reading: 'おうわ', start: 961, yomi: 'Ōwa' }],\n  ['康保', { reading: 'こうほう', start: 964, yomi: 'Kōhō' }],\n  ['安和', { reading: 'あんな', start: 968, yomi: 'Anna' }],\n  ['天禄', { reading: 'てんろく', start: 970, yomi: 'Tenroku' }],\n  ['天延', { reading: 'てんえん', start: 974, yomi: \"Ten'en\" }],\n  ['貞元', { reading: 'じょうげん', start: 976, yomi: 'Jōgen' }],\n  ['天元', { reading: 'てんげん', start: 979, yomi: 'Tengen' }],\n  ['永観', { reading: 'えいかん', start: 983, yomi: 'Eikan' }],\n  ['寛和', { reading: 'かんな', start: 985, yomi: 'Kanna' }],\n  ['永延', { reading: 'えいえん', start: 987, yomi: 'Eien' }],\n  ['永祚', { reading: 'えいそ', start: 989, yomi: 'Eiso' }],\n  ['正暦', { reading: 'しょうりゃく', start: 990, yomi: 'Shōryaku' }],\n  ['長徳', { reading: 'ちょうとく', start: 995, yomi: 'Chōtoku' }],\n  ['長保', { reading: 'ちょうほう', start: 999, yomi: 'Chōhō' }],\n  ['寛弘', { reading: 'かんこう', start: 1004, yomi: 'Kankō' }],\n  ['長和', { reading: 'ちょうわ', start: 1013, yomi: 'Chōwa' }],\n  ['寛仁', { reading: 'かんにん', start: 1017, yomi: 'Kannin' }],\n  ['治安', { reading: 'じあん', start: 1021, yomi: 'Jian' }],\n  ['万寿', { reading: 'まんじゅ', start: 1024, yomi: 'Manju' }],\n  ['長元', { reading: 'ちょうげん', start: 1028, yomi: 'Chōgen' }],\n  ['長暦', { reading: 'ちょうりゃく', start: 1037, yomi: 'Chōryaku' }],\n  ['長久', { reading: 'ちょうきゅう', start: 1040, yomi: 'Chōkyū' }],\n  ['寛徳', { reading: 'かんとく', start: 1045, yomi: 'Kantoku' }],\n  ['永承', { reading: 'えいしょう', start: 1046, yomi: 'Eishō' }],\n  ['天喜', { reading: 'てんぎ', start: 1053, yomi: 'Tengi' }],\n  ['康平', { reading: 'こうへい', start: 1058, yomi: 'Kōhei' }],\n  ['治暦', { reading: 'じりゃく', start: 1065, yomi: 'Jiryaku' }],\n  ['延久', { reading: 'えんきゅう', start: 1069, yomi: 'Enkyū' }],\n  ['承保', { reading: 'じょうほう', start: 1074, yomi: 'Jōhō' }],\n  ['承暦', { reading: 'じょうりゃく', start: 1078, yomi: 'Jōryaku' }],\n  ['永保', { reading: 'えいほう', start: 1081, yomi: 'Eihō' }],\n  ['応徳', { reading: 'おうとく', start: 1084, yomi: 'Ōtoku' }],\n  ['寛治', { reading: 'かんじ', start: 1087, yomi: 'Kanji' }],\n  ['嘉保', { reading: 'かほう', start: 1095, yomi: 'Kahō' }],\n  ['永長', { reading: 'えいちょう', start: 1097, yomi: 'Eichō' }],\n  ['承徳', { reading: 'じょうとく', start: 1098, yomi: 'Jōtoku' }],\n  ['康和', { reading: 'こうわ', start: 1099, yomi: 'Kōwa' }],\n  ['長治', { reading: 'ちょうじ', start: 1104, yomi: 'Chōji' }],\n  ['嘉承', { reading: 'かじょう', start: 1106, yomi: 'Kajō' }],\n  ['天仁', { reading: 'てんにん', start: 1108, yomi: 'Tennin' }],\n  ['天永', { reading: 'てんねい', start: 1110, yomi: 'Tennei' }],\n  ['永久', { reading: 'えいきゅう', start: 1113, yomi: 'Eikyū' }],\n  ['元永', { reading: 'げんえい', start: 1118, yomi: \"Gen'ei\" }],\n  ['保安', { reading: 'ほうあん', start: 1120, yomi: 'Hōan' }],\n  ['天治', { reading: 'てんじ', start: 1124, yomi: 'Tenji' }],\n  ['大治', { reading: 'だいじ', start: 1126, yomi: 'Daiji' }],\n  ['天承', { reading: 'てんしょう', start: 1131, yomi: 'Tenshō' }],\n  ['長承', { reading: 'ちょうしょう', start: 1132, yomi: 'Chōshō' }],\n  ['保延', { reading: 'ほうえん', start: 1135, yomi: 'Hōen' }],\n  ['永治', { reading: 'えいじ', start: 1141, yomi: 'Eiji' }],\n  ['康治', { reading: 'こうじ', start: 1142, yomi: 'Kōji' }],\n  ['天養', { reading: 'てんよう', start: 1144, yomi: \"Ten'yō\" }],\n  ['久安', { reading: 'きゅうあん', start: 1145, yomi: 'Kyūan' }],\n  ['仁平', { reading: 'にんぺい', start: 1151, yomi: 'Nimpei' }],\n  ['久寿', { reading: 'きゅうじゅ', start: 1154, yomi: 'Kyūju' }],\n  ['保元', { reading: 'ほうげん', start: 1156, yomi: 'Hōgen' }],\n  ['平治', { reading: 'へいじ', start: 1159, yomi: 'Heiji' }],\n  ['永暦', { reading: 'えいりゃく', start: 1160, yomi: 'Eiryaku' }],\n  ['応保', { reading: 'おうほう', start: 1161, yomi: 'Ōhō' }],\n  ['長寛', { reading: 'ちょうかん', start: 1163, yomi: 'Chōkan' }],\n  ['永万', { reading: 'えいまん', start: 1165, yomi: 'Eiman' }],\n  ['仁安', { reading: 'にんあん', start: 1166, yomi: \"Nin'an\" }],\n  ['嘉応', { reading: 'かおう', start: 1169, yomi: 'Kaō' }],\n  ['承安', { reading: 'しょうあん', start: 1171, yomi: 'Shōan' }],\n  ['安元', { reading: 'あんげん', start: 1175, yomi: 'Angen' }],\n  ['治承', { reading: 'じしょう', start: 1177, yomi: 'Jishō' }],\n  ['養和', { reading: 'ようわ', start: 1181, yomi: 'Yōwa' }],\n  ['寿永', { reading: 'じゅえい', start: 1182, yomi: 'Juei' }],\n  ['元暦', { reading: 'げんりゃく', start: 1184, yomi: 'Genryaku' }],\n  ['文治', { reading: 'ぶんじ', start: 1185, yomi: 'Bunji' }],\n  ['建久', { reading: 'けんきゅう', start: 1190, yomi: 'Kenkyū' }],\n  ['正治', { reading: 'しょうじ', start: 1199, yomi: 'Shōji' }],\n  ['建仁', { reading: 'けんにん', start: 1201, yomi: 'Kennin' }],\n  ['元久', { reading: 'げんきゅう', start: 1204, yomi: 'Genkyū' }],\n  ['建永', { reading: 'けんえい', start: 1206, yomi: \"Ken'ei\" }],\n  ['承元', { reading: 'じょうげん', start: 1207, yomi: 'Jōgen' }],\n  ['建暦', { reading: 'けんりゃく', start: 1211, yomi: 'Kenryaku' }],\n  ['建保', { reading: 'けんぽう', start: 1214, yomi: 'Kempō' }],\n  ['承久', { reading: 'じょうきゅう', start: 1219, yomi: 'Jōkyū' }],\n  ['貞応', { reading: 'じょうおう', start: 1222, yomi: 'Jōō' }],\n  ['元仁', { reading: 'げんにん', start: 1225, yomi: 'Gennin' }],\n  ['嘉禄', { reading: 'かろく', start: 1225, yomi: 'Karoku' }],\n  ['安貞', { reading: 'あんてい', start: 1228, yomi: 'Antei' }],\n  ['寛喜', { reading: 'かんき', start: 1229, yomi: 'Kanki' }],\n  ['貞永', { reading: 'じょうえい', start: 1232, yomi: 'Jōei' }],\n  ['天福', { reading: 'てんぷく', start: 1233, yomi: 'Tempuku' }],\n  ['文暦', { reading: 'ぶんりゃく', start: 1235, yomi: 'Bunryaku' }],\n  ['嘉禎', { reading: 'かてい', start: 1235, yomi: 'Katei' }],\n  ['暦仁', { reading: 'りゃくにん', start: 1239, yomi: 'Ryakunin' }],\n  ['延応', { reading: 'えんおう', start: 1239, yomi: \"En'ō\" }],\n  ['仁治', { reading: 'にんじ', start: 1240, yomi: 'Ninji' }],\n  ['寛元', { reading: 'かんげん', start: 1243, yomi: 'Kangen' }],\n  ['宝治', { reading: 'ほうじ', start: 1247, yomi: 'Hōji' }],\n  ['建長', { reading: 'けんちょう', start: 1249, yomi: 'Kenchō' }],\n  ['康元', { reading: 'こうげん', start: 1256, yomi: 'Kōgen' }],\n  ['正嘉', { reading: 'しょうか', start: 1257, yomi: 'Shōka' }],\n  ['正元', { reading: 'しょうげん', start: 1259, yomi: 'Shōgen' }],\n  ['文応', { reading: 'ぶんおう', start: 1260, yomi: \"Bun'ō\" }],\n  ['弘長', { reading: 'こうちょう', start: 1261, yomi: 'Kōchō' }],\n  ['文永', { reading: 'ぶんえい', start: 1264, yomi: \"Bun'ei\" }],\n  ['健治', { reading: 'けんじ', start: 1275, yomi: 'Kenji' }],\n  ['弘安', { reading: 'こうあん', start: 1278, yomi: 'Kōan' }],\n  ['正応', { reading: 'しょうおう', start: 1288, yomi: 'Shōō' }],\n  ['永仁', { reading: 'えいにん', start: 1293, yomi: 'Einin' }],\n  ['正安', { reading: 'しょうあん', start: 1299, yomi: 'Shōan' }],\n  ['乾元', { reading: 'けんげん', start: 1303, yomi: 'Kengen' }],\n  ['嘉元', { reading: 'かげん', start: 1303, yomi: 'Kagen' }],\n  ['徳治', { reading: 'とくじ', start: 1307, yomi: 'Tokuji' }],\n  ['延慶', { reading: 'えんきょう', start: 1308, yomi: 'Enkyō' }],\n  ['応長', { reading: 'おうちょう', start: 1311, yomi: 'Ōchō' }],\n  ['正和', { reading: 'しょうわ', start: 1312, yomi: 'Shōwa' }],\n  ['文保', { reading: 'ぶんぽう', start: 1317, yomi: 'Bumpō' }],\n  ['元応', { reading: 'げんおう', start: 1319, yomi: \"Gen'ō\" }],\n  ['元亨', { reading: 'げんこう', start: 1321, yomi: 'Genkō' }],\n  ['正中', { reading: 'しょうちゅ', start: 1325, yomi: 'Shōchu' }],\n  ['嘉暦', { reading: 'かりゃく', start: 1326, yomi: 'Karyaku' }],\n  ['元徳', { reading: 'げんとく', start: 1329, yomi: 'Gentoku' }],\n  ['元弘', { reading: 'げんこう', start: 1331, yomi: 'Genkō (Southern)' }],\n  ['正慶', { reading: 'しょうけい', start: 1332, yomi: 'Shōkei' }],\n  ['建武', { reading: 'けんむ', start: 1334, yomi: 'Kemmu (Southern)' }],\n  ['延元', { reading: 'えいげん', start: 1336, yomi: 'Eigen (Southern)' }],\n  ['暦応', { reading: 'りゃくおう', start: 1338, yomi: 'Ryakuō' }],\n  ['興国', { reading: 'こうこく', start: 1340, yomi: 'Kōkoku (Southern)' }],\n  ['康永', { reading: 'こうえい', start: 1342, yomi: 'Kōei' }],\n  ['貞和', { reading: 'じょうわ', start: 1345, yomi: 'Jōwa' }],\n  ['正平', { reading: 'しょうへい', start: 1347, yomi: 'Shōhei (Southern)' }],\n  ['観応', { reading: 'かんおう', start: 1350, yomi: \"Kan'ō\" }],\n  ['文和', { reading: 'ぶんな', start: 1352, yomi: 'Bunna' }],\n  ['延文', { reading: 'えんぶん', start: 1356, yomi: 'Embun' }],\n  ['康安', { reading: 'こうあん', start: 1361, yomi: 'Kōan' }],\n  ['貞治', { reading: 'じょうじ', start: 1362, yomi: 'Jōji' }],\n  ['応安', { reading: 'おうあん', start: 1368, yomi: 'Ōan' }],\n  ['建徳', { reading: 'けんとく', start: 1370, yomi: 'Kentoku (Southern)' }],\n  ['文中', { reading: 'ぶんちゅう', start: 1372, yomi: 'Bunchū (Southern)' }],\n  ['永和', { reading: 'えいわ', start: 1375, yomi: 'Eiwa' }],\n  ['天授', { reading: 'てんじゅ', start: 1375, yomi: 'Tenju (Southern)' }],\n  ['康暦', { reading: 'こうりゃく', start: 1379, yomi: 'Kōryaku' }],\n  ['永徳', { reading: 'えいとく', start: 1381, yomi: 'Eitoku' }],\n  ['弘和', { reading: 'こうわ', start: 1381, yomi: 'Kōwa (Southern)' }],\n  ['至徳', { reading: 'しとく', start: 1384, yomi: 'Shitoku' }],\n  ['元中', { reading: 'げんちゅう', start: 1384, yomi: 'Genchū (Southern)' }],\n  ['嘉慶', { reading: 'かけい', start: 1387, yomi: 'Kakei' }],\n  ['康応', { reading: 'こうおう', start: 1389, yomi: 'Kōō' }],\n  ['明徳', { reading: 'めいとく', start: 1390, yomi: 'Meitoku' }],\n  ['応永', { reading: 'おうえい', start: 1394, yomi: 'Ōei' }],\n  ['正長', { reading: 'しょうちょう', start: 1428, yomi: 'Shōchō' }],\n  ['永享', { reading: 'えいきょう', start: 1429, yomi: 'Eikyō' }],\n  ['嘉吉', { reading: 'かきつ', start: 1441, yomi: 'Kakitsu' }],\n  ['文安', { reading: 'ぶんあん', start: 1444, yomi: \"Bun'an\" }],\n  ['宝徳', { reading: 'ほうとく', start: 1449, yomi: 'Hōtoku' }],\n  ['享徳', { reading: 'きょうとく', start: 1452, yomi: 'Kyōtoku' }],\n  ['康正', { reading: 'こうしょう', start: 1455, yomi: 'Kōshō' }],\n  ['長禄', { reading: 'ちょうろく', start: 1457, yomi: 'Chōroku' }],\n  ['寛正', { reading: 'かんしょう', start: 1461, yomi: 'Kanshō' }],\n  ['文正', { reading: 'ぶんしょう', start: 1466, yomi: 'Bunshō' }],\n  ['応仁', { reading: 'おうにん', start: 1467, yomi: 'Ōnin' }],\n  ['文明', { reading: 'ぶんめい', start: 1469, yomi: 'Bummei' }],\n  ['長享', { reading: 'ちょうきょう', start: 1487, yomi: 'Chōkyō' }],\n  ['延徳', { reading: 'えんとく', start: 1489, yomi: 'Entoku' }],\n  ['明応', { reading: 'めいおう', start: 1492, yomi: 'Meiō' }],\n  ['文亀', { reading: 'ぶんき', start: 1501, yomi: 'Bunki' }],\n  ['永正', { reading: 'えいしょう', start: 1504, yomi: 'Eishō' }],\n  ['大永', { reading: 'だいえい', start: 1521, yomi: 'Daiei' }],\n  ['享禄', { reading: 'きょうろく', start: 1528, yomi: 'Kyōroku' }],\n  ['天文', { reading: 'てんぶん', start: 1532, yomi: 'Tembun' }],\n  ['弘治', { reading: 'こうじ', start: 1555, yomi: 'Kōji' }],\n  ['永禄', { reading: 'えいろく', start: 1558, yomi: 'Eiroku' }],\n  ['元亀', { reading: 'げんき', start: 1570, yomi: 'Genki' }],\n  ['天正', { reading: 'てんしょう', start: 1573, yomi: 'Tenshō' }],\n  ['文禄', { reading: 'ぶんろく', start: 1593, yomi: 'Bunroku' }],\n  ['慶長', { reading: 'けいちょう', start: 1596, yomi: 'Keichō' }],\n  ['元和', { reading: 'げんな', start: 1615, yomi: 'Genna' }],\n  ['寛永', { reading: 'かんえい', start: 1624, yomi: \"Kan'ei\" }],\n  ['正保', { reading: 'しょうほう', start: 1645, yomi: 'Shōhō' }],\n  ['慶安', { reading: 'けいあん', start: 1648, yomi: 'Keian' }],\n  ['承応', { reading: 'じょうおう', start: 1652, yomi: 'Jōō' }],\n  ['明暦', { reading: 'めいれき', start: 1655, yomi: 'Meireki' }],\n  ['万治', { reading: 'まんじ', start: 1658, yomi: 'Manji' }],\n  ['寛文', { reading: 'かんぶん', start: 1661, yomi: 'Kambun' }],\n  ['延宝', { reading: 'えんぽう', start: 1673, yomi: 'Empō' }],\n  ['天和', { reading: 'てんな', start: 1681, yomi: 'Tenna' }],\n  ['貞享', { reading: 'じょうきょう', start: 1684, yomi: 'Jōkyō' }],\n  ['元禄', { reading: 'げんろく', start: 1688, yomi: 'Genroku' }],\n  ['宝永', { reading: 'ほうえい', start: 1704, yomi: 'Hōei' }],\n  ['正徳', { reading: 'しょうとく', start: 1711, yomi: 'Shōtoku' }],\n  ['享保', { reading: 'きょうほう', start: 1716, yomi: 'Kyōhō' }],\n  ['元文', { reading: 'げんぶん', start: 1736, yomi: 'Gembun' }],\n  ['寛保', { reading: 'かんぽう', start: 1741, yomi: 'Kampō' }],\n  ['延享', { reading: 'えんきょう', start: 1744, yomi: 'Enkyō' }],\n  ['寛延', { reading: 'かんえん', start: 1748, yomi: \"Kan'en\" }],\n  ['宝暦', { reading: 'ほうれき', start: 1751, yomi: 'Hōreki' }],\n  ['明和', { reading: 'めいわ', start: 1764, yomi: 'Meiwa' }],\n  ['安永', { reading: 'あんえい', start: 1773, yomi: \"An'ei\" }],\n  ['天明', { reading: 'てんめい', start: 1781, yomi: 'Temmei' }],\n  ['寛政', { reading: 'かんせい', start: 1801, yomi: 'Kansei' }],\n  ['享和', { reading: 'きょうわ', start: 1802, yomi: 'Kyōwa' }],\n  ['文化', { reading: 'ぶんか', start: 1804, yomi: 'Bunka' }],\n  ['文政', { reading: 'ぶんせい', start: 1818, yomi: 'Bunsei' }],\n  ['天保', { reading: 'てんぽう', start: 1831, yomi: 'Tempō' }],\n  ['弘化', { reading: 'こうか', start: 1845, yomi: 'Kōka' }],\n  ['嘉永', { reading: 'かえい', start: 1848, yomi: 'Kaei' }],\n  ['安政', { reading: 'あんせい', start: 1855, yomi: 'Ansei' }],\n  ['万延', { reading: 'まんえい', start: 1860, yomi: \"Man'ei\" }],\n  ['文久', { reading: 'ぶんきゅう', start: 1861, yomi: 'Bunkyū' }],\n  ['元治', { reading: 'げんじ', start: 1864, yomi: 'Genji' }],\n  ['慶応', { reading: 'けいおう', start: 1865, yomi: 'Keiō' }],\n  ['明治', { reading: 'めいじ', start: 1868, yomi: 'Meiji' }],\n  ['㍾', { reading: 'めいじ', start: 1868, yomi: 'Meiji' }],\n  ['大正', { reading: 'たいしょう', start: 1912, yomi: 'Taishō' }],\n  ['㍽', { reading: 'たいしょう', start: 1912, yomi: 'Taishō' }],\n  ['昭和', { reading: 'しょうわ', start: 1926, yomi: 'Shōwa' }],\n  ['㍼', { reading: 'しょうわ', start: 1926, yomi: 'Shōwa' }],\n  ['平成', { reading: 'へいせい', start: 1989, yomi: 'Heisei' }],\n  ['㍻', { reading: 'へいせい', start: 1989, yomi: 'Heisei' }],\n  ['令和', { reading: 'れいわ', start: 2019, yomi: 'Reiwa' }],\n  ['㋿', { reading: 'れいわ', start: 2019, yomi: 'Reiwa' }],\n]);\n\nexport type EraMeta = {\n  type: 'era';\n  era: string;\n  // 0 here represents that the matched text used 元年 (equivalent to 1 but we\n  // might want to display it differently).\n  year: number;\n  // The length of the text that matched\n  matchLen: number;\n};\n\n// This is a bit complicated because for a numeric year we don't require the\n// 年 but for 元年 we do. i.e. '令和2' is valid but '令和元' is not.\nconst yearRegex = /(?:([0-9０-９〇一二三四五六七八九十百]+)\\s*年?|(?:元\\s*年))/;\n\nexport function extractEraMetadata(text: string): EraMeta | undefined {\n  // Look for a year\n  const matches = yearRegex.exec(text);\n  if (!matches || matches.index === 0) {\n    return undefined;\n  }\n\n  // Look for an era\n  const era = text.substring(0, matches.index).trim();\n  if (!isEraName(era)) {\n    return undefined;\n  }\n\n  // Parse year\n  let year: number | null = 0;\n  if (typeof matches[1] !== 'undefined') {\n    year = parseNumber(matches[1]);\n    if (typeof year === 'number' && year < 1) {\n      year = null;\n    }\n  }\n\n  if (year === null) {\n    return undefined;\n  }\n\n  const matchLen = matches.index + matches[0].length;\n\n  return { type: 'era', era, year, matchLen };\n}\n\nfunction isEraName(text: string): boolean {\n  return yearMap.has(text);\n}\n\nexport function getEraInfo(text: string): EraInfo | undefined {\n  return yearMap.get(text);\n}\n","import {\n  CurrencyMeta,\n  extractCurrencyMetadata,\n  lookForCurrency,\n} from './currency';\nimport { MeasureMeta, extractMeasureMetadata, lookForMeasure } from './measure';\nimport { NumberMeta, extractNumberMetadata } from './numbers';\nimport { ShogiMeta, extractShogiMetadata, lookForShogi } from './shogi';\nimport { EraMeta, extractEraMetadata, lookForEra } from './years';\n\nexport type SelectionMeta =\n  | CurrencyMeta\n  | EraMeta\n  | MeasureMeta\n  | NumberMeta\n  | ShogiMeta;\n\nexport function lookForMetadata({\n  currentText,\n  nodeText,\n  matchCurrency,\n  textEnd,\n  textDelimiter,\n}: {\n  currentText: string;\n  nodeText: string;\n  matchCurrency: boolean;\n  textEnd: number;\n  textDelimiter: RegExp;\n}): {\n  textDelimiter: RegExp;\n  textEnd: number;\n} {\n  return (\n    (matchCurrency\n      ? lookForCurrency({ currentText, nodeText, textDelimiter })\n      : undefined) ||\n    lookForEra({ currentText, nodeText, textEnd, textDelimiter }) ||\n    lookForShogi({ nodeText, textDelimiter }) ||\n    lookForMeasure({ nodeText, textDelimiter }) || {\n      textDelimiter,\n      textEnd,\n    }\n  );\n}\n\nexport function extractGetTextMetadata({\n  text,\n  matchCurrency,\n}: {\n  text: string;\n  matchCurrency: boolean;\n}): SelectionMeta | undefined {\n  return (\n    (matchCurrency ? extractCurrencyMetadata(text) : undefined) ||\n    extractEraMetadata(text) ||\n    extractShogiMetadata(text) ||\n    extractMeasureMetadata(text) ||\n    extractNumberMetadata(text)\n  );\n}\n","import { nonJapaneseChar } from '../utils/char-range';\n\nimport { CursorPosition } from './get-cursor-position';\nimport { GetTextAtPointResult } from './get-text';\nimport { extractGetTextMetadata, lookForMetadata } from './meta';\n\nexport function scanText({\n  startPosition,\n  matchCurrency,\n  maxLength,\n}: {\n  startPosition: CursorPosition<Text>;\n  matchCurrency: boolean;\n  maxLength?: number;\n}): GetTextAtPointResult | null {\n  const { offsetNode: startNode, offset: startOffset } = startPosition;\n\n  // Get the ancestor node for all inline nodes\n  let inlineAncestor = startNode.parentElement;\n  while (isInline(inlineAncestor) && !isRubyAnnotationElement(inlineAncestor)) {\n    inlineAncestor = inlineAncestor!.parentElement;\n  }\n\n  // Skip ruby annotation elements when traversing. However, don't do that\n  // if the inline ancestor is itself a ruby annotation element or else\n  // we'll never be able to find the starting point within the tree walker.\n  let filter: NodeFilter | undefined;\n  if (!isRubyAnnotationElement(inlineAncestor)) {\n    filter = {\n      acceptNode: (node) =>\n        node.parentElement?.closest('rp, rt')\n          ? NodeFilter.FILTER_REJECT\n          : NodeFilter.FILTER_ACCEPT,\n    };\n  }\n\n  // Setup a treewalker starting at the current node\n  const treeWalker = document.createNodeIterator(\n    inlineAncestor || startNode,\n    NodeFilter.SHOW_TEXT,\n    filter\n  );\n\n  /* eslint-disable curly */\n  while (treeWalker.referenceNode !== startNode && treeWalker.nextNode());\n\n  if (treeWalker.referenceNode !== startNode) {\n    console.error('Could not find node in tree', startNode);\n    return null;\n  }\n\n  // Look for start, skipping any initial whitespace\n  let node = startNode;\n  let offset = startOffset;\n  do {\n    const nodeText = node.data.substring(offset);\n    const textStart = nodeText.search(/\\S/);\n    if (textStart !== -1) {\n      offset += textStart;\n      break;\n    }\n    // Curiously with our synthesized text nodes, the next node can sometimes\n    // be the same node. We only tend to reach that case, however, when our\n    // offset corresponds to the end of the text so we just detect that case\n    // earlier on and don't bother checking it here.\n    node = treeWalker.nextNode() as Text;\n    offset = 0;\n  } while (node);\n  // (This should probably not traverse block siblings but oh well)\n\n  if (!node) {\n    return null;\n  }\n\n  const result: GetTextAtPointResult = {\n    text: '',\n    textRange: [],\n  };\n\n  let textDelimiter = nonJapaneseChar;\n\n  // Look for range ends\n  do {\n    const nodeText = node.data.substring(offset);\n    let textEnd = nodeText.search(textDelimiter);\n\n    // Check if we are looking at a special string that accepts a different\n    // range of characters.\n    if (textDelimiter === nonJapaneseChar) {\n      const currentText =\n        result.text +\n        nodeText.substring(0, textEnd === -1 ? undefined : textEnd);\n\n      // Check if we should further expand the set of allowed characters in\n      // order to recognize certain types of metadata-type strings (e.g. years\n      // or floor space measurements).\n      ({ textDelimiter, textEnd } = lookForMetadata({\n        currentText,\n        matchCurrency,\n        nodeText,\n        textDelimiter,\n        textEnd,\n      }));\n    }\n\n    if (typeof maxLength === 'number' && maxLength >= 0) {\n      const maxEnd = maxLength - result.text.length;\n      if (textEnd === -1) {\n        // The >= here is important since it means that if the node has\n        // exactly enough characters to reach the maxLength then we will\n        // stop walking the tree at this point.\n        textEnd = node.data.length - offset >= maxEnd ? maxEnd : -1;\n      } else {\n        textEnd = Math.min(textEnd, maxEnd);\n      }\n    }\n\n    if (textEnd === 0) {\n      // There are no characters here for us.\n      break;\n    } else if (textEnd !== -1) {\n      // The text node has disallowed characters mid-way through so\n      // return up to that point.\n      result.text += nodeText.substring(0, textEnd);\n      result.textRange!.push({\n        node,\n        start: offset,\n        end: offset + textEnd,\n      });\n      break;\n    }\n\n    // The whole text node is allowed characters, keep going.\n    result.text += nodeText;\n    result.textRange!.push({\n      node,\n      start: offset,\n      end: node.data.length,\n    });\n    node = treeWalker.nextNode() as Text;\n    offset = 0;\n  } while (\n    node &&\n    inlineAncestor &&\n    (node.parentElement === inlineAncestor || isInline(node.parentElement))\n  );\n\n  // Check if we didn't find any suitable characters\n  if (!result.textRange!.length) {\n    return null;\n  }\n\n  result.meta = extractGetTextMetadata({ text: result.text, matchCurrency });\n\n  return result;\n}\n\nfunction isRubyAnnotationElement(element: Element | null) {\n  return element?.matches('rp, rt');\n}\n\nfunction isInline(element: Element | null) {\n  return (\n    element &&\n    // We always treat <rb> and <ruby> tags as inline regardless of the styling\n    // since sites like renshuu.org do faux-ruby styling where they give these\n    // elements styles like 'display: table-row-group'.\n    //\n    // We also make an exception for <span> because pdf.js uses\n    // absolutely-positioned (and hence `display: block`) spans to lay out\n    // characters in vertical text.\n    //\n    // Furthermore, we treat inline-block as inline because YouTube puts\n    // okurigana in a separate inline-block span when using ruby.\n    //\n    // Finally, if an element's parent is inline-block, then the element will\n    // still be laid out \"inline\" so we allow that too (and that appears to be\n    // used by Kanshudo at least).\n    //\n    // Given all these exceptions, I wonder if we should even both checking\n    // the display property.\n    (['RB', 'RUBY', 'SPAN'].includes(element.tagName) ||\n      ['inline', 'inline-block', 'ruby', 'ruby-base', 'ruby-text'].includes(\n        getComputedStyle(element).display!\n      ) ||\n      (element.parentElement &&\n        getComputedStyle(element.parentElement)?.display === 'inline-block'))\n  );\n}\n","import { Point, bboxIncludesPoint } from '../utils/geometry';\nimport {\n  getBboxForSingleCodepointRange,\n  getRangeForSingleCodepoint,\n} from '../utils/range';\n\nimport { getContentType } from './content-type';\nimport { getTextFromAnnotatedCanvas } from './gdocs-canvas';\nimport {\n  CursorPosition,\n  getCursorPosition,\n  isGdocsOverlayPosition,\n  isTextInputPosition,\n  isTextNodePosition,\n} from './get-cursor-position';\nimport { SelectionMeta } from './meta';\nimport { scanText } from './scan-text';\nimport { TextRange } from './text-range';\n\nexport type GetTextAtPointResult = {\n  text: string;\n  // Contains the set of nodes and their ranges where text was found.\n  // This will be null if, for example, the result is the text from an element's\n  // title attribute.\n  textRange: TextRange | null;\n  // Extra metadata we parsed in the process\n  meta?: SelectionMeta;\n};\n\n// Cache of previous result (since often the mouse position will change but\n// the cursor position will not).\nlet previousResult:\n  | {\n      point: Point;\n      position: CursorPosition | undefined;\n      result: GetTextAtPointResult;\n      firstCharBbox?: DOMRect;\n    }\n  | undefined;\n\nexport function getTextAtPoint({\n  matchCurrency = true,\n  matchText = true,\n  matchImages = true,\n  point,\n  maxLength,\n}: {\n  matchCurrency?: boolean;\n  matchText?: boolean;\n  matchImages?: boolean;\n  point: Point;\n  maxLength?: number;\n}): GetTextAtPointResult | null {\n  // First check for a cache hit on the glyph bounding box\n  //\n  // This will often be the case when scanning along a line of text\n  if (\n    previousResult?.firstCharBbox &&\n    bboxIncludesPoint({ bbox: previousResult.firstCharBbox, point })\n  ) {\n    return previousResult.result;\n  }\n\n  // First fetch the hit elements (dropping duplicates)\n  const elements = [...new Set(document.elementsFromPoint(point.x, point.y))];\n\n  // Look for text matches\n  const [position, scanNode] = matchText\n    ? getTextNodeStart({ elements, maxLength, point })\n    : [null, null];\n\n  // Check if we have a cache hit on the position\n  //\n  // This will mostly happen when we are working with non-text nodes (e.g. input\n  // boxes) or when the cursor is moving just outside the glyph bounds (e.g.\n  // along the top of a line).\n  if (\n    position &&\n    position.offsetNode === previousResult?.position?.offsetNode &&\n    position.offset === previousResult?.position?.offset\n  ) {\n    return previousResult.result;\n  }\n\n  const synthesizedPosition = position\n    ? {\n        offsetNode: scanNode || position.offsetNode,\n        offset: position.offset,\n      }\n    : undefined;\n\n  if (position && isTextNodePosition(synthesizedPosition)) {\n    const result = scanText({\n      startPosition: synthesizedPosition,\n      matchCurrency,\n      maxLength,\n    });\n\n    if (result) {\n      console.assert(\n        !!result.textRange,\n        'There should be a text range when getting text from a text node'\n      );\n\n      // If we synthesized a text node, substitute the original node into the\n      // result.\n      if (position.offsetNode !== synthesizedPosition.offsetNode) {\n        console.assert(\n          result.textRange?.length === 1,\n          'When using a synthesized text node there should be a single range'\n        );\n        console.assert(\n          result.textRange![0].node === scanNode,\n          'When using a synthesized text node the range should start' +\n            ' from that node'\n        );\n        result.textRange![0].node = position.offsetNode;\n      }\n\n      previousResult = {\n        point,\n        position,\n        result,\n        firstCharBbox: getFirstCharBbox(position),\n      };\n      return result;\n    }\n  }\n\n  // Otherwise just pull whatever text we can off the element\n  const elem = elements[0];\n  if (elem) {\n    const text = getTextFromRandomElement({ elem, matchImages, matchText });\n    if (text) {\n      const result = { text, textRange: null };\n      previousResult = { point, position: undefined, result };\n      return result;\n    }\n  }\n\n  // We haven't found anything, but if the cursor hasn't moved far we should\n  // just re-use the last result so the user doesn't have try to keep the\n  // mouse over the text precisely in order to read the result.\n\n  if (previousResult) {\n    const dx = previousResult.point.x - point.x;\n    const dy = previousResult.point.y - point.y;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    if (dist < 4) {\n      return previousResult.result;\n    }\n  }\n\n  previousResult = undefined;\n  return null;\n}\n\n// For unit testing\nexport function clearPreviousResult() {\n  previousResult = undefined;\n}\n\nfunction getFirstCharBbox(position: CursorPosition): DOMRect | undefined {\n  if (!isTextNodePosition(position)) {\n    return undefined;\n  }\n\n  const firstCharRange = getRangeForSingleCodepoint({\n    source: position.offsetNode,\n    offset: position.offset,\n  });\n\n  // Skip empty ranges\n  if (firstCharRange.collapsed) {\n    return undefined;\n  }\n\n  return getBboxForSingleCodepointRange(firstCharRange);\n}\n\nfunction getTextNodeStart({\n  elements,\n  maxLength,\n  point,\n}: {\n  elements: readonly Element[];\n  maxLength?: number;\n  point: Point;\n}): [position: CursorPosition, scanNode: Text | null] | [null, null] {\n  let position = getCursorPosition({ point, elements });\n\n  // If we have a textual <input> node or a <textarea> we synthesize a\n  // text node and use that for finding text since it allows us to re-use\n  // the same handling for text nodes and 'value' attributes.\n  if (isTextInputPosition(position)) {\n    if (position.offset === position.offsetNode.value.length) {\n      return [null, null];\n    }\n\n    return [position, document.createTextNode(position.offsetNode.value)];\n  }\n\n  // Similarly, if we have a Google Docs node, synthesize a node to scan.\n  if (isGdocsOverlayPosition(position)) {\n    let text = '';\n    ({ position, text } = getTextFromAnnotatedCanvas({\n      maxLength,\n      point,\n    }));\n\n    return position ? [position, document.createTextNode(text)] : [null, null];\n  }\n\n  return [position, null];\n}\n\nfunction getTextFromRandomElement({\n  elem,\n  matchImages,\n  matchText,\n}: {\n  elem: Element;\n  matchImages: boolean;\n  matchText: boolean;\n}): string | null {\n  // Don't return anything for an iframe since this script will run inside the\n  // iframe's contents as well.\n  if (elem.nodeName === 'IFRAME') {\n    return null;\n  }\n\n  // We divide the world into two types of elements: image-like elements and the\n  // rest which we presume to be \"text\" elements.\n  const isImage = getContentType(elem) === 'image';\n  if ((isImage && !matchImages) || (!isImage && !matchText)) {\n    return null;\n  }\n\n  if (hasTitleAttribute(elem) && elem.title.length) {\n    return elem.title;\n  }\n\n  if (hasAltAttribute(elem) && elem.alt.length) {\n    // Ignore the default '画像' alt text Twitter and others put on many of their\n    // images.\n    return elem.alt !== '画像' ? elem.alt : null;\n  }\n\n  if (elem.nodeName === 'OPTION') {\n    return (elem as HTMLOptionElement).text;\n  }\n\n  if (isSelectElement(elem)) {\n    return elem.options[elem.selectedIndex].text;\n  }\n\n  return null;\n}\n\nfunction hasTitleAttribute(elem: Element): elem is HTMLElement {\n  return typeof (elem as HTMLElement).title === 'string';\n}\n\nfunction hasAltAttribute(elem: Element): elem is HTMLImageElement {\n  return typeof (elem as HTMLImageElement).alt === 'string';\n}\n\nfunction isSelectElement(elem: Element): elem is HTMLSelectElement {\n  return elem.nodeName === 'SELECT';\n}\n","import browser from 'webextension-polyfill';\n\nimport { Point } from '../utils/geometry';\nimport { WithRequired } from '../utils/type-helpers';\n\nexport type IframeSearchParams = {\n  frameId?: number;\n  initialSrc?: string;\n  currentSrc?: string;\n  dimensions?: {\n    width: number;\n    height: number;\n  };\n};\n\n// As with IframeSearchParams but will a few members marked not optional\nexport type IframeSourceParams = WithRequired<\n  IframeSearchParams,\n  'frameId' | 'currentSrc' | 'dimensions'\n>;\n\nexport function findIframeElement(\n  params: IframeSearchParams\n): HTMLIFrameElement | HTMLFrameElement | undefined {\n  // First collect together all the iframes we can.\n  const iframes = getIframes(document);\n  if (!iframes.length) {\n    return undefined;\n  }\n  if (iframes.length === 1) {\n    return iframes[0];\n  }\n\n  // Look for an iframe that matches on frameId\n  if (typeof params.frameId === 'number') {\n    // Use the getFrameId API if available\n    //\n    // If it is available, we treat this as definitive since, at least in\n    // Firefox, it should work for cross-origin iframes, unlike when using the\n    // data attribute.\n    if (typeof browser.runtime.getFrameId === 'function') {\n      return iframes.find(\n        (iframe) => browser.runtime.getFrameId(iframe) === params.frameId\n      );\n    }\n\n    // Otherwise look for a frameId stored in a data attribute\n    const frameIdMatch = iframes.find(\n      (f) => f.dataset.frameId === String(params.frameId)\n    );\n    if (frameIdMatch) {\n      return frameIdMatch;\n    }\n  }\n\n  // Then try to narrow the list by matches on initialSrc or currentSrc\n  let candidates = iframes.filter(\n    (f) => f.src && (f.src === params.initialSrc || f.src === params.currentSrc)\n  );\n  if (!candidates.length) {\n    candidates = iframes;\n  }\n  if (candidates.length === 1) {\n    return candidates[0];\n  }\n\n  // We have multiple candidates, so try to sort by those with the closest\n  // dimensions.\n  if (params.dimensions) {\n    candidates.sort((a, b) => {\n      const aDimensions = getIframeDimensions(a);\n      const aDiff =\n        Math.abs(params.dimensions!.width - aDimensions.width) +\n        Math.abs(params.dimensions!.height - aDimensions.height);\n\n      const bDimensions = getIframeDimensions(b);\n      const bDiff =\n        Math.abs(params.dimensions!.width - bDimensions.width) +\n        Math.abs(params.dimensions!.height - bDimensions.height);\n\n      return aDiff - bDiff;\n    });\n  }\n\n  return candidates[0];\n}\n\nfunction getIframes(\n  doc: Document\n): Array<HTMLIFrameElement | HTMLFrameElement> {\n  const iframes = [\n    ...doc.getElementsByTagName('iframe'),\n    ...doc.getElementsByTagName('frame'),\n  ];\n\n  // For same-origin iframes, fetch their child iframe elements recursively.\n  for (const iframe of iframes) {\n    // If we try to access iframe.contentDocument and it's cross-origin,\n    // Safari will print an error to the console. In fact, even if we just use\n    // `typeof iframe.contentDocument` it will print the same message.\n    //\n    // Inspecting the contentWindow doesn't seem to provide any clues either.\n    //\n    // However, if we try to access `iframe.contentWindow.frameElement` it\n    // will throw a SecurityError which we can detect and it won't print\n    // anything to the console.\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n      iframe.contentWindow?.frameElement;\n    } catch {\n      continue;\n    }\n\n    if (iframe.contentDocument) {\n      iframes.push(...getIframes(iframe.contentDocument));\n    }\n  }\n\n  return iframes;\n}\n\nfunction getIframeDimensions(elem: HTMLIFrameElement | HTMLFrameElement): {\n  width: number;\n  height: number;\n} {\n  // In order to get dimensions that will correspond with the innerHeight /\n  // innerWidth that the iframe sees on its document element we should use the\n  // offsetWidth / offsetHeight and subtract and borders and padding.\n  const cs = getComputedStyle(elem);\n  const width =\n    elem.offsetWidth -\n    parseFloat(cs.paddingLeft) -\n    parseFloat(cs.paddingRight) -\n    parseFloat(cs.borderLeftWidth) -\n    parseFloat(cs.borderRightWidth);\n  const height =\n    elem.offsetHeight -\n    parseFloat(cs.paddingTop) -\n    parseFloat(cs.paddingBottom) -\n    parseFloat(cs.borderTopWidth) -\n    parseFloat(cs.borderBottomWidth);\n\n  return { width, height };\n}\n\nlet cachedOrigin:\n  | {\n      iframe: HTMLIFrameElement | HTMLFrameElement;\n      origin: Point;\n      resizeObserver: ResizeObserver;\n    }\n  | undefined;\n\nexport function getIframeOrigin(\n  iframeElement: HTMLIFrameElement | HTMLFrameElement\n): Point {\n  if (cachedOrigin?.iframe === iframeElement) {\n    return cachedOrigin.origin;\n  } else if (cachedOrigin) {\n    cachedOrigin.resizeObserver.disconnect();\n    cachedOrigin = undefined;\n  }\n\n  const resizeObserver = new ResizeObserver(() => {\n    cachedOrigin = undefined;\n    resizeObserver.disconnect();\n  });\n\n  let x = 0;\n  let y = 0;\n\n  let currentIframe: HTMLIFrameElement | HTMLFrameElement | null =\n    iframeElement;\n  let iterationCount = 0;\n  while (currentIframe && iterationCount < 20) {\n    // I don't _think_ you can ever have circular references of iframes but just\n    // in case, we'll limit the number of iterations.\n    iterationCount++;\n\n    let { left: currentX, top: currentY } =\n      currentIframe.getBoundingClientRect();\n\n    // The bounding client rect includes the element and its borders and padding.\n    // However, the coordinates within the iframe are minus the borders and\n    // padding.\n    //\n    // Note that if these values change, the ResizeObserver _should_ fire because\n    // it is supposed to fire when either the iframe's border box _or_ content box\n    // size changes.\n    const cs = getComputedStyle(currentIframe);\n    currentX += parseFloat(cs.borderLeftWidth);\n    currentY += parseFloat(cs.paddingLeft);\n    currentX += parseFloat(cs.borderTopWidth);\n    currentY += parseFloat(cs.paddingTop);\n\n    x += currentX;\n    y += currentY;\n\n    resizeObserver.observe(currentIframe);\n\n    // See if there are parent iframes we need to account for.\n    try {\n      const parentIframe: Element | null | undefined =\n        currentIframe.ownerDocument.defaultView?.frameElement;\n      if (\n        parentIframe instanceof HTMLIFrameElement ||\n        parentIframe instanceof HTMLFrameElement\n      ) {\n        currentIframe = parentIframe;\n      } else {\n        currentIframe = null;\n      }\n    } catch {\n      currentIframe = null;\n    }\n  }\n\n  cachedOrigin = {\n    iframe: iframeElement,\n    origin: { x, y },\n    resizeObserver,\n  };\n\n  return cachedOrigin.origin;\n}\n\n// Called from within an iframe, returns the window dimensions using a size that\n// should match the size we expect when expecting the <iframe> element from its\n// parent.\nexport function getWindowDimensions(): { width: number; height: number } {\n  if (document.compatMode === 'BackCompat') {\n    return {\n      width: document.body?.clientWidth ?? window.innerWidth,\n      height: document.body?.clientHeight ?? window.innerHeight,\n    };\n  } else {\n    return {\n      width: window.innerWidth,\n      height: window.innerHeight,\n    };\n  }\n}\n","export function normalizeKey(key: string): string {\n  const upperKey = key.toUpperCase();\n  switch (upperKey) {\n    case 'ESCAPE':\n      return 'ESC';\n\n    case 'CONTROL':\n      return 'CTRL';\n\n    case ' ':\n      return 'SPACE';\n  }\n\n  return upperKey;\n}\n\nexport function normalizeKeys(keys: ReadonlyArray<string>): Array<string> {\n  return keys.map(normalizeKey);\n}\n\nexport function hasModifiers(event: KeyboardEvent): boolean {\n  const key = normalizeKey(event.key);\n\n  return (\n    (event.ctrlKey && key !== 'CTRL') ||\n    ((event.altKey || event.getModifierState('AltGraph')) && key !== 'ALT') ||\n    (event.shiftKey && key !== 'SHIFT') ||\n    (event.metaKey && key !== 'META')\n  );\n}\n","import { CopyType } from '../../common/copy-keys';\n\nexport type CopyState =\n  | {\n      kind: 'inactive';\n    }\n  | {\n      kind: 'active';\n      index: number;\n      // We distinguish between touch and mouse because when interacting using\n      // the mouse we want the popup to maintain a minimum height when\n      // entering/leaving copy mode so that the cursor doesn't fall outside the\n      // window.\n      //\n      // Although it's possible the user could combine using touch and mouse\n      // interaction, for example, it's simpler to just assume one interaction\n      // mode (and if we're wrong, they simply end up getting\n      // a resized/unresized window).\n      mode: 'touch' | 'mouse' | 'keyboard';\n    }\n  | {\n      kind: 'finished';\n      type: CopyType;\n      index: number;\n      mode: 'touch' | 'mouse' | 'keyboard';\n    }\n  | {\n      kind: 'error';\n      index: number;\n      mode: 'touch' | 'mouse' | 'keyboard';\n    };\n\n// Convenience method to extract the mode\nexport function getCopyMode(\n  state: CopyState\n): Extract<CopyState, { kind: 'active' }>['mode'] | 'n/a' {\n  return state.kind !== 'inactive' ? state.mode : 'n/a';\n}\n","export function getThemeClass(theme: string): string {\n  if (theme !== 'default') {\n    return `theme-${theme}`;\n  }\n\n  // It is up to the call site to register for media query updates if they\n  // need to respond to dark mode changes. Generally, e.g. for popups etc.,\n  // however, the usage of this value is short-lived enough that it's not\n  // needed.\n  if (window.matchMedia('(prefers-color-scheme: dark)').matches) {\n    return 'theme-black';\n  }\n\n  return 'theme-light';\n}\n","export function getHash(input: Readonly<string>): string {\n  // Based on https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\n  //\n  // I really have no idea if it's right. All we really use it for is to detect\n  // if we need to replace the stylesheet data or not.\n  let h1 = 0xdeadbeef;\n  let h2 = 0x41c6ce57;\n\n  for (let i = 0, ch; i < input.length; i++) {\n    ch = input.charCodeAt(i);\n    h1 = Math.imul(h1 ^ ch, 2654435761);\n    h2 = Math.imul(h2 ^ ch, 1597334677);\n  }\n\n  h1 =\n    Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^\n    Math.imul(h2 ^ (h2 >>> 13), 3266489909);\n  h2 =\n    Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^\n    Math.imul(h1 ^ (h1 >>> 13), 3266489909);\n\n  const asNum = 4294967296 * (2097151 & h2) + (h1 >>> 0);\n\n  return ('0000000000000' + asNum.toString(16)).substr(-14);\n}\n","import { SVG_NS } from '../utils/dom-utils';\n\nexport const isSvgDoc = (doc: Document): boolean => {\n  return doc.documentElement.namespaceURI === SVG_NS;\n};\n\nexport const isForeignObjectElement = (\n  elem: Element | null\n): elem is SVGForeignObjectElement =>\n  !!elem &&\n  elem.namespaceURI === SVG_NS &&\n  elem.nodeName.toUpperCase() === 'FOREIGNOBJECT';\n\n// This is only needed because Edge's WebIDL definitions are wrong\n// (they have documentElement as having type HTMLElement)\nexport const isSvgSvgElement = (elem: Element | null): elem is SVGSVGElement =>\n  !!elem &&\n  elem.namespaceURI === SVG_NS &&\n  elem.nodeName.toUpperCase() === 'SVG';\n","import { HTML_NS, SVG_NS } from '../utils/dom-utils';\nimport { getHash } from '../utils/hash';\n\nimport { isForeignObjectElement, isSvgDoc } from './svg';\n\nexport function getOrCreateEmptyContainer({\n  id,\n  styles,\n  before,\n  legacyIds,\n}: {\n  id: string;\n  styles: string;\n  before?: string;\n  legacyIds?: Array<string>;\n}): HTMLElement {\n  // Drop any legacy containers\n  if (legacyIds?.length) {\n    const legacyContainers = document.querySelectorAll(\n      legacyIds.map((id) => `#${id}`).join(', ')\n    );\n    for (const container of legacyContainers) {\n      removeContainerElement(container);\n    }\n  }\n\n  // Look for an existing container we can re-use\n  const existingContainers = Array.from<HTMLElement>(\n    document.querySelectorAll(`#${id}`)\n  );\n  if (existingContainers.length) {\n    // Drop any duplicate containers, returning only the last one\n    while (existingContainers.length > 1) {\n      removeContainerElement(existingContainers.shift()!);\n    }\n\n    // Drop any existing content (except styles)\n    resetContent(existingContainers[0]);\n\n    // Make sure the styles are up-to-date\n    resetStyles({ container: existingContainers[0], styles });\n\n    // Make sure we have a fullscreenchange callback registered\n    addFullScreenChangeCallback({ id, before });\n\n    return existingContainers[0];\n  }\n\n  // We didn't find an existing content container so create a new one\n  const container = document.createElementNS(HTML_NS, 'div');\n  container.id = id;\n  addContainerElement({ elem: container, before });\n\n  // Reset any styles the page may have applied.\n  container.style.all = 'initial';\n\n  // Add the necessary style element\n  resetStyles({ container, styles });\n\n  // Update the position in the document if we go to/from fullscreen mode\n  addFullScreenChangeCallback({ id, before });\n\n  return container;\n}\n\nexport function removeContentContainer(id: string | Array<string>) {\n  const containerIds = typeof id === 'string' ? [id] : id;\n  const containers = Array.from<HTMLElement>(\n    document.querySelectorAll(containerIds.map((id) => `#${id}`).join(', '))\n  );\n  for (const container of containers) {\n    removeContainerElement(container);\n  }\n  for (const id of containerIds) {\n    removeFullScreenChangeCallback(id);\n  }\n}\n\n// --------------------------------------------------------------------------\n//\n// Implementation helpers\n//\n// --------------------------------------------------------------------------\n\nfunction addContainerElement({\n  elem,\n  before,\n}: {\n  elem: HTMLElement;\n  before?: string;\n}) {\n  const previousParent = elem.parentElement;\n\n  // Set up a method to add to the DOM, respecting any `before` ID we might\n  // have.\n  const insertBefore = (parent: Element, elem: Element) => {\n    const beforeElem = before ? parent.children.namedItem(before) : null;\n    if (beforeElem) {\n      parent.insertBefore(elem, beforeElem);\n    } else {\n      parent.append(elem);\n    }\n  };\n\n  let parent: Element;\n  if (document.fullscreenElement) {\n    parent = document.fullscreenElement;\n  } else if (isSvgDoc(document)) {\n    // For SVG documents we put the container <div> inside a <foreignObject>.\n    const foreignObject = document.createElementNS(SVG_NS, 'foreignObject');\n    foreignObject.setAttribute('width', '100%');\n    foreignObject.setAttribute('height', '100%');\n    foreignObject.style.setProperty('pointer-events', 'none', 'important');\n    foreignObject.style.setProperty('overflow', 'visible', 'important');\n    insertBefore(document.documentElement, foreignObject);\n    parent = foreignObject;\n  } else {\n    parent = document.documentElement;\n  }\n\n  insertBefore(parent, elem);\n\n  // If our previous parent was a foreignObject wrapper, drop it\n  if (isForeignObjectElement(previousParent)) {\n    previousParent.remove();\n  }\n}\n\nfunction removeContainerElement(elem: Element) {\n  if (isForeignObjectElement(elem.parentElement)) {\n    elem.parentElement.remove();\n  } else {\n    elem.remove();\n  }\n}\n\nconst fullScreenChangedCallbacks: Record<string, (event: Event) => void> = {};\n\nfunction addFullScreenChangeCallback({\n  id,\n  before,\n}: {\n  id: string;\n  before?: string;\n}) {\n  const existingCallback = fullScreenChangedCallbacks[id];\n  if (typeof existingCallback !== 'undefined') {\n    return;\n  }\n\n  const callback = () => {\n    const container = document.getElementById(id);\n    if (!container) {\n      return;\n    }\n\n    // Re-add the container element, respecting the updated\n    // document.fullScreenElement property.\n    addContainerElement({ elem: container, before });\n  };\n\n  document.addEventListener('fullscreenchange', callback);\n  fullScreenChangedCallbacks[id] = callback;\n}\n\nfunction removeFullScreenChangeCallback(id: string) {\n  const callback = fullScreenChangedCallbacks[id];\n  if (callback) {\n    document.removeEventListener('fullscreenchange', callback);\n  }\n}\n\nfunction resetContent(elem: HTMLElement) {\n  if (!elem.shadowRoot) {\n    return;\n  }\n\n  const children = Array.from(elem.shadowRoot.children);\n  for (const child of children) {\n    // We need to convert to uppercase because for standalone SVG documents the\n    // tag name case is not normalized.\n    if (child.tagName.toUpperCase() !== 'STYLE') {\n      child.remove();\n    }\n  }\n}\n\nfunction resetStyles({\n  container,\n  styles,\n}: {\n  container: HTMLElement;\n  styles: string;\n}) {\n  const styleHash = getHash(styles);\n\n  if (!container.shadowRoot) {\n    container.attachShadow({ mode: 'open' });\n\n    // Add <style>\n    const style = document.createElementNS(HTML_NS, 'style');\n    style.textContent = styles;\n    style.dataset.hash = styleHash;\n    container.shadowRoot!.append(style);\n  } else {\n    // Reset style\n    let existingStyle = container.shadowRoot.querySelector('style');\n    if (existingStyle && existingStyle.dataset.hash !== styleHash) {\n      existingStyle.remove();\n      existingStyle = null;\n    }\n\n    if (!existingStyle) {\n      const style = document.createElementNS(HTML_NS, 'style');\n      style.textContent = styles;\n      style.dataset.hash = styleHash;\n      container.shadowRoot!.append(style);\n    }\n  }\n}\n","import browser from 'webextension-polyfill';\n\nimport { html } from '../../utils/builder';\n\nexport function addFontStyles() {\n  if (document.getElementById('tenten-font-styles')) {\n    return;\n  }\n\n  (document.head || document.documentElement).append(\n    html('link', {\n      id: 'tenten-font-styles',\n      rel: 'stylesheet',\n      href: browser.runtime.getURL('css/popup-fonts.css'),\n    })\n  );\n}\n\nexport function removeFontStyles() {\n  document.getElementById('tenten-font-styles')?.remove();\n}\n","import type { FontFace, FontSize } from '../../common/content-config-params';\nimport { getThemeClass } from '../../utils/themes';\n\nimport { removeContentContainer } from '../content-container';\n\nimport { addFontStyles, removeFontStyles } from './font-styles';\nimport { getPopupContainer } from './popup-container';\n\nexport function isPopupVisible(): boolean {\n  const popupContainer = getPopupContainer();\n  return !!popupContainer && !popupContainer.classList.contains('hidden');\n}\n\nexport function hidePopup() {\n  getPopupContainer()?.classList.add('hidden');\n}\n\nexport function removePopup() {\n  removeContentContainer(['rikaichamp-window', 'tenten-ja-window']);\n  removeFontStyles();\n}\n\nexport function setFontFace(fontFace: FontFace) {\n  const popupWindow = getPopupWindow();\n  if (!popupWindow) {\n    return;\n  }\n\n  if (fontFace === 'bundled') {\n    addFontStyles();\n    popupWindow.classList.add('bundled-fonts');\n  } else {\n    removeFontStyles();\n    popupWindow.classList.remove('bundled-fonts');\n  }\n}\n\nexport function setFontSize(size: FontSize) {\n  const popupWindow = getPopupWindow();\n  if (!popupWindow) {\n    return;\n  }\n\n  for (const className of popupWindow.classList.values()) {\n    if (className.startsWith('font-')) {\n      popupWindow.classList.remove(className);\n    }\n  }\n\n  if (size !== 'normal') {\n    popupWindow.classList.add(`font-${size}`);\n  }\n}\n\nexport function setPopupStyle(style: string) {\n  const elems = [getPopupWindow(), getPopupArrow()];\n\n  for (const elem of elems) {\n    if (!elem) {\n      continue;\n    }\n\n    for (const className of elem.classList.values()) {\n      if (className.startsWith('theme-')) {\n        elem.classList.remove(className);\n      }\n    }\n\n    elem.classList.add(getThemeClass(style));\n  }\n}\n\nfunction getPopupWindow(): HTMLElement | null {\n  const hostElem = document.getElementById('tenten-ja-window');\n  return hostElem && hostElem.shadowRoot\n    ? hostElem.shadowRoot.querySelector('.window')\n    : null;\n}\n\nfunction getPopupArrow(): HTMLElement | null {\n  const hostElem = document.getElementById('tenten-ja-window');\n  return hostElem && hostElem.shadowRoot\n    ? hostElem.shadowRoot.querySelector('.arrow')\n    : null;\n}\n","import { MarginBox, PaddingBox, Point } from '../../utils/geometry';\n\nimport { getScrollOffset } from '../scroll-offset';\n\nexport const enum PopupPositionMode {\n  Start,\n  TopLeft = Start,\n  Auto,\n  BottomRight,\n  End = BottomRight,\n}\n\nexport interface PopupPosition {\n  x: number;\n  y: number;\n  constrainWidth: number | null;\n  constrainHeight: number | null;\n  direction: 'vertical' | 'horizontal' | 'disjoint';\n  side: 'before' | 'after' | 'disjoint';\n}\n\n// We have three (ok, two) possible situations:\n//\n// A) Tab bar is on the top -- we want to fix the top and left position.\n// B) Tab bar is on the left -- we want to fix the top and left position.\n//    i.e. as with A\n// C) Tab bar is on the right -- we want to fix the top and right position.\n//\nexport type PopupPositionConstraints = {\n  // Note that the 'x' position here should correspond to the _right_ edge of\n  // the popup when `anchor` is `'right'`.\n  x: number;\n  y: number;\n  anchor: 'top' | 'left' | 'right';\n  direction: 'vertical' | 'horizontal' | 'disjoint';\n  side: 'before' | 'after' | 'disjoint';\n};\n\n// Minimum space to leave between the edge of the pop-up and the edge of the\n// stage.\nconst GUTTER = 5;\n\n// Minimum space to leave between the edge of the pop-up and the cursor when in\n// interactive mode.\n//\n// We don't want this value to be too large or else it becomes too hard to move\n// the mouse over the popup.\nconst INTERACTIVE_MARGIN_TO_POPUP = 10;\n\n// Minimum space to leave between the edge of the pop-up and the cursor when we\n// are NOT in interactive mode. In future we'd probably like to make this the\n// same value as INTERACTIVE_MARGIN_TO_POPUP but for now it's safest to keep\n// things as they are.\nconst NON_INTERACTIVE_MARGIN_TO_POPUP = 25;\n\nexport function getPopupPosition({\n  allowVerticalOverlap,\n  cursorClearance,\n  cursorPos,\n  fixedPosition,\n  interactive,\n  isVerticalText,\n  popupSize,\n  positionMode,\n  safeArea: initialSafeArea,\n  pointerType,\n}: {\n  // Allow overlapping with the cursor position in order to avoid constraining\n  // the height\n  allowVerticalOverlap: boolean;\n  cursorClearance: MarginBox;\n  cursorPos?: Point;\n  fixedPosition?: PopupPositionConstraints;\n  interactive: boolean;\n  isVerticalText: boolean;\n  popupSize: { width: number; height: number };\n  positionMode: PopupPositionMode;\n  safeArea: PaddingBox;\n  pointerType: 'cursor' | 'puck';\n}): PopupPosition {\n  const { scrollX, scrollY } = getScrollOffset();\n\n  // Use the clientWidth (as opposed to doc.defaultView.innerWidth) since this\n  // excludes the width of any scrollbars.\n  const stageWidth = document.documentElement.clientWidth;\n\n  // For the height, we'd like to similarly use clientHeight...\n  let stageHeight = document.documentElement.clientHeight;\n\n  // ... but we need to be careful because:\n  //\n  // (a) in quirks mode, the body has the viewport height;\n  if (document.compatMode === 'BackCompat') {\n    stageHeight =\n      document.body?.clientHeight || document.defaultView!.innerHeight;\n  }\n\n  // (b) at least in iOS 15 Safari, the safe area appears to be measured from\n  // the innerHeight so if we have a non-zero vertical safe area inset, we\n  // should use the innerHeight instead.\n  if (initialSafeArea.top !== 0 || initialSafeArea.bottom !== 0) {\n    stageHeight = document.defaultView!.innerHeight;\n  }\n\n  // Now that we have finished detecting the absence/presence of a vertical safe\n  // area, merge our gutter into the safe area.\n  const safeArea = {\n    left: initialSafeArea.left + GUTTER,\n    right: initialSafeArea.right + GUTTER,\n    top: initialSafeArea.top + GUTTER,\n    bottom: initialSafeArea.bottom + GUTTER,\n  };\n\n  if (fixedPosition) {\n    return getFixedPosition({\n      allowVerticalOverlap,\n      cursorClearance,\n      cursorPos,\n      fixedPosition,\n      interactive,\n      popupSize,\n      safeArea,\n      scrollX,\n      scrollY,\n      stageWidth,\n      stageHeight,\n    });\n  }\n\n  if (positionMode === PopupPositionMode.Auto) {\n    return getAutoPosition({\n      allowVerticalOverlap,\n      cursorClearance,\n      cursorPos,\n      interactive,\n      isVerticalText,\n      popupSize,\n      safeArea,\n      scrollX,\n      scrollY,\n      stageWidth,\n      stageHeight,\n      pointerType,\n    });\n  }\n\n  //\n  // Manual positioning\n  //\n\n  const availableStageHeight = stageHeight - (safeArea.top + safeArea.bottom);\n\n  const left = scrollX + safeArea.left;\n  const top = scrollY + safeArea.top;\n  const right = scrollX + stageWidth - popupSize.width - safeArea.right;\n  const bottom =\n    scrollY +\n    stageHeight -\n    Math.min(popupSize.height, availableStageHeight) -\n    safeArea.bottom;\n\n  // We could calculate a value for constrainHeight as something like:\n  //\n  //   constrainHeight = popupSize.height > availableWindowHeight\n  //                     ? availableWindowHeight\n  //                     : null;\n  //\n  // and we'd get the nice fade effect to show in that case, but it's probably\n  // more useful to NOT constrain it and let the user scroll if the content\n  // overflows the viewport.\n\n  switch (positionMode) {\n    case PopupPositionMode.TopLeft:\n      return {\n        x: left,\n        y: top,\n        constrainWidth: null,\n        constrainHeight: null,\n        direction: 'disjoint',\n        side: 'disjoint',\n      };\n\n    case PopupPositionMode.BottomRight:\n      return {\n        x: right,\n        y: bottom,\n        constrainWidth: null,\n        constrainHeight: null,\n        direction: 'disjoint',\n        side: 'disjoint',\n      };\n  }\n}\n\nfunction getFixedPosition({\n  allowVerticalOverlap,\n  cursorClearance,\n  cursorPos,\n  fixedPosition,\n  interactive,\n  popupSize,\n  safeArea,\n  scrollX,\n  scrollY,\n  stageWidth,\n  stageHeight,\n}: {\n  allowVerticalOverlap: boolean;\n  cursorClearance: MarginBox;\n  cursorPos?: Point;\n  fixedPosition: PopupPositionConstraints;\n  interactive: boolean;\n  popupSize: { width: number; height: number };\n  safeArea: PaddingBox;\n  scrollX: number;\n  scrollY: number;\n  stageWidth: number;\n  stageHeight: number;\n}): PopupPosition {\n  // Work out our safe area in screen coordinates (as opposed to an inset).\n  let { left: safeLeft, top: safeTop } = safeArea;\n  let safeRight = stageWidth - safeArea.right;\n  const stageBottom = stageHeight - safeArea.bottom;\n  let safeBottom = stageBottom;\n\n  // Convert inputs to screen coordinates\n  let screenY = fixedPosition.y - scrollY;\n  let screenX = fixedPosition.x - scrollX;\n\n  // See if we can further constrain the area to place the popup in based on\n  // the text being highlighted.\n  const { direction, anchor, side } = fixedPosition;\n  if (direction !== 'disjoint' && side !== 'disjoint' && cursorPos) {\n    const [min, max] = getRangeForPopup({\n      axis: direction,\n      cursorClearance,\n      interactive,\n      side,\n      safeBoundaries: { safeLeft, safeRight, safeTop, safeBottom },\n      target: cursorPos,\n    });\n\n    if (direction === 'vertical') {\n      safeBottom = max;\n    } else {\n      safeLeft = min;\n      safeRight = max;\n    }\n  }\n\n  // Height constraints\n  let constrainHeight = null;\n  let verticalOverflow = Math.max(screenY + popupSize.height - safeBottom, 0);\n\n  // See if we can unconstrain the height by overlapping the cursor.\n  if (verticalOverflow && allowVerticalOverlap) {\n    const nudgeAmount = Math.min(verticalOverflow, screenY - safeTop);\n    screenY -= nudgeAmount;\n    verticalOverflow = Math.max(screenY + popupSize.height - stageBottom, 0);\n  }\n\n  if (\n    verticalOverflow &&\n    shouldConstrainHeight({ interactive, direction, side })\n  ) {\n    constrainHeight = popupSize.height - verticalOverflow;\n  }\n\n  // The x position and width will depend on if we are anchoring to the left or\n  // right.\n  let constrainWidth: number | null;\n  if (anchor !== 'right') {\n    constrainWidth =\n      screenX + popupSize.width > safeRight ? safeRight - screenX : null;\n  } else {\n    constrainWidth =\n      screenX - popupSize.width < safeLeft ? screenX - safeLeft : null;\n    screenX =\n      constrainWidth !== null\n        ? screenX - constrainWidth\n        : screenX - popupSize.width;\n  }\n\n  return {\n    x: screenX + scrollX,\n    y: screenY + scrollY,\n    constrainWidth,\n    constrainHeight,\n    direction,\n    side,\n  };\n}\n\nfunction shouldConstrainHeight(options: {\n  interactive: boolean;\n  direction: 'vertical' | 'horizontal' | 'disjoint';\n  side: 'before' | 'after' | 'disjoint';\n}) {\n  // If we're not interactive, we don't want to constrain the height because\n  // the user can't scroll the popup to see the rest of the content (but they\n  // _can_ scroll the page).\n  //\n  // However, if the popup is positioned above the cursor, we need to constrain\n  // the height otherwise it will cover up the cursor.\n  return (\n    options.interactive ||\n    (options.direction === 'vertical' && options.side === 'before')\n  );\n}\n\nfunction getAutoPosition({\n  allowVerticalOverlap,\n  cursorClearance,\n  cursorPos,\n  interactive,\n  isVerticalText,\n  popupSize,\n  safeArea,\n  scrollX,\n  scrollY,\n  stageWidth,\n  stageHeight,\n  pointerType,\n}: {\n  allowVerticalOverlap: boolean;\n  cursorClearance: MarginBox;\n  cursorPos?: Point;\n  interactive: boolean;\n  isVerticalText: boolean;\n  popupSize: { width: number; height: number };\n  safeArea: PaddingBox;\n  scrollX: number;\n  scrollY: number;\n  stageWidth: number;\n  stageHeight: number;\n  pointerType: 'cursor' | 'puck';\n}): PopupPosition {\n  const extendedPosition = getScreenAutoPosition({\n    allowVerticalOverlap,\n    cursorClearance,\n    cursorPos,\n    interactive,\n    isVerticalText,\n    popupSize,\n    safeArea,\n    stageWidth,\n    stageHeight,\n    pointerType,\n  });\n\n  return extendedPosition\n    ? {\n        ...extendedPosition.position,\n        x: extendedPosition.position.x + scrollX,\n        y: extendedPosition.position.y + scrollY,\n        constrainHeight: shouldConstrainHeight({\n          interactive,\n          direction: extendedPosition.axis,\n          side: extendedPosition.side,\n        })\n          ? extendedPosition.position.constrainHeight\n          : null,\n      }\n    : {\n        x: scrollX,\n        y: scrollY,\n        constrainWidth: null,\n        constrainHeight: null,\n        direction: 'disjoint',\n        side: 'disjoint',\n      };\n}\n\ntype ExtendedPopupPosition = {\n  axis: 'vertical' | 'horizontal';\n  side: 'before' | 'after';\n  position: PopupPosition;\n};\n\nfunction getScreenAutoPosition({\n  allowVerticalOverlap,\n  cursorClearance,\n  cursorPos,\n  interactive,\n  isVerticalText,\n  popupSize,\n  safeArea,\n  stageWidth,\n  stageHeight,\n  pointerType,\n}: {\n  allowVerticalOverlap: boolean;\n  cursorClearance: MarginBox;\n  cursorPos?: Point;\n  interactive: boolean;\n  isVerticalText: boolean;\n  popupSize: { width: number; height: number };\n  safeArea: PaddingBox;\n  stageWidth: number;\n  stageHeight: number;\n  pointerType: 'cursor' | 'puck';\n}): ExtendedPopupPosition | undefined {\n  // Set up a few useful variables...\n  const x = cursorPos?.x || 0;\n  const y = cursorPos?.y || 0;\n\n  const { left: safeLeft, top: safeTop } = safeArea;\n  const safeRight = stageWidth - safeArea.right;\n  const safeBottom = stageHeight - safeArea.bottom;\n\n  // Generate the possible position sizes in order of preference.\n  //\n  // We prefer positions in the block direction on the 'after' side unless we\n  // are looking up horizontal text with the puck, in which case we prefer the\n  // 'before' side (i.e. above the target text).\n\n  // Prefer the block direction\n  const axisOrder = isVerticalText\n    ? (['horizontal', 'vertical'] as const)\n    : (['vertical', 'horizontal'] as const);\n\n  // Prefer the 'after' side\n  const sides = ['after', 'before'] as const;\n\n  // Store the possible layouts\n  const candidates: Array<ExtendedPopupPosition | undefined> = [];\n\n  for (const axis of axisOrder) {\n    // Prefer the 'before' side when we are looking up horizontal text with the\n    // puck.\n    const swapSides = pointerType === 'puck' && axis === 'vertical';\n    for (const side of swapSides ? sides.slice().reverse() : sides) {\n      const position = calculatePosition({\n        axis,\n        cursorClearance,\n        interactive,\n        popupSize,\n        safeBoundaries: { safeLeft, safeRight, safeTop, safeBottom },\n        target: { x, y },\n        side,\n      });\n      candidates.push(\n        position\n          ? {\n              axis,\n              side,\n              position,\n            }\n          : undefined\n      );\n    }\n  }\n\n  // See if we have an unconstrained position in the block direction, and if so,\n  // use that.\n  const blockCandidates = candidates.slice(0, 2);\n  const blockPosition = blockCandidates.find(\n    (candidate) =>\n      candidate &&\n      (isVerticalText\n        ? candidate.position.constrainWidth\n        : candidate.position.constrainHeight) === null\n  );\n  if (blockPosition) {\n    return blockPosition;\n  }\n\n  // Beyond that, our behavior depends on the sort of screen we're dealing with.\n  //\n  // There are two modes:\n  //\n  // A) In the general case, we want to stick to one of the block direction\n  //    positions so we need to work out which direction is _less_ constrained.\n  //\n  // B) However, if the user is on a small screen which has more room in the\n  //    inline direction (i.e. it's in \"landscape mode\" as far as the block\n  //    direction is concerned) then putting the popup to the side could be\n  //    quite helpful so we should check all the possible positions.\n  let bestPosition: ExtendedPopupPosition | undefined;\n  if (\n    !isSmallLandscapeScreen({\n      isVerticalText,\n      safeBoundaries: { safeLeft, safeRight, safeTop, safeBottom },\n    })\n  ) {\n    bestPosition = blockCandidates.sort(sizeComparator(popupSize))[0];\n  }\n\n  // Otherwise, use the layout with the greatest width/area.\n  if (!bestPosition) {\n    bestPosition = candidates.sort(sizeComparator(popupSize))[0];\n  }\n  if (!bestPosition) {\n    return undefined;\n  }\n\n  // Now that we have our best position, see if we can unconstrain it by\n  // allowing overlap.\n  if (\n    allowVerticalOverlap &&\n    bestPosition.axis === 'vertical' &&\n    bestPosition.position.constrainHeight\n  ) {\n    const { position } = bestPosition;\n\n    // Nudge up the top\n    const nudgeAmount = Math.min(\n      popupSize.height - position.constrainHeight!,\n      position.y - safeTop\n    );\n    position.y -= nudgeAmount;\n\n    // See if we are still constrained\n    if (position.y + popupSize.height > safeBottom) {\n      position.constrainHeight = safeBottom - position.y;\n    } else {\n      position.constrainHeight = null;\n    }\n  }\n\n  return bestPosition;\n}\n\nfunction calculatePosition({\n  axis,\n  cursorClearance,\n  interactive,\n  popupSize,\n  safeBoundaries: { safeLeft, safeRight, safeTop, safeBottom },\n  side,\n  target,\n}: {\n  axis: 'vertical' | 'horizontal';\n  cursorClearance: MarginBox;\n  interactive: boolean;\n  popupSize: { width: number; height: number };\n  safeBoundaries: {\n    safeLeft: number;\n    safeRight: number;\n    safeTop: number;\n    safeBottom: number;\n  };\n  side: 'before' | 'after';\n  target: Point;\n}): PopupPosition | undefined {\n  // Cross-axis position\n  //\n  // (e.g. horizontal position when we are laying the popup out on the vertical\n  // axis).\n\n  // We want the popup to be positioned slightly \"before\" the target position so\n  // that if we are showing an arrow from the popup to the target position there\n  // is enough slack to position the arrow inside the popup and still have it\n  // line up with the target.\n  //\n  // Graphically,\n  //\n  //    x <-- target\n  //  ╭^─────╮\n  //   ⏟\n  //   Cross offset\n  //\n  // At minimum we want to push the popup \"back\" by the width of the popup\n  // rounding and half the width of the arrow.\n  //\n  // We _could_ fetch those values from computed style but we'd rather avoid\n  // adding even more layout flushes so we just fudge it.\n  //\n  // At the time of writing the rounding is 5px and the arrow width is 20px, or\n  // actually 28px if you add in the margin we allow for the shadow.\n  //\n  // That would give us an offset of 5px + 28px / 2 = 19px so we just use 20px\n  // to allow us some leeway if those values change marginally.\n  const CROSS_OFFSET = 20;\n  const idealCrossPos =\n    axis === 'vertical' ? target.x - CROSS_OFFSET : target.y - CROSS_OFFSET;\n  const crossPopupSize =\n    axis === 'vertical' ? popupSize.width : popupSize.height;\n  const maxCrossExtent = axis === 'vertical' ? safeRight : safeBottom;\n  const minCrossExtent = axis === 'vertical' ? safeLeft : safeTop;\n  const crossPos =\n    idealCrossPos + crossPopupSize > maxCrossExtent\n      ? Math.max(minCrossExtent, maxCrossExtent - crossPopupSize)\n      : idealCrossPos;\n  const constrainCrossExtent =\n    crossPos + crossPopupSize > maxCrossExtent\n      ? maxCrossExtent - crossPos\n      : null;\n\n  // Axis position\n  //\n  // (e.g. vertical position when we are laying the popup out on the vertical\n  // axis).\n  const [axisMin, axisMax] = getRangeForPopup({\n    axis,\n    cursorClearance,\n    interactive,\n    side,\n    safeBoundaries: { safeLeft, safeRight, safeTop, safeBottom },\n    target,\n  });\n\n  const axisPopupSize =\n    axis === 'vertical' ? popupSize.height : popupSize.width;\n  let axisPos;\n  if (side === 'before') {\n    axisPos = Math.max(axisMin, axisMax - axisPopupSize);\n    if (axisPos >= axisMax) {\n      return undefined;\n    }\n  } else {\n    axisPos = axisMin;\n    if (axisPos >= axisMax) {\n      return undefined;\n    }\n  }\n  const constrainAxisExtent =\n    axisPos + axisPopupSize > axisMax ? axisMax - axisPos : null;\n\n  return axis === 'vertical'\n    ? {\n        x: crossPos,\n        y: axisPos,\n        constrainWidth: constrainCrossExtent,\n        constrainHeight: constrainAxisExtent,\n        direction: axis,\n        side,\n      }\n    : {\n        x: axisPos,\n        y: crossPos,\n        constrainWidth: constrainAxisExtent,\n        constrainHeight: constrainCrossExtent,\n        direction: axis,\n        side,\n      };\n}\n\nfunction getRangeForPopup({\n  axis,\n  cursorClearance,\n  interactive,\n  side,\n  safeBoundaries: { safeLeft, safeRight, safeTop, safeBottom },\n  target,\n}: {\n  axis: 'vertical' | 'horizontal';\n  cursorClearance: MarginBox;\n  interactive: boolean;\n  safeBoundaries: {\n    safeLeft: number;\n    safeRight: number;\n    safeTop: number;\n    safeBottom: number;\n  };\n  side: 'before' | 'after';\n  target: Point;\n}): [min: number, max: number] {\n  const targetAxisPos = axis === 'vertical' ? target.y : target.x;\n  const marginToPopup = interactive\n    ? INTERACTIVE_MARGIN_TO_POPUP\n    : NON_INTERACTIVE_MARGIN_TO_POPUP;\n\n  let minAxisExtent;\n  let maxAxisExtent;\n\n  if (side === 'before') {\n    minAxisExtent = axis === 'vertical' ? safeTop : safeLeft;\n\n    const clearanceAtFarEdge =\n      axis === 'vertical' ? cursorClearance.top : cursorClearance.left;\n    const marginAtFarEdge = clearanceAtFarEdge + marginToPopup;\n    maxAxisExtent = targetAxisPos - marginAtFarEdge;\n  } else {\n    const clearanceAtNearEdge =\n      axis === 'vertical' ? cursorClearance.bottom : cursorClearance.right;\n    const marginAtNearEdge = clearanceAtNearEdge + marginToPopup;\n    minAxisExtent = targetAxisPos + marginAtNearEdge;\n\n    maxAxisExtent = axis === 'vertical' ? safeBottom : safeRight;\n  }\n\n  return [minAxisExtent, maxAxisExtent];\n}\n\nfunction isSmallLandscapeScreen({\n  isVerticalText,\n  safeBoundaries: { safeLeft, safeRight, safeTop, safeBottom },\n}: {\n  isVerticalText: boolean;\n  safeBoundaries: {\n    safeLeft: number;\n    safeRight: number;\n    safeTop: number;\n    safeBottom: number;\n  };\n}): boolean {\n  const verticalRange = safeBottom - safeTop;\n  const horizontalRange = safeRight - safeLeft;\n  const [blockRange, inlineRange] = isVerticalText\n    ? [horizontalRange, verticalRange]\n    : [verticalRange, horizontalRange];\n  const isLandscape = inlineRange > blockRange;\n  const isSmallScreen = blockRange < 500;\n\n  return isLandscape && isSmallScreen;\n}\n\nfunction sizeComparator(popupSize: { width: number; height: number }) {\n  return (\n    a: { position: PopupPosition } | undefined,\n    b: { position: PopupPosition } | undefined\n  ): number => {\n    // Sort undefined entries last\n    if (!b) {\n      return 0;\n    }\n\n    if (!a) {\n      return 1;\n    }\n\n    const widthA = a.position.constrainWidth ?? popupSize.width;\n    const heightA = a.position.constrainHeight ?? popupSize.height;\n    const areaA = widthA * heightA;\n\n    const widthB = b.position.constrainWidth ?? popupSize.width;\n    const heightB = b.position.constrainHeight ?? popupSize.height;\n    const areaB = widthB * heightB;\n\n    if (widthA === widthB) {\n      return areaB - areaA;\n    }\n\n    // Prefer wider results wherever possible, as it's okay to lose a few entries\n    // from the bottom of the popup, but disastrous for all the entries to be\n    // clipped off on the right.\n    return widthB - widthA;\n  };\n}\n","/// <reference path=\"../common/css.d.ts\" />\nimport puckStyles from '../../css/puck.css?inline';\n\nimport { PuckState } from '../common/puck-state';\nimport { SVG_NS } from '../utils/dom-utils';\nimport { MarginBox } from '../utils/geometry';\nimport { getThemeClass } from '../utils/themes';\nimport { isIOS } from '../utils/ua-utils';\n\nimport {\n  getOrCreateEmptyContainer,\n  removeContentContainer,\n} from './content-container';\nimport { getIframeOrigin } from './iframes';\nimport { isPopupWindowHostElem } from './popup/popup-container';\nimport type { SafeAreaProvider } from './safe-area-provider';\n\ninterface ViewportDimensions {\n  viewportWidth: number;\n  viewportHeight: number;\n}\n\nexport interface PuckRenderOptions {\n  icon: 'default' | 'sky';\n  theme: string;\n}\n\nexport function isPuckPointerEvent(\n  pointerEvent: PointerEvent\n): pointerEvent is PuckPointerEvent {\n  return !!(pointerEvent as PuckPointerEvent).fromPuck;\n}\n\nexport interface PuckPointerEvent extends PointerEvent {\n  fromPuck: true;\n}\n\ntype ClickState =\n  | {\n      kind: 'idle';\n    }\n  | {\n      kind: 'firstpointerdown';\n      // This is the timeout we use to detect if it's a drag or not\n      timeout: number;\n    }\n  | {\n      kind: 'dragging';\n    }\n  | {\n      kind: 'firstclick';\n      // This is the timeout we use to detect if it's a double-click or not\n      timeout: number;\n    }\n  | {\n      kind: 'secondpointerdown';\n      // This is the same timeout as we start when we enter the firstclick state\n      timeout: number;\n    };\n\ninterface ClickStateBase<T extends string> {\n  kind: T;\n}\ninterface ClickStateWithTimeout<T extends string> extends ClickStateBase<T> {\n  timeout: number;\n}\n\nfunction clickStateHasTimeout<T extends ClickState['kind']>(\n  clickState: ClickStateBase<T>\n): clickState is ClickStateWithTimeout<T> {\n  return typeof (clickState as ClickStateWithTimeout<T>).timeout === 'number';\n}\n\nfunction clearClickTimeout(clickState: ClickState) {\n  if (clickStateHasTimeout(clickState)) {\n    clearTimeout(clickState.timeout);\n  }\n}\n\n// - 'disabled': Does not listen for any events (so can't be moved\n//   nor tapped).\n// - 'inactive': Listens for events (so can be moved and tapped),\n//   but does not look up words.\n// - 'active': Listens for events (so can be moved and tapped), and\n//   furthermore looks up words.\nexport type PuckEnabledState = 'disabled' | 'inactive' | 'active';\n\nexport type InitialPuckPosition = Omit<PuckState, 'active'>;\n\ntype RestoreContentParams = { root: Element; restore: () => void };\n\nexport const LookupPuckId = 'tenten-ja-puck';\n\nconst clickHysteresis = 300;\n\nexport class LookupPuck {\n  private puck: HTMLDivElement | undefined;\n  private enabledState: PuckEnabledState = 'disabled';\n\n  private clickState: ClickState = { kind: 'idle' };\n\n  private puckX: number;\n  private puckY: number;\n  private earthWidth: number;\n  private earthHeight: number;\n  private earthScaleFactorWhenDragging: number;\n  private moonWidth: number;\n  private moonHeight: number;\n  // The translateY value to apply to the moon when it is orbiting above the\n  // earth. Expressed as an absolute (positive) value.\n  private targetAbsoluteOffsetYAbove: number;\n  // The translateY value to apply to the moon when it is orbiting below the\n  // earth. Expressed as an absolute (positive) value.\n  private targetAbsoluteOffsetYBelow: number;\n  // The translate (X and Y) values applied to the moon whilst it is being\n  // dragged. They are measured relative to the midpoint of the moon (which is\n  // also the midpoint of the earth).\n  private targetOffset: { x: number; y: number } = { x: 0, y: 0 };\n  private targetOrientation: 'above' | 'below' = 'above';\n  private cachedViewportDimensions: ViewportDimensions | null = null;\n\n  // We need to detect if the browser has a buggy position:fixed behavior\n  // (as is currently the case for Safari\n  // https://bugs.webkit.org/show_bug.cgi?id=207089)\n  // so we can adjust the way we position the puck.\n  //\n  // This probably should _also_ apply to the way we position the safe area\n  // but we haven't looked into that case just yet.\n  //\n  // undefined means we haven't been able to detect whether or not the bug is\n  // present yet.\n  private hasBuggyPositionFixed: boolean | undefined;\n\n  // We sometimes temporarily modify the content so we can look it up. In such\n  // a case we register a `restore` function to return the content back\n  // to its original state when we have finished with it.\n  private contentToRestore: RestoreContentParams | undefined;\n\n  private safeAreaProvider: SafeAreaProvider;\n\n  // Callbacks\n  private onLookupDisabled: () => void;\n  private onPuckStateChanged: (puckState: PuckState) => void;\n\n  constructor({\n    initialPosition,\n    safeAreaProvider,\n    onLookupDisabled,\n    onPuckStateChanged,\n  }: {\n    initialPosition?: InitialPuckPosition;\n    safeAreaProvider: SafeAreaProvider;\n    onLookupDisabled: () => void;\n    onPuckStateChanged: (puckState: PuckState) => void;\n  }) {\n    if (initialPosition) {\n      this.puckX = initialPosition.x;\n      this.puckY = initialPosition.y;\n      this.targetOrientation = initialPosition.orientation;\n    } else {\n      // Initially position the puck in the bottom-right corner of the screen\n      this.puckX = Number.MAX_SAFE_INTEGER;\n      this.puckY = Number.MAX_SAFE_INTEGER;\n    }\n    this.safeAreaProvider = safeAreaProvider;\n    this.onLookupDisabled = onLookupDisabled;\n    this.onPuckStateChanged = onPuckStateChanged;\n  }\n\n  private readonly onSafeAreaUpdated = () => {\n    this.cachedViewportDimensions = null;\n    this.setPositionWithinSafeArea(this.puckX, this.puckY);\n  };\n\n  private setPosition({\n    x,\n    y,\n    safeAreaLeft,\n    safeAreaRight,\n  }: {\n    x: number;\n    y: number;\n    safeAreaLeft: number;\n    safeAreaRight: number;\n  }) {\n    this.puckX = x;\n    this.puckY = y;\n\n    // Update the puck position (that is, the earth)\n    if (this.puck) {\n      this.puck.style.transform = `translate(${this.puckX}px, ${this.puckY}px)`;\n    }\n\n    // Calculate the corresponding target point (that is, the moon)\n\n    // First determine the actual range of motion of the moon, taking into\n    // account any safe area on either side of the screen.\n    const { viewportWidth } = this.getViewportDimensions(document);\n    const safeAreaWidth = viewportWidth - safeAreaLeft - safeAreaRight;\n\n    // Now work out where the moon is within that range such that it is\n    //\n    // * 0 when the the left side of the earth is touching the left safe area\n    //   inset, and\n    // * 1 when the right side of the earth is touching the right safe area\n    //   inset.\n    const clamp = (num: number, min: number, max: number) =>\n      Math.min(Math.max(num, min), max);\n    const horizontalPortion = clamp(\n      (this.puckX - safeAreaLeft) / (safeAreaWidth - this.earthWidth),\n      0,\n      1\n    );\n\n    // Then we calculate the horizontal offset. We need to ensure that we\n    // produce enough displacement that we can reach to the other edge of the\n    // safe area in either direction.\n\n    // The range is the amount the moon rotates either side of the moon, in this\n    // case 45 degrees in either direction.\n    const range = Math.PI / 2;\n\n    // We need to determine the radius of the offset.\n    //\n    // Typically we set this to 10 pixels greater than the radius of the earth\n    // itself.\n    const radiusOfEarth = this.earthWidth / 2;\n    const preferredRadius = radiusOfEarth + 10;\n\n    // However, we may need to extend that to reach the other side of the safe\n    // area.\n    const safeAreaExtent = Math.max(safeAreaLeft, safeAreaRight);\n    const requiredReach = safeAreaExtent + radiusOfEarth;\n    const requiredRadius = requiredReach / Math.sin(range / 2);\n\n    // Choose whichever is larger\n    const offsetRadius = Math.max(preferredRadius, requiredRadius);\n\n    // Now finally we can calculate the horizontal offset.\n    const angle = horizontalPortion * range - range / 2;\n    const offsetX = Math.sin(angle) * offsetRadius;\n\n    // For the vertical offset, we don't actually extend the moon out by the\n    // same radius but instead try to keep a fixed vertical offset since that\n    // makes scanning horizontally easier and allows us to tweak that offset to\n    // make room for the user's thumb.\n    const offsetYOrientationFactor =\n      this.targetOrientation === 'above' ? -1 : 1;\n    const offsetY =\n      (this.targetOrientation === 'above'\n        ? this.targetAbsoluteOffsetYAbove\n        : this.targetAbsoluteOffsetYBelow) * offsetYOrientationFactor;\n\n    // At rest, make the target land on the surface of the puck.\n    const restOffsetX = Math.sin(angle) * radiusOfEarth;\n    const restOffsetY =\n      Math.cos(angle) * radiusOfEarth * offsetYOrientationFactor;\n\n    this.targetOffset = { x: offsetX, y: offsetY };\n\n    // Update target position in style\n    if (this.puck) {\n      this.puck.style.setProperty('--target-x-offset', `${offsetX}px`);\n      this.puck.style.setProperty('--target-y-offset', `${offsetY}px`);\n      this.puck.style.setProperty('--rest-x-offset', `${restOffsetX}px`);\n      this.puck.style.setProperty('--rest-y-offset', `${restOffsetY}px`);\n    }\n  }\n\n  // Returns the total clearance to allow arround the target offset for the\n  // puck.\n  public getPuckClearance(): MarginBox {\n    const moonVerticalClearance = this.moonHeight / 2;\n    const earthVerticalClearance =\n      Math.abs(this.targetOffset.y) +\n      (this.earthScaleFactorWhenDragging * this.earthHeight) / 2;\n\n    return {\n      top:\n        this.targetOrientation === 'above'\n          ? moonVerticalClearance\n          : earthVerticalClearance,\n      bottom:\n        this.targetOrientation === 'above'\n          ? earthVerticalClearance\n          : moonVerticalClearance,\n      left:\n        (this.earthScaleFactorWhenDragging * this.earthWidth) / 2 +\n        this.targetOffset.x,\n      right:\n        (this.earthScaleFactorWhenDragging * this.earthWidth) / 2 -\n        this.targetOffset.x,\n    };\n  }\n\n  public getTargetOrientation(): 'above' | 'below' {\n    return this.targetOrientation;\n  }\n\n  private getViewportDimensions(document: Document): ViewportDimensions {\n    if (this.cachedViewportDimensions) {\n      return this.cachedViewportDimensions;\n    }\n\n    // We'd ideally use document.documentElement.clientWidth and\n    // document.documentElement.clientHeight for both viewport measurements, but\n    // iOS 15 Safari doesn't behave suitably for that.\n    //\n    // iOS 15 Safari:\n    //\n    // - seems to measure its safe area insets from the area defined by\n    //   document.defaultView.innerHeight and .innerWidth.\n    //\n    // - decreases both document.defaultView.innerHeight and the\n    //   safe-area-inset-bottom in compact mode, and vice versa in non-compact\n    //   mode.\n    //\n    // @see https://github.com/shirakaba/10ten-ja-reader/pull/3#issuecomment-875127566\n    //\n    // Another curiousity, if you load a page initially zoomed-in using pinch\n    // zoom (e.g. by refreshing it after zooming in), the innerHeight will\n    // initially report the zoomed-in viewport height (i.e. the same value as\n    // window.visualViewport.height). However, if you zoom all the way out and\n    // back in again, it will give you the layout viewport. If you zoom\n    // partially out and back in, you get something in between.\n    this.cachedViewportDimensions = {\n      viewportWidth: document.documentElement.clientWidth,\n      viewportHeight:\n        document.defaultView?.innerHeight ??\n        document.documentElement.clientHeight,\n    };\n\n    return this.cachedViewportDimensions;\n  }\n\n  private setPositionWithinSafeArea(x: number, y: number) {\n    if (!this.puck) {\n      return;\n    }\n\n    const {\n      top: safeAreaTop,\n      right: safeAreaRight,\n      bottom: safeAreaBottom,\n      left: safeAreaLeft,\n    } = this.safeAreaProvider.getSafeArea();\n\n    const { viewportWidth, viewportHeight } =\n      this.getViewportDimensions(document);\n\n    const minX = safeAreaLeft;\n    const maxX = viewportWidth - safeAreaRight - this.earthWidth;\n    const minY = safeAreaTop;\n    const maxY = viewportHeight - safeAreaBottom - this.earthHeight;\n\n    let clampedX = Math.min(Math.max(minX, x), maxX);\n    let clampedY = Math.min(Math.max(minY, y), maxY);\n\n    // When we initialize the puck, we put it in the bottom-right corner, but on\n    // iOS 15 Safari, if it's flush up against the right edge of the screen then\n    // when you try to drag it away, you end up dragging in the next tab.\n    //\n    // To avoid that we detect the initial position coordinates and add a few\n    // pixels margin.\n    if (x === Number.MAX_SAFE_INTEGER && y === Number.MAX_SAFE_INTEGER) {\n      clampedX -= 15;\n      clampedY -= 15;\n    }\n\n    this.setPosition({\n      x: clampedX,\n      y: clampedY,\n      safeAreaLeft,\n      safeAreaRight,\n    });\n  }\n\n  readonly onWindowPointerMove = (event: PointerEvent) => {\n    if (isPuckPointerEvent(event)) {\n      return;\n    }\n\n    if (\n      !this.puck ||\n      !this.earthWidth ||\n      !this.earthHeight ||\n      this.enabledState === 'disabled' ||\n      // If we're not being pressed or dragged, ignore\n      !(\n        this.clickState.kind === 'dragging' ||\n        this.clickState.kind === 'firstpointerdown' ||\n        this.clickState.kind === 'secondpointerdown'\n      )\n    ) {\n      return;\n    }\n\n    event.preventDefault();\n\n    let { clientX, clientY } = event;\n\n    // Factor in any viewport offset needed to make up for Safari iOS's buggy\n    // implementation of position:fixed.\n    let viewportOffsetLeft = 0;\n    let viewportOffsetTop = 0;\n    if (this.hasBuggyPositionFixed) {\n      viewportOffsetLeft = window.visualViewport?.offsetLeft ?? 0;\n      viewportOffsetTop = window.visualViewport?.offsetTop ?? 0;\n    }\n    clientX += viewportOffsetLeft;\n    clientY += viewportOffsetTop;\n\n    // Translate the midpoint of the earth to the position of the pointer event.\n    // This updates the moon offset\n    this.setPositionWithinSafeArea(\n      clientX - this.earthWidth / 2,\n      clientY - this.earthHeight / 2\n    );\n\n    if (this.enabledState !== 'active') {\n      return;\n    }\n\n    // Before applying the transformations to the earth and the moon, they\n    // both share the same midpoint.\n    // Work out the midpoint of the moon post-transformations. This is where\n    // we'll fire the mousemove event to trigger a lookup.\n    //\n    // We drop any zoom offsets here since both elementFromPoint and the mouse\n    // event handlers we pass these coordinates to will expect an unadjusted\n    // value.\n    const targetX =\n      this.puckX +\n      this.earthWidth / 2 +\n      this.targetOffset.x -\n      viewportOffsetLeft;\n    const targetY =\n      this.puckY +\n      this.earthHeight / 2 +\n      this.targetOffset.y -\n      viewportOffsetTop;\n\n    // See what we are pointing at\n    let target =\n      document\n        .elementsFromPoint(targetX, targetY)\n        // Ignore any element in the 10ten popup itself; we don't want\n        // the puck moon to hold the popup open like a mouse event does.\n        .find((target) => !isPopupWindowHostElem(target)) || null;\n\n    // Check if we need to adjust the content to look it up.\n    //\n    // But first check we aren't pointing at the same content as we adjusted\n    // last time (or one of its descendents).\n    if (!this.contentToRestore?.root.contains(target)) {\n      // Restore any content we previously adjusted.\n      this.restoreContent();\n\n      // Look for hidden textboxes on mokuro reader pages\n      const mokuroResult = LookupPuck.uncoverMokuroText(\n        target,\n        targetX,\n        targetY\n      );\n      if (mokuroResult) {\n        target = mokuroResult.newTarget;\n        this.contentToRestore = mokuroResult.contentToRestore;\n      }\n    }\n\n    // Make sure the target is an actual element since the mousemove handler\n    // expects that.\n    if (!target) {\n      return;\n    }\n\n    // When the target is an iframe, simply firing a 'mousemove' event at it\n    // does not have the desired effect of prompting a lookup at the target\n    // location within the iframe.\n    //\n    // Instead, we send a 'puckMoved' message to the iframe. Our injected\n    // content script ensures that the iframe has a listener in place to handle\n    // this message. Upon receiving this message, the iframe will fire a\n    // 'mousemove' event at the indicated location, ultimately resulting in a\n    // lookup at the target point.\n    //\n    // Note that this is the one and only case where we use postMessage, the\n    // reasons for which are described here:\n    //\n    //  https://github.com/birchill/10ten-ja-reader/issues/747#issuecomment-918774588\n    //\n    // For any other cross-frame messaging we should very very strongly prefer\n    // passing messages via the background page.\n    if (target.tagName === 'IFRAME') {\n      const iframeElement = target as HTMLIFrameElement;\n      const contentWindow = iframeElement.contentWindow;\n      if (!contentWindow) {\n        return;\n      }\n\n      // Adjust the target position by the offset of the iframe itself within\n      // the viewport.\n      const originPoint = getIframeOrigin(iframeElement);\n      if (!originPoint) {\n        return;\n      }\n      const { x, y } = originPoint;\n\n      contentWindow.postMessage(\n        {\n          type: '10ten(ja):puckMoved',\n          clientX: targetX - x,\n          clientY: targetY - y,\n        },\n        '*'\n      );\n      return;\n    }\n\n    const pointerEvent = new PointerEvent('pointermove', {\n      // Make sure the event bubbles up to the listener on the window\n      bubbles: true,\n      clientX: targetX,\n      clientY: targetY,\n      pointerType: 'mouse',\n    });\n    (pointerEvent as PuckPointerEvent).fromPuck = true;\n\n    target.dispatchEvent(pointerEvent);\n  };\n\n  private restoreContent() {\n    this.contentToRestore?.restore();\n    this.contentToRestore = undefined;\n  }\n\n  // Look for textBox elements generated by mokuro reader\n  // (https://github.com/kha-white/mokuro) since they have hidden paragraph\n  // elements that are only shown on hover.\n  private static uncoverMokuroText(\n    target: Element | null,\n    targetX: number,\n    targetY: number\n  ): { newTarget: Element; contentToRestore: RestoreContentParams } | null {\n    // Check for a suitable suspect\n    if (\n      !(target instanceof HTMLElement) ||\n      !target.classList.contains('textBox')\n    ) {\n      return null;\n    }\n\n    // Set the paragraphs to display: table to match the hover style's from\n    // mokuro's stylesheet:\n    //\n    // https://github.com/kha-white/mokuro/blob/43c59a3c49100db522db088563297dc609afa031/mokuro/styles.css#L70-L72\n    //\n    // We also record the previous setting on the inline style attribute so we\n    // can faithfully restore it when we're done.\n    const paragraphs = target.querySelectorAll('p');\n    const toRestore: Array<[HTMLParagraphElement, string | null]> = [];\n    for (const p of paragraphs) {\n      if (getComputedStyle(p).display === 'none') {\n        toRestore.push([p, p.style.display || null]);\n        p.style.display = 'table';\n      }\n    }\n\n    // Check if we found any paragraphs to adjust\n    if (!toRestore.length) {\n      return null;\n    }\n\n    // Setup a function to restore the content\n    const restore = () => {\n      // If we selected part of the content we uncovered we need to clear\n      // selection or else we'll be unable to select anything more.\n      const selection = window.getSelection();\n      if (target && toRestore.some(([p]) => selection?.containsNode(p, true))) {\n        selection!.removeAllRanges();\n      }\n\n      // Restore the inline style display\n      for (const [p, display] of toRestore) {\n        if (display) {\n          p.style.display = display;\n        } else {\n          p.style.removeProperty('display');\n        }\n      }\n    };\n\n    const newTarget = document.elementFromPoint(targetX, targetY);\n    if (!newTarget) {\n      restore();\n      return null;\n    }\n\n    return { newTarget, contentToRestore: { root: target, restore } };\n  }\n\n  private readonly checkForBuggyPositionFixed = () => {\n    // Check if we've already run this check\n    if (typeof this.hasBuggyPositionFixed !== 'undefined') {\n      return;\n    }\n\n    // Check we have the visual viewport API available.\n    //\n    // If not, it's hard to detect the browser bug (since we don't know if we're\n    // scaled or not) and it's hard to work around it too without flushing style\n    // on every pointer event so we just act as if there's no bug.\n    //\n    // (Normally this function won't be called in the first place if we don't\n    // have the visual viewport API since we can't register for viewport resize\n    // events, but we manually call this function initially after rendering so\n    // we can still arrive here even without the API.)\n    if (\n      typeof window.visualViewport === 'undefined' ||\n      window.visualViewport === null\n    ) {\n      this.hasBuggyPositionFixed = false;\n      return;\n    }\n\n    // Check that there is a suitable viewport scale applied so that we could\n    // potentially detect the bug\n    if (\n      Math.abs(window.visualViewport.scale - 1) < 0.01 ||\n      (Math.abs(window.visualViewport.offsetLeft) <= 1 &&\n        Math.abs(window.visualViewport.offsetTop) <= 1)\n    ) {\n      return;\n    }\n\n    // Check the puck is actually being rendered\n    if (!this.puck) {\n      return;\n    }\n\n    // Clear the transform on the puck and check if its resting position is\n    // actually equal to the offset of the visual viewport.\n    //\n    // When that's the case we've got iOS's buggy position:fixed that makes the\n    // element not actually fixed.\n    //\n    // https://bugs.webkit.org/show_bug.cgi?id=207089\n    //\n    // Furthermore, because the offsets match we know we can work around it\n    // by factoring the viewport offset into our calculations.\n    const previousTransform = this.puck.style.transform || 'none';\n    this.puck.style.transform = 'none';\n    const bbox = this.puck.getBoundingClientRect();\n    this.hasBuggyPositionFixed =\n      Math.abs(bbox.left + window.visualViewport.offsetLeft) < 1 &&\n      Math.abs(bbox.top + window.visualViewport.offsetTop) < 1;\n    this.puck.style.transform = previousTransform;\n\n    // Don't listen for any more viewport resize events\n    window.visualViewport.removeEventListener(\n      'resize',\n      this.checkForBuggyPositionFixed\n    );\n  };\n\n  private readonly onPuckPointerDown = (event: PointerEvent) => {\n    if (this.enabledState === 'disabled' || !this.puck) {\n      return;\n    }\n\n    // Ignore right-clicks\n    if (event.button) {\n      return;\n    }\n\n    // NOTE: Some of the code in this function is duplicated in onPuckMouseDown\n    // so please make sure to keep these two functions in sync.\n\n    if (this.clickState.kind === 'idle') {\n      // If no transition to 'pointerup' occurs during the click hysteresis\n      // period, then we transition to 'dragging'. This avoids onPuckClick()\n      // being fired every time the puck gets parked.\n      this.clickState = {\n        kind: 'firstpointerdown',\n        timeout: window.setTimeout(() => {\n          if (this.clickState.kind === 'firstpointerdown') {\n            this.clickState = { kind: 'dragging' };\n          }\n        }, clickHysteresis),\n      };\n    } else if (this.clickState.kind === 'firstclick') {\n      // Carry across the timeout from 'firstclick', as we still want to\n      // transition back to 'idle' if no 'pointerdown' event came within\n      // the hysteresis period of the preceding 'firstclick' state.\n      this.clickState = { ...this.clickState, kind: 'secondpointerdown' };\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    this.puck.classList.add('dragging');\n    this.puck.setPointerCapture(event.pointerId);\n\n    // We need to register in the capture phase because Bibi reader (which\n    // apparently is based on Epub.js) registers a pointermove handler on the\n    // window in the capture phase and calls `stopPropagation()` on the events\n    // so if we don't register in the capture phase, we'll never see the events.\n    window.addEventListener('pointermove', this.onWindowPointerMove, {\n      capture: true,\n    });\n    window.addEventListener('pointerup', this.stopDraggingPuck);\n    window.addEventListener('pointercancel', this.stopDraggingPuck);\n  };\n\n  // See notes where we register the following two functions (onPuckMouseDown\n  // and onPuckMouseUp) for why they are needed. The summary is that they are\n  // only here to work around iOS swallowing pointerevents during the _second_\n  // tap of a double-tap gesture.\n  //\n  // As a result these event listeners are _only_ interested in when we are\n  // detecting the second tap of a double-tap gesture.\n  //\n  // When the pointer events are _not_ swallowed, because we call preventDefault\n  // on the pointerdown / pointerup events, these functions should never be\n  // called.\n\n  private readonly onPuckMouseDown = (event: MouseEvent) => {\n    // This is only needed for iOS Safari and on Firefox for Android, calling\n    // preventDefault on a pointerdown event will _not_ prevent it from\n    // triggering subsequent mousedown/mouseup events (see\n    // https://codepen.io/birtles/pen/rNPKNQJ) so we should _not_ run this code\n    // on platforms other than iOS.\n    if (!isIOS()) {\n      return;\n    }\n\n    if (this.enabledState === 'disabled' || !this.puck) {\n      return;\n    }\n\n    // Ignore right-clicks\n    if (event.button) {\n      return;\n    }\n\n    // We only care about detecting the start of a second tap\n    if (this.clickState.kind !== 'firstclick') {\n      return;\n    }\n\n    // Following are the important bits of onPuckPointerDown.\n    //\n    // Eventually we should find a way to share this code better with that\n    // function.\n    this.clickState = {\n      ...this.clickState,\n      kind: 'secondpointerdown',\n    };\n\n    event.preventDefault();\n\n    // See note in onPointerDown for why we need to register in the capture\n    // phase.\n    window.addEventListener('pointermove', this.onWindowPointerMove, {\n      capture: true,\n    });\n    window.addEventListener('pointerup', this.stopDraggingPuck);\n    window.addEventListener('pointercancel', this.stopDraggingPuck);\n  };\n\n  private readonly onPuckMouseUp = (event: MouseEvent) => {\n    // This is only needed for iOS Safari and on Firefox for Android, calling\n    // preventDefault on a pointerdown event will _not_ prevent it from\n    // triggering subsequent mousedown/mouseup events (see\n    // https://codepen.io/birtles/pen/rNPKNQJ) so we should _not_ run this code\n    // on platforms other than iOS.\n    if (!isIOS()) {\n      return;\n    }\n\n    if (this.enabledState === 'disabled' || !this.puck) {\n      return;\n    }\n\n    // Ignore right-clicks\n    if (event.button) {\n      return;\n    }\n\n    // We only care about detecting the end of the second tap in a double-tap\n    // gesture.\n    if (this.clickState.kind !== 'secondpointerdown') {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    this.stopDraggingPuck();\n    this.onPuckDoubleClick();\n  };\n\n  private readonly onPuckSingleClick = () => {\n    this.setEnabledState(\n      this.enabledState === 'active' ? 'inactive' : 'active'\n    );\n    this.notifyPuckStateChanged();\n  };\n\n  private readonly onPuckDoubleClick = () => {\n    this.targetOrientation =\n      this.targetOrientation === 'above' ? 'below' : 'above';\n    this.setPositionWithinSafeArea(this.puckX, this.puckY);\n    this.notifyPuckStateChanged();\n  };\n\n  // May be called manually (without an event), or upon 'pointerup' or\n  // 'pointercancel'.\n  private readonly stopDraggingPuck = (event?: PointerEvent) => {\n    // Ignore right-clicks\n    if (event?.button) {\n      return;\n    }\n\n    if (this.puck) {\n      this.puck.classList.remove('dragging');\n      this.setPositionWithinSafeArea(this.puckX, this.puckY);\n      this.notifyPuckStateChanged();\n    }\n\n    window.removeEventListener('pointermove', this.onWindowPointerMove, {\n      capture: true,\n    });\n    window.removeEventListener('pointerup', this.stopDraggingPuck);\n    window.removeEventListener('pointercancel', this.stopDraggingPuck);\n\n    if (!event || event.type === 'pointercancel') {\n      clearClickTimeout(this.clickState);\n      this.clickState = { kind: 'idle' };\n      return;\n    }\n\n    // Prevent any double-taps turning into a zoom\n    event.preventDefault();\n    event.stopPropagation();\n\n    if (this.clickState.kind === 'firstpointerdown') {\n      // Prevent 'firstpointerdown' transitioning to 'dragging' state.\n      clearClickTimeout(this.clickState);\n\n      // Wait for the hysteresis period to expire before calling\n      // this.onPuckSingleClick() (to rule out a double-click).\n      this.clickState = {\n        kind: 'firstclick',\n        timeout: window.setTimeout(() => {\n          if (this.clickState.kind === 'firstclick') {\n            this.clickState = { kind: 'idle' };\n            this.onPuckSingleClick();\n          } else if (this.clickState.kind === 'secondpointerdown') {\n            this.clickState = { kind: 'dragging' };\n          }\n        }, clickHysteresis),\n      };\n    } else if (this.clickState.kind === 'secondpointerdown') {\n      clearClickTimeout(this.clickState);\n      this.clickState = { kind: 'idle' };\n      this.onPuckDoubleClick();\n    } else if (this.clickState.kind === 'dragging') {\n      this.clickState = { kind: 'idle' };\n    }\n  };\n\n  private readonly noOpEventHandler = () => {};\n\n  render({ icon, theme }: PuckRenderOptions): void {\n    // Set up shadow tree\n    const container = getOrCreateEmptyContainer({\n      id: LookupPuckId,\n      styles: puckStyles.toString(),\n    });\n\n    // Create puck elem\n    this.puck = document.createElement('div');\n    this.puck.classList.add('puck');\n\n    const earth = document.createElement('div');\n    earth.classList.add('earth');\n    this.puck.append(earth);\n\n    // Brand the earth\n    const logoSvg = this.renderIcon(icon);\n    logoSvg.classList.add('logo');\n    earth.append(logoSvg);\n\n    const moon = document.createElement('div');\n    moon.classList.add('moon');\n    this.puck.append(moon);\n\n    container.shadowRoot!.append(this.puck);\n\n    // Set theme styles\n    this.puck.classList.add(getThemeClass(theme));\n\n    // Calculate the earth size (which is equal to the puck's overall size)\n    if (!this.earthWidth || !this.earthHeight) {\n      const { width, height } = earth.getBoundingClientRect();\n      this.earthWidth = width;\n      this.earthHeight = height;\n    }\n\n    // Calculate the moon size\n    if (!this.moonWidth || !this.moonHeight) {\n      const { width, height } = moon.getBoundingClientRect();\n      this.moonWidth = width;\n      this.moonHeight = height;\n    }\n\n    if (typeof this.earthScaleFactorWhenDragging === 'undefined') {\n      this.earthScaleFactorWhenDragging =\n        parseFloat(\n          getComputedStyle(earth).getPropertyValue(\n            '--scale-factor-when-dragging'\n          )\n        ) || 0;\n    }\n\n    if (\n      typeof this.targetAbsoluteOffsetYAbove === 'undefined' ||\n      typeof this.targetAbsoluteOffsetYBelow === 'undefined'\n    ) {\n      const minimumMoonOffsetY =\n        parseFloat(\n          getComputedStyle(moon).getPropertyValue('--minimum-moon-offset-y')\n        ) || 0;\n\n      // Depending on whether the moon is above or below the earth, some extra\n      // altitude needs to be added to the orbit so that the thumb doesn't cover\n      // it.\n      const extraAltitudeToClearAboveThumb =\n        parseFloat(\n          getComputedStyle(moon).getPropertyValue(\n            '--extra-altitude-to-clear-above-thumb'\n          )\n        ) || 0;\n      const extraAltitudeToClearBelowThumb =\n        parseFloat(\n          getComputedStyle(moon).getPropertyValue(\n            '--extra-altitude-to-clear-above-thumb'\n          )\n        ) || 0;\n\n      // By adding this extra clearance, we avoid the iOS 15 Safari full-size\n      // URL bar springing back into place when dragging the puck too far into\n      // the bottom of the viewport. Hopefully this covers the worst-case\n      // scenario.\n      // @see https://github.com/shirakaba/10ten-ja-reader/pull/5#issuecomment-877794905\n      const extraAltitudeToClearIos15SafariSafeAreaActivationZone =\n        parseFloat(\n          getComputedStyle(moon).getPropertyValue(\n            '--extra-altitude-to-clear-ios-15-safari-safe-area-activation-zone'\n          )\n        ) || 0;\n\n      this.targetAbsoluteOffsetYAbove =\n        minimumMoonOffsetY + extraAltitudeToClearAboveThumb;\n      this.targetAbsoluteOffsetYBelow =\n        minimumMoonOffsetY +\n        extraAltitudeToClearBelowThumb +\n        extraAltitudeToClearIos15SafariSafeAreaActivationZone;\n    }\n\n    this.setPositionWithinSafeArea(this.puckX, this.puckY);\n\n    // Add event listeners\n    //\n    // Note: This currently never happens. We always render before enabling.\n    if (this.enabledState !== 'disabled') {\n      this.puck.addEventListener('pointerdown', this.onPuckPointerDown);\n      this.puck.addEventListener('mousedown', this.onPuckMouseDown);\n      this.puck.addEventListener('mouseup', this.onPuckMouseUp);\n    }\n\n    // Start trying to detect a buggy position:fixed implementation.\n    window.visualViewport?.addEventListener(\n      'resize',\n      this.checkForBuggyPositionFixed\n    );\n    // If the viewport has already been scaled, we might be able to detect it\n    // right away (and avoid mis-positioning the puck before the viewport is\n    // next resized).\n    this.checkForBuggyPositionFixed();\n  }\n\n  private renderIcon(icon: 'default' | 'sky'): SVGSVGElement {\n    return icon === 'default' ? this.renderDefaultIcon() : this.renderSkyIcon();\n  }\n\n  private renderDefaultIcon(): SVGSVGElement {\n    const icon = document.createElementNS(SVG_NS, 'svg');\n    icon.setAttribute('viewBox', '0 0 20 20');\n\n    const dot1 = document.createElementNS(SVG_NS, 'circle');\n    dot1.setAttribute('cx', '11.5');\n    dot1.setAttribute('cy', '10');\n    dot1.setAttribute('r', '1.5');\n    icon.append(dot1);\n\n    const dot2 = document.createElementNS(SVG_NS, 'circle');\n    dot2.setAttribute('cx', '18.5');\n    dot2.setAttribute('cy', '15.5');\n    dot2.setAttribute('r', '1.5');\n    icon.append(dot2);\n\n    const path = document.createElementNS(SVG_NS, 'path');\n    path.setAttribute(\n      'd',\n      'M4.9 7.1c-.1-.5-.2-.9-.5-1.3-.2-.4-.5-.8-.8-1.1-.2-.3-.5-.5-.8-.7C2 3.3 1 3 0 3v3c1.2 0 1.9.7 2 1.9v9.2h3V8.2c0-.4 0-.8-.1-1.1zM11.5 3c-2.8 0-5 2.3-5 5.1v3.7c0 2.8 2.2 5.1 5 5.1s5-2.3 5-5.1V8.1c0-2.8-2.2-5.1-5-5.1zm2.3 5.1v3.7c0 .3-.1.6-.2.9-.4.8-1.2 1.4-2.1 1.4s-1.7-.6-2.1-1.4c-.1-.3-.2-.6-.2-.9V8.1c0-.3.1-.6.2-.9.4-.8 1.2-1.4 2.1-1.4s1.7.6 2.1 1.4c.1.3.2.6.2.9z'\n    );\n    icon.append(path);\n\n    return icon;\n  }\n\n  private renderSkyIcon(): SVGSVGElement {\n    const icon = document.createElementNS(SVG_NS, 'svg');\n    icon.setAttribute('viewBox', '0 0 20 20');\n\n    const dot1 = document.createElementNS(SVG_NS, 'circle');\n    dot1.setAttribute('cx', '18.5');\n    dot1.setAttribute('cy', '15.5');\n    dot1.setAttribute('r', '1.5');\n    icon.append(dot1);\n\n    const dot2 = document.createElementNS(SVG_NS, 'circle');\n    dot2.setAttribute('cx', '1.5');\n    dot2.setAttribute('cy', '4.5');\n    dot2.setAttribute('r', '1.5');\n    icon.append(dot2);\n\n    const path = document.createElementNS(SVG_NS, 'path');\n    path.setAttribute(\n      'd',\n      'M3.4 3.5c.1.3.2.6.2 1s-.1.7-.2 1h4.1V8H3c-.5 0-1 .5-1 1s.5 1 1 1h4.3c-.3.9-.7 1.6-1.5 2.4-1 1-2.3 1.8-3.8 2.3-.6.2-.9.9-.7 1.5.3.5.9.8 1.4.6 2.9-1.1 5-2.9 6-5.2 1 2.3 3.1 4.1 6 5.2.5.2 1.2-.1 1.4-.6.3-.6 0-1.3-.7-1.5a9.7 9.7 0 0 1-3.8-2.3c-.8-.8-1.2-1.5-1.5-2.4h4.4c.5 0 1-.5 1-1s-.4-1-1-1H10V5.5h5.4c.5 0 1-.5 1-1s-.4-1-1-1h-12z'\n    );\n    icon.append(path);\n\n    return icon;\n  }\n\n  setTheme(theme: string) {\n    if (!this.puck) {\n      return;\n    }\n\n    for (const className of this.puck.classList.values()) {\n      if (className.startsWith('theme-')) {\n        this.puck.classList.remove(className);\n      }\n    }\n\n    this.puck.classList.add(getThemeClass(theme));\n  }\n\n  setIcon(icon: 'default' | 'sky') {\n    if (!this.puck) {\n      return;\n    }\n\n    const logo = this.puck.querySelector('.logo');\n    const logoParent = logo?.parentElement;\n    if (!logo || !logoParent) {\n      return;\n    }\n\n    const classes = logo.getAttribute('class') || '';\n\n    logo.remove();\n    const newLogo = this.renderIcon(icon);\n    newLogo.setAttribute('class', classes);\n    logoParent.append(newLogo);\n  }\n\n  unmount(): void {\n    this.restoreContent();\n    removePuck();\n    window.visualViewport?.removeEventListener(\n      'resize',\n      this.checkForBuggyPositionFixed\n    );\n    this.setEnabledState('disabled');\n    this.puck = undefined;\n  }\n\n  getEnabledState(): PuckEnabledState {\n    return this.enabledState;\n  }\n\n  setEnabledState(enabledState: PuckEnabledState): void {\n    const previousState = this.enabledState;\n    this.enabledState = enabledState;\n\n    if (enabledState === 'disabled') {\n      this.safeAreaProvider.removeEventListener(this.onSafeAreaUpdated);\n      if (this.puck) {\n        this.stopDraggingPuck();\n        this.puck.removeEventListener('pointerdown', this.onPuckPointerDown);\n        this.puck.removeEventListener('mousedown', this.onPuckMouseDown);\n        this.puck.removeEventListener('mouseup', this.onPuckMouseUp);\n      }\n      window.removeEventListener('pointerup', this.noOpEventHandler);\n      clearClickTimeout(this.clickState);\n      this.clickState = { kind: 'idle' };\n\n      // Reset puck position\n      this.puckX = Number.MAX_SAFE_INTEGER;\n      this.puckY = Number.MAX_SAFE_INTEGER;\n      this.targetOrientation = 'above';\n\n      return;\n    }\n\n    // Avoid redoing any of this setup (that's common between both 'active'\n    // and 'inactive').\n    if (previousState === 'disabled') {\n      this.safeAreaProvider.addEventListener(this.onSafeAreaUpdated);\n      if (this.puck) {\n        this.puck.addEventListener('pointerdown', this.onPuckPointerDown);\n\n        // The following event handlers are needed to cover the case where iOS\n        // Safari sometimes seems to eat the second tap in a double-tap gesture.\n        //\n        // We've tried everything to avoid this (touch-action: none,\n        // -webkit-user-select: none, etc. etc.) but it just sometimes does it.\n        //\n        // Furthermore, when debugging, after about ~1hr or so it will sometimes\n        // _stop_ eating these events, leading you to believe you've fixed it\n        // only for it to start eating them again a few minutes later.\n        //\n        // However, in this case it still dispatches _mouse_ events so we listen\n        // to them and trigger the necessary state transitions when needed.\n        //\n        // Note that the mere _presence_ of the mousedown handler is also needed\n        // to prevent double-tap being interpreted as a zoom.\n        this.puck.addEventListener('mousedown', this.onPuckMouseDown);\n        this.puck.addEventListener('mouseup', this.onPuckMouseUp);\n      }\n      // Needed to stop iOS Safari from stealing pointer events after we finish\n      // scrolling.\n      window.addEventListener('pointerup', this.noOpEventHandler);\n    }\n\n    if (this.puck) {\n      this.puck.classList.toggle(\n        'lookup-inactive',\n        this.enabledState === 'inactive'\n      );\n    }\n\n    if (this.enabledState === 'inactive') {\n      // Calling this callback allows the owner (ContentHandler) to clear any\n      // existing popups.\n      this.onLookupDisabled();\n      return;\n    }\n  }\n\n  setState(state: PuckState): void {\n    if (this.enabledState === 'disabled') {\n      return;\n    }\n\n    this.targetOrientation = state.orientation;\n    this.setPositionWithinSafeArea(state.x, state.y);\n\n    const updatedEnabledState = state.active ? 'active' : 'inactive';\n    if (this.enabledState !== updatedEnabledState) {\n      this.setEnabledState(updatedEnabledState);\n    }\n  }\n\n  notifyPuckStateChanged(): void {\n    if (this.enabledState === 'disabled') {\n      return;\n    }\n\n    this.onPuckStateChanged({\n      x: this.puckX,\n      y: this.puckY,\n      orientation: this.targetOrientation,\n      active: this.enabledState === 'active',\n    });\n  }\n\n  highlightMatch(): void {\n    // On iOS the selection API is very unreliable so we don't have a good way\n    // of indicating to the user what they looked up, unless they enable the\n    // (experimental) CSS Highlight API.\n    //\n    // So, in that case, whenever our lookup gets a match we make the moon\n    // stick to its extended position.\n    if (!isIOS() || CSS?.highlights) {\n      return;\n    }\n\n    this.puck?.classList.add('hold-position');\n  }\n\n  clearHighlight(): void {\n    this.puck?.classList.remove('hold-position');\n  }\n}\n\nexport function removePuck(): void {\n  removeContentContainer(LookupPuckId);\n}\n","import { Point } from '../../utils/geometry';\nimport { getThemeClass } from '../../utils/themes';\n\nconst POPUP_ROUNDING = 5;\n\nexport function renderArrow({\n  direction,\n  popupContainer,\n  popupPos: { x: popupX, y: popupY },\n  popupSize,\n  side,\n  target,\n  theme,\n}: {\n  direction: 'vertical' | 'horizontal';\n  popupContainer: HTMLElement;\n  popupPos: Point;\n  popupSize: { width: number; height: number };\n  side: 'before' | 'after';\n  target: Point;\n  theme: string;\n}) {\n  const arrow = document.createElement('div');\n  arrow.classList.add('arrow');\n  arrow.classList.add(getThemeClass(theme));\n  popupContainer.append(arrow);\n\n  const arrowWidth = parseFloat(getComputedStyle(arrow).width);\n  const arrowHeight = parseFloat(getComputedStyle(arrow).height);\n\n  // XXX Make the CSS rule that causes us to ignore the constrained width when\n  // tabs are on top, _not_ apply when positioning the popup left/right of\n  // vertical text.\n\n  if (direction === 'vertical') {\n    let left = target.x - arrowWidth / 2 - popupX;\n\n    // Make sure the arrow does not overlap with the rounding of the popup\n    left = Math.max(left, POPUP_ROUNDING);\n    arrow.style.left = `${left}px`;\n\n    if (side === 'before') {\n      arrow.style.top = `${popupSize.height}px`;\n      arrow.classList.add('-bottom');\n    } else {\n      arrow.style.top = `${-arrowHeight}px`;\n      arrow.classList.add('-top');\n    }\n  } else {\n    let top = target.y - arrowWidth / 2 - popupY;\n\n    top = Math.max(top, POPUP_ROUNDING);\n    arrow.style.top = `${top}px`;\n\n    if (side === 'before') {\n      arrow.style.left = `${popupSize.width}px`;\n      arrow.classList.add('-right');\n    } else {\n      arrow.style.left = `${-arrowHeight}px`;\n      arrow.classList.add('-left');\n    }\n  }\n}\n","import browser from 'webextension-polyfill';\n\nimport { svg } from '../../utils/builder';\n\nexport function renderBook(): SVGElement {\n  const bookSvg = svg(\n    'svg',\n    {\n      viewBox: '0 0 16 16',\n      role: 'presentation',\n    },\n    svg('path', {\n      d: 'M14,2H10.09a2.16,2.16,0,0,0-.71.12l-1.11.41a.83.83,0,0,1-.54,0L6.62,2.12A2.16,2.16,0,0,0,5.91,2H2A2,2,0,0,0,0,4v8a2,2,0,0,0,2.05,2H5.91a.76.76,0,0,1,.27.05l1.12.4a1.95,1.95,0,0,0,1.4,0L10.33,14l.84,0a.84.84,0,0,0,.71-.8c0-.67-.76-.69-.76-.69a5.17,5.17,0,0,0-1.25.12L9,13V4l.07,0,1.11-.4a.86.86,0,0,1,.27,0h3.27a.78.78,0,0,1,.78.78V9A.75.75,0,0,0,16,9V4A2,2,0,0,0,14,2ZM7,13l-.76-.33a1.85,1.85,0,0,0-.7-.13H2.28a.78.78,0,0,1-.78-.78V4.28a.78.78,0,0,1,.78-.78H5.54a.75.75,0,0,1,.26,0L6.92,4,7,4Z',\n    })\n  );\n\n  const lineGroup = svg('g', {\n    fill: 'none',\n    stroke: 'currentColor',\n    'stroke-linecap': 'round',\n  });\n  bookSvg.append(lineGroup);\n\n  const lines = [\n    [3, 7.5, 5.5, 7.5],\n    [3, 5.5, 5.5, 5.5],\n    [3, 9.5, 5.5, 9.5],\n    [10.5, 7.5, 13, 7.5],\n    [10.5, 5.5, 13, 5.5],\n    [10.5, 9.5, 11.5, 9.5],\n  ];\n  for (const [x1, y1, x2, y2] of lines) {\n    const line = svg('line', {\n      x1: String(x1),\n      y1: String(y1),\n      x2: String(x2),\n      y2: String(y2),\n    });\n    lineGroup.append(line);\n  }\n\n  const circle = svg('circle', {\n    cx: '14.5',\n    cy: '12.5',\n    r: '1.5',\n  });\n  bookSvg.append(circle);\n\n  return bookSvg;\n}\n\nexport function renderClipboard(): SVGElement {\n  return svg(\n    'svg',\n    {\n      viewBox: '0 0 24 24',\n      role: 'presentation',\n      fill: 'currentColor',\n    },\n    svg('circle', {\n      cx: '19.5',\n      cy: '21.5',\n      r: '1.5',\n    }),\n    svg('path', {\n      d: 'M10.46 5.54c0-.89.7-1.61 1.54-1.61s1.54.72 1.54 1.61v.65c0 .17-.14.32-.31.32h-2.46a.32.32 0 0 1-.31-.32v-.65zM15.97 20H6.9c-.5 0-.9-.46-.9-1V7.48c0-.54.4-.97.9-.97h1.74a2.19 2.19 0 0 0 2.13 1.94h2.46c1.07 0 1.98-.83 2.13-1.94h1.7c.5 0 .94.43.94.97V18a1 1 0 0 0 2 0V7.48c0-1.6-1.42-2.9-2.94-2.9h-1.8a3.37 3.37 0 0 0-4.2-2.44c-1.12.33-2 1.26-2.32 2.43H6.9c-1.53 0-2.9 1.3-2.9 2.9V19c0 1.6 1.47 3 3 3h8.97a1 1 0 1 0 0-2z',\n    })\n  );\n}\n\nexport function renderCog(): SVGElement {\n  return svg(\n    'svg',\n    { viewBox: '0 0 24 24' },\n    svg('circle', {\n      cx: '21.5',\n      cy: '21.5',\n      r: '1.5',\n      fill: 'currentColor',\n      stroke: 'none',\n    }),\n    svg('circle', {\n      cx: '12',\n      cy: '12',\n      r: '4',\n    }),\n    svg('path', {\n      d: 'M10.48 3.28a2 2 0 003 0 2.05 2.05 0 013.57 1.48 2.05 2.05 0 002.15 2.15 2.05 2.05 0 011.48 3.57 2 2 0 000 3 2.05 2.05 0 01-1.48 3.57 2.05 2.05 0 00-2.15 2.15 2.05 2.05 0 01-3.57 1.48 2 2 0 00-3 0 2.05 2.05 0 01-3.57-1.48 2.05 2.05 0 00-2.15-2.15 2.05 2.05 0 01-1.48-3.57 2 2 0 000-3 2.05 2.05 0 011.48-3.57 2.05 2.05 0 002.15-2.15 2.05 2.05 0 013.57-1.48z',\n    })\n  );\n}\n\nexport function renderCross(): SVGElement {\n  return svg(\n    'svg',\n    { viewBox: '0 0 24 24' },\n    svg('path', { d: 'M6 18L18 6M6 6l12 12' })\n  );\n}\n\nexport function renderKanjiIcon(): SVGElement {\n  return svg(\n    'svg',\n    {\n      viewBox: '0 0 16 16',\n      role: 'presentation',\n    },\n    svg('circle', {\n      cx: '14.5',\n      cy: '14.5',\n      r: '1.5',\n    }),\n    svg('path', {\n      d: 'M11,15H2a2,2,0,0,1-2-2V2A2,2,0,0,1,2,0H13a2,2,0,0,1,2,2v9a1,1,0,0,1-2,0V2H2V13h9a1,1,0,0,1,0,2Z',\n    }),\n    svg('path', {\n      d: 'M8.5,7H5V6h5V7H9.5l-1,1H12V9H8v2a1,1,0,0,1-.24.71A1.15,1.15,0,0,1,7,12H6V11H7V9H3V8H7.5ZM8,4h4V6H11V5H4V6H3V4H7V3H8Z',\n    })\n  );\n}\n\nexport function renderPerson(): SVGElement {\n  return svg(\n    'svg',\n    {\n      viewBox: '0 0 16 16',\n      role: 'presentation',\n    },\n    svg('circle', {\n      cx: '14.5',\n      cy: '14.5',\n      r: '1.5',\n    }),\n    svg('path', {\n      d: 'M8,0A2.87,2.87,0,0,0,5,2.72v2.5A2.92,2.92,0,0,0,8,8a2.92,2.92,0,0,0,3-2.78V2.72A2.87,2.87,0,0,0,8,0Z',\n    }),\n    svg('path', {\n      d: 'M13.91,11.71A5.09,5.09,0,0,0,9.45,9H5.09A5.18,5.18,0,0,0,0,14.25.74.74,0,0,0,.73,15h10.9a.74.74,0,0,0,.73-.75,1.49,1.49,0,0,1,1.09-1.45.75.75,0,0,0,.49-.43A.76.76,0,0,0,13.91,11.71Z',\n    })\n  );\n}\n\nexport function renderPin(): SVGElement {\n  return svg(\n    'svg',\n    {\n      role: 'presentation',\n      viewBox: '0 0 24 24',\n    },\n    svg('path', {\n      d: 'm14 3 .593 1.833c.104.295.157.604.157.917v3.42l.666.236a2.759 2.759 0 0 1 1.834 2.591c0 .05 0 .197-.33.253a3.504 3.504 0 0 0-3.42 3.499c-.029.065-.283.251-.5.251h-1v4.75V16H8.904a2.156 2.156 0 0 1-2.154-2.154v-1.849a2.75 2.75 0 0 1 1.833-2.592l.667-.235V5.75c0-.313.053-.622.157-.916L10 3H8h8-2z',\n      fill: 'none',\n      stroke: 'currentColor',\n    }),\n    svg('circle', {\n      cx: '18', // 18\n      cy: '16.5', // 16.5\n      r: '1.5',\n      fill: 'currentColor',\n      stroke: 'none',\n    })\n  );\n}\n\nexport function renderSpinner(): SVGElement {\n  return svg(\n    'svg',\n    {\n      viewBox: '0 0 16 16',\n      role: 'presentation',\n    },\n    svg('path', {\n      d: 'M8.54,2.11l.66-.65A.78.78,0,0,0,9.2.38a.76.76,0,0,0-1.08,0L6.19,2.31A.81.81,0,0,0,6,2.55a.8.8,0,0,0-.06.3A.72.72,0,0,0,6,3.14a.74.74,0,0,0,.17.25L8.12,5.32a.73.73,0,0,0,.54.22.76.76,0,0,0,.54-.22.78.78,0,0,0,0-1.08l-.58-.58A4.38,4.38,0,1,1,3.68,8.82a.76.76,0,0,0-1.5.28,5.92,5.92,0,1,0,6.36-7Z',\n    }),\n    svg('circle', {\n      cx: '2.673',\n      cy: '6.71',\n      r: '0.965',\n    })\n  );\n}\n\nexport function renderStar(style: 'full' | 'hollow'): SVGElement {\n  const message =\n    style === 'full'\n      ? 'entry_priority_label_high'\n      : 'entry_priority_label_regular';\n\n  return svg(\n    'svg',\n    {\n      class: 'svgicon',\n      viewBox: '0 0 98.6 93.2',\n      style: 'opacity: 0.5',\n    },\n    svg('title', {}, browser.i18n.getMessage(message)),\n    svg('path', {\n      d:\n        style === 'full'\n          ? 'M98 34a4 4 0 00-3-1l-30-4L53 2a4 4 0 00-7 0L33 29 4 33a4 4 0 00-3 6l22 20-6 29a4 4 0 004 5 4 4 0 002 0l26-15 26 15a4 4 0 002 0 4 4 0 004-4 4 4 0 000-1l-6-29 22-20a4 4 0 001-5z'\n          : 'M77 93a4 4 0 004-4 4 4 0 000-1l-6-29 22-20a4 4 0 00-2-6l-30-4L53 2a4 4 0 00-7 0L33 29 4 33a4 4 0 00-3 6l22 20-6 29a4 4 0 004 5 4 4 0 002 0l26-15 26 15a4 4 0 002 0zm-5-12L51 70a4 4 0 00-4 0L27 81l5-22a4 4 0 00-1-4L13 40l23-3a4 4 0 004-2l9-21 10 21a4 4 0 003 2l23 3-17 15a4 4 0 00-1 4z',\n    })\n  );\n}\n","import browser from 'webextension-polyfill';\n\nimport { html } from '../../utils/builder';\n\nimport { renderCross } from './icons';\n\nexport function renderCloseButton(\n  onClosePopup: () => void,\n  closeShortcuts: ReadonlyArray<string>\n): HTMLElement {\n  const label = browser.i18n.getMessage('popup_close_label');\n  const title = closeShortcuts.length\n    ? `${label} (${closeShortcuts.join(' / ')})`\n    : label;\n  const closeButton = html(\n    'button',\n    {\n      'aria-label': label,\n      title,\n      class: 'close-button',\n      type: 'button',\n    },\n    renderCross()\n  );\n  closeButton.onclick = (event: MouseEvent) => {\n    event.preventDefault();\n    onClosePopup();\n  };\n\n  return html('div', { class: 'close' }, closeButton);\n}\n","import browser from 'webextension-polyfill';\n\n// Cache language tag since we fetch it a lot\nlet langTag: string | null = null;\nexport function getLangTag() {\n  if (langTag === null) {\n    langTag = browser.i18n.getMessage('lang_tag');\n  }\n  return langTag;\n}\n\nexport function clearLangTagCache() {\n  langTag = null;\n}\n","import { MajorDataSeries } from '@birchill/jpdict-idb';\nimport browser from 'webextension-polyfill';\n\nimport { CopyType } from '../../common/copy-keys';\nimport { ReferenceAbbreviation } from '../../common/refs';\nimport { html, svg } from '../../utils/builder';\n\nimport { getTextToCopy } from '../copy-text';\nimport { getCopyEntryFromResult } from '../get-copy-entry';\nimport { QueryResult } from '../query';\n\nimport { CopyState } from './copy-state';\nimport { renderClipboard } from './icons';\nimport { getLangTag } from './lang-tag';\n\nexport function renderCopyOverlay({\n  copyState,\n  includeAllSenses,\n  includeLessCommonHeadwords,\n  includePartOfSpeech,\n  kanjiReferences,\n  onCancelCopy,\n  onCopy,\n  result,\n  series,\n  showKanjiComponents,\n}: {\n  copyState: CopyState;\n  includeAllSenses: boolean;\n  includeLessCommonHeadwords: boolean;\n  includePartOfSpeech: boolean;\n  kanjiReferences: Array<ReferenceAbbreviation>;\n  onCancelCopy?: () => void;\n  onCopy?: (copyType: CopyType) => void;\n  result?: QueryResult;\n  series: MajorDataSeries;\n  showKanjiComponents?: boolean;\n}): HTMLDivElement {\n  const copyOverlay = html('div', { class: 'copy-overlay' });\n\n  // Work out what we would copy so we can generate suitable preview text\n  const entryToCopy = result\n    ? getCopyEntryFromResult({\n        result,\n        series,\n        index: copyState.kind !== 'inactive' ? copyState.index : 0,\n      })\n    : null;\n\n  // Heading\n  const wordToCopy = entryToCopy\n    ? getTextToCopy({\n        entry: entryToCopy,\n        copyType: 'word',\n        getMessage: browser.i18n.getMessage.bind(browser.i18n),\n      })\n    : null;\n  const heading = wordToCopy\n    ? browser.i18n.getMessage(\n        'content_copy_overlay_copy_title_with_word',\n        wordToCopy\n      )\n    : browser.i18n.getMessage('content_copy_overlay_copy_title');\n  copyOverlay.append(\n    html(\n      'div',\n      {\n        role: 'heading',\n        class: 'copy-heading',\n        lang: getLangTag(),\n      },\n      heading\n    )\n  );\n\n  // Options\n  const list = copyOverlay.appendChild(html('ul', { class: 'copy-options' }));\n\n  // Entry button\n  {\n    const entryPreviewText = entryToCopy\n      ? getTextToCopy({\n          entry: entryToCopy,\n          copyType: 'entry',\n          getMessage: browser.i18n.getMessage.bind(browser.i18n),\n          includeAllSenses,\n          includeLessCommonHeadwords,\n          includePartOfSpeech,\n          kanjiReferences,\n          showKanjiComponents,\n        })\n      : undefined;\n    const button = renderButtonWithPreview({\n      label: browser.i18n.getMessage('content_copy_overlay_entry_button'),\n      previewText: entryPreviewText,\n    });\n    button.addEventListener('click', () => onCopy?.('entry'));\n    list.append(html('li', {}, button));\n  }\n\n  // Tab-separated button\n  {\n    const tabSeparatedPreviewText = entryToCopy\n      ? getTextToCopy({\n          entry: entryToCopy,\n          copyType: 'tab',\n          getMessage: browser.i18n.getMessage.bind(browser.i18n),\n          includeAllSenses,\n          includeLessCommonHeadwords,\n          includePartOfSpeech,\n          kanjiReferences,\n          showKanjiComponents,\n        }).replace(/\\t/g, ' → ')\n      : undefined;\n    const button = renderButtonWithPreview({\n      label: browser.i18n.getMessage(\n        'content_copy_overlay_tab_separated_button'\n      ),\n      previewText: tabSeparatedPreviewText,\n    });\n    button.addEventListener('click', () => onCopy?.('tab'));\n    list.append(html('li', {}, button));\n  }\n\n  // Word button\n  {\n    const copyWordButton = list\n      .appendChild(html('li'))\n      .appendChild(html('button', { class: '-icon-label' }));\n\n    if (wordToCopy) {\n      const icon = renderClipboard();\n      icon.classList.add('icon');\n      copyWordButton.append(icon);\n    }\n    const copyWordLabel = html('span');\n    if (wordToCopy) {\n      copyWordLabel.append(wordToCopy);\n      copyWordLabel.lang = 'ja';\n    } else {\n      copyWordLabel.append(\n        browser.i18n.getMessage(\n          series === 'kanji'\n            ? 'content_copy_overlay_kanji_button'\n            : 'content_copy_overlay_word_button'\n        )\n      );\n      copyWordLabel.lang = getLangTag();\n    }\n    copyWordButton.append(copyWordLabel);\n    copyWordButton.addEventListener('click', () => onCopy?.('word'));\n  }\n\n  // Cancel button\n  const cancelButton = html(\n    'button',\n    {\n      class: 'cancel-button',\n      lang: getLangTag(),\n    },\n    svg(\n      'svg',\n      {\n        class: 'icon',\n        viewBox: '0 0 24 24',\n        stroke: 'currentColor',\n        'stroke-width': '2',\n      },\n      svg('path', { d: 'M6 18L18 6M6 6l12 12' })\n    ),\n    browser.i18n.getMessage('content_copy_overlay_cancel_button')\n  );\n  cancelButton.addEventListener('click', () => onCancelCopy?.());\n  copyOverlay.append(cancelButton);\n\n  return copyOverlay;\n}\n\nfunction renderButtonWithPreview({\n  label,\n  previewText,\n}: {\n  label: string;\n  previewText?: string;\n}) {\n  const button = html('button', { lang: getLangTag() }, label);\n\n  if (previewText) {\n    const previewRow = html('div', {\n      class: 'copy-preview',\n      role: 'presentation',\n    });\n\n    const icon = renderClipboard();\n    icon.classList.add('icon');\n    previewRow.append(icon);\n\n    previewRow.append(html('span', { lang: 'ja' }, previewText));\n\n    button.append(previewRow);\n  }\n\n  return button;\n}\n","export function round(number: number, precision: number): number {\n  const factor = Math.pow(10, precision);\n  return Math.round((number + Number.EPSILON) * factor) / factor;\n}\n","import browser from 'webextension-polyfill';\n\nimport { html, svg } from '../../utils/builder';\nimport { round } from '../../utils/round';\n\nexport function updateExpandable(\n  expandable: HTMLElement,\n  options: {\n    expandShortcuts?: ReadonlyArray<string>;\n    isExpanded: boolean;\n    onExpandPopup?: () => void;\n    showKeyboardShortcut?: boolean;\n  }\n) {\n  if (options.isExpanded) {\n    // We style kanji content differently depending on whether or not we're in\n    // the (manually) expanded state.\n    //\n    // Specifically, when we're not expanded, we lay out the kanji in a grid\n    // such that each kanji table has the same height so that you can scroll\n    // through the kanji one-by-one and even if later kanji tables are bigger,\n    // they still fit in the popup.\n    //\n    // When the popup is expanded, however, that's not necessary. Ironically,\n    // that means that the \"expanded\" state is actually smaller than the\n    // \"collapsed\" state.\n    expandable.classList.add('expanded');\n\n    // In all cases, if we're in the (manually) expanded state we never need to\n    // worry about constraining the height or showing the expand button so we're\n    // done here.\n    return;\n  }\n\n  // Calculate the preferred expanded height\n  //\n  // Note that this is the height _before_ adding the expand button.\n  // i.e. if we have this much room, we don't need the expand button and the\n  // extra space it requires.\n  const { top: expandableTop, height: expandedHeight } =\n    expandable.getBoundingClientRect();\n\n  // Calculate the collapsed height\n  const foldPoint = getFoldPoint(expandable);\n  const collapsedHeight =\n    foldPoint === null ? expandedHeight : foldPoint - expandableTop;\n\n  // Work out if we are effectively collapsed\n  //\n  // Note that \"effectively\" collapsed is not quite the same as\n  // `!options.isExpanded` as if we have no fold point (or the fold point occurs\n  // at the end of the content) then even if `options.isExpanded` is false,\n  // we are not collapsed.\n  //\n  // This is almost always going to be the same as `foldPoint !== null` but just\n  // in case we add a fold point at the end of the content we compare the\n  // collapsedHeight to the expandedHeight.\n  const isCollapsed = expandedHeight - collapsedHeight > 1;\n\n  // Set an explicit height on the expandable so that we can add a\n  // `position: sticky` expand button without it affecting the height.\n  expandable.style.height = isCollapsed\n    ? // Add in some extra space for the expand button\n      `calc(${round(collapsedHeight, 2)}px + var(--expand-button-allowance))`\n    : `${expandedHeight}px`;\n\n  // Add a `position: sticky` expand button to the bottom of the content\n  const label = browser.i18n.getMessage('popup_expand_label');\n  const title = options.expandShortcuts?.length\n    ? `${label} (${options.expandShortcuts.join(' / ')})`\n    : label;\n  const expandButton = html(\n    'button',\n    { class: 'expand-button', title, type: 'button' },\n    svg(\n      'svg',\n      { class: 'icon', viewBox: '0 0 24 24', role: 'presentation' },\n      svg('path', {\n        fill: 'currentColor',\n        d: 'M21 6c1.7 0 2.6 2 1.4 3.2L13.5 20c-.7.9-2.3.9-3 0L1.6 9.2C.4 8 1.3 6 3 6h18z',\n      })\n    )\n  );\n  expandButton.addEventListener('click', () => {\n    options.onExpandPopup?.();\n  });\n  if (options.showKeyboardShortcut && options.expandShortcuts?.length) {\n    expandButton.append(html('kbd', {}, options.expandShortcuts[0]));\n  }\n  expandable.append(expandButton);\n\n  // Hide the button if we are not currently collapsed\n  if (!isCollapsed) {\n    expandButton.style.display = 'none';\n  }\n\n  // Hide/show the expand button in response to changes to the available content\n  // height.\n  //\n  // There are two cases where this is necessary.\n  //\n  // a) Once we apply any height constraints to the popup, even if there is no\n  //    fold point, there might not be enough room for the content so we want\n  //    to show the expand button to provide a consistent experience.\n  //\n  //    (The user doesn't care if the content is hidden due to the popup height\n  //    constraints or self-inflicted \"hide everything below the fold point\"\n  //    constraints. They just expect to be able to press the expand button to\n  //    see everything.)\n  //\n  //    However, until we actually position the popup and possibly constrain its\n  //    height we won't know whether or not the content fits.\n  //\n  // b) A specific case where we actually enlarge the content area by activating\n  //    and then clearing the copy overlay:\n  //\n  //    1. The expandable is collapsed.\n  //    2. The user clicks on the top entry to activate the copy screen\n  //       overlay.\n  //    3. When the copy screen overlay is active, we enlarge the size of the\n  //       popup so that all the copy buttons are visible.\n  //    4. Then, when the user exits copy mode we ensure that the height\n  //       doesn't change (unless they've pinned the window) so that they don't\n  //       suddenly find themselves in a situation where their mouse is outside\n  //       the window.\n  //\n  //    At this point, depending on the size of the content being shown, we can\n  //    arrive at a situation where the content in the expandable is fully\n  //    visible, despite having a fold point.\n  //\n  //    If we continue showing the expand button in that situation it not only\n  //    looks odd, if the user _were_ to click it the window would shrink\n  //    leaving their mouse outside of it.\n  //\n  //    We _could_ handle this by simply forcing the popup to be expanded as\n  //    soon as the user ends copy mode. That would be simplest but it sometimes\n  //    means that when you go to copy an entry the popup becomes MASSIVE which\n  //    is not the nicest user experience.\n  //\n  //    Instead, we try to do the nice thing and expand the popup just enough\n  //    to show the copy controls, then keep it just that big when the user\n  //    exits copy mode.\n  //\n  const resizeObserver = new ResizeObserver(\n    (entries: Array<ResizeObserverEntry>) => {\n      for (const entry of entries) {\n        const { blockSize: expandableRenderedHeight } = entry.contentBoxSize[0];\n        if (!expandableRenderedHeight) {\n          return;\n        }\n\n        // From my tests in Firefox and Chrome, even if we refer to the button\n        // via `expandButton`, once the popup is removed from the DOM, the\n        // ResizeObserver closure is successfully garbage/cycle collected\n        // (despite claims to the contrary [1][2]).\n        //\n        // With Safari I don't know what is going on. It never seems to reclaim\n        // the memory but that might just be because garbage collection is very\n        // lazy.\n        //\n        // In any case, it's probably safer to _not_ hold onto a reference to\n        // the expandable or any of its contents and instead look up the button\n        // from the ResizeObserver entry.\n        //\n        // [1] https://github.com/w3c/csswg-drafts/issues/5155#issuecomment-1382387212\n        // [2] https://bugzilla.mozilla.org/show_bug.cgi?id=1596992#c10\n\n        const button =\n          entry.target.querySelector<HTMLElement>('.expand-button');\n        if (!button) {\n          return;\n        }\n\n        button.style.display =\n          expandedHeight - expandableRenderedHeight < 1 ? 'none' : '';\n      }\n    }\n  );\n  resizeObserver.observe(expandable);\n\n  // Turn on scroll snapping after the window has been resized\n  //\n  // In Firefox we can set this from the outset but for Chrome and Safari if\n  // we do that, it seems like we end up re-snapping at some point and the list\n  // jumps randomly, often to somewhere in the middle or end.\n  requestAnimationFrame(() => {\n    expandable.style.scrollSnapType = 'y mandatory';\n  });\n}\n\nfunction getFoldPoint(expandable: HTMLElement): number | null {\n  const foldPointElem = expandable.querySelector('.fold-point');\n  if (!foldPointElem) {\n    return null;\n  }\n\n  // The fold point is `display: contents` so that it doesn't affect the layout\n  // of any grid or flex elements it is added too but that also means that we\n  // can't measure it's position directly.\n  //\n  // Instead we take the point between its direct siblings.\n  const prev = foldPointElem.previousElementSibling;\n  const next = foldPointElem.nextElementSibling;\n  if (!prev || !next) {\n    return null;\n  }\n  const { bottom: previousBottom } = prev.getBoundingClientRect();\n  const { top: nextTop } = next.getBoundingClientRect();\n\n  return previousBottom + (nextTop - previousBottom) / 2;\n}\n","/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 16;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 17;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","import { EMPTY_ARR } from './constants';\n\nexport const isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-expect-error We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {preact.ContainerNode} node The node to remove\n */\nexport function removeNode(node) {\n\tif (node && node.parentNode) node.parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import { slice } from './util';\nimport options from './options';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\t/** @type {VNode} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: original == null ? ++vnodeId : original,\n\t\t_index: -1,\n\t\t_flags: 0\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == null && options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor == undefined;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\nimport { MODE_HYDRATE } from './constants';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function BaseComponent(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._index + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet oldVNode = component._vnode,\n\t\toldDom = oldVNode._dom,\n\t\tcommitQueue = [],\n\t\trefQueue = [];\n\n\tif (component._parentDom) {\n\t\tconst newVNode = assign({}, oldVNode);\n\t\tnewVNode._original = oldVNode._original + 1;\n\t\tif (options.vnode) options.vnode(newVNode);\n\n\t\tdiff(\n\t\t\tcomponent._parentDom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tcomponent._parentDom.namespaceURI,\n\t\t\toldVNode._flags & MODE_HYDRATE ? [oldDom] : null,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(oldVNode) : oldDom,\n\t\t\t!!(oldVNode._flags & MODE_HYDRATE),\n\t\t\trefQueue\n\t\t);\n\n\t\tnewVNode._original = oldVNode._original;\n\t\tnewVNode._parent._children[newVNode._index] = newVNode;\n\t\tcommitRoot(commitQueue, newVNode, refQueue);\n\n\t\tif (newVNode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(newVNode);\n\t\t}\n\t}\n}\n\n/**\n * @param {VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {Component} a\n * @param {Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c;\n\trerenderQueue.sort(depthSort);\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile ((c = rerenderQueue.shift())) {\n\t\tif (c._dirty) {\n\t\t\tlet renderQueueLength = rerenderQueue.length;\n\t\t\trenderComponent(c);\n\t\t\tif (rerenderQueue.length > renderQueueLength) {\n\t\t\t\t// When i.e. rerendering a provider additional new items can be injected, we want to\n\t\t\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t\t\t// single pass\n\t\t\t\trerenderQueue.sort(depthSort);\n\t\t\t}\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value == null ? '' : value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nlet eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {string} namespace Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, namespace) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture =\n\t\t\tname !== (name = name.replace(/(PointerCapture)$|Capture$/i, '$1'));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (\n\t\t\tname.toLowerCase() in dom ||\n\t\t\tname === 'onFocusOut' ||\n\t\t\tname === 'onFocusIn'\n\t\t)\n\t\t\tname = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tvalue._attached = eventClock;\n\t\t\t\tdom.addEventListener(\n\t\t\t\t\tname,\n\t\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\t\tuseCapture\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvalue._attached = oldValue._attached;\n\t\t\t}\n\t\t} else {\n\t\t\tdom.removeEventListener(\n\t\t\t\tname,\n\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\tuseCapture\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (namespace == 'http://www.w3.org/2000/svg') {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname != 'width' &&\n\t\t\tname != 'height' &&\n\t\t\tname != 'href' &&\n\t\t\tname != 'list' &&\n\t\t\tname != 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname != 'tabIndex' &&\n\t\t\tname != 'download' &&\n\t\t\tname != 'rowSpan' &&\n\t\t\tname != 'colSpan' &&\n\t\t\tname != 'role' &&\n\t\t\tname != 'popover' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\n\t\tif (typeof value == 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != null && (value !== false || name[4] === '-')) {\n\t\t\tdom.setAttribute(name, name == 'popover' && value == true ? '' : value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n\t/**\n\t * Proxy an event to hooked event handlers\n\t * @param {PreactEvent} e The event object from the browser\n\t * @private\n\t */\n\treturn function (e) {\n\t\tif (this._listeners) {\n\t\t\tconst eventHandler = this._listeners[e.type + useCapture];\n\t\t\tif (e._dispatched == null) {\n\t\t\t\te._dispatched = eventClock++;\n\n\t\t\t\t// When `e._dispatched` is smaller than the time when the targeted event\n\t\t\t\t// handler was attached we know we have bubbled up to an element that was added\n\t\t\t\t// during patching the DOM.\n\t\t\t} else if (e._dispatched < eventHandler._attached) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn eventHandler(options.event ? options.event(e) : e);\n\t\t}\n\t};\n}\n\nconst eventProxy = createEventProxy(false);\nconst eventProxyCapture = createEventProxy(true);\n","import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\t/** @type {FunctionComponent} */\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\t/** @type {FunctionComponent} */\n\t\tProvider(props) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\t/** @type {Component[] | null} */\n\t\t\t\tlet subs = [];\n\t\t\t\tlet ctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\t\tsubs = null;\n\t\t\t\t};\n\n\t\t\t\tthis.shouldComponentUpdate = function (_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\tsubs.some(c => {\n\t\t\t\t\t\t\tc._force = true;\n\t\t\t\t\t\t\tenqueueRender(c);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tif (subs) {\n\t\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType =\n\t\tcontext);\n}\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR, INSERT_VNODE, MATCHED } from '../constants';\nimport { isArray } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\tlet i,\n\t\t/** @type {VNode} */\n\t\toldVNode,\n\t\t/** @type {VNode} */\n\t\tchildVNode,\n\t\t/** @type {PreactElement} */\n\t\tnewDom,\n\t\t/** @type {PreactElement} */\n\t\tfirstChildDom;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\t/** @type {VNode[]} */\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet newChildrenLength = renderResult.length;\n\n\tnewParentVNode._nextDom = oldDom;\n\tconstructNewChildrenArray(newParentVNode, renderResult, oldChildren);\n\toldDom = newParentVNode._nextDom;\n\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\tchildVNode = newParentVNode._children[i];\n\t\tif (childVNode == null) continue;\n\n\t\t// At this point, constructNewChildrenArray has assigned _index to be the\n\t\t// matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n\t\tif (childVNode._index === -1) {\n\t\t\toldVNode = EMPTY_OBJ;\n\t\t} else {\n\t\t\toldVNode = oldChildren[childVNode._index] || EMPTY_OBJ;\n\t\t}\n\n\t\t// Update childVNode._index to its final index\n\t\tchildVNode._index = i;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\n\t\t// Adjust DOM nodes\n\t\tnewDom = childVNode._dom;\n\t\tif (childVNode.ref && oldVNode.ref != childVNode.ref) {\n\t\t\tif (oldVNode.ref) {\n\t\t\t\tapplyRef(oldVNode.ref, null, childVNode);\n\t\t\t}\n\t\t\trefQueue.push(\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildVNode._component || newDom,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t}\n\n\t\tif (firstChildDom == null && newDom != null) {\n\t\t\tfirstChildDom = newDom;\n\t\t}\n\n\t\tif (\n\t\t\tchildVNode._flags & INSERT_VNODE ||\n\t\t\toldVNode._children === childVNode._children\n\t\t) {\n\t\t\toldDom = insert(childVNode, oldDom, parentDom);\n\t\t} else if (\n\t\t\ttypeof childVNode.type == 'function' &&\n\t\t\tchildVNode._nextDom !== undefined\n\t\t) {\n\t\t\t// Since Fragments or components that return Fragment like VNodes can\n\t\t\t// contain multiple DOM nodes as the same level, continue the diff from\n\t\t\t// the sibling of last DOM child of this child VNode\n\t\t\toldDom = childVNode._nextDom;\n\t\t} else if (newDom) {\n\t\t\toldDom = newDom.nextSibling;\n\t\t}\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because it\n\t\t// is only used by `diffChildren` to determine where to resume the diff\n\t\t// after diffing Components and Fragments. Once we store it the nextDOM\n\t\t// local var, we can clean up the property. Also prevents us hanging on to\n\t\t// DOM nodes that may have been unmounted.\n\t\tchildVNode._nextDom = undefined;\n\n\t\t// Unset diffing flags\n\t\tchildVNode._flags &= ~(INSERT_VNODE | MATCHED);\n\t}\n\n\t// TODO: With new child diffing algo, consider alt ways to diff Fragments.\n\t// Such as dropping oldDom and moving fragments in place\n\t//\n\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t// _nextDom property to the nextSibling of its last child DOM node.\n\t//\n\t// `oldDom` contains the correct value here because if the last child\n\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t// node's nextSibling.\n\tnewParentVNode._nextDom = oldDom;\n\tnewParentVNode._dom = firstChildDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(newParentVNode, renderResult, oldChildren) {\n\t/** @type {number} */\n\tlet i;\n\t/** @type {VNode} */\n\tlet childVNode;\n\t/** @type {VNode} */\n\tlet oldVNode;\n\n\tconst newChildrenLength = renderResult.length;\n\tlet oldChildrenLength = oldChildren.length,\n\t\tremainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\t// @ts-expect-error We are reusing the childVNode variable to hold both the\n\t\t// pre and post normalized childVNode\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == null ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t\tcontinue;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint' ||\n\t\t\tchildVNode.constructor == String\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode.constructor === undefined && childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : null,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\tconst skewedIndex = i + skew;\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Temporarily store the matchingIndex on the _index property so we can pull\n\t\t// out the oldVNode in diffChildren. We'll override this to the VNode's\n\t\t// final index after using this property to get the oldVNode\n\t\tconst matchingIndex = (childVNode._index = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t));\n\n\t\toldVNode = null;\n\t\tif (matchingIndex !== -1) {\n\t\t\toldVNode = oldChildren[matchingIndex];\n\t\t\tremainingOldChildren--;\n\t\t\tif (oldVNode) {\n\t\t\t\toldVNode._flags |= MATCHED;\n\t\t\t}\n\t\t}\n\n\t\t// Here, we define isMounting for the purposes of the skew diffing\n\t\t// algorithm. Nodes that are unsuspending are considered mounting and we detect\n\t\t// this by checking if oldVNode._original === null\n\t\tconst isMounting = oldVNode == null || oldVNode._original === null;\n\n\t\tif (isMounting) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\tskew--;\n\t\t\t}\n\n\t\t\t// If we are mounting a DOM VNode, mark it for insertion\n\t\t\tif (typeof childVNode.type != 'function') {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t} else if (matchingIndex !== skewedIndex) {\n\t\t\t// When we move elements around i.e. [0, 1, 2] --> [1, 0, 2]\n\t\t\t// --> we diff 1, we find it at position 1 while our skewed index is 0 and our skew is 0\n\t\t\t//     we set the skew to 1 as we found an offset.\n\t\t\t// --> we diff 0, we find it at position 0 while our skewed index is at 2 and our skew is 1\n\t\t\t//     this makes us increase the skew again.\n\t\t\t// --> we diff 2, we find it at position 2 while our skewed index is at 4 and our skew is 2\n\t\t\t//\n\t\t\t// this becomes an optimization question where currently we see a 1 element offset as an insertion\n\t\t\t// or deletion i.e. we optimize for [0, 1, 2] --> [9, 0, 1, 2]\n\t\t\t// while a more than 1 offset we see as a swap.\n\t\t\t// We could probably build heuristics for having an optimized course of action here as well, but\n\t\t\t// might go at the cost of some bytes.\n\t\t\t//\n\t\t\t// If we wanted to optimize for i.e. only swaps we'd just do the last two code-branches and have\n\t\t\t// only the first item be a re-scouting and all the others fall in their skewed counter-part.\n\t\t\t// We could also further optimize for swaps\n\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\tskew--;\n\t\t\t} else if (matchingIndex == skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t} else {\n\t\t\t\tif (matchingIndex > skewedIndex) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\n\t\t\t\t// Move this VNode's DOM if the original index (matchingIndex) doesn't\n\t\t\t\t// match the new skew index (i + new skew)\n\t\t\t\t// In the former two branches we know that it matches after skewing\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any. Loop forwards so that as we\n\t// unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n\t// point to the next child, which needs to be the first DOM node that won't be\n\t// unmounted.\n\tif (remainingOldChildren) {\n\t\tfor (i = 0; i < oldChildrenLength; i++) {\n\t\t\toldVNode = oldChildren[i];\n\t\t\tif (oldVNode != null && (oldVNode._flags & MATCHED) === 0) {\n\t\t\t\tif (oldVNode._dom == newParentVNode._nextDom) {\n\t\t\t\t\tnewParentVNode._nextDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\n\tif (typeof parentVNode.type == 'function') {\n\t\tlet children = parentVNode._children;\n\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\tif (children[i]) {\n\t\t\t\t// If we enter this code path on sCU bailout, where we copy\n\t\t\t\t// oldVNode._children to newVNode._children, we need to update the old\n\t\t\t\t// children's _parent pointer to point to the newVNode (parentVNode\n\t\t\t\t// here).\n\t\t\t\tchildren[i]._parent = parentVNode;\n\t\t\t\toldDom = insert(children[i], oldDom, parentDom);\n\t\t\t}\n\t\t}\n\n\t\treturn oldDom;\n\t} else if (parentVNode._dom != oldDom) {\n\t\tif (oldDom && parentVNode.type && !parentDom.contains(oldDom)) {\n\t\t\toldDom = getDomSibling(parentVNode);\n\t\t}\n\t\tparentDom.insertBefore(parentVNode._dom, oldDom || null);\n\t\toldDom = parentVNode._dom;\n\t}\n\n\tdo {\n\t\toldDom = oldDom && oldDom.nextSibling;\n\t} while (oldDom != null && oldDom.nodeType === 8);\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst key = childVNode.key;\n\tconst type = childVNode.type;\n\tlet x = skewedIndex - 1;\n\tlet y = skewedIndex + 1;\n\tlet oldVNode = oldChildren[skewedIndex];\n\n\t// We only need to perform a search if there are more children\n\t// (remainingOldChildren) to search. However, if the oldVNode we just looked\n\t// at skewedIndex was not already used in this diff, then there must be at\n\t// least 1 other (so greater than 1) remainingOldChildren to attempt to match\n\t// against. So the following condition checks that ensuring\n\t// remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n\t// if the oldVNode was null or matched, then there could needs to be at least\n\t// 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n\tlet shouldSearch =\n\t\tremainingOldChildren >\n\t\t(oldVNode != null && (oldVNode._flags & MATCHED) === 0 ? 1 : 0);\n\n\tif (\n\t\toldVNode === null ||\n\t\t(oldVNode &&\n\t\t\tkey == oldVNode.key &&\n\t\t\ttype === oldVNode.type &&\n\t\t\t(oldVNode._flags & MATCHED) === 0)\n\t) {\n\t\treturn skewedIndex;\n\t} else if (shouldSearch) {\n\t\twhile (x >= 0 || y < oldChildren.length) {\n\t\t\tif (x >= 0) {\n\t\t\t\toldVNode = oldChildren[x];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) === 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\tx--;\n\t\t\t}\n\n\t\t\tif (y < oldChildren.length) {\n\t\t\t\toldVNode = oldChildren[y];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) === 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn y;\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n","import {\n\tEMPTY_OBJ,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tRESET_MODE\n} from '../constants';\nimport { BaseComponent, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { setProperty } from './props';\nimport { assign, isArray, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\t/** @type {any} */\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._flags & MODE_SUSPENDED) {\n\t\tisHydrating = !!(oldVNode._flags & MODE_HYDRATE);\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\touter: if (typeof newType == 'function') {\n\t\ttry {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\t\t\tconst isClassComponent =\n\t\t\t\t'prototype' in newType && newType.prototype.render;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif (isClassComponent) {\n\t\t\t\t\t// @ts-expect-error The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new BaseComponent(\n\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (isClassComponent && c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (isClassComponent && newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!c._force &&\n\t\t\t\t\t((c.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\t\tnewVNode._original === oldVNode._original)\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.some(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\t\t\tc._force = false;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif (isClassComponent) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (isClassComponent && !isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type === Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tisArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnamespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._flags &= RESET_MODE;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnewVNode._original = null;\n\t\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\t\tif (isHydrating || excessDomChildren != null) {\n\t\t\t\tnewVNode._flags |= isHydrating\n\t\t\t\t\t? MODE_HYDRATE | MODE_SUSPENDED\n\t\t\t\t\t: MODE_HYDRATE;\n\n\t\t\t\twhile (oldDom && oldDom.nodeType === 8 && oldDom.nextSibling) {\n\t\t\t\t\toldDom = oldDom.nextSibling;\n\t\t\t\t}\n\t\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\n\t\t\t\tnewVNode._dom = oldDom;\n\t\t\t} else {\n\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t}\n\t\t\toptions._catchError(e, newVNode, oldVNode);\n\t\t}\n\t} else if (\n\t\texcessDomChildren == null &&\n\t\tnewVNode._original === oldVNode._original\n\t) {\n\t\tnewVNode._children = oldVNode._children;\n\t\tnewVNode._dom = oldVNode._dom;\n\t} else {\n\t\tnewVNode._dom = diffElementNodes(\n\t\t\toldVNode._dom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\t}\n\n\tif ((tmp = options.diffed)) tmp(newVNode);\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nexport function commitRoot(commitQueue, root, refQueue) {\n\troot._nextDom = undefined;\n\n\tfor (let i = 0; i < refQueue.length; i++) {\n\t\tapplyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n\t}\n\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-expect-error Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-expect-error See above comment on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating,\n\trefQueue\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = /** @type {string} */ (newVNode.type);\n\t/** @type {any} */\n\tlet i;\n\t/** @type {{ __html?: string }} */\n\tlet newHtml;\n\t/** @type {{ __html?: string }} */\n\tlet oldHtml;\n\t/** @type {ComponentChildren} */\n\tlet newChildren;\n\tlet value;\n\tlet inputValue;\n\tlet checked;\n\n\t// Tracks entering and exiting namespaces when descending through the tree.\n\tif (nodeType === 'svg') namespace = 'http://www.w3.org/2000/svg';\n\telse if (nodeType === 'math')\n\t\tnamespace = 'http://www.w3.org/1998/Math/MathML';\n\telse if (!namespace) namespace = 'http://www.w3.org/1999/xhtml';\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tvalue = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tvalue &&\n\t\t\t\t'setAttribute' in value === !!nodeType &&\n\t\t\t\t(nodeType ? value.localName === nodeType : value.nodeType === 3)\n\t\t\t) {\n\t\t\t\tdom = value;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (nodeType === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = document.createElementNS(\n\t\t\tnamespace,\n\t\t\tnodeType,\n\t\t\tnewProps.is && newProps\n\t\t);\n\n\t\t// we are creating a new node, so we can assume this is a new subtree (in\n\t\t// case we are hydrating), this deopts the hydrate\n\t\tif (isHydrating) {\n\t\t\tif (options._hydrationMismatch)\n\t\t\t\toptions._hydrationMismatch(newVNode, excessDomChildren);\n\t\t\tisHydrating = false;\n\t\t}\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t}\n\n\tif (nodeType === null) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\t// If we are in a situation where we are not hydrating but are using\n\t\t// existing DOM (e.g. replaceNode) we should read the existing DOM\n\t\t// attributes to diff them\n\t\tif (!isHydrating && excessDomChildren != null) {\n\t\t\toldProps = {};\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i];\n\t\t\t\toldProps[value.name] = value.value;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in oldProps) {\n\t\t\tvalue = oldProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\toldHtml = value;\n\t\t\t} else if (!(i in newProps)) {\n\t\t\t\tif (\n\t\t\t\t\t(i == 'value' && 'defaultValue' in newProps) ||\n\t\t\t\t\t(i == 'checked' && 'defaultChecked' in newProps)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetProperty(dom, i, null, value, namespace);\n\t\t\t}\n\t\t}\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i == 'value') {\n\t\t\t\tinputValue = value;\n\t\t\t} else if (i == 'checked') {\n\t\t\t\tchecked = value;\n\t\t\t} else if (\n\t\t\t\t(!isHydrating || typeof value == 'function') &&\n\t\t\t\toldProps[i] !== value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\tif (\n\t\t\t\t!isHydrating &&\n\t\t\t\t(!oldHtml ||\n\t\t\t\t\t(newHtml.__html !== oldHtml.__html &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML))\n\t\t\t) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tisArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnodeType === 'foreignObject'\n\t\t\t\t\t? 'http://www.w3.org/1999/xhtml'\n\t\t\t\t\t: namespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// As above, don't diff props during hydration\n\t\tif (!isHydrating) {\n\t\t\ti = 'value';\n\t\t\tif (nodeType === 'progress' && inputValue == null) {\n\t\t\t\tdom.removeAttribute('value');\n\t\t\t} else if (\n\t\t\t\tinputValue !== undefined &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(inputValue !== dom[i] ||\n\t\t\t\t\t(nodeType === 'progress' && !inputValue) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType === 'option' && inputValue !== oldProps[i]))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, inputValue, oldProps[i], namespace);\n\t\t\t}\n\n\t\t\ti = 'checked';\n\t\t\tif (checked !== undefined && checked !== dom[i]) {\n\t\t\t\tsetProperty(dom, i, checked, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any> & { _unmount?: unknown }} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') {\n\t\t\tlet hasRefUnmount = typeof ref._unmount == 'function';\n\t\t\tif (hasRefUnmount) {\n\t\t\t\t// @ts-ignore TS doesn't like moving narrowing checks into variables\n\t\t\t\tref._unmount();\n\t\t\t}\n\n\t\t\tif (!hasRefUnmount || value != null) {\n\t\t\t\t// Store the cleanup function on the function\n\t\t\t\t// instance object itself to avoid shape\n\t\t\t\t// transitioning vnode\n\t\t\t\tref._unmount = ref(value);\n\t\t\t}\n\t\t} else ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) {\n\t\t\tapplyRef(r, null, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type != 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._component = vnode._parent = vnode._dom = vnode._nextDom = undefined;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { EMPTY_OBJ } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to render into\n * @param {PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode == 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = ((!isHydrating && replaceNode) || parentDom)._children =\n\t\tcreateElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [],\n\t\trefQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.namespaceURI,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t\t? null\n\t\t\t\t: parentDom.firstChild\n\t\t\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t\t\t: null,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t\t? oldVNode._dom\n\t\t\t\t: parentDom.firstChild,\n\t\tisHydrating,\n\t\trefQueue\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {ComponentChild} vnode The virtual node to render\n * @param {PreactElement} parentDom The DOM element to update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n","import { assign, slice } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tlet defaultProps;\n\n\tif (vnode.type && vnode.type.defaultProps) {\n\t\tdefaultProps = vnode.type.defaultProps;\n\t}\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse if (props[i] === undefined && defaultProps !== undefined) {\n\t\t\tnormalizedProps[i] = defaultProps[i];\n\t\t} else {\n\t\t\tnormalizedProps[i] = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n","/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {VNode} [oldVNode]\n * @param {ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {Component} */\n\tlet component,\n\t\t/** @type {ComponentType} */\n\t\tctor,\n\t\t/** @type {boolean} */\n\t\thandled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != null) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import { options as _options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {import('./internal').Component} */\nlet previousComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\n// Cast to use internal Options type\nconst options = /** @type {import('./internal').Options} */ (_options);\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\nlet oldRoot = options._root;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._diff = vnode => {\n\tcurrentComponent = null;\n\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n};\n\noptions._root = (vnode, parentDom) => {\n\tif (vnode && parentDom._children && parentDom._children._mask) {\n\t\tvnode._mask = parentDom._children._mask;\n\t}\n\n\tif (oldRoot) oldRoot(vnode, parentDom);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\tif (previousComponent === currentComponent) {\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentComponent._renderCallbacks = [];\n\t\t\thooks._list.forEach(hookItem => {\n\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t}\n\t\t\t\thookItem._pendingArgs = hookItem._nextValue = undefined;\n\t\t\t});\n\t\t} else {\n\t\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentIndex = 0;\n\t\t}\n\t}\n\tpreviousComponent = currentComponent;\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tif (c.__hooks._pendingEffects.length) afterPaint(afterPaintEffects.push(c));\n\t\tc.__hooks._list.forEach(hookItem => {\n\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t}\n\t\t\thookItem._pendingArgs = undefined;\n\t\t});\n\t}\n\tpreviousComponent = currentComponent = null;\n};\n\n// TODO: Improve typing of commitQueue parameter\n/** @type {(vnode: import('./internal').VNode, commitQueue: any) => void} */\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tlet hasErrored;\n\t\tc.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tc.__hooks = undefined;\n\t\tif (hasErrored) options._catchError(hasErrored, c._vnode);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\n\treturn hooks._list[index];\n}\n\n/**\n * @template {unknown} S\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} [initialState]\n * @returns {[S, (state: S) => void]}\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @template {unknown} S\n * @template {unknown} A\n * @param {import('./index').Reducer<S, A>} reducer\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ S, (state: S) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst currentValue = hookState._nextValue\n\t\t\t\t\t? hookState._nextValue[0]\n\t\t\t\t\t: hookState._value[0];\n\t\t\t\tconst nextValue = hookState._reducer(currentValue, action);\n\n\t\t\t\tif (currentValue !== nextValue) {\n\t\t\t\t\thookState._nextValue = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._component = currentComponent;\n\n\t\tif (!currentComponent._hasScuFromHooks) {\n\t\t\tcurrentComponent._hasScuFromHooks = true;\n\t\t\tlet prevScu = currentComponent.shouldComponentUpdate;\n\t\t\tconst prevCWU = currentComponent.componentWillUpdate;\n\n\t\t\t// If we're dealing with a forced update `shouldComponentUpdate` will\n\t\t\t// not be called. But we use that to update the hook values, so we\n\t\t\t// need to call it.\n\t\t\tcurrentComponent.componentWillUpdate = function (p, s, c) {\n\t\t\t\tif (this._force) {\n\t\t\t\t\tlet tmp = prevScu;\n\t\t\t\t\t// Clear to avoid other sCU hooks from being called\n\t\t\t\t\tprevScu = undefined;\n\t\t\t\t\tupdateHookState(p, s, c);\n\t\t\t\t\tprevScu = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (prevCWU) prevCWU.call(this, p, s, c);\n\t\t\t};\n\n\t\t\t// This SCU has the purpose of bailing out after repeated updates\n\t\t\t// to stateful hooks.\n\t\t\t// we store the next value in _nextValue[0] and keep doing that for all\n\t\t\t// state setters, if we have next states and\n\t\t\t// all next states within a component end up being equal to their original state\n\t\t\t// we are safe to bail out for this specific component.\n\t\t\t/**\n\t\t\t *\n\t\t\t * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n\t\t\t */\n\t\t\t// @ts-ignore - We don't use TS to downtranspile\n\t\t\t// eslint-disable-next-line no-inner-declarations\n\t\t\tfunction updateHookState(p, s, c) {\n\t\t\t\tif (!hookState._component.__hooks) return true;\n\n\t\t\t\t/** @type {(x: import('./internal').HookState) => x is import('./internal').ReducerHookState} */\n\t\t\t\tconst isStateHook = x => !!x._component;\n\t\t\t\tconst stateHooks =\n\t\t\t\t\thookState._component.__hooks._list.filter(isStateHook);\n\n\t\t\t\tconst allHooksEmpty = stateHooks.every(x => !x._nextValue);\n\t\t\t\t// When we have no updated hooks in the component we invoke the previous SCU or\n\t\t\t\t// traverse the VDOM tree further.\n\t\t\t\tif (allHooksEmpty) {\n\t\t\t\t\treturn prevScu ? prevScu.call(this, p, s, c) : true;\n\t\t\t\t}\n\n\t\t\t\t// We check whether we have components with a nextValue set that\n\t\t\t\t// have values that aren't equal to one another this pushes\n\t\t\t\t// us to update further down the tree\n\t\t\t\tlet shouldUpdate = false;\n\t\t\t\tstateHooks.forEach(hookItem => {\n\t\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\t\tconst currentValue = hookItem._value[0];\n\t\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t\t\thookItem._nextValue = undefined;\n\t\t\t\t\t\tif (currentValue !== hookItem._value[0]) shouldUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn shouldUpdate || hookState._component.props !== p\n\t\t\t\t\t? prevScu\n\t\t\t\t\t\t? prevScu.call(this, p, s, c)\n\t\t\t\t\t\t: true\n\t\t\t\t\t: false;\n\t\t\t}\n\n\t\t\tcurrentComponent.shouldComponentUpdate = updateHookState;\n\t\t}\n\t}\n\n\treturn hookState._nextValue || hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\n/** @type {(initialValue: unknown) => unknown} */\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') {\n\t\t\t\tref(createHandle());\n\t\t\t\treturn () => ref(null);\n\t\t\t} else if (ref) {\n\t\t\t\tref.current = createHandle();\n\t\t\t\treturn () => (ref.current = null);\n\t\t\t}\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @template {unknown} T\n * @param {() => T} factory\n * @param {unknown[]} args\n * @returns {T}\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState<T>} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._value = factory();\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {unknown[]} args\n * @returns {() => void}\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(\n\t\t\tformatter ? formatter(value) : /** @type {any}*/ (value)\n\t\t);\n\t}\n}\n\n/**\n * @param {(error: unknown, errorInfo: import('preact').ErrorInfo) => void} cb\n * @returns {[unknown, () => void]}\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = (err, errorInfo) => {\n\t\t\tif (state._value) state._value(err, errorInfo);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/** @type {() => string} */\nexport function useId() {\n\t/** @type {import('./internal').IdHookState} */\n\tconst state = getHookState(currentIndex++, 11);\n\tif (!state._value) {\n\t\t// Grab either the root node or the nearest async boundary node.\n\t\t/** @type {import('./internal.d').VNode} */\n\t\tlet root = currentComponent._vnode;\n\t\twhile (root !== null && !root._mask && root._parent !== null) {\n\t\t\troot = root._parent;\n\t\t}\n\n\t\tlet mask = root._mask || (root._mask = [0, 0]);\n\t\tstate._value = 'P' + mask[0] + '-' + mask[1]++;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet component;\n\twhile ((component = afterPaintEffects.shift())) {\n\t\tif (!component._parentDom || !component.__hooks) continue;\n\t\ttry {\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t} catch (e) {\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n * @returns {void}\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').HookState} hook\n * @returns {void}\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\n\tcurrentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n * @returns {void}\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\thook._cleanup = hook._value();\n\tcurrentComponent = comp;\n}\n\n/**\n * @param {unknown[]} oldArgs\n * @param {unknown[]} newArgs\n * @returns {boolean}\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\n/**\n * @template Arg\n * @param {Arg} arg\n * @param {(arg: Arg) => any} f\n * @returns {any}\n */\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n","/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nexport function shallowDiffers(a, b) {\n\tfor (let i in a) if (i !== '__source' && !(i in b)) return true;\n\tfor (let i in b) if (i !== '__source' && a[i] !== b[i]) return true;\n\treturn false;\n}\n\n/**\n * Check if two values are the same value\n * @param {*} x\n * @param {*} y\n * @returns {boolean}\n */\nexport function is(x, y) {\n\treturn (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\n","import { Component } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nexport function PureComponent(p, c) {\n\tthis.props = p;\n\tthis.context = c;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function (props, state) {\n\treturn shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n","import { createElement } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionComponent}\n */\nexport function memo(c, comparer) {\n\tfunction shouldUpdate(nextProps) {\n\t\tlet ref = this.props.ref;\n\t\tlet updateRef = ref == nextProps.ref;\n\t\tif (!updateRef && ref) {\n\t\t\tref.call ? ref(null) : (ref.current = null);\n\t\t}\n\n\t\tif (!comparer) {\n\t\t\treturn shallowDiffers(this.props, nextProps);\n\t\t}\n\n\t\treturn !comparer(this.props, nextProps) || !updateRef;\n\t}\n\n\tfunction Memoed(props) {\n\t\tthis.shouldComponentUpdate = shouldUpdate;\n\t\treturn createElement(c, props);\n\t}\n\tMemoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n\tMemoed.prototype.isReactComponent = true;\n\tMemoed._forwarded = true;\n\treturn Memoed;\n}\n","import { options } from 'preact';\n\nlet oldDiffHook = options._diff;\noptions._diff = vnode => {\n\tif (vnode.type && vnode.type._forwarded && vnode.ref) {\n\t\tvnode.props.ref = vnode.ref;\n\t\tvnode.ref = null;\n\t}\n\tif (oldDiffHook) oldDiffHook(vnode);\n};\n\nexport const REACT_FORWARD_SYMBOL =\n\t(typeof Symbol != 'undefined' &&\n\t\tSymbol.for &&\n\t\tSymbol.for('react.forward_ref')) ||\n\t0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionComponent}\n */\nexport function forwardRef(fn) {\n\tfunction Forwarded(props) {\n\t\tif (!('ref' in props)) return fn(props, null);\n\n\t\tlet ref = props.ref;\n\t\tdelete props.ref;\n\t\tconst result = fn(props, ref);\n\t\tprops.ref = ref;\n\t\treturn result;\n\t}\n\n\t// mobx-react checks for this being present\n\tForwarded.$$typeof = REACT_FORWARD_SYMBOL;\n\t// mobx-react heavily relies on implementation details.\n\t// It expects an object here with a `render` property,\n\t// and prototype.render will fail. Without this\n\t// mobx-react throws.\n\tForwarded.render = Forwarded;\n\n\tForwarded.prototype.isReactComponent = Forwarded._forwarded = true;\n\tForwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n\treturn Forwarded;\n}\n","import { toChildArray } from 'preact';\n\nconst mapFn = (children, fn) => {\n\tif (children == null) return null;\n\treturn toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nexport const Children = {\n\tmap: mapFn,\n\tforEach: mapFn,\n\tcount(children) {\n\t\treturn children ? toChildArray(children).length : 0;\n\t},\n\tonly(children) {\n\t\tconst normalized = toChildArray(children);\n\t\tif (normalized.length !== 1) throw 'Children.only';\n\t\treturn normalized[0];\n\t},\n\ttoArray: toChildArray\n};\n","import { Component, createElement, options, Fragment } from 'preact';\nimport { MODE_HYDRATE } from '../../src/constants';\nimport { assign } from './util';\n\nconst oldCatchError = options._catchError;\noptions._catchError = function (error, newVNode, oldVNode, errorInfo) {\n\tif (error.then) {\n\t\t/** @type {import('./internal').Component} */\n\t\tlet component;\n\t\tlet vnode = newVNode;\n\n\t\tfor (; (vnode = vnode._parent); ) {\n\t\t\tif ((component = vnode._component) && component._childDidSuspend) {\n\t\t\t\tif (newVNode._dom == null) {\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t}\n\t\t\t\t// Don't call oldCatchError if we found a Suspense\n\t\t\t\treturn component._childDidSuspend(error, newVNode);\n\t\t\t}\n\t\t}\n\t}\n\toldCatchError(error, newVNode, oldVNode, errorInfo);\n};\n\nconst oldUnmount = options.unmount;\noptions.unmount = function (vnode) {\n\t/** @type {import('./internal').Component} */\n\tconst component = vnode._component;\n\tif (component && component._onResolve) {\n\t\tcomponent._onResolve();\n\t}\n\n\t// if the component is still hydrating\n\t// most likely it is because the component is suspended\n\t// we set the vnode.type as `null` so that it is not a typeof function\n\t// so the unmount will remove the vnode._dom\n\tif (component && vnode._flags & MODE_HYDRATE) {\n\t\tvnode.type = null;\n\t}\n\n\tif (oldUnmount) oldUnmount(vnode);\n};\n\nfunction detachedClone(vnode, detachedParent, parentDom) {\n\tif (vnode) {\n\t\tif (vnode._component && vnode._component.__hooks) {\n\t\t\tvnode._component.__hooks._list.forEach(effect => {\n\t\t\t\tif (typeof effect._cleanup == 'function') effect._cleanup();\n\t\t\t});\n\n\t\t\tvnode._component.__hooks = null;\n\t\t}\n\n\t\tvnode = assign({}, vnode);\n\t\tif (vnode._component != null) {\n\t\t\tif (vnode._component._parentDom === parentDom) {\n\t\t\t\tvnode._component._parentDom = detachedParent;\n\t\t\t}\n\t\t\tvnode._component = null;\n\t\t}\n\n\t\tvnode._children =\n\t\t\tvnode._children &&\n\t\t\tvnode._children.map(child =>\n\t\t\t\tdetachedClone(child, detachedParent, parentDom)\n\t\t\t);\n\t}\n\n\treturn vnode;\n}\n\nfunction removeOriginal(vnode, detachedParent, originalParent) {\n\tif (vnode && originalParent) {\n\t\tvnode._original = null;\n\t\tvnode._children =\n\t\t\tvnode._children &&\n\t\t\tvnode._children.map(child =>\n\t\t\t\tremoveOriginal(child, detachedParent, originalParent)\n\t\t\t);\n\n\t\tif (vnode._component) {\n\t\t\tif (vnode._component._parentDom === detachedParent) {\n\t\t\t\tif (vnode._dom) {\n\t\t\t\t\toriginalParent.appendChild(vnode._dom);\n\t\t\t\t}\n\t\t\t\tvnode._component._force = true;\n\t\t\t\tvnode._component._parentDom = originalParent;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nexport function Suspense() {\n\t// we do not call super here to golf some bytes...\n\tthis._pendingSuspensionCount = 0;\n\tthis._suspenders = null;\n\tthis._detachOnNextRender = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {Promise} promise The thrown promise\n * @param {import('./internal').VNode<any, any>} suspendingVNode The suspending component\n */\nSuspense.prototype._childDidSuspend = function (promise, suspendingVNode) {\n\tconst suspendingComponent = suspendingVNode._component;\n\n\t/** @type {import('./internal').SuspenseComponent} */\n\tconst c = this;\n\n\tif (c._suspenders == null) {\n\t\tc._suspenders = [];\n\t}\n\tc._suspenders.push(suspendingComponent);\n\n\tconst resolve = suspended(c._vnode);\n\n\tlet resolved = false;\n\tconst onResolved = () => {\n\t\tif (resolved) return;\n\n\t\tresolved = true;\n\t\tsuspendingComponent._onResolve = null;\n\n\t\tif (resolve) {\n\t\t\tresolve(onSuspensionComplete);\n\t\t} else {\n\t\t\tonSuspensionComplete();\n\t\t}\n\t};\n\n\tsuspendingComponent._onResolve = onResolved;\n\n\tconst onSuspensionComplete = () => {\n\t\tif (!--c._pendingSuspensionCount) {\n\t\t\t// If the suspension was during hydration we don't need to restore the\n\t\t\t// suspended children into the _children array\n\t\t\tif (c.state._suspended) {\n\t\t\t\tconst suspendedVNode = c.state._suspended;\n\t\t\t\tc._vnode._children[0] = removeOriginal(\n\t\t\t\t\tsuspendedVNode,\n\t\t\t\t\tsuspendedVNode._component._parentDom,\n\t\t\t\t\tsuspendedVNode._component._originalParentDom\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tc.setState({ _suspended: (c._detachOnNextRender = null) });\n\n\t\t\tlet suspended;\n\t\t\twhile ((suspended = c._suspenders.pop())) {\n\t\t\t\tsuspended.forceUpdate();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * We do not set `suspended: true` during hydration because we want the actual markup\n\t * to remain on screen and hydrate it when the suspense actually gets resolved.\n\t * While in non-hydration cases the usual fallback -> component flow would occour.\n\t */\n\tif (\n\t\t!c._pendingSuspensionCount++ &&\n\t\t!(suspendingVNode._flags & MODE_HYDRATE)\n\t) {\n\t\tc.setState({ _suspended: (c._detachOnNextRender = c._vnode._children[0]) });\n\t}\n\tpromise.then(onResolved, onResolved);\n};\n\nSuspense.prototype.componentWillUnmount = function () {\n\tthis._suspenders = [];\n};\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {import('./internal').SuspenseComponent[\"props\"]} props\n * @param {import('./internal').SuspenseState} state\n */\nSuspense.prototype.render = function (props, state) {\n\tif (this._detachOnNextRender) {\n\t\t// When the Suspense's _vnode was created by a call to createVNode\n\t\t// (i.e. due to a setState further up in the tree)\n\t\t// it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n\t\tif (this._vnode._children) {\n\t\t\tconst detachedParent = document.createElement('div');\n\t\t\tconst detachedComponent = this._vnode._children[0]._component;\n\t\t\tthis._vnode._children[0] = detachedClone(\n\t\t\t\tthis._detachOnNextRender,\n\t\t\t\tdetachedParent,\n\t\t\t\t(detachedComponent._originalParentDom = detachedComponent._parentDom)\n\t\t\t);\n\t\t}\n\n\t\tthis._detachOnNextRender = null;\n\t}\n\n\t// Wrap fallback tree in a VNode that prevents itself from being marked as aborting mid-hydration:\n\t/** @type {import('./internal').VNode} */\n\tconst fallback =\n\t\tstate._suspended && createElement(Fragment, null, props.fallback);\n\tif (fallback) fallback._flags &= ~MODE_HYDRATE;\n\n\treturn [\n\t\tcreateElement(Fragment, null, state._suspended ? null : props.children),\n\t\tfallback\n\t];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('./internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nexport function suspended(vnode) {\n\t/** @type {import('./internal').Component} */\n\tlet component = vnode._parent._component;\n\treturn component && component._suspended && component._suspended(vnode);\n}\n\nexport function lazy(loader) {\n\tlet prom;\n\tlet component;\n\tlet error;\n\n\tfunction Lazy(props) {\n\t\tif (!prom) {\n\t\t\tprom = loader();\n\t\t\tprom.then(\n\t\t\t\texports => {\n\t\t\t\t\tcomponent = exports.default || exports;\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\terror = e;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!component) {\n\t\t\tthrow prom;\n\t\t}\n\n\t\treturn createElement(component, props);\n\t}\n\n\tLazy.displayName = 'Lazy';\n\tLazy._forwarded = true;\n\treturn Lazy;\n}\n","import { Component, toChildArray } from 'preact';\nimport { suspended } from './suspense.js';\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nconst SUSPENDED_COUNT = 0;\nconst RESOLVED_COUNT = 1;\nconst NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nexport function SuspenseList() {\n\tthis._next = null;\n\tthis._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nconst resolve = (list, child, node) => {\n\tif (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n\t\t// The number a child (or any of its descendants) has been suspended\n\t\t// matches the number of times it's been resolved. Therefore we\n\t\t// mark the child as completely resolved by deleting it from ._map.\n\t\t// This is used to figure out when *all* children have been completely\n\t\t// resolved when revealOrder is 'together'.\n\t\tlist._map.delete(child);\n\t}\n\n\t// If revealOrder is falsy then we can do an early exit, as the\n\t// callbacks won't get queued in the node anyway.\n\t// If revealOrder is 'together' then also do an early exit\n\t// if all suspended descendants have not yet been resolved.\n\tif (\n\t\t!list.props.revealOrder ||\n\t\t(list.props.revealOrder[0] === 't' && list._map.size)\n\t) {\n\t\treturn;\n\t}\n\n\t// Walk the currently suspended children in order, calling their\n\t// stored callbacks on the way. Stop if we encounter a child that\n\t// has not been completely resolved yet.\n\tnode = list._next;\n\twhile (node) {\n\t\twhile (node.length > 3) {\n\t\t\tnode.pop()();\n\t\t}\n\t\tif (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n\t\t\tbreak;\n\t\t}\n\t\tlist._next = node = node[NEXT_NODE];\n\t}\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\n\nSuspenseList.prototype._suspended = function (child) {\n\tconst list = this;\n\tconst delegated = suspended(list._vnode);\n\n\tlet node = list._map.get(child);\n\tnode[SUSPENDED_COUNT]++;\n\n\treturn unsuspend => {\n\t\tconst wrappedUnsuspend = () => {\n\t\t\tif (!list.props.revealOrder) {\n\t\t\t\t// Special case the undefined (falsy) revealOrder, as there\n\t\t\t\t// is no need to coordinate a specific order or unsuspends.\n\t\t\t\tunsuspend();\n\t\t\t} else {\n\t\t\t\tnode.push(unsuspend);\n\t\t\t\tresolve(list, child, node);\n\t\t\t}\n\t\t};\n\t\tif (delegated) {\n\t\t\tdelegated(wrappedUnsuspend);\n\t\t} else {\n\t\t\twrappedUnsuspend();\n\t\t}\n\t};\n};\n\nSuspenseList.prototype.render = function (props) {\n\tthis._next = null;\n\tthis._map = new Map();\n\n\tconst children = toChildArray(props.children);\n\tif (props.revealOrder && props.revealOrder[0] === 'b') {\n\t\t// If order === 'backwards' (or, well, anything starting with a 'b')\n\t\t// then flip the child list around so that the last child will be\n\t\t// the first in the linked list.\n\t\tchildren.reverse();\n\t}\n\t// Build the linked list. Iterate through the children in reverse order\n\t// so that `_next` points to the first linked list node to be resolved.\n\tfor (let i = children.length; i--; ) {\n\t\t// Create a new linked list node as an array of form:\n\t\t// \t[suspended_count, resolved_count, next_node]\n\t\t// where suspended_count and resolved_count are numeric counters for\n\t\t// keeping track how many times a node has been suspended and resolved.\n\t\t//\n\t\t// Note that suspended_count starts from 1 instead of 0, so we can block\n\t\t// processing callbacks until componentDidMount has been called. In a sense\n\t\t// node is suspended at least until componentDidMount gets called!\n\t\t//\n\t\t// Pending callbacks are added to the end of the node:\n\t\t// \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n\t\tthis._map.set(children[i], (this._next = [1, 0, this._next]));\n\t}\n\treturn props.children;\n};\n\nSuspenseList.prototype.componentDidUpdate =\n\tSuspenseList.prototype.componentDidMount = function () {\n\t\t// Iterate through all children after mounting for two reasons:\n\t\t// 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n\t\t//    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n\t\t//    The nodes can now be completely consumed from the linked list.\n\t\t// 2. Handle nodes that might have gotten resolved between render and\n\t\t//    componentDidMount.\n\t\tthis._map.forEach((node, child) => {\n\t\t\tresolve(this, child, node);\n\t\t});\n\t};\n","import { createElement, render } from 'preact';\n\n/**\n * @param {import('../../src/index').RenderableProps<{ context: any }>} props\n */\nfunction ContextProvider(props) {\n\tthis.getChildContext = () => props.context;\n\treturn props.children;\n}\n\n/**\n * Portal component\n * @this {import('./internal').Component}\n * @param {object | null | undefined} props\n *\n * TODO: use createRoot() instead of fake root\n */\nfunction Portal(props) {\n\tconst _this = this;\n\tlet container = props._container;\n\n\t_this.componentWillUnmount = function () {\n\t\trender(null, _this._temp);\n\t\t_this._temp = null;\n\t\t_this._container = null;\n\t};\n\n\t// When we change container we should clear our old container and\n\t// indicate a new mount.\n\tif (_this._container && _this._container !== container) {\n\t\t_this.componentWillUnmount();\n\t}\n\n\tif (!_this._temp) {\n\t\t_this._container = container;\n\n\t\t// Create a fake DOM parent node that manages a subset of `container`'s children:\n\t\t_this._temp = {\n\t\t\tnodeType: 1,\n\t\t\tparentNode: container,\n\t\t\tchildNodes: [],\n\t\t\tcontains: () => true,\n\t\t\tappendChild(child) {\n\t\t\t\tthis.childNodes.push(child);\n\t\t\t\t_this._container.appendChild(child);\n\t\t\t},\n\t\t\tinsertBefore(child, before) {\n\t\t\t\tthis.childNodes.push(child);\n\t\t\t\t_this._container.appendChild(child);\n\t\t\t},\n\t\t\tremoveChild(child) {\n\t\t\t\tthis.childNodes.splice(this.childNodes.indexOf(child) >>> 1, 1);\n\t\t\t\t_this._container.removeChild(child);\n\t\t\t}\n\t\t};\n\t}\n\n\t// Render our wrapping element into temp.\n\trender(\n\t\tcreateElement(ContextProvider, { context: _this.context }, props._vnode),\n\t\t_this._temp\n\t);\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\tconst el = createElement(Portal, { _vnode: vnode, _container: container });\n\tel.containerInfo = container;\n\treturn el;\n}\n","import {\n\trender as preactRender,\n\thydrate as preactHydrate,\n\toptions,\n\ttoChildArray,\n\tComponent\n} from 'preact';\nimport {\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tuseEffect,\n\tuseId,\n\tuseImperativeHandle,\n\tuseLayoutEffect,\n\tuseMemo,\n\tuseReducer,\n\tuseRef,\n\tuseState\n} from 'preact/hooks';\nimport {\n\tuseDeferredValue,\n\tuseInsertionEffect,\n\tuseSyncExternalStore,\n\tuseTransition\n} from './index';\n\nexport const REACT_ELEMENT_TYPE =\n\t(typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element')) ||\n\t0xeac7;\n\nconst CAMEL_PROPS =\n\t/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;\nconst ON_ANI = /^on(Ani|Tra|Tou|BeforeInp|Compo)/;\nconst CAMEL_REPLACE = /[A-Z0-9]/g;\nconst IS_DOM = typeof document !== 'undefined';\n\n// Input types for which onchange should not be converted to oninput.\n// type=\"file|checkbox|radio\", plus \"range\" in IE11.\n// (IE11 doesn't support Symbol, which we use here to turn `rad` into `ra` which matches \"range\")\nconst onChangeInputType = type =>\n\t(typeof Symbol != 'undefined' && typeof Symbol() == 'symbol'\n\t\t? /fil|che|rad/\n\t\t: /fil|che|ra/\n\t).test(type);\n\n// Some libraries like `react-virtualized` explicitly check for this.\nComponent.prototype.isReactComponent = {};\n\n// `UNSAFE_*` lifecycle hooks\n// Preact only ever invokes the unprefixed methods.\n// Here we provide a base \"fallback\" implementation that calls any defined UNSAFE_ prefixed method.\n// - If a component defines its own `componentDidMount()` (including via defineProperty), use that.\n// - If a component defines `UNSAFE_componentDidMount()`, `componentDidMount` is the alias getter/setter.\n// - If anything assigns to an `UNSAFE_*` property, the assignment is forwarded to the unprefixed property.\n// See https://github.com/preactjs/preact/issues/1941\n[\n\t'componentWillMount',\n\t'componentWillReceiveProps',\n\t'componentWillUpdate'\n].forEach(key => {\n\tObject.defineProperty(Component.prototype, key, {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn this['UNSAFE_' + key];\n\t\t},\n\t\tset(v) {\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: v\n\t\t\t});\n\t\t}\n\t});\n});\n\n/**\n * Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null\n */\nexport function render(vnode, parent, callback) {\n\t// React destroys any existing DOM nodes, see #1727\n\t// ...but only on the first render, see #1828\n\tif (parent._children == null) {\n\t\tparent.textContent = '';\n\t}\n\n\tpreactRender(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nexport function hydrate(vnode, parent, callback) {\n\tpreactHydrate(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nlet oldEventHook = options.event;\noptions.event = e => {\n\tif (oldEventHook) e = oldEventHook(e);\n\n\te.persist = empty;\n\te.isPropagationStopped = isPropagationStopped;\n\te.isDefaultPrevented = isDefaultPrevented;\n\treturn (e.nativeEvent = e);\n};\n\nfunction empty() {}\n\nfunction isPropagationStopped() {\n\treturn this.cancelBubble;\n}\n\nfunction isDefaultPrevented() {\n\treturn this.defaultPrevented;\n}\n\nconst classNameDescriptorNonEnumberable = {\n\tenumerable: false,\n\tconfigurable: true,\n\tget() {\n\t\treturn this.class;\n\t}\n};\n\nfunction handleDomVNode(vnode) {\n\tlet props = vnode.props,\n\t\ttype = vnode.type,\n\t\tnormalizedProps = {};\n\n\tlet isNonDashedType = type.indexOf('-') === -1;\n\tfor (let i in props) {\n\t\tlet value = props[i];\n\n\t\tif (\n\t\t\t(i === 'value' && 'defaultValue' in props && value == null) ||\n\t\t\t// Emulate React's behavior of not rendering the contents of noscript tags on the client.\n\t\t\t(IS_DOM && i === 'children' && type === 'noscript') ||\n\t\t\ti === 'class' ||\n\t\t\ti === 'className'\n\t\t) {\n\t\t\t// Skip applying value if it is null/undefined and we already set\n\t\t\t// a default value\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet lowerCased = i.toLowerCase();\n\t\tif (i === 'defaultValue' && 'value' in props && props.value == null) {\n\t\t\t// `defaultValue` is treated as a fallback `value` when a value prop is present but null/undefined.\n\t\t\t// `defaultValue` for Elements with no value prop is the same as the DOM defaultValue property.\n\t\t\ti = 'value';\n\t\t} else if (i === 'download' && value === true) {\n\t\t\t// Calling `setAttribute` with a truthy value will lead to it being\n\t\t\t// passed as a stringified value, e.g. `download=\"true\"`. React\n\t\t\t// converts it to an empty string instead, otherwise the attribute\n\t\t\t// value will be used as the file name and the file will be called\n\t\t\t// \"true\" upon downloading it.\n\t\t\tvalue = '';\n\t\t} else if (lowerCased === 'translate' && value === 'no') {\n\t\t\tvalue = false;\n\t\t} else if (lowerCased[0] === 'o' && lowerCased[1] === 'n') {\n\t\t\tif (lowerCased === 'ondoubleclick') {\n\t\t\t\ti = 'ondblclick';\n\t\t\t} else if (\n\t\t\t\tlowerCased === 'onchange' &&\n\t\t\t\t(type === 'input' || type === 'textarea') &&\n\t\t\t\t!onChangeInputType(props.type)\n\t\t\t) {\n\t\t\t\tlowerCased = i = 'oninput';\n\t\t\t} else if (lowerCased === 'onfocus') {\n\t\t\t\ti = 'onfocusin';\n\t\t\t} else if (lowerCased === 'onblur') {\n\t\t\t\ti = 'onfocusout';\n\t\t\t} else if (ON_ANI.test(i)) {\n\t\t\t\ti = lowerCased;\n\t\t\t}\n\t\t} else if (isNonDashedType && CAMEL_PROPS.test(i)) {\n\t\t\ti = i.replace(CAMEL_REPLACE, '-$&').toLowerCase();\n\t\t} else if (value === null) {\n\t\t\tvalue = undefined;\n\t\t}\n\n\t\t// Add support for onInput and onChange, see #3561\n\t\t// if we have an oninput prop already change it to oninputCapture\n\t\tif (lowerCased === 'oninput') {\n\t\t\ti = lowerCased;\n\t\t\tif (normalizedProps[i]) {\n\t\t\t\ti = 'oninputCapture';\n\t\t\t}\n\t\t}\n\n\t\tnormalizedProps[i] = value;\n\t}\n\n\t// Add support for array select values: <select multiple value={[]} />\n\tif (\n\t\ttype == 'select' &&\n\t\tnormalizedProps.multiple &&\n\t\tArray.isArray(normalizedProps.value)\n\t) {\n\t\t// forEach() always returns undefined, which we abuse here to unset the value prop.\n\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\tchild.props.selected =\n\t\t\t\tnormalizedProps.value.indexOf(child.props.value) != -1;\n\t\t});\n\t}\n\n\t// Adding support for defaultValue in select tag\n\tif (type == 'select' && normalizedProps.defaultValue != null) {\n\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\tif (normalizedProps.multiple) {\n\t\t\t\tchild.props.selected =\n\t\t\t\t\tnormalizedProps.defaultValue.indexOf(child.props.value) != -1;\n\t\t\t} else {\n\t\t\t\tchild.props.selected =\n\t\t\t\t\tnormalizedProps.defaultValue == child.props.value;\n\t\t\t}\n\t\t});\n\t}\n\n\tif (props.class && !props.className) {\n\t\tnormalizedProps.class = props.class;\n\t\tObject.defineProperty(\n\t\t\tnormalizedProps,\n\t\t\t'className',\n\t\t\tclassNameDescriptorNonEnumberable\n\t\t);\n\t} else if (props.className && !props.class) {\n\t\tnormalizedProps.class = normalizedProps.className = props.className;\n\t} else if (props.class && props.className) {\n\t\tnormalizedProps.class = normalizedProps.className = props.className;\n\t}\n\n\tvnode.props = normalizedProps;\n}\n\nlet oldVNodeHook = options.vnode;\noptions.vnode = vnode => {\n\t// only normalize props on Element nodes\n\tif (typeof vnode.type === 'string') {\n\t\thandleDomVNode(vnode);\n\t}\n\n\tvnode.$$typeof = REACT_ELEMENT_TYPE;\n\n\tif (oldVNodeHook) oldVNodeHook(vnode);\n};\n\n// Only needed for react-relay\nlet currentComponent;\nconst oldBeforeRender = options._render;\noptions._render = function (vnode) {\n\tif (oldBeforeRender) {\n\t\toldBeforeRender(vnode);\n\t}\n\tcurrentComponent = vnode._component;\n};\n\nconst oldDiffed = options.diffed;\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = function (vnode) {\n\tif (oldDiffed) {\n\t\toldDiffed(vnode);\n\t}\n\n\tconst props = vnode.props;\n\tconst dom = vnode._dom;\n\n\tif (\n\t\tdom != null &&\n\t\tvnode.type === 'textarea' &&\n\t\t'value' in props &&\n\t\tprops.value !== dom.value\n\t) {\n\t\tdom.value = props.value == null ? '' : props.value;\n\t}\n\n\tcurrentComponent = null;\n};\n\n// This is a very very private internal function for React it\n// is used to sort-of do runtime dependency injection.\nexport const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {\n\tReactCurrentDispatcher: {\n\t\tcurrent: {\n\t\t\treadContext(context) {\n\t\t\t\treturn currentComponent._globalContext[context._id].props.value;\n\t\t\t},\n\t\t\tuseCallback,\n\t\t\tuseContext,\n\t\t\tuseDebugValue,\n\t\t\tuseDeferredValue,\n\t\t\tuseEffect,\n\t\t\tuseId,\n\t\t\tuseImperativeHandle,\n\t\t\tuseInsertionEffect,\n\t\t\tuseLayoutEffect,\n\t\t\tuseMemo,\n\t\t\t// useMutableSource, // experimental-only and replaced by uSES, likely not worth supporting\n\t\t\tuseReducer,\n\t\t\tuseRef,\n\t\t\tuseState,\n\t\t\tuseSyncExternalStore,\n\t\t\tuseTransition\n\t\t}\n\t}\n};\n","import {\n\tcreateElement,\n\trender as preactRender,\n\tcloneElement as preactCloneElement,\n\tcreateRef,\n\tComponent,\n\tcreateContext,\n\tFragment\n} from 'preact';\nimport {\n\tuseState,\n\tuseId,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue\n} from 'preact/hooks';\nimport { PureComponent } from './PureComponent';\nimport { memo } from './memo';\nimport { forwardRef } from './forwardRef';\nimport { Children } from './Children';\nimport { Suspense, lazy } from './suspense';\nimport { SuspenseList } from './suspense-list';\nimport { createPortal } from './portals';\nimport { is } from './util';\nimport {\n\thydrate,\n\trender,\n\tREACT_ELEMENT_TYPE,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n} from './render';\n\nconst version = '18.3.1'; // trick libraries to think we are react\n\n/**\n * Legacy version of createElement.\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor\n */\nfunction createFactory(type) {\n\treturn createElement.bind(null, type);\n}\n\n/**\n * Check if the passed element is a valid (p)react node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isValidElement(element) {\n\treturn !!element && element.$$typeof === REACT_ELEMENT_TYPE;\n}\n\n/**\n * Check if the passed element is a Fragment node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isFragment(element) {\n\treturn isValidElement(element) && element.type === Fragment;\n}\n\n/**\n * Check if the passed element is a Memo node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isMemo(element) {\n\treturn (\n\t\t!!element &&\n\t\t!!element.displayName &&\n\t\t(typeof element.displayName === 'string' ||\n\t\t\telement.displayName instanceof String) &&\n\t\telement.displayName.startsWith('Memo(')\n\t);\n}\n\n/**\n * Wrap `cloneElement` to abort if the passed element is not a valid element and apply\n * all vnode normalizations.\n * @param {import('./internal').VNode} element The vnode to clone\n * @param {object} props Props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Optional component children\n */\nfunction cloneElement(element) {\n\tif (!isValidElement(element)) return element;\n\treturn preactCloneElement.apply(null, arguments);\n}\n\n/**\n * Remove a component tree from the DOM, including state and event handlers.\n * @param {import('./internal').PreactElement} container\n * @returns {boolean}\n */\nfunction unmountComponentAtNode(container) {\n\tif (container._children) {\n\t\tpreactRender(null, container);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Get the matching DOM node for a component\n * @param {import('./internal').Component} component\n * @returns {import('./internal').PreactElement | null}\n */\nfunction findDOMNode(component) {\n\treturn (\n\t\t(component &&\n\t\t\t(component.base || (component.nodeType === 1 && component))) ||\n\t\tnull\n\t);\n}\n\n/**\n * Deprecated way to control batched rendering inside the reconciler, but we\n * already schedule in batches inside our rendering code\n * @template Arg\n * @param {(arg: Arg) => void} callback function that triggers the updated\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n */\n// eslint-disable-next-line camelcase\nconst unstable_batchedUpdates = (callback, arg) => callback(arg);\n\n/**\n * In React, `flushSync` flushes the entire tree and forces a rerender. It's\n * implmented here as a no-op.\n * @template Arg\n * @template Result\n * @param {(arg: Arg) => Result} callback function that runs before the flush\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n * @returns\n */\nconst flushSync = (callback, arg) => callback(arg);\n\n/**\n * Strict Mode is not implemented in Preact, so we provide a stand-in for it\n * that just renders its children without imposing any restrictions.\n */\nconst StrictMode = Fragment;\n\nexport function startTransition(cb) {\n\tcb();\n}\n\nexport function useDeferredValue(val) {\n\treturn val;\n}\n\nexport function useTransition() {\n\treturn [false, startTransition];\n}\n\n// TODO: in theory this should be done after a VNode is diffed as we want to insert\n// styles/... before it attaches\nexport const useInsertionEffect = useLayoutEffect;\n\n// compat to react-is\nexport const isElement = isValidElement;\n\n/**\n * This is taken from https://github.com/facebook/react/blob/main/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js#L84\n * on a high level this cuts out the warnings, ... and attempts a smaller implementation\n * @typedef {{ _value: any; _getSnapshot: () => any }} Store\n */\nexport function useSyncExternalStore(subscribe, getSnapshot) {\n\tconst value = getSnapshot();\n\n\t/**\n\t * @typedef {{ _instance: Store }} StoreRef\n\t * @type {[StoreRef, (store: StoreRef) => void]}\n\t */\n\tconst [{ _instance }, forceUpdate] = useState({\n\t\t_instance: { _value: value, _getSnapshot: getSnapshot }\n\t});\n\n\tuseLayoutEffect(() => {\n\t\t_instance._value = value;\n\t\t_instance._getSnapshot = getSnapshot;\n\n\t\tif (didSnapshotChange(_instance)) {\n\t\t\tforceUpdate({ _instance });\n\t\t}\n\t}, [subscribe, value, getSnapshot]);\n\n\tuseEffect(() => {\n\t\tif (didSnapshotChange(_instance)) {\n\t\t\tforceUpdate({ _instance });\n\t\t}\n\n\t\treturn subscribe(() => {\n\t\t\tif (didSnapshotChange(_instance)) {\n\t\t\t\tforceUpdate({ _instance });\n\t\t\t}\n\t\t});\n\t}, [subscribe]);\n\n\treturn value;\n}\n\n/** @type {(inst: Store) => boolean} */\nfunction didSnapshotChange(inst) {\n\tconst latestGetSnapshot = inst._getSnapshot;\n\tconst prevValue = inst._value;\n\ttry {\n\t\tconst nextValue = latestGetSnapshot();\n\t\treturn !is(prevValue, nextValue);\n\t} catch (error) {\n\t\treturn true;\n\t}\n}\n\nexport * from 'preact/hooks';\nexport {\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tisFragment,\n\tisMemo,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tflushSync,\n\t// eslint-disable-next-line camelcase\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n\n// React copies the named exports to the default one.\nexport default {\n\tuseState,\n\tuseId,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseInsertionEffect,\n\tuseTransition,\n\tuseDeferredValue,\n\tuseSyncExternalStore,\n\tstartTransition,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tisElement,\n\tisFragment,\n\tisMemo,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tflushSync,\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n","import { options, Fragment } from 'preact';\nimport { encodeEntities } from './utils';\nimport { IS_NON_DIMENSIONAL } from '../../src/constants';\n\nlet vnodeId = 0;\n\nconst isArray = Array.isArray;\n\n/**\n * @fileoverview\n * This file exports various methods that implement Babel's \"automatic\" JSX runtime API:\n * - jsx(type, props, key)\n * - jsxs(type, props, key)\n * - jsxDEV(type, props, key, __source, __self)\n *\n * The implementation of createVNode here is optimized for performance.\n * Benchmarks: https://esbench.com/bench/5f6b54a0b4632100a7dcd2b3\n */\n\n/**\n * JSX.Element factory used by Babel's {runtime:\"automatic\"} JSX transform\n * @param {VNode['type']} type\n * @param {VNode['props']} props\n * @param {VNode['key']} [key]\n * @param {unknown} [isStaticChildren]\n * @param {unknown} [__source]\n * @param {unknown} [__self]\n */\nfunction createVNode(type, props, key, isStaticChildren, __source, __self) {\n\tif (!props) props = {};\n\t// We'll want to preserve `ref` in props to get rid of the need for\n\t// forwardRef components in the future, but that should happen via\n\t// a separate PR.\n\tlet normalizedProps = props,\n\t\tref,\n\t\ti;\n\n\tif ('ref' in props) {\n\t\tref = props.ref;\n\t\tdelete props.ref;\n\t}\n\n\t/** @type {VNode & { __source: any; __self: any }} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops: normalizedProps,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: --vnodeId,\n\t\t_index: -1,\n\t\t_flags: 0,\n\t\t__source,\n\t\t__self\n\t};\n\n\t// If a Component VNode, check for and apply defaultProps.\n\t// Note: `type` is often a String, and can be `undefined` in development.\n\tif (typeof type === 'function' && (ref = type.defaultProps)) {\n\t\tfor (i in ref)\n\t\t\tif (typeof normalizedProps[i] === 'undefined') {\n\t\t\t\tnormalizedProps[i] = ref[i];\n\t\t\t}\n\t}\n\n\tif (options.vnode) options.vnode(vnode);\n\treturn vnode;\n}\n\n/**\n * Create a template vnode. This function is not expected to be\n * used directly, but rather through a precompile JSX transform\n * @param {string[]} templates\n * @param  {Array<string | null | VNode>} exprs\n * @returns {VNode}\n */\nfunction jsxTemplate(templates, ...exprs) {\n\tconst vnode = createVNode(Fragment, { tpl: templates, exprs });\n\t// Bypass render to string top level Fragment optimization\n\tvnode.key = vnode._vnode;\n\treturn vnode;\n}\n\nconst JS_TO_CSS = {};\nconst CSS_REGEX = /[A-Z]/g;\n\n/**\n * Serialize an HTML attribute to a string. This function is not\n * expected to be used directly, but rather through a precompile\n * JSX transform\n * @param {string} name The attribute name\n * @param {*} value The attribute value\n * @returns {string}\n */\nfunction jsxAttr(name, value) {\n\tif (options.attr) {\n\t\tconst result = options.attr(name, value);\n\t\tif (typeof result === 'string') return result;\n\t}\n\n\tif (name === 'ref' || name === 'key') return '';\n\tif (name === 'style' && typeof value === 'object') {\n\t\tlet str = '';\n\t\tfor (let prop in value) {\n\t\t\tlet val = value[prop];\n\t\t\tif (val != null && val !== '') {\n\t\t\t\tconst name =\n\t\t\t\t\tprop[0] == '-'\n\t\t\t\t\t\t? prop\n\t\t\t\t\t\t: JS_TO_CSS[prop] ||\n\t\t\t\t\t\t\t(JS_TO_CSS[prop] = prop.replace(CSS_REGEX, '-$&').toLowerCase());\n\n\t\t\t\tlet suffix = ';';\n\t\t\t\tif (\n\t\t\t\t\ttypeof val === 'number' &&\n\t\t\t\t\t// Exclude custom-attributes\n\t\t\t\t\t!name.startsWith('--') &&\n\t\t\t\t\t!IS_NON_DIMENSIONAL.test(name)\n\t\t\t\t) {\n\t\t\t\t\tsuffix = 'px;';\n\t\t\t\t}\n\t\t\t\tstr = str + name + ':' + val + suffix;\n\t\t\t}\n\t\t}\n\t\treturn name + '=\"' + str + '\"';\n\t}\n\n\tif (\n\t\tvalue == null ||\n\t\tvalue === false ||\n\t\ttypeof value === 'function' ||\n\t\ttypeof value === 'object'\n\t) {\n\t\treturn '';\n\t} else if (value === true) return name;\n\n\treturn name + '=\"' + encodeEntities(value) + '\"';\n}\n\n/**\n * Escape a dynamic child passed to `jsxTemplate`. This function\n * is not expected to be used directly, but rather through a\n * precompile JSX transform\n * @param {*} value\n * @returns {string | null | VNode | Array<string | null | VNode>}\n */\nfunction jsxEscape(value) {\n\tif (\n\t\tvalue == null ||\n\t\ttypeof value === 'boolean' ||\n\t\ttypeof value === 'function'\n\t) {\n\t\treturn null;\n\t}\n\n\tif (typeof value === 'object') {\n\t\t// Check for VNode\n\t\tif (value.constructor === undefined) return value;\n\n\t\tif (isArray(value)) {\n\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\tvalue[i] = jsxEscape(value[i]);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n\n\treturn encodeEntities('' + value);\n}\n\nexport {\n\tcreateVNode as jsx,\n\tcreateVNode as jsxs,\n\tcreateVNode as jsxDEV,\n\tFragment,\n\t// precompiled JSX transform\n\tjsxTemplate,\n\tjsxAttr,\n\tjsxEscape\n};\n","export function classes(\n  ...classNames: Array<string | undefined | boolean>\n): string {\n  return classNames.filter(Boolean).join(' ');\n}\n","import { RenderableProps, createContext } from 'preact';\nimport { useContext } from 'preact/hooks';\nimport browser from 'webextension-polyfill';\n\nexport type TranslateFunctionType = (\n  key: string,\n  substitutions?: string | Array<string>\n) => string;\n\nexport type i18nContextType = {\n  t: TranslateFunctionType;\n  langTag: string;\n};\n\nconst contextValue: i18nContextType = {\n  t: browser.i18n.getMessage.bind(browser.i18n),\n  langTag: browser.i18n.getMessage('lang_tag'),\n};\n\nconst i18nContext = createContext<i18nContextType>(contextValue);\n\ntype LocaleType = 'en' | 'ja' | 'zh_hans';\n\ntype I18nProviderProps = {\n  locale?: LocaleType;\n};\n\nexport function I18nProvider(props: RenderableProps<I18nProviderProps>) {\n  if (props.locale !== undefined) {\n    throw new Error('Changing locale is not supported');\n  }\n\n  return (\n    <i18nContext.Provider value={contextValue}>\n      {props.children}\n    </i18nContext.Provider>\n  );\n}\n\nexport function useLocale(): i18nContextType {\n  return useContext(i18nContext);\n}\n","import { useLocale } from '../../common/i18n';\n\nexport type Props = { frequency?: number };\n\nexport function FrequencyIndicator(props: Props) {\n  const { t } = useLocale();\n\n  return (\n    <div class=\"tp-flex tp-gap-1.5 tp-items-center tp-text-smish\">\n      <svg\n        class=\"tp-block tp-h-[12px] tp-w-[12px] tp-fill-current\"\n        role=\"presentation\"\n        viewBox=\"0 0 8 8\"\n      >\n        <rect\n          x=\"0\"\n          y=\"5\"\n          width=\"2\"\n          height=\"3\"\n          rx=\"0.5\"\n          ry=\"0.5\"\n          opacity={!props.frequency ? '0.5' : undefined}\n        />\n        <rect\n          x=\"3\"\n          y=\"3\"\n          width=\"2\"\n          height=\"5\"\n          rx=\"0.5\"\n          ry=\"0.5\"\n          opacity={\n            !props.frequency || props.frequency >= (2500 * 2) / 3\n              ? '0.5'\n              : undefined\n          }\n        />\n        <rect\n          x=\"6\"\n          width=\"2\"\n          height=\"8\"\n          rx=\"0.5\"\n          ry=\"0.5\"\n          opacity={\n            !props.frequency || props.frequency >= 2500 / 3 ? '0.5' : undefined\n          }\n        />\n      </svg>\n      <span>\n        {props.frequency ? (\n          <>\n            {`${t('content_kanji_frequency_label')} ${props.frequency.toLocaleString()}`}\n            <span class=\"tp-text-xs\"> / {Number(2500).toLocaleString()}</span>\n          </>\n        ) : (\n          '-'\n        )}\n      </span>\n    </div>\n  );\n}\n","import { useLocale } from '../../common/i18n';\n\nexport type Props = { gr?: number };\n\nexport function GradeIndicator(props: Props) {\n  const { t } = useLocale();\n\n  let label: string;\n  switch (props.gr || 0) {\n    case 8:\n      label = t('content_kanji_grade_general_use');\n      break;\n\n    case 9:\n      label = t('content_kanji_grade_name_use');\n      break;\n\n    default:\n      if (props.gr === undefined) {\n        label = '-';\n      } else {\n        label = t('content_kanji_grade_label', [String(props.gr)]);\n      }\n      break;\n  }\n\n  return (\n    <div class=\"tp-flex tp-gap-1.5 tp-items-center tp-text-smish\">\n      <svg\n        class=\"tp-block tp-h-[12px] tp-w-[12px] tp-fill-current tp-opacity-50\"\n        role=\"presentation\"\n        viewBox=\"0 0 16 16\"\n      >\n        <circle cx=\"14.5\" cy=\"14.5\" r=\"1.5\" />\n        <path d=\"M8,0A2.87,2.87,0,0,0,5,2.72v2.5A2.92,2.92,0,0,0,8,8a2.92,2.92,0,0,0,3-2.78V2.72A2.87,2.87,0,0,0,8,0Z\" />\n        <path d=\"M13.91,11.71A5.09,5.09,0,0,0,9.45,9H5.09A5.18,5.18,0,0,0,0,14.25.74.74,0,0,0,.73,15h10.9a.74.74,0,0,0,.73-.75,1.49,1.49,0,0,1,1.09-1.45.75.75,0,0,0,.49-.43A.76.76,0,0,0,13.91,11.71Z\" />\n      </svg>\n      <span>{label}</span>\n    </div>\n  );\n}\n","import type { ExpandedRadical, KanjiResult } from '@birchill/jpdict-idb';\n\nimport { useLocale } from '../../common/i18n';\n\nexport type Props = Pick<KanjiResult, 'rad' | 'comp'>;\n\nexport function KanjiComponents(props: Props) {\n  const componentsIncludesRadical = props.comp.some(\n    (comp) => comp.c === props.rad.b || comp.c === props.rad.k\n  );\n\n  return (\n    <div>\n      <table\n        // There's something odd in Firefox where, when you're viewing a\n        // text/plain document, the text color rule on the window doesn't\n        // inherit into the table so we have to explicitly re-establish the\n        // color here.\n        class=\"-tp-mx-3 tp-border-collapse tp-text-[--text-color] tp-text-xs tp-leading-normal\"\n      >\n        {/* Typically, the radical will also be one of the components, but in\n         * case it's not (the data is frequently hand-edited, after all),\n         * make sure we add it first. */}\n        {!componentsIncludesRadical && <RadicalRow {...props.rad} />}\n        {props.comp.map((comp) => {\n          if (comp.c === props.rad.b || comp.c === props.rad.k) {\n            return <RadicalRow key={comp.c} {...props.rad} />;\n          }\n\n          return (\n            <tr key={comp.c} class=\"*:tp-align-top *:tp-py-1\">\n              <td class=\"tp-px-3\" lang=\"ja\">\n                {comp.c}\n              </td>\n              <td class=\"tp-px-1.5\" lang=\"ja\">\n                {comp.na[0] || '-'}\n              </td>\n              <td class=\"tp-px-3\" lang={comp.m_lang}>\n                {comp.m[0] || '-'}\n              </td>\n            </tr>\n          );\n        })}\n      </table>\n    </div>\n  );\n}\n\nfunction RadicalRow(props: ExpandedRadical) {\n  const { t, langTag } = useLocale();\n\n  return (\n    <>\n      <tr class=\"*:tp-bg-[--cell-highlight-bg] *:tp-text-[--cell-highlight-fg] *:tp-align-top *:tp-py-1\">\n        <td class=\"tp-px-3 tp-rounded-s-md\" lang=\"ja\">\n          {props.b || props.k}\n        </td>\n        <td class=\"tp-px-1.5\" lang=\"ja\">\n          {props.na.join('、')}\n        </td>\n        <td class=\"tp-px-3 tp-rounded-e-md\" lang={props.m_lang}>\n          {props.m.join(', ')}\n        </td>\n      </tr>\n      {!!props.base && (\n        <tr class=\"-baseradical\" lang={langTag}>\n          <td\n            colspan={3}\n            class=\"tp-text-[--cell-highlight-fg] tp-align-top tp-py-1 tp-px-3 tp-italic\"\n          >\n            {t('content_kanji_base_radical', [\n              (props.base.b || props.base.k)!,\n              props.base.na.join('、'),\n            ])}\n          </td>\n        </tr>\n      )}\n    </>\n  );\n}\n","import { useLocale } from '../../common/i18n';\n\nexport type Props = { tags: Array<string> };\n\nexport function KanjiMeta(props: Props) {\n  const { t, langTag } = useLocale();\n\n  return (\n    <div class=\"tp-flex tp-gap-2 -tp-mx-1\">\n      {props.tags.map((tag) => (\n        <span\n          key={tag}\n          class=\"tp-text-sm tp-border tp-border-current tp-border-solid tp-rounded tp-py-0.5 tp-px-1\"\n          lang={langTag}\n        >\n          {t(`content_kanji_meta_${tag.replace(' ', '_')}`)}\n        </span>\n      ))}\n    </div>\n  );\n}\n","import type { KanjiResult } from '@birchill/jpdict-idb';\n\nimport { useLocale } from '../../common/i18n';\n\nexport type Props = { r: KanjiResult['r'] };\n\nexport function KanjiReadings(props: Props) {\n  const { t, langTag } = useLocale();\n\n  return (\n    <div lang=\"ja\" class=\"tp-text-[--reading-highlight] tp-text-base\">\n      {props.r.on?.join('、') || null}\n      {props.r.kun?.map((k, i) => {\n        const hasPreceding = i !== 0 || !!props.r.on?.length;\n        return (\n          <>\n            {hasPreceding ? '、' : null}\n            <KunReading k={k} />\n          </>\n        );\n      }) || null}\n      {props.r.na?.length ? (\n        <>\n          <br />\n          <span class=\"tp-text-[--reading-label] tp-text-xs\" lang={langTag}>\n            {t('content_kanji_nanori_label')}\n          </span>{' '}\n          {props.r.na.join('、')}\n        </>\n      ) : null}\n    </div>\n  );\n}\n\n// Kun readings sometimes have a . in them separating the initial part that\n// represents the kanji, from the okurigana.\n//\n// e.g. あた.える\n//\n// We want to take the bit after the '.' and wrap it in a span with an\n// appropriate class.\nfunction KunReading(props: { k: string }) {\n  const highlightIndex = props.k.indexOf('.');\n\n  return highlightIndex === -1 ? (\n    <>{props.k}</>\n  ) : (\n    <>\n      {props.k.substring(0, highlightIndex)}\n      <span class=\"tp-text-[--okurigana-color]\">\n        {props.k.substring(highlightIndex + 1)}\n      </span>\n    </>\n  );\n}\n","import { useLocale } from '../../common/i18n';\n\nexport type Props = { sc: number };\n\nexport function StrokeCount(props: Props) {\n  const { t } = useLocale();\n\n  const strokeLabel =\n    props.sc === 1\n      ? t('content_kanji_strokes_label_1')\n      : t('content_kanji_strokes_label', [String(props.sc)]);\n\n  return (\n    <div class=\"tp-flex tp-gap-1.5 tp-items-center tp-text-smish\">\n      <svg\n        class=\"tp-block tp-h-[12px] tp-w-[12px] tp-fill-current tp-opacity-50\"\n        role=\"presentation\"\n        viewBox=\"0 0 16 16\"\n      >\n        <circle cx=\"14.5\" cy=\"1.5\" r=\"1.5\" />\n        <polyline\n          points=\"13 4.5 4 13.5 1 15 2.5 12 11.5 3\"\n          fill=\"none\"\n          stroke=\"currentColor\"\n          stroke-width=\"1.5\"\n          stroke-linecap=\"round\"\n          stroke-linejoin=\"round\"\n        />\n      </svg>\n      <span>{strokeLabel}</span>\n    </div>\n  );\n}\n","import type { KanjiResult } from '@birchill/jpdict-idb';\n\nimport { useLocale } from '../../common/i18n';\n\nimport { FrequencyIndicator } from './FrequencyIndicator';\nimport { GradeIndicator } from './GradeIndicator';\nimport { KanjiComponents } from './KanjiComponents';\nimport { KanjiMeta } from './KanjiMeta';\nimport { KanjiReadings } from './KanjiReadings';\nimport { StrokeCount } from './StrokeCount';\n\nexport type Props = Pick<\n  KanjiResult,\n  'r' | 'misc' | 'm' | 'm_lang' | 'rad' | 'comp'\n> & {\n  showComponents?: boolean;\n};\n\nexport function KanjiInfo(props: Props) {\n  const { langTag } = useLocale();\n\n  return (\n    <div class=\"tp-flex tp-flex-col tp-gap-3\">\n      <KanjiReadings r={props.r} />\n      {!!props.misc.meta?.length && (\n        <div class=\"-tp-mt-1.5\">\n          <KanjiMeta tags={props.misc.meta} />\n        </div>\n      )}\n      <div class=\"tp-text-base tp-leading-snug\" lang={props.m_lang}>\n        {props.m.join(', ')}\n      </div>\n      <div class=\"tp-flex tp-items-base tp-gap-3.5 *:tp-grow\" lang={langTag}>\n        <StrokeCount sc={props.misc.sc} />\n        <FrequencyIndicator frequency={props.misc.freq} />\n        <GradeIndicator gr={props.misc.gr} />\n      </div>\n      {props.showComponents !== false && (\n        <KanjiComponents rad={props.rad} comp={props.comp} />\n      )}\n    </div>\n  );\n}\n","import { KanjiResult } from '@birchill/jpdict-idb';\nimport type { RenderableProps } from 'preact';\nimport { useMemo } from 'preact/hooks';\n\nimport { useLocale } from '../../common/i18n';\nimport {\n  ReferenceAbbreviation,\n  getSelectedReferenceLabels,\n} from '../../common/refs';\nimport { classes } from '../../utils/classes';\n\nimport { getReferenceValue } from '../reference-value';\n\ntype Props = {\n  entry: KanjiResult;\n  kanjiReferences: Array<ReferenceAbbreviation>;\n};\n\nexport function KanjiReferencesTable({ entry, kanjiReferences }: Props) {\n  const { t, langTag } = useLocale();\n\n  const referenceTableInfo = useMemo(() => {\n    const referenceNames = getSelectedReferenceLabels(kanjiReferences, t);\n    const referenceTableInfo = [];\n    for (const ref of referenceNames) {\n      // Don't show the Nelson radical if it's the same as the regular radical\n      // (in which case it will be empty) and we're showing the regular radical.\n      if (\n        ref.ref === 'nelson_r' &&\n        !entry.rad.nelson &&\n        kanjiReferences.includes('radical')\n      ) {\n        continue;\n      }\n\n      const value = getReferenceValue(entry, ref.ref, t) || '-';\n      referenceTableInfo.push({\n        ref: ref.ref,\n        name: {\n          lang: ref.lang,\n          value: ref.short || ref.full,\n        },\n        value: {\n          lang:\n            ref.ref === 'radical' || ref.ref === 'nelson_r' ? 'ja' : undefined,\n          value,\n        },\n        highlight: false,\n      });\n    }\n\n    // Now we go through and toggle the styles to get the desired alternating\n    // effect.\n    //\n    // We can't easily use nth-child voodoo here because we need to\n    // handle unbalanced columns etc. We also can't easily do this in the loop\n    // where we generate the cells because we don't know how many references we\n    // will generate at that point.\n    for (const [index, cellInfo] of [...referenceTableInfo].entries()) {\n      const row = index % Math.ceil(referenceTableInfo.length / 2);\n      if (row % 2 === 0) {\n        cellInfo.highlight = true;\n      }\n    }\n\n    return referenceTableInfo;\n  }, [t, kanjiReferences]);\n\n  // The layout we want is something in-between what CSS grid and CSS multicol\n  // can do. See:\n  //\n  //   https://twitter.com/brianskold/status/1186198347184398336\n  //\n  // In the stylesheet we make let the table flow horizontally, but then here\n  // where we know the number of rows, we update it to produce the desired\n  // vertical flow.\n  let gridAutoFlow: string | undefined;\n  let gridTemplateRows: string | undefined;\n  if (referenceTableInfo.length > 1) {\n    gridAutoFlow = 'column';\n    gridTemplateRows = `repeat(${Math.ceil(\n      referenceTableInfo.length / 2\n    )}, minmax(min-content, max-content))`;\n  }\n\n  return (\n    <div\n      class={classes(\n        'tp-grid tp-grid-cols-[repeat(2,minmax(200px,1fr))] tp-gap-x-2',\n        'max-[450px]:tp-grid-cols-none',\n        '[--bg-overhang:8px]',\n        '-tp-mx-[--bg-overhang] tp-w-[calc(100%+2*var(--bg-overhang))]'\n      )}\n      lang={langTag}\n      style={{ gridAutoFlow, gridTemplateRows }}\n    >\n      {referenceTableInfo.map((cellInfo) => (\n        <ReferenceEntryWrapper\n          c={entry.c}\n          highlight={cellInfo.highlight}\n          refCode={cellInfo.ref}\n          key={cellInfo.name.value}\n        >\n          <span lang={cellInfo.name.lang}>{cellInfo.name.value}</span>\n          <span class=\"tp-ml-2\" lang={cellInfo.value.lang}>\n            {cellInfo.value.value}\n          </span>\n        </ReferenceEntryWrapper>\n      ))}\n    </div>\n  );\n}\n\nfunction ReferenceEntryWrapper(\n  props: RenderableProps<{\n    c: string;\n    highlight: boolean;\n    refCode: ReferenceAbbreviation;\n  }>\n) {\n  const { t } = useLocale();\n\n  const href =\n    props.refCode === 'wk'\n      ? `https://wanikani.com/kanji/${encodeURIComponent(props.c)}`\n      : undefined;\n\n  const containerStyles = classes(\n    'tp-flex tp-justify-between',\n    'tp-rounded-lg tp-px-[--bg-overhang] tp-py-0.5',\n    'tp-text-sm tp-leading-normal',\n    href &&\n      'tp-cursor-pointer hover:tp-bg-[--cell-bg-hover] tp-underline-offset-2',\n    href\n      ? 'tp-text-[--cell-link-fg]'\n      : props.highlight\n        ? 'tp-text-[--cell-highlight-fg]'\n        : '',\n    props.highlight && 'tp-bg-[--cell-highlight-bg]'\n  );\n\n  if (href) {\n    return (\n      <a\n        href={href}\n        target=\"_blank\"\n        rel=\"noreferrer\"\n        class={containerStyles}\n        title={t('content_wk_link_title', props.c)}\n      >\n        {props.children}\n      </a>\n    );\n  } else {\n    return <div class={containerStyles}>{props.children}</div>;\n  }\n}\n","import type { RefObject } from 'preact';\nimport {\n  type MutableRef,\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'preact/hooks';\n\nimport { useLocale } from '../../common/i18n';\nimport { classes } from '../../utils/classes';\n\nexport type Props = {\n  onClick?: (trigger: 'touch' | 'mouse') => void;\n  selectState: 'unselected' | 'selected' | 'flash';\n  st: string;\n};\n\nconst STROKE_SPEED = 150; // User units / second\nconst STROKE_GAP = 250; // ms\nconst FREEZE_LENGTH = 1000; // ms\n\nconst TIMELINE_RANGE = 50; // px in SVG user unit space\n\n// This is a bit larger than the actual range the scrubber moves\n// so that you have a bit more control over seeking.\nconst SCRUBBER_DRAG_RANGE = TIMELINE_RANGE + 10; // px in SVG user unit space\n\n// How far the timeline is from the left edge of the SVG\nconst TIMELINE_OFFSET = 35; // px in SVG user unit space\n\nexport function KanjiStrokeAnimation(props: Props) {\n  const { t } = useLocale();\n\n  // References\n  const animatedStrokeContainer = useRef<SVGGElement>(null);\n  const timelineSvg = useRef<SVGSVGElement>(null);\n  const scrubberContainer = useRef<SVGGElement>(null);\n\n  // Animation state\n  const [isPlaying, setIsPlaying] = useState(false);\n  const currentAnimations = useRef<Array<Animation>>([]);\n\n  // Scrubber handling\n  const { applySeek, onScrubberPointerDown, onTimelineClick } = useScrubber(\n    timelineSvg,\n    currentAnimations\n  );\n\n  // Update the animation parameters\n  const subpaths = useMemo(() => props.st.split(/(?=M[0-9])/), [props.st]);\n  useLayoutEffect(() => {\n    if (!animatedStrokeContainer.current || !isPlaying) {\n      currentAnimations.current = [];\n      return;\n    }\n\n    const animations: Array<Animation> = [];\n\n    // Stroke animations\n    const paths = Array.from(\n      animatedStrokeContainer.current.querySelectorAll('path')\n    );\n    const strokeDurations = paths.map(\n      (stroke) => stroke.getTotalLength() * (1000 / STROKE_SPEED)\n    );\n    const totalDuration =\n      strokeDurations.reduce((acc, length) => acc + length, 0) +\n      STROKE_GAP * (paths.length - 1) +\n      FREEZE_LENGTH;\n\n    let cumulativeDuration = 0;\n    for (const [i, stroke] of paths.entries()) {\n      const duration = strokeDurations[i];\n      const startOffset = cumulativeDuration / totalDuration;\n      const endOffset = Math.min(\n        (cumulativeDuration + duration) / totalDuration,\n        1\n      );\n      animations.push(\n        stroke.animate(\n          {\n            strokeDashoffset: [100, 100, 0, 0],\n            offset: [0, startOffset, endOffset, 1],\n            easing: 'cubic-bezier(.28,.08,.79,.6)',\n          },\n          { duration: totalDuration, iterations: Infinity }\n        )\n      );\n      cumulativeDuration += duration + STROKE_GAP;\n    }\n\n    // Scrubber animation\n    if (scrubberContainer.current) {\n      animations.push(\n        scrubberContainer.current.animate(\n          {\n            transform: [\n              'translate(0)',\n              `translate(${TIMELINE_RANGE}px)`,\n              `translate(${TIMELINE_RANGE}px)`,\n            ],\n            offset: [0, (totalDuration - FREEZE_LENGTH) / totalDuration],\n          },\n          { duration: totalDuration, iterations: Infinity }\n        )\n      );\n    }\n\n    // If we are currently seeking, fast-forward to the appropriate point\n    applySeek(animations);\n\n    currentAnimations.current = animations;\n\n    return () => {\n      currentAnimations.current.forEach((animation) => animation.cancel());\n      currentAnimations.current = [];\n    };\n  }, [subpaths, isPlaying]);\n\n  // Rendering parameters\n  const strokeWidth = subpaths.length > 16 ? 4 : 5;\n\n  // Copy state\n  const lastPointerType = useRef<string>('touch');\n\n  return (\n    <div class=\"tp-flex tp-flex-col tp-items-center tp-gap-3\">\n      <svg\n        class={classes(\n          'tp-group',\n          'tp-h-big-kanji tp-w-big-kanji tp-rounded-md',\n          'hh:hover:tp-bg-[--hover-bg]',\n          'hh:hover:tp-cursor-pointer',\n          // Fade _out_ the color change\n          'hh:tp-transition-colors hh:interactive:tp-duration-100',\n          'hh:tp-ease-out',\n          'hh:hover:tp-transition-none',\n          // Ensure any selection colors are applied before fading in the\n          // overlay\n          props.selectState === 'selected' &&\n            'no-overlay:tp-text-[--selected-highlight] no-overlay:tp-bg-[--selected-bg]',\n          // Run the flash animation, but not until the overlay has\n          // disappeared.\n          props.selectState === 'flash' && 'no-overlay:tp-animate-flash'\n        )}\n        viewBox=\"0 0 109 109\"\n        onPointerUp={(evt) => {\n          lastPointerType.current = evt.pointerType;\n        }}\n        onClick={() => {\n          const trigger =\n            lastPointerType.current === 'mouse' ? 'mouse' : 'touch';\n          props.onClick?.(trigger);\n        }}\n      >\n        <g\n          stroke-width={strokeWidth}\n          stroke-linecap=\"round\"\n          stroke-linejoin=\"round\"\n          stroke=\"var(--text-color)\"\n          opacity=\"0.3\"\n          fill=\"none\"\n        >\n          {subpaths.map((path, index) => (\n            <path key={index} d={path} fill=\"none\" />\n          ))}\n        </g>\n        <g\n          class={classes(\n            'tp-stroke-[--primary-highlight] hh:group-hover:tp-stroke-[--selected-highlight]',\n            'hh:tp-transition-colors hh:interactive:tp-duration-100',\n            'hh:tp-ease-out',\n            'hh:hover:tp-transition-none',\n            props.selectState === 'selected' &&\n              'no-overlay:tp-stroke-[--selected-highlight]'\n          )}\n          stroke-width={strokeWidth}\n          stroke-linecap=\"round\"\n          stroke-linejoin=\"round\"\n          stroke=\"var(--primary-highlight)\"\n          stroke-dasharray=\"100 100\"\n          stroke-dashoffset={isPlaying ? 100 : 0}\n          fill=\"none\"\n          ref={animatedStrokeContainer}\n        >\n          {subpaths.map((path, index) => (\n            <path\n              key={index}\n              d={path}\n              fill=\"none\"\n              // We use 99.5 instead of 100 to work around path length\n              // inaccuracies in Chrome. Without this you'd occasionally see a\n              // dot at the end of a stroke that should be invisible.\n              pathLength={99.5}\n            />\n          ))}\n        </g>\n      </svg>\n      <div>\n        {/* The content is only 25 user units high but we make it 50 so that we\n         * can expand the hit regions vertically since iOS Safari doesn't do\n         * very good hit detection of small targets. */}\n        <svg\n          class=\"tp-w-big-kanji\"\n          ref={timelineSvg}\n          viewBox=\"0 0 100 50\"\n          style={{\n            webkitTapHighlightColor: 'transparent',\n          }}\n        >\n          {/* Play/stop button */}\n          <g\n            onClick={() => setIsPlaying((prev) => !prev)}\n            pointer-events=\"all\"\n            class=\"tp-cursor-pointer tp-opacity-30 hh:hover:tp-opacity-100 tp-fill-[--text-color] hh:hover:tp-fill-[--primary-highlight] tp-transition-transform tp-duration-500\"\n            style={{\n              transform: isPlaying ? 'none' : 'translate(40px)',\n            }}\n          >\n            <title>\n              {t(\n                isPlaying\n                  ? 'content_stroke_animation_stop'\n                  : 'content_stroke_animation_play'\n              )}\n            </title>\n            {/* Play/stop button hit region */}\n            <rect\n              x={isPlaying ? 0 : -40}\n              width={isPlaying ? 25 : 100}\n              height={50}\n              fill=\"none\"\n            />\n            <path\n              d={\n                isPlaying\n                  ? 'M20 12.5v6a4 4 0 01-4 4l-12 0c0 0 0 0 0 0a4 4 90 01-4-4v-12a4 4 90 014-4c0 0 0 0 0 0l12 0a4 4 0 014 4z'\n                  : 'M20 12.5v0a2 2 0 01-1 1.7l-16.1 8.1c-.3.1-.6.2-.9.2a2 2 90 01-2-2v-16a2 2 90 012-2c.3 0 .7.1 1 .2l16 8.1a2 2 0 011 1.7z'\n              }\n              class=\"tp-transition-[d] tp-duration-500\"\n              transform=\"scale(0.9)\"\n              transform-origin=\"10px 12.5px\"\n            />\n          </g>\n          {/* Timeline and scrubber */}\n          <g\n            style={{\n              transform: isPlaying ? 'translate(25px)' : 'translate(65px)',\n            }}\n            class={classes(\n              'tp-transition-transform tp-duration-500',\n              isPlaying ? 'tp-delay-100' : 'tp-pointer-events-none'\n            )}\n          >\n            {/* Timeline */}\n            <g\n              fill=\"var(--primary-highlight)\"\n              opacity=\"0.1\"\n              style={{\n                transform: isPlaying ? 'scale(1)' : 'scale(0)',\n                transformOrigin: '12.5px 12.5px',\n              }}\n              class={classes(\n                'tp-transition-transform',\n                !isPlaying && 'tp-delay-[450ms]'\n              )}\n              onClick={onTimelineClick}\n            >\n              {/* Timeline middle rectangle */}\n              <rect\n                x={12.5}\n                // Add an extra pixel to the width to avoid a gap between the\n                // scrubber and the right end of the timeline.\n                width={TIMELINE_RANGE + 1}\n                height={25}\n                style={{\n                  transform: isPlaying ? 'scale(1)' : 'scale(0, 1)',\n                  transformOrigin: '12.5px 12.5px',\n                }}\n                class={classes(\n                  'tp-transition-transform tp-duration-500',\n                  isPlaying && 'tp-delay-100'\n                )}\n              />\n              {/* Timeline rounded left end */}\n              <path d=\"M12.5 0a12.5 12.5 0 0 0 0 25z\" />\n              {/* Timeline rounded right end */}\n              <path\n                d={`M${TIMELINE_RANGE + 12.5} 0a12.5 12.5 0 0 1 0 25z`}\n                style={{\n                  transform: isPlaying\n                    ? 'translate(0)'\n                    : `translate(-${TIMELINE_RANGE}px)`,\n                }}\n                class={classes(\n                  'tp-transition-transform tp-duration-500',\n                  isPlaying && 'tp-delay-100'\n                )}\n              />\n            </g>\n            {/* Scrubber group -- translation animation is applied here */}\n            <g ref={scrubberContainer}>\n              {/* Scrubber scale group */}\n              <g\n                style={{\n                  transform: isPlaying ? 'scale(1)' : 'scale(0)',\n                  transformOrigin: '12.5px 12.5px',\n                }}\n                class={classes(\n                  'tp-transition-transform',\n                  !isPlaying ? 'tp-delay-[400ms]' : 'tp-delay-50'\n                )}\n              >\n                {/* Hit region for scrubber */}\n                <rect\n                  x={-10}\n                  width={40}\n                  height={50}\n                  fill=\"none\"\n                  class=\"tp-cursor-pointer tp-peer\"\n                  pointer-events=\"all\"\n                  onPointerDown={onScrubberPointerDown}\n                  // This is needed to prevent the container from scrolling\n                  onTouchStart={(evt) => evt.preventDefault()}\n                />\n                <circle\n                  cx={12.5}\n                  cy={12.5}\n                  r={8}\n                  class=\"tp-fill-[--primary-highlight] tp-opacity-50 peer-hover:tp-opacity-100\"\n                  pointer-events=\"none\"\n                />\n              </g>\n            </g>\n          </g>\n        </svg>\n      </div>\n    </div>\n  );\n}\n\nfunction useScrubber(\n  timelineSvg: RefObject<SVGSVGElement>,\n  currentAnimations: MutableRef<Array<Animation>>\n): {\n  applySeek: (animations: Array<Animation>) => void;\n  onScrubberPointerDown: (event: PointerEvent) => void;\n  onTimelineClick: (event: MouseEvent) => void;\n} {\n  const seekState = useRef<{ scrubberStart: number; offset: number } | null>(\n    null\n  );\n\n  // The following callback needs to be stable so that the caller doesn't need\n  // to mark it as a dependency in their effects.\n\n  const applySeek = useCallback((animations: Array<Animation>) => {\n    if (!seekState.current) {\n      return;\n    }\n\n    for (const animation of animations) {\n      if (animation.playState !== 'paused') {\n        animation.pause();\n      }\n      const timing = animation.effect!.getComputedTiming();\n      animation.currentTime =\n        seekState.current.offset *\n        ((timing.duration as number) - FREEZE_LENGTH);\n    }\n  }, []);\n\n  // The following callbacks need to be stable so we can unregister them from\n  // the window when dragging stops or the component unmounts.\n\n  const onWindowPointerMove = useCallback((event: PointerEvent) => {\n    if (!seekState.current || !timelineSvg.current) {\n      return;\n    }\n\n    // Calculate the offset of the scrubber\n    const [svgX] = toSvgCoords(timelineSvg.current, event.clientX, 0);\n    const offset = Math.min(\n      Math.max(\n        (svgX - seekState.current.scrubberStart) / SCRUBBER_DRAG_RANGE,\n        0\n      ),\n      1\n    );\n    seekState.current.offset = offset;\n\n    // Seek each of the animations to the equivalent point\n    applySeek(currentAnimations.current);\n  }, []);\n\n  const onWindowPointerUpOrCancel = useCallback(() => {\n    if (!seekState.current) {\n      return;\n    }\n\n    currentAnimations.current.forEach((animation) => animation.play());\n    seekState.current = null;\n\n    window.removeEventListener('pointermove', onWindowPointerMove);\n    window.removeEventListener('pointerup', onWindowPointerUpOrCancel);\n    window.removeEventListener('pointercancel', onWindowPointerUpOrCancel);\n  }, []);\n\n  useEffect(() => {\n    return () => {\n      if (seekState.current) {\n        window.removeEventListener('pointermove', onWindowPointerMove);\n        window.removeEventListener('pointerup', onWindowPointerUpOrCancel);\n        window.removeEventListener('pointercancel', onWindowPointerUpOrCancel);\n      }\n    };\n  }, []);\n\n  const onScrubberPointerDown = (event: PointerEvent) => {\n    if (seekState.current || !timelineSvg.current) {\n      return;\n    }\n\n    // Work out how far we are into the animation\n    if (currentAnimations.current.length === 0) {\n      return;\n    }\n    const animationTiming =\n      currentAnimations.current[0].effect!.getComputedTiming();\n    const iterationProgress = animationTiming.progress as number;\n    const iterationDuration = animationTiming.duration as number;\n    const strokeAnimationProgress = Math.min(\n      iterationProgress *\n        (iterationDuration / (iterationDuration - FREEZE_LENGTH)),\n      1\n    );\n\n    // Based on that, work out where the scrubber should start\n    const [svgX] = toSvgCoords(timelineSvg.current, event.clientX, 0);\n    const scrubberStart = svgX - strokeAnimationProgress * SCRUBBER_DRAG_RANGE;\n    seekState.current = { scrubberStart, offset: strokeAnimationProgress };\n\n    // Pause the animations\n    currentAnimations.current.forEach((animation) => animation.pause());\n\n    // Register the move/up/cancel events\n    window.addEventListener('pointermove', onWindowPointerMove);\n    window.addEventListener('pointerup', onWindowPointerUpOrCancel);\n    window.addEventListener('pointercancel', onWindowPointerUpOrCancel);\n  };\n\n  const onTimelineClick = useCallback((event: MouseEvent) => {\n    if (seekState.current || !timelineSvg.current) {\n      return;\n    }\n\n    const [svgX] = toSvgCoords(timelineSvg.current, event.clientX, 0);\n    const offset = Math.min(\n      Math.max((svgX - TIMELINE_OFFSET) / TIMELINE_RANGE, 0),\n      1\n    );\n\n    // Seek the animations to that point\n    for (const animation of currentAnimations.current) {\n      const timing = animation.effect!.getComputedTiming();\n      animation.currentTime =\n        offset * ((timing.duration as number) - FREEZE_LENGTH);\n    }\n  }, []);\n\n  return {\n    onScrubberPointerDown,\n    onTimelineClick,\n    applySeek,\n  };\n}\n\nfunction toSvgCoords(\n  svg: SVGSVGElement,\n  x: number,\n  y: number\n): [number, number] {\n  const ctm = svg.getScreenCTM()!;\n  const point = svg.createSVGPoint();\n  point.x = x;\n  point.y = y;\n  const transformed = point.matrixTransform(ctm.inverse());\n  return [transformed.x, transformed.y];\n}\n","import { RenderableProps, createContext } from 'preact';\nimport { useContext } from 'preact/hooks';\n\n// Not every popup option belongs here. This is really just for cross-cutting\n// options that we want to be able to toggle from the Cosmos UI.\n\nexport type PopupOptionsContextType = {\n  interactive: boolean;\n};\n\nconst contextValue: PopupOptionsContextType = {\n  interactive: true,\n};\n\nconst popupOptionsContext =\n  createContext<PopupOptionsContextType>(contextValue);\n\ntype PopupOptionsProviderProps = PopupOptionsContextType;\n\nexport function PopupOptionsProvider(\n  props: RenderableProps<PopupOptionsProviderProps>\n) {\n  return (\n    <popupOptionsContext.Provider value={props}>\n      {props.children}\n    </popupOptionsContext.Provider>\n  );\n}\n\nexport function usePopupOptions(): PopupOptionsContextType {\n  return useContext(popupOptionsContext);\n}\n","export function containerHasSelectedText(container: HTMLElement) {\n  const selection = window.getSelection();\n  return (\n    selection &&\n    !selection.isCollapsed &&\n    container.contains(selection.focusNode)\n  );\n}\n","import type { KanjiResult } from '@birchill/jpdict-idb';\nimport { useRef } from 'preact/hooks';\n\nimport type { ReferenceAbbreviation } from '../../common/refs';\nimport { classes } from '../../utils/classes';\n\nimport { KanjiInfo } from './KanjiInfo';\nimport { KanjiReferencesTable } from './KanjiReferencesTable';\nimport { KanjiStrokeAnimation } from './KanjiStrokeAnimation';\nimport { usePopupOptions } from './options-context';\nimport { containerHasSelectedText } from './selection';\nimport type { StartCopyCallback } from './show-popup';\n\nexport type Props = {\n  entry: KanjiResult;\n  index: number;\n  kanjiReferences: Array<ReferenceAbbreviation>;\n  onStartCopy?: StartCopyCallback;\n  selectState: 'unselected' | 'selected' | 'flash';\n  showComponents?: boolean;\n};\n\nexport function KanjiEntry(props: Props) {\n  const kanjiTable = useRef<HTMLDivElement>(null);\n\n  return (\n    <div\n      class={classes(\n        'tp-flex tp-flex-col tp-gap-3.5 tp-px-5 tp-py-3',\n        // Set the -selected / -flash class since we use that we scroll into\n        // view any selected item during / after copying.\n        //\n        // Once everything is converted to Preact we hopefully won't need this\n        // anymore (since we'll do minimal DOM updates) but if we do, then we\n        // should prefer using a data attribute to a CSS class.\n        props.selectState === 'selected' && '-selected',\n        props.selectState === 'flash' && '-flash'\n      )}\n      ref={kanjiTable}\n    >\n      <div class=\"tp-flex tp-items-start tp-gap-[20px]\">\n        <KanjiCharacter\n          c={props.entry.c}\n          onClick={(trigger) => {\n            if (containerHasSelectedText(kanjiTable.current!)) {\n              return;\n            }\n\n            props.onStartCopy?.(props.index, trigger);\n          }}\n          selectState={props.selectState}\n          st={props.entry.st}\n        />\n        <div class=\"tp-mt-1.5 tp-grow\">\n          <KanjiInfo {...props.entry} showComponents={props.showComponents} />\n        </div>\n      </div>\n      {!!props.kanjiReferences.length && (\n        <div>\n          <KanjiReferencesTable\n            entry={props.entry}\n            kanjiReferences={props.kanjiReferences}\n          />\n        </div>\n      )}\n    </div>\n  );\n}\n\ntype KanjiCharacterProps = {\n  c: string;\n  onClick?: (trigger: 'touch' | 'mouse') => void;\n  selectState: 'unselected' | 'selected' | 'flash';\n  st?: string;\n};\n\nfunction KanjiCharacter(props: KanjiCharacterProps) {\n  const { interactive } = usePopupOptions();\n\n  // There's no way to trigger the animation when we're not in \"mouse\n  // interactive\" mode so just show the static character in that case.\n  return props.st && interactive ? (\n    <KanjiStrokeAnimation\n      onClick={props.onClick}\n      selectState={props.selectState}\n      st={props.st}\n    />\n  ) : (\n    <StaticKanjiCharacter\n      c={props.c}\n      onClick={props.onClick}\n      selectState={props.selectState}\n    />\n  );\n}\n\nfunction StaticKanjiCharacter(props: KanjiCharacterProps) {\n  const lastPointerType = useRef<string>('touch');\n  const { interactive } = usePopupOptions();\n\n  return (\n    <div\n      class={classes(\n        'tp-text-[--primary-highlight] tp-text-big-kanji tp-text-center tp-pt-2 tp-rounded-md',\n        '[text-shadow:var(--shadow-color)_1px_1px_4px]',\n        ...(interactive\n          ? [\n              'hh:hover:tp-text-[--selected-highlight]',\n              'hh:hover:tp-bg-[--hover-bg]',\n              'hh:hover:tp-cursor-pointer',\n              // Fade _out_ the color change\n              'hh:tp-transition-colors hh:interactive:tp-duration-100',\n              'hh:tp-ease-out',\n              'hh:hover:tp-transition-none',\n            ]\n          : []),\n        // Ensure any selection colors are applied before fading in the\n        // overlay\n        props.selectState === 'selected' &&\n          'no-overlay:tp-text-[--selected-highlight] no-overlay:tp-bg-[--selected-bg]',\n        // Run the flash animation, but not until the overlay has\n        // disappeared.\n        props.selectState === 'flash' && 'no-overlay:tp-animate-flash'\n      )}\n      lang=\"ja\"\n      onPointerUp={(evt) => {\n        lastPointerType.current = evt.pointerType;\n      }}\n      onClick={() => {\n        const trigger = lastPointerType.current === 'mouse' ? 'mouse' : 'touch';\n        props.onClick?.(trigger);\n      }}\n    >\n      {props.c}\n    </div>\n  );\n}\n","import type { CopyState } from './copy-state';\n\nexport function getSelectedIndex(copyState: CopyState, numEntries: number) {\n  return copyState.kind !== 'inactive' && numEntries\n    ? copyState.index % numEntries\n    : -1;\n}\n","import { KanjiResult } from '@birchill/jpdict-idb';\nimport { h, render } from 'preact';\n\nimport { html } from '../../utils/builder';\n\nimport { KanjiEntry } from './KanjiEntry';\nimport { PopupOptionsProvider } from './options-context';\nimport { getSelectedIndex } from './selected-index';\nimport { ShowPopupOptions } from './show-popup';\n\nexport function renderKanjiEntries({\n  entries,\n  options,\n}: {\n  entries: ReadonlyArray<KanjiResult>;\n  options: ShowPopupOptions;\n}): HTMLElement {\n  const container = html('div', { class: 'kanjilist entry-data' });\n\n  const selectedIndex = getSelectedIndex(options.copyState, entries.length);\n  for (const [i, entry] of entries.entries()) {\n    if (i === 1) {\n      container.append(html('div', { class: 'fold-point' }));\n    }\n    container.append(\n      renderKanjiEntry({\n        entry,\n        index: i,\n        options,\n        selectState:\n          selectedIndex === i\n            ? options.copyState.kind === 'active'\n              ? 'selected'\n              : 'flash'\n            : 'unselected',\n      })\n    );\n  }\n\n  return container;\n}\n\nfunction renderKanjiEntry({\n  entry,\n  index,\n  options,\n  selectState,\n}: {\n  entry: KanjiResult;\n  index: number;\n  options: ShowPopupOptions;\n  selectState: 'unselected' | 'selected' | 'flash';\n}): HTMLElement {\n  const containerElement = html('div', {\n    /* Make sure it's possible to scroll all the way to the bottom of each kanji\n     * table. */\n    style:\n      'scroll-snap-align: start; scroll-margin-bottom: var(--expand-button-allowance);',\n  });\n  render(\n    h(\n      PopupOptionsProvider,\n      { interactive: options.interactive },\n      h(KanjiEntry, {\n        entry,\n        index,\n        kanjiReferences: options.kanjiReferences,\n        onStartCopy: options.onStartCopy,\n        selectState,\n        showComponents: options.showKanjiComponents,\n      })\n    ),\n    containerElement\n  );\n  return containerElement;\n}\n","import browser from 'webextension-polyfill';\n\nimport { ContentConfigParams } from '../../common/content-config-params';\nimport { html } from '../../utils/builder';\n\nimport { CurrencyMeta } from '../currency';\nimport { MeasureMeta, convertMeasure } from '../measure';\nimport { SelectionMeta } from '../meta';\nimport { NumberMeta } from '../numbers';\nimport { ShogiMeta, serializeShogi, serializeShogiDest } from '../shogi';\nimport { EraInfo, EraMeta, getEraInfo } from '../years';\n\nimport { getLangTag } from './lang-tag';\n\nexport function renderMetadata({\n  fxData,\n  preferredUnits,\n  isCombinedResult,\n  matchLen,\n  meta,\n}: {\n  fxData: ContentConfigParams['fx'];\n  preferredUnits: ContentConfigParams['preferredUnits'];\n  isCombinedResult: boolean;\n  matchLen: number;\n  meta: SelectionMeta;\n}): HTMLElement | null {\n  switch (meta.type) {\n    case 'era':\n      {\n        const eraInfo = getEraInfo(meta.era);\n        if (eraInfo) {\n          return renderEraInfo(meta, eraInfo);\n        }\n      }\n      break;\n\n    case 'measure':\n      return renderMeasureInfo(meta, preferredUnits);\n\n    case 'currency':\n      return fxData ? renderCurrencyInfo(meta, fxData) : null;\n\n    case 'number':\n      return meta.matchLen > matchLen\n        ? renderNumberInfo(meta, { isCombinedResult })\n        : null;\n\n    case 'shogi':\n      return renderShogiInfo(meta);\n  }\n\n  return null;\n}\n\nfunction renderEraInfo(meta: EraMeta, eraInfo: EraInfo): HTMLElement {\n  const seireki =\n    meta.year === 0 ? eraInfo.start : meta.year - 1 + eraInfo.start;\n\n  return html(\n    'div',\n    { class: 'meta era', lang: 'ja' },\n    html(\n      'span',\n      { class: 'era-name' },\n      html(\n        'ruby',\n        {},\n        meta.era,\n        html('rp', {}, '('),\n        html('rt', {}, eraInfo.reading),\n        html('rp', {}, ')'),\n        meta.year === 0 ? '元年' : `${meta.year}年`\n      )\n    ),\n    html('span', { class: 'equals' }, '='),\n    html('span', { class: 'seireki' }, `${seireki}年`)\n  );\n}\n\nfunction renderMeasureInfo(\n  meta: MeasureMeta,\n  preferredUnits: ContentConfigParams['preferredUnits']\n): HTMLElement {\n  const converted = convertMeasure(meta, preferredUnits);\n\n  const metaDiv = html(\n    'div',\n    { class: 'meta measure', lang: 'ja' },\n    html(\n      'span',\n      { class: 'main' },\n      html(\n        'span',\n        { class: 'value' },\n        meta.value.toLocaleString(),\n        renderUnit(meta.unit)\n      ),\n      html('span', { class: 'equals' }, '='),\n      html(\n        'span',\n        { class: 'value' },\n        renderValue(converted.value),\n        renderUnit(converted.unit)\n      )\n    )\n  );\n\n  if (converted.alt) {\n    for (const { type, label, unit, value } of converted.alt) {\n      const altRow = html('div', { class: 'alt' });\n\n      const altLabel = html('span', {});\n      if (label) {\n        altLabel.append(label);\n      }\n      const expl = browser.i18n.getMessage(`measure_expl_${type}`);\n      if (expl) {\n        const altExplLabel = html('span', { lang: getLangTag() }, expl);\n        altLabel.append(altExplLabel);\n      }\n\n      altRow.append(\n        altLabel,\n        html('span', { class: 'equals' }, '='),\n        html(\n          'span',\n          { class: 'measure' },\n          renderValue(value),\n          renderUnit(unit, { showRuby: false })\n        )\n      );\n\n      metaDiv.append(altRow);\n    }\n  }\n\n  return metaDiv;\n}\n\nfunction renderValue(value: number): string {\n  // Round to two decimal places, then to five significant figures\n  return parseFloat(round(value, 2).toPrecision(5)).toLocaleString();\n}\n\nfunction round(value: number, places: number): number {\n  const base = Math.pow(10, places);\n  return Math.round(value * base) / base;\n}\n\nfunction renderUnit(\n  unit: MeasureMeta['unit'],\n  { showRuby = true }: { showRuby?: boolean } = {}\n): HTMLElement {\n  const unitSpan = html('span', { class: 'unit' });\n\n  if (unit === 'm2') {\n    unitSpan.append('m', html('sup', {}, '2'));\n  } else if (unit === 'sq ft') {\n    unitSpan.append('ft', html('sup', {}, '2'));\n  } else if (showRuby) {\n    unitSpan.append(\n      html(\n        'ruby',\n        {},\n        unit,\n        html('rp', {}, '('),\n        html('rt', {}, 'じょう'),\n        html('rp', {}, ')')\n      )\n    );\n  } else {\n    unitSpan.append(unit);\n  }\n\n  return unitSpan;\n}\n\nfunction renderCurrencyInfo(\n  meta: CurrencyMeta,\n  fxData: NonNullable<ContentConfigParams['fx']>\n): HTMLElement {\n  const metaDiv = html(\n    'div',\n    { class: 'meta currency', lang: 'ja' },\n    html(\n      'div',\n      { class: 'main' },\n      // LHS\n      html(\n        'div',\n        { class: 'equation-part' },\n        html('span', { class: 'curr' }, 'JPY'),\n        html(\n          'span',\n          { class: 'src' },\n          new Intl.NumberFormat('ja-JP', {\n            style: 'currency',\n            currency: 'JPY',\n          }).format(meta.value)\n        ),\n        html('span', { class: 'equals' }, '≈')\n      ),\n      // RHS\n      html(\n        'div',\n        { class: 'equation-part' },\n        html('span', { class: 'curr' }, fxData.currency),\n        html(\n          'span',\n          { class: 'value' },\n          renderCurrencyValue({\n            currency: fxData.currency,\n            value: meta.value * fxData.rate,\n          })\n        )\n      )\n    )\n  );\n\n  const timestampRow = html('div', { class: 'timestamp' });\n  const timestampAsDate = new Date(fxData.timestamp);\n  const timestampAsString = timestampAsDate.toLocaleString(undefined, {\n    dateStyle: 'medium',\n    timeStyle: 'short',\n  } as any);\n  const expl = browser.i18n.getMessage(\n    'currency_data_updated_label',\n    timestampAsString\n  );\n  timestampRow.append(expl);\n  metaDiv.append(timestampRow);\n\n  return metaDiv;\n}\n\nfunction renderCurrencyValue({\n  currency,\n  value,\n}: {\n  currency: string;\n  value: number;\n}): string {\n  // BTC is a bit special because Intl.NumberFormat doesn't support it and if we\n  // let it do its fallback rounding to two decimal places we'll lose most of\n  // the information.\n  //\n  // In fact, the convention for BTC appears to be to always use 8 decimal\n  // places.\n  if (currency === 'BTC') {\n    return `\\u20bf${value.toFixed(8)}`;\n  }\n\n  let formattedValue: string;\n  try {\n    formattedValue = new Intl.NumberFormat(undefined, {\n      style: 'currency',\n      currency,\n      currencyDisplay: 'narrowSymbol',\n    }).format(value);\n  } catch {\n    // Some older browsers may not support all the options above so fall back to\n    // general number formatting in that case.\n    formattedValue = new Intl.NumberFormat().format(value);\n  }\n\n  // Drop redundant currency code.\n  //\n  // If the browser doesn't have a specific symbol (e.g. $) for the currency,\n  // it generally just prepends the currency code (e.g. USD) but that's\n  // redundant with our valueCurrencyLabel so we try to detect and drop it in\n  // that case.\n  formattedValue = formattedValue.replace(\n    new RegExp(`^\\\\s*${currency}\\\\s*`),\n    ''\n  );\n\n  return formattedValue;\n}\n\nfunction renderNumberInfo(\n  meta: NumberMeta,\n  { isCombinedResult }: { isCombinedResult: boolean }\n): HTMLElement {\n  const metaDiv = html('div', { class: 'meta number' });\n\n  if (isCombinedResult) {\n    metaDiv.append(\n      html('span', { class: 'src', lang: 'ja' }, meta.src),\n      html('span', { class: 'equals' }, '=')\n    );\n  }\n\n  metaDiv.append(html('span', { class: 'value' }, meta.value.toLocaleString()));\n\n  return metaDiv;\n}\n\nfunction renderShogiInfo(meta: ShogiMeta): HTMLElement {\n  const metaDiv = html('div', { class: 'meta shogi' });\n\n  metaDiv.append(\n    html(\n      'span',\n      { class: 'label', lang: getLangTag() },\n      browser.i18n.getMessage('shogi_label')\n    ),\n    html('span', { class: 'src', lang: 'ja' }, serializeShogi(meta)),\n    html('span', { class: 'equals' }, '=')\n  );\n\n  // For Chinese we use the Japanese expansion anyway\n  let lang = getLangTag();\n  if (lang === 'zh-Hans') {\n    lang = 'ja';\n  }\n\n  // Side\n  const side = meta.side\n    ? browser.i18n.getMessage(`shogi_side_${meta.side}`)\n    : undefined;\n\n  // Piece\n  const piece = browser.i18n.getMessage(`shogi_piece_${meta.piece}`);\n\n  // Destination\n  let dest: string;\n  if (meta.dest) {\n    dest =\n      lang === 'ja'\n        ? serializeShogiDest(meta.dest)\n        : meta.dest.slice(0, 2).map(String).join('');\n    if (meta.dest.length === 3) {\n      dest += browser.i18n.getMessage('shogi_dest_same_suffix');\n    }\n  } else {\n    dest = browser.i18n.getMessage('shogi_dest_same');\n  }\n\n  // Movement\n  const movement = meta.movement\n    ? browser.i18n.getMessage(`shogi_movement_${meta.movement}`)\n    : undefined;\n\n  // Get the combined string\n  let move: string;\n  if (side && movement) {\n    move = browser.i18n.getMessage('shogi_move_side_piece_dest_movement', [\n      side,\n      piece,\n      dest,\n      movement,\n    ]);\n  } else if (side) {\n    move = browser.i18n.getMessage('shogi_move_side_piece_dest', [\n      side,\n      piece,\n      dest,\n    ]);\n  } else if (movement) {\n    move = browser.i18n.getMessage('shogi_move_piece_dest_movement', [\n      piece,\n      dest,\n      movement,\n    ]);\n  } else {\n    move = browser.i18n.getMessage('shogi_move_piece_dest', [piece, dest]);\n  }\n\n  // Add promotion annotation\n  if (typeof meta.promotion === 'boolean') {\n    move += browser.i18n.getMessage(\n      meta.promotion ? 'shogi_promoted_suffix' : 'shogi_not_promoted_suffix'\n    );\n  }\n\n  metaDiv.append(html('span', { class: 'value', lang }, move));\n\n  return metaDiv;\n}\n","const regularAgeRegex = /(\\d{4})\\.(\\d{1,2})(?:\\.(\\d{1,2}))?-[;)]/;\nconst backwardsAgeRegex = /(\\d{1,2})\\.(\\d{1,2})\\.(\\d{4})?-[;)]/;\n\nexport function getDob(text: string): { date: Date; approx: boolean } | null {\n  let year: number;\n  let month: number;\n  let approx: boolean;\n  let day: number;\n\n  let matches = regularAgeRegex.exec(text);\n  if (matches) {\n    year = parseInt(matches[1], 10);\n    month = parseInt(matches[2], 10) - 1;\n    approx = typeof matches[3] === 'undefined';\n    day = !approx ? parseInt(matches[3], 10) : 1;\n  } else {\n    matches = backwardsAgeRegex.exec(text);\n    if (matches) {\n      year = parseInt(matches[3], 10);\n      month = parseInt(matches[1], 10) - 1;\n      day = parseInt(matches[2], 10);\n      approx = false;\n    } else {\n      return null;\n    }\n  }\n\n  // Sanity check\n  if (\n    year > 2100 ||\n    year < 100 ||\n    month < 0 ||\n    month > 11 ||\n    day < 1 ||\n    day > 31\n  ) {\n    return null;\n  }\n\n  return {\n    // This will create a date in the current user's timezone but that's fine\n    // since we're going to compare this to the user's local time anyway.\n    date: new Date(year, month, day),\n    approx,\n  };\n}\n","import { NameTranslation } from '@birchill/jpdict-idb';\nimport browser from 'webextension-polyfill';\n\nimport { NameResult } from '../../background/search-result';\nimport { getDob } from '../../utils/age';\nimport { html } from '../../utils/builder';\n\nimport { getLangTag } from './lang-tag';\nimport { renderMetadata } from './metadata';\nimport { getSelectedIndex } from './selected-index';\nimport { containerHasSelectedText } from './selection';\nimport { ShowPopupOptions } from './show-popup';\n\nexport function renderNamesEntries({\n  entries,\n  matchLen,\n  more,\n  options,\n}: {\n  entries: Array<NameResult>;\n  matchLen: number;\n  more: boolean;\n  options: ShowPopupOptions;\n}): HTMLElement {\n  const namesTable = html('div', { class: 'name-table entry-data' });\n\n  if (options.meta) {\n    const metadata = renderMetadata({\n      fxData: options.fxData,\n      preferredUnits: options.preferredUnits,\n      isCombinedResult: true,\n      matchLen,\n      meta: options.meta,\n    });\n    if (metadata) {\n      namesTable.append(metadata);\n    }\n  }\n\n  if (entries.length > 4) {\n    namesTable.classList.add('-multicol');\n  }\n\n  let lastPointerType = 'touch';\n  const selectedIndex = getSelectedIndex(options.copyState, entries.length);\n  for (const [index, entry] of entries.entries()) {\n    const entryDiv = renderName(entry);\n    if (index === selectedIndex) {\n      entryDiv.classList.add(\n        options.copyState.kind === 'active' ? '-selected' : '-flash'\n      );\n    }\n\n    entryDiv.addEventListener('pointerup', (evt) => {\n      lastPointerType = evt.pointerType;\n    });\n    entryDiv.addEventListener('click', () => {\n      if (containerHasSelectedText(namesTable)) {\n        return;\n      }\n\n      const trigger = lastPointerType === 'mouse' ? 'mouse' : 'touch';\n      options.onStartCopy?.(index, trigger);\n    });\n\n    namesTable.append(entryDiv);\n  }\n\n  if (more) {\n    namesTable.append(html('span', { class: 'more' }, '…'));\n  }\n\n  return namesTable;\n}\n\nexport function renderName(entry: NameResult): HTMLElement {\n  const entryDiv = html('div', { class: 'entry' });\n\n  const entryTitleDiv = html('div', { class: 'w-title', lang: 'ja' });\n  entryDiv.append(entryTitleDiv);\n\n  if (entry.k) {\n    const MAX_KANJI = 15;\n    const trimKanji = entry.k.length > MAX_KANJI;\n    const kanjiToDisplay = trimKanji ? entry.k.slice(0, MAX_KANJI) : entry.k;\n    let kanji = kanjiToDisplay.join('、');\n    if (trimKanji) {\n      kanji += '…';\n    }\n\n    entryTitleDiv.append(html('span', { class: 'w-kanji' }, kanji));\n  }\n\n  const kana = entry.r.join('、');\n  entryTitleDiv.append(html('span', { class: 'w-kana' }, kana));\n\n  const definitionBlock = html('div', { class: 'w-def' });\n  for (const tr of entry.tr) {\n    definitionBlock.append(renderNameTranslation(tr));\n  }\n  entryDiv.append(definitionBlock);\n\n  return entryDiv;\n}\n\nfunction renderNameTranslation(tr: NameTranslation): HTMLSpanElement {\n  const definitionSpan = html('div', {\n    // ENAMDICT only has English glosses\n    lang: 'en',\n  });\n\n  // Only add age annotations if the name is for a person\n  const annotateDetailFn = tr.type?.includes('person')\n    ? annotateAge\n    : (det: string) => det;\n  definitionSpan.append(tr.det.map(annotateDetailFn).join(', '));\n\n  for (const tag of tr.type || []) {\n    const tagText = browser.i18n.getMessage(`content_names_tag_${tag}`);\n    if (!tagText) {\n      continue;\n    }\n\n    definitionSpan.append(\n      html(\n        'span',\n        {\n          class: `tag tag-${tag}`,\n          lang: getLangTag(),\n        },\n        tagText\n      )\n    );\n  }\n\n  return definitionSpan;\n}\n\nfunction annotateAge(text: string): string {\n  const dob = getDob(text);\n  if (!dob) {\n    return text;\n  }\n\n  // Calculate age\n  const { date, approx } = dob;\n  const today = new Date();\n  let age = today.getFullYear() - date.getFullYear();\n  const month = today.getMonth() - date.getMonth();\n  if (month < 0 || (month === 0 && today.getDate() < date.getDate())) {\n    age--;\n  }\n\n  // Sanity check\n  if (age < 1 || age > 150) {\n    return text;\n  }\n\n  const ageString = approx\n    ? browser.i18n.getMessage('content_names_age_approx', [String(age)])\n    : browser.i18n.getMessage('content_names_age', [String(age)]);\n\n  return `${text} (${ageString})`;\n}\n","import { MajorDataSeries } from '@birchill/jpdict-idb';\nimport browser from 'webextension-polyfill';\n\nimport {\n  CopyKanjiKeyStrings,\n  CopyKeys,\n  CopyNextKeyStrings,\n  CopyType,\n} from '../../common/copy-keys';\nimport { html } from '../../utils/builder';\n\nimport { CopyState } from './copy-state';\nimport { renderSpinner } from './icons';\nimport { getLangTag } from './lang-tag';\n\nexport function renderCopyDetails({\n  copyNextKey,\n  copyState,\n  series,\n}: {\n  copyNextKey: string;\n  copyState: CopyState;\n  series: MajorDataSeries;\n}): HTMLElement | null {\n  if (copyState.kind === 'inactive') {\n    return null;\n  }\n\n  // In interactive mode, we only use the status bar to show the finished and\n  // error states.\n  if (copyState.mode !== 'keyboard' && copyState.kind === 'active') {\n    return null;\n  }\n\n  const statusDiv = html('div', {\n    class: 'status-bar -stack',\n    lang: getLangTag(),\n  });\n\n  if (copyState.mode === 'keyboard') {\n    const keysDiv = html(\n      'div',\n      { class: 'keys' },\n      browser.i18n.getMessage('content_copy_keys_label') + ' '\n    );\n    statusDiv.append(keysDiv);\n\n    const copyKeys: Array<{ key: string; l10nKey: string }> = CopyKeys.map(\n      ({ key, type, popupString }) => {\n        if (type === 'word' && series === 'kanji') {\n          return { key, l10nKey: CopyKanjiKeyStrings.popupString };\n        } else {\n          return { key, l10nKey: popupString };\n        }\n      }\n    );\n    copyKeys.push({\n      key: copyNextKey,\n      l10nKey: CopyNextKeyStrings.popupString,\n    });\n\n    for (const copyKey of copyKeys) {\n      keysDiv.append(\n        html('kbd', {}, copyKey.key),\n        ' = ' + browser.i18n.getMessage(copyKey.l10nKey)\n      );\n      if (copyKey.key !== copyNextKey) {\n        keysDiv.append(', ');\n      }\n    }\n  }\n\n  if (copyState.kind === 'finished') {\n    statusDiv.append(renderCopyStatus(getCopiedString(copyState.type)));\n  } else if (copyState.kind === 'error') {\n    statusDiv.append(\n      renderCopyStatus(browser.i18n.getMessage('content_copy_error'))\n    );\n  }\n\n  return statusDiv;\n}\n\nfunction getCopiedString(target: CopyType): string {\n  switch (target) {\n    case 'entry':\n      return browser.i18n.getMessage('content_copied_entry');\n\n    case 'tab':\n      return browser.i18n.getMessage('content_copied_fields');\n\n    case 'word':\n      return browser.i18n.getMessage('content_copied_word');\n  }\n}\n\nfunction renderCopyStatus(message: string): HTMLElement {\n  return html('div', { class: 'status' }, message);\n}\n\nexport function renderUpdatingStatus(): HTMLElement {\n  const statusDiv = html('div', {\n    class: 'status-bar -subdued',\n    lang: getLangTag(),\n  });\n\n  const statusText = html('div', { class: 'status' });\n\n  const spinner = renderSpinner();\n  spinner.classList.add('spinner');\n  statusText.append(\n    spinner,\n    browser.i18n.getMessage('content_database_updating')\n  );\n\n  statusDiv.append(statusText);\n\n  return statusDiv;\n}\n","type HorizontalSwipeDirection = 'right' | 'left';\n\nexport function onHorizontalSwipe(\n  element: HTMLElement,\n  handler: (swipeDirection: HorizontalSwipeDirection) => void\n) {\n  // Min x distance traveled to be considered swipe\n  const xMinThreshold = 50;\n  // Max y distance that can be traveled before\n  // it's no longer considered a horizontal swipe\n  const yMaxThreshold = 100;\n  // Max time allowed to travel that distance\n  const allowedTime = 200;\n\n  let startTime = 0;\n  let startX: number;\n  let startY: number;\n\n  element.addEventListener(\n    'touchstart',\n    function (e) {\n      startX = e.changedTouches[0].pageX;\n      startY = e.changedTouches[0].pageY;\n      startTime = performance.now();\n    },\n    false\n  );\n\n  element.addEventListener(\n    'touchend',\n    function (e) {\n      const touch = e.changedTouches[0];\n      const deltaX = touch.pageX - startX;\n      const deltaY = touch.pageY - startY;\n      const elapsedTime = performance.now() - startTime;\n\n      // Check that elapsed time is within specified, horizontal dist\n      // traveled >= threshold, and vertical dist traveled <= 100\n      const isSwipe =\n        elapsedTime <= allowedTime &&\n        Math.abs(deltaX) >= xMinThreshold &&\n        Math.abs(deltaY) <= yMaxThreshold;\n      if (isSwipe) {\n        handler(deltaX < 0 ? 'right' : 'left');\n      }\n    },\n    false\n  );\n}\n","import { MajorDataSeries } from '@birchill/jpdict-idb';\nimport browser from 'webextension-polyfill';\n\nimport { html } from '../../utils/builder';\nimport { getMouseCapabilityMql } from '../../utils/device';\nimport { isFenix } from '../../utils/ua-utils';\n\nimport { DisplayMode } from '../popup-state';\n\nimport { renderCloseButton } from './close';\nimport {\n  renderBook,\n  renderCog,\n  renderKanjiIcon,\n  renderPerson,\n  renderPin,\n} from './icons';\nimport { getLangTag } from './lang-tag';\n\nexport function renderTabBar({\n  closeShortcuts,\n  displayMode,\n  enabledTabs,\n  onClosePopup,\n  onShowSettings,\n  onSwitchDictionary,\n  onTogglePin,\n  pinShortcuts,\n  selectedTab,\n}: {\n  closeShortcuts?: ReadonlyArray<string>;\n  displayMode: DisplayMode;\n  enabledTabs: Record<MajorDataSeries, boolean>;\n  onClosePopup?: () => void;\n  onShowSettings?: () => void;\n  onSwitchDictionary?: (newDict: MajorDataSeries) => void;\n  onTogglePin?: () => void;\n  pinShortcuts?: ReadonlyArray<string>;\n  selectedTab: MajorDataSeries;\n}): HTMLElement {\n  const tabBar = html('div', { class: 'tab-bar', lang: getLangTag() });\n\n  tabBar.addEventListener('pointerup', () => {\n    // Dummy event to make Safari not eat clicks on the child links / buttons.\n  });\n\n  const list = html('ul', { class: 'tabs' });\n\n  const sections: Array<{\n    series: MajorDataSeries;\n    renderIcon: () => SVGElement;\n  }> = [\n    { series: 'words', renderIcon: renderBook },\n    { series: 'kanji', renderIcon: renderKanjiIcon },\n    { series: 'names', renderIcon: renderPerson },\n  ];\n  for (const { series, renderIcon } of sections) {\n    const li = html('li', { class: 'tab', role: 'presentation' });\n\n    if (series === selectedTab) {\n      li.setAttribute('aria-selected', 'true');\n    } else if (!enabledTabs[series]) {\n      li.classList.add('disabled');\n    }\n\n    // We use a button because if it's a link there will be a little tooltip\n    // show in the corner of the browser when the user hovers over the tab.\n    const button = html('button', {});\n    if (series !== selectedTab && onSwitchDictionary) {\n      button.onclick = (event: Event) => {\n        event.preventDefault();\n        onSwitchDictionary(series);\n      };\n    }\n    li.append(button);\n\n    const icon = renderIcon();\n    icon.classList.add('icon');\n    button.append(icon);\n\n    button.append(\n      html('span', {}, browser.i18n.getMessage(`tabs_${series}_label`))\n    );\n\n    list.append(li);\n  }\n  tabBar.append(list);\n\n  // We don't want to show the pin on devices that don't have a mouse since it's\n  // generally not useful there (and just takes up room).\n  //\n  // If, however, the user somehow managed to get the popup into a pinned state,\n  // we should show the icon just so they don't get confused (and can get out of\n  // that state).\n  const showPin =\n    onTogglePin &&\n    (getMouseCapabilityMql()?.matches !== false || displayMode === 'pinned');\n  if (showPin) {\n    tabBar.append(renderPinButton(onTogglePin, pinShortcuts || []));\n  }\n\n  // Firefox for Android has a bug that when calling\n  // `browser.runtime.openOptionsPage` a new tab is opened but nothing is\n  // displayed.\n  //\n  // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1795449\n  //\n  // Until that is fixed, we don't show the settings button on Firefox for\n  // Android to avoid confusion.\n  if (onShowSettings && !isFenix()) {\n    tabBar.append(renderSettingsButton(onShowSettings));\n  }\n\n  if (onClosePopup) {\n    tabBar.append(renderCloseButton(onClosePopup, closeShortcuts || []));\n  }\n\n  return tabBar;\n}\n\nfunction renderPinButton(\n  onTogglePin: () => void,\n  pinShortcuts: ReadonlyArray<string>\n): HTMLElement {\n  const label = browser.i18n.getMessage('popup_pin_label');\n  const title = pinShortcuts.length\n    ? `${label} (${pinShortcuts.join(' / ')})`\n    : label;\n  const pinButton = html(\n    'button',\n    {\n      'aria-label': label,\n      title,\n      class: 'pin-button',\n      type: 'button',\n    },\n    renderPin()\n  );\n  pinButton.onclick = onTogglePin;\n\n  return html('div', { class: 'pin' }, pinButton);\n}\n\nfunction renderSettingsButton(onShowSettings: () => void): HTMLElement {\n  const label = browser.i18n.getMessage('popup_settings_label');\n  const settingsButton = html(\n    'button',\n    {\n      'aria-label': label,\n      title: label,\n      class: 'settings-button',\n      type: 'button',\n    },\n    renderCog()\n  );\n  settingsButton.onclick = onShowSettings;\n\n  return html('div', { class: 'settings' }, settingsButton);\n}\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n","// prettier-ignore\nconst HANKAKU_KATAKANA_TO_ZENKAKU = [\n 0x3002, 0x300c, 0x300d, 0x3001, 0x30fb, 0x30f2, 0x30a1, 0x30a3, 0x30a5,\n 0x30a7, 0x30a9, 0x30e3, 0x30e5, 0x30e7, 0x30c3, 0x30fc, 0x30a2, 0x30a4,\n 0x30a6, 0x30a8, 0x30aa, 0x30ab, 0x30ad, 0x30af, 0x30b1, 0x30b3, 0x30b5,\n 0x30b7, 0x30b9, 0x30bb, 0x30bd, 0x30bf, 0x30c1, 0x30c4, 0x30c6, 0x30c8,\n 0x30ca, 0x30cb, 0x30cc, 0x30cd, 0x30ce, 0x30cf, 0x30d2, 0x30d5, 0x30d8,\n 0x30db, 0x30de, 0x30df, 0x30e0, 0x30e1, 0x30e2, 0x30e4, 0x30e6, 0x30e8,\n 0x30e9, 0x30ea, 0x30eb, 0x30ec, 0x30ed, 0x30ef, 0x30f3, 0x3099, 0x309a,\n];\n\n// prettier-ignore\nconst VOICED_TO_COMPOSED = new Map([\n  [0x3046, 0x3094], [0x304b, 0x304c], [0x304d, 0x304e], [0x304f, 0x3050],\n  [0x3051, 0x3052], [0x3053, 0x3054], [0x3055, 0x3056], [0x3057, 0x3058],\n  [0x3059, 0x305a], [0x305b, 0x305c], [0x305d, 0x305e], [0x305f, 0x3060],\n  [0x3061, 0x3062], [0x3064, 0x3065], [0x3066, 0x3067], [0x3068, 0x3069],\n  [0x306f, 0x3070], [0x3072, 0x3073], [0x3075, 0x3076], [0x3078, 0x3079],\n  [0x307b, 0x307c], [0x309d, 0x309e], [0x30ab, 0x30ac], [0x30ad, 0x30ae],\n  [0x30a6, 0x30f4], [0x30af, 0x30b0], [0x30b1, 0x30b2], [0x30b3, 0x30b4],\n  [0x30b5, 0x30b6], [0x30b7, 0x30b8], [0x30b9, 0x30ba], [0x30bb, 0x30bc],\n  [0x30bd, 0x30be], [0x30bf, 0x30c0], [0x30c1, 0x30c2], [0x30c4, 0x30c5],\n  [0x30c6, 0x30c7], [0x30c8, 0x30c9], [0x30cf, 0x30d0], [0x30d2, 0x30d3],\n  [0x30d5, 0x30d6], [0x30d8, 0x30d9], [0x30db, 0x30dc], [0x30ef, 0x30f7],\n  [0x30f0, 0x30f8], [0x30f1, 0x30f9], [0x30f2, 0x30fa], [0x30fd, 0x30fe]\n]);\n\n// prettier-ignore\nconst SEMIVOICED_TO_COMPOSED = new Map([\n  [0x306f, 0x3071], [0x3072, 0x3074], [0x3075, 0x3077], [0x3078, 0x307a],\n  [0x307b, 0x307d], [0x30cf, 0x30d1], [0x30d2, 0x30d4], [0x30d5, 0x30d7],\n  [0x30d8, 0x30da], [0x30db, 0x30dd]\n]);\n\n// First part of the CJK Compatibility block: 0x3300-0x3370\n// prettier-ignore\nconst COMBINED_CHARS_A = [\n 'アパート', 'アルファ', 'アンペア', 'アール', 'イニング', 'インチ', 'ウォン',\n  'エスクード', 'エーカー', 'オンス', 'オーム', 'カイリ', 'カラット',\n  'カロリー', 'ガロン', 'ガンマ', 'ギガ', 'ギニー', 'キュリー', 'ギルダー',\n  'キロ', 'キログラム', 'キロメートル', 'キロワット', 'グラム', 'グラムトン',\n  'クルゼイロ', 'クローネ', 'ケース', 'コルナ', 'コーポ', 'サイクル',\n  'サンチーム', 'シリング', 'センチ', 'セント', 'ダース', 'デシ', 'ドル',\n  'トン', 'ナノ', 'ノット', 'ハイツ', 'パーセント', 'パーツ', 'バーレル',\n  'ピアストル', 'ピクル', 'ピコ', 'ビル', 'ファラッド', 'フィート',\n  'ブッシェル', 'フラン', 'ヘクタール', 'ペソ', 'ペニヒ', 'ヘルツ', 'ペンス',\n  'ページ', 'ベータ', 'ポイント', 'ボルト', 'ホン', 'ポンド', 'ホール',\n  'ホーン', 'マイクロ', 'マイル', 'マッハ', 'マルク', 'マンション', 'ミクロン',\n  'ミリ', 'ミリバール', 'メガ', 'メガトン', 'メートル', 'ヤード', 'ヤール',\n  'ユアン', 'リットル', 'リラ', 'ルピー', 'ルーブル', 'レム', 'レントゲン',\n  'ワット', '0点', '1点', '2点', '3点', '4点', '5点', '6点', '7点', '8点',\n  '9点', '10点', '11点', '12点', '13点', '14点', '15点', '16点', '17点', '18点',\n  '19点', '20点', '21点', '22点', '23点', '24点'\n];\n\n// Second part of the CJK Compatibility block: 0x337b-0x337f\n// prettier-ignore\nconst COMBINED_CHARS_B = ['平成', '昭和', '大正', '明治', '株式会社'];\n\n// First part of Enclosed CJK letters and motnhs block: 0x3220-0x3247\n// prettier-ignore\nconst ENCLOSED_CHARS_A = [\n  '一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '月', '火', '水',\n  '木', '金', '土', '日', '株', '有', '社', '名', '特', '財', '祝', '労', '代',\n  '呼', '学', '監', '企', '資', '協', '祭', '休', '自', '至', '問', '幼', '文',\n  '箏'\n];\n\n// Second part of Enclosed CJK letters and motnhs block: 0x3280-0x32b0\n// prettier-ignore\nconst ENCLOSED_CHARS_B = [\n  '一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '月', '火', '水',\n  '木', '金', '土', '日', '株', '有', '社', '名', '特', '財', '祝', '労', '秘',\n  '男', '女', '適', '優', '印', '注', '頂', '休', '写', '正', '上', '中', '下',\n  '左', '右', '医', '宗', '学', '監', '企', '資', '協', '夜'\n];\n\n// Third part of Enclosed CJK letters and motnhs block: 0x32c0-0x32cb\n// prettier-ignore\nconst ENCLOSED_CHARS_C = [\n  '1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月',\n  '12月'\n];\n\n// Fourth part of Enclosed CJK letters and motnhs block: 0x32d0-0x32ff\n// prettier-ignore\nconst ENCLOSED_CHARS_D = [\n  'ア', 'イ', 'ウ', 'エ', 'オ', 'カ', 'キ', 'ク', 'ケ', 'コ', 'サ', 'シ', 'ス',\n  'セ', 'ソ', 'タ', 'チ', 'ツ', 'テ', 'ト', 'ナ', 'ニ', 'ヌ', 'ネ', 'ノ', 'ハ',\n  'ヒ', 'フ', 'ヘ', 'ホ', 'マ', 'ミ', 'ム', 'メ', 'モ', 'ヤ', 'ユ', 'ヨ', 'ラ',\n  'リ', 'ル', 'レ', 'ロ', 'ワ', 'ヰ', 'ヱ', 'ヲ', '令和'\n];\n\n// We should handle the Enclosed Ideographic Supplement too\n// (https://en.wikipedia.org/wiki/Enclosed_Ideographic_Supplement)\n// but it's in the SMP so it makes processing more complicated.\n//\n// We'll wait until it's actually needed.\n\n// The following is a mapping from radical characters in the Kangxi Radicals\n// and _some_ of the radicals in the CJK Radicals Supplement block.\n//\n// The purpose of this mapping is to help in looking up mis-encoded characters.\n// Therefore, we have deliberately _not_ included some characters where even\n// where there's a possible mapping because the characters don't necessarily\n// look similar or are ambiguous (e.g. the different variants on しんにょう).\n//\n// We've also avoided using equivalents that are not in the BMP even if they're\n// better because it seems unlikely someone would have wanted to encode a\n// non-BMP character and used a radical character instead.\nconst RADICAL_TO_KANJI_CHARS: ReadonlyArray<[number, number]> = [\n  // ⼀ → 一\n  [0x2f00, 0x4e00],\n  // ⼁ → 丨\n  [0x2f01, 0x4e28],\n  // ⼂ → 丶\n  [0x2f02, 0x4e36],\n  // ⼃ → 丿\n  [0x2f03, 0x4e3f],\n  // ⼄ → 乙\n  [0x2f04, 0x4e59],\n  // ⼅ → 亅\n  [0x2f05, 0x4e85],\n  // ⼆ → 二\n  [0x2f06, 0x4e8c],\n  // ⼇ → 亠\n  [0x2f07, 0x4ea0],\n  // ⼈ → 人\n  [0x2f08, 0x4eba],\n  // ⼉ → 儿\n  [0x2f09, 0x513f],\n  // ⼊ → 入\n  [0x2f0a, 0x5165],\n  // ⼋ → 八\n  [0x2f0b, 0x516b],\n  // ⼌ → 冂\n  [0x2f0c, 0x5182],\n  // ⼍ → 冖\n  [0x2f0d, 0x5196],\n  // ⼎ → 冫\n  [0x2f0e, 0x51ab],\n  // ⼏ → 几\n  [0x2f0f, 0x51e0],\n  // ⼐ → 凵\n  [0x2f10, 0x51f5],\n  // ⼑ → 刀\n  [0x2f11, 0x5200],\n  // ⼒ → 力\n  [0x2f12, 0x529b],\n  // ⼓ → 勹\n  [0x2f13, 0x52f9],\n  // ⼔ → 匕\n  [0x2f14, 0x5315],\n  // ⼕ → 匚\n  [0x2f15, 0x531a],\n  // ⼖ → 匸\n  [0x2f16, 0x5338],\n  // ⼗ → 十\n  [0x2f17, 0x5341],\n  // ⼘ → 卜\n  [0x2f18, 0x535c],\n  // ⼙ → 卩\n  [0x2f19, 0x5369],\n  // ⼚ → 厂\n  [0x2f1a, 0x5382],\n  // ⼛ → 厶\n  [0x2f1b, 0x53b6],\n  // ⼜ → 又\n  [0x2f1c, 0x53c8],\n  // ⼝ → 口\n  [0x2f1d, 0x53e3],\n  // ⼞ → 囗\n  [0x2f1e, 0x56d7],\n  // ⼟ → 土\n  [0x2f1f, 0x571f],\n  // ⼠ → 士\n  [0x2f20, 0x58eb],\n  // ⼡ → 夂\n  [0x2f21, 0x5902],\n  // ⼢ → 夊\n  [0x2f22, 0x590a],\n  // ⼣ → 夕\n  [0x2f23, 0x5915],\n  // ⼤ → 大\n  [0x2f24, 0x5927],\n  // ⼥ → 女\n  [0x2f25, 0x5973],\n  // ⼦ → 子\n  [0x2f26, 0x5b50],\n  // ⼧ → 宀\n  [0x2f27, 0x5b80],\n  // ⼨ → 寸\n  [0x2f28, 0x5bf8],\n  // ⼩ → 小\n  [0x2f29, 0x5c0f],\n  // ⼪ → 尢\n  [0x2f2a, 0x5c22],\n  // ⼫ → 尸\n  [0x2f2b, 0x5c38],\n  // ⼬ → 屮\n  [0x2f2c, 0x5c6e],\n  // ⼭ → 山\n  [0x2f2d, 0x5c71],\n  // ⼮ → 巛\n  [0x2f2e, 0x5ddb],\n  // ⼯ → 工\n  [0x2f2f, 0x5de5],\n  // ⼰ → 己\n  [0x2f30, 0x5df1],\n  // ⼱ → 巾\n  [0x2f31, 0x5dfe],\n  // ⼲ → 干\n  [0x2f32, 0x5e72],\n  // ⼳ → 幺\n  [0x2f33, 0x5e7a],\n  // ⼴ → 广\n  [0x2f34, 0x5e7f],\n  // ⼵ → 廴\n  [0x2f35, 0x5ef4],\n  // ⼶ → 廾\n  [0x2f36, 0x5efe],\n  // ⼷ → 弋\n  [0x2f37, 0x5f0b],\n  // ⼸ → 弓\n  [0x2f38, 0x5f13],\n  // ⼹ → 彐\n  [0x2f39, 0x5f50],\n  // ⼺ → 彡\n  [0x2f3a, 0x5f61],\n  // ⼻ → 彳\n  [0x2f3b, 0x5f73],\n  // ⼼ → 心\n  [0x2f3c, 0x5fc3],\n  // ⼽ → 戈\n  [0x2f3d, 0x6208],\n  // ⼾ → 戶\n  [0x2f3e, 0x6236],\n  // ⼿ → 手\n  [0x2f3f, 0x624b],\n  // ⽀ → 支\n  [0x2f40, 0x652f],\n  // ⽁ → 攴\n  [0x2f41, 0x6534],\n  // ⽂ → 文\n  [0x2f42, 0x6587],\n  // ⽃ → 斗\n  [0x2f43, 0x6597],\n  // ⽄ → 斤\n  [0x2f44, 0x65a4],\n  // ⽅ → 方\n  [0x2f45, 0x65b9],\n  // ⽆ → 无\n  [0x2f46, 0x65e0],\n  // ⽇ → 日\n  [0x2f47, 0x65e5],\n  // ⽈ → 曰\n  [0x2f48, 0x66f0],\n  // ⽉ → 月\n  [0x2f49, 0x6708],\n  // ⽊ → 木\n  [0x2f4a, 0x6728],\n  // ⽋ → 欠\n  [0x2f4b, 0x6b20],\n  // ⽌ → 止\n  [0x2f4c, 0x6b62],\n  // ⽍ → 歹\n  [0x2f4d, 0x6b79],\n  // ⽎ → 殳\n  [0x2f4e, 0x6bb3],\n  // ⽏ → 毋\n  [0x2f4f, 0x6bcb],\n  // ⽐ → 比\n  [0x2f50, 0x6bd4],\n  // ⽑ → 毛\n  [0x2f51, 0x6bdb],\n  // ⽒ → 氏\n  [0x2f52, 0x6c0f],\n  // ⽓ → 气\n  [0x2f53, 0x6c14],\n  // ⽔ → 水\n  [0x2f54, 0x6c34],\n  // ⽕ → 火\n  [0x2f55, 0x706b],\n  // ⽖ → 爪\n  [0x2f56, 0x722a],\n  // ⽗ → 父\n  [0x2f57, 0x7236],\n  // ⽘ → 爻\n  [0x2f58, 0x723b],\n  // ⽙ → 爿\n  [0x2f59, 0x723f],\n  // ⽚ → 片\n  [0x2f5a, 0x7247],\n  // ⽛ → 牙\n  [0x2f5b, 0x7259],\n  // ⽜ → 牛\n  [0x2f5c, 0x725b],\n  // ⽝ → 犬\n  [0x2f5d, 0x72ac],\n  // ⽞ → 玄\n  [0x2f5e, 0x7384],\n  // ⽟ → 玉\n  [0x2f5f, 0x7389],\n  // ⽠ → 瓜\n  [0x2f60, 0x74dc],\n  // ⽡ → 瓦\n  [0x2f61, 0x74e6],\n  // ⽢ → 甘\n  [0x2f62, 0x7518],\n  // ⽣ → 生\n  [0x2f63, 0x751f],\n  // ⽤ → 用\n  [0x2f64, 0x7528],\n  // ⽥ → 田\n  [0x2f65, 0x7530],\n  // ⽦ → 疋\n  [0x2f66, 0x758b],\n  // ⽧ → 疒\n  [0x2f67, 0x7592],\n  // ⽨ → 癶\n  [0x2f68, 0x7676],\n  // ⽩ → 白\n  [0x2f69, 0x767d],\n  // ⽪ → 皮\n  [0x2f6a, 0x76ae],\n  // ⽫ → 皿\n  [0x2f6b, 0x76bf],\n  // ⽬ → 目\n  [0x2f6c, 0x76ee],\n  // ⽭ → 矛\n  [0x2f6d, 0x77db],\n  // ⽮ → 矢\n  [0x2f6e, 0x77e2],\n  // ⽯ → 石\n  [0x2f6f, 0x77f3],\n  // ⽰ → 示\n  [0x2f70, 0x793a],\n  // ⽱ → 禸\n  [0x2f71, 0x79b8],\n  // ⽲ → 禾\n  [0x2f72, 0x79be],\n  // ⽳ → 穴\n  [0x2f73, 0x7a74],\n  // ⽴ → 立\n  [0x2f74, 0x7acb],\n  // ⽵ → 竹\n  [0x2f75, 0x7af9],\n  // ⽶ → 米\n  [0x2f76, 0x7c73],\n  // ⽷ → 糸\n  [0x2f77, 0x7cf8],\n  // ⽸ → 缶\n  [0x2f78, 0x7f36],\n  // ⽹ → 网\n  [0x2f79, 0x7f51],\n  // ⽺ → 羊\n  [0x2f7a, 0x7f8a],\n  // ⽻ → 羽\n  [0x2f7b, 0x7fbd],\n  // ⽼ → 老\n  [0x2f7c, 0x8001],\n  // ⽽ → 而\n  [0x2f7d, 0x800c],\n  // ⽾ → 耒\n  [0x2f7e, 0x8012],\n  // ⽿ → 耳\n  [0x2f7f, 0x8033],\n  // ⾀ → 聿\n  [0x2f80, 0x807f],\n  // ⾁ → 肉\n  [0x2f81, 0x8089],\n  // ⾂ → 臣\n  [0x2f82, 0x81e3],\n  // ⾃ → 自\n  [0x2f83, 0x81ea],\n  // ⾄ → 至\n  [0x2f84, 0x81f3],\n  // ⾅ → 臼\n  [0x2f85, 0x81fc],\n  // ⾆ → 舌\n  [0x2f86, 0x820c],\n  // ⾇ → 舛\n  [0x2f87, 0x821b],\n  // ⾈ → 舟\n  [0x2f88, 0x821f],\n  // ⾉ → 艮\n  [0x2f89, 0x826e],\n  // ⾊ → 色\n  [0x2f8a, 0x8272],\n  // ⾋ → 艸\n  [0x2f8b, 0x8278],\n  // ⾌ → 虍\n  [0x2f8c, 0x864d],\n  // ⾍ → 虫\n  [0x2f8d, 0x866b],\n  // ⾎ → 血\n  [0x2f8e, 0x8840],\n  // ⾏ → 行\n  [0x2f8f, 0x884c],\n  // ⾐ → 衣\n  [0x2f90, 0x8863],\n  // ⾑ → 襾\n  [0x2f91, 0x897e],\n  // ⾒ → 見\n  [0x2f92, 0x898b],\n  // ⾓ → 角\n  [0x2f93, 0x89d2],\n  // ⾔ → 言\n  [0x2f94, 0x8a00],\n  // ⾕ → 谷\n  [0x2f95, 0x8c37],\n  // ⾖ → 豆\n  [0x2f96, 0x8c46],\n  // ⾗ → 豕\n  [0x2f97, 0x8c55],\n  // ⾘ → 豸\n  [0x2f98, 0x8c78],\n  // ⾙ → 貝\n  [0x2f99, 0x8c9d],\n  // ⾚ → 赤\n  [0x2f9a, 0x8d64],\n  // ⾛ → 走\n  [0x2f9b, 0x8d70],\n  // ⾜ → 足\n  [0x2f9c, 0x8db3],\n  // ⾝ → 身\n  [0x2f9d, 0x8eab],\n  // ⾞ → 車\n  [0x2f9e, 0x8eca],\n  // ⾟ → 辛\n  [0x2f9f, 0x8f9b],\n  // ⾠ → 辰\n  [0x2fa0, 0x8fb0],\n  // ⾡ → 辵\n  [0x2fa1, 0x8fb5],\n  // ⾢ → 邑\n  [0x2fa2, 0x9091],\n  // ⾣ → 酉\n  [0x2fa3, 0x9149],\n  // ⾤ → 釆\n  [0x2fa4, 0x91c6],\n  // ⾥ → 里\n  [0x2fa5, 0x91cc],\n  // ⾦ → 金\n  [0x2fa6, 0x91d1],\n  // ⾧ → 長\n  [0x2fa7, 0x9577],\n  // ⾨ → 門\n  [0x2fa8, 0x9580],\n  // ⾩ → 阜\n  [0x2fa9, 0x961c],\n  // ⾪ → 隶\n  [0x2faa, 0x96b6],\n  // ⾫ → 隹\n  [0x2fab, 0x96b9],\n  // ⾬ → 雨\n  [0x2fac, 0x96e8],\n  // ⾭ → 靑\n  [0x2fad, 0x9751],\n  // ⾮ → 非\n  [0x2fae, 0x975e],\n  // ⾯ → 面\n  [0x2faf, 0x9762],\n  // ⾰ → 革\n  [0x2fb0, 0x9769],\n  // ⾱ → 韋\n  [0x2fb1, 0x97cb],\n  // ⾲ → 韭\n  [0x2fb2, 0x97ed],\n  // ⾳ → 音\n  [0x2fb3, 0x97f3],\n  // ⾴ → 頁\n  [0x2fb4, 0x9801],\n  // ⾵ → 風\n  [0x2fb5, 0x98a8],\n  // ⾶ → 飛\n  [0x2fb6, 0x98db],\n  // ⾷ → 食\n  [0x2fb7, 0x98df],\n  // ⾸ → 首\n  [0x2fb8, 0x9996],\n  // ⾹ → 香\n  [0x2fb9, 0x9999],\n  // ⾺ → 馬\n  [0x2fba, 0x99ac],\n  // ⾻ → 骨\n  [0x2fbb, 0x9aa8],\n  // ⾼ → 高\n  [0x2fbc, 0x9ad8],\n  // ⾽ → 髟\n  [0x2fbd, 0x9adf],\n  // ⾾ → 鬥\n  [0x2fbe, 0x9b25],\n  // ⾿ → 鬯\n  [0x2fbf, 0x9b2f],\n  // ⿀ → 鬲\n  [0x2fc0, 0x9b32],\n  // ⿁ → 鬼\n  [0x2fc1, 0x9b3c],\n  // ⿂ → 魚\n  [0x2fc2, 0x9b5a],\n  // ⿃ → 鳥\n  [0x2fc3, 0x9ce5],\n  // ⿄ → 鹵\n  [0x2fc4, 0x9e75],\n  // ⿅ → 鹿\n  [0x2fc5, 0x9e7f],\n  // ⿆ → 麥\n  [0x2fc6, 0x9ea5],\n  // ⿇ → 麻\n  [0x2fc7, 0x9ebb],\n  // ⿈ → 黃\n  [0x2fc8, 0x9ec3],\n  // ⿉ → 黍\n  [0x2fc9, 0x9ecd],\n  // ⿊ → 黑\n  [0x2fca, 0x9ed1],\n  // ⿋ → 黹\n  [0x2fcb, 0x9ef9],\n  // ⿌ → 黽\n  [0x2fcc, 0x9efd],\n  // ⿍ → 鼎\n  [0x2fcd, 0x9f0e],\n  // ⿎ → 鼓\n  [0x2fce, 0x9f13],\n  // ⿏ → 鼠\n  [0x2fcf, 0x9f20],\n  // ⿐ → 鼻\n  [0x2fd0, 0x9f3b],\n  // ⿑ → 齊\n  [0x2fd1, 0x9f4a],\n  // ⿒ → 齒\n  [0x2fd2, 0x9f52],\n  // ⿓ → 龍\n  [0x2fd3, 0x9f8d],\n  // ⿔ → 龜\n  [0x2fd4, 0x9f9c],\n  // ⿕ → 龠\n  [0x2fd5, 0x9fa0],\n  // ⺁ → 厂\n  [0x2e81, 0x5382],\n  // ⺃ → 乚\n  [0x2e83, 0x4e5a],\n  // ⺅ → 亻\n  [0x2e85, 0x4ebb],\n  // ⺆ → 冂\n  [0x2e86, 0x5182],\n  // ⺇ → 几\n  [0x2e87, 0x51e0],\n  // ⺉ → 刂\n  [0x2e89, 0x5202],\n  // ⺎ → 兀\n  [0x2e8e, 0x5140],\n  // ⺏ → 尣\n  [0x2e8f, 0x5c23],\n  // ⺐ → 尢\n  [0x2e90, 0x5c22],\n  // ⺑ → 尣\n  [0x2e91, 0x5c23],\n  // ⺒ → 巳\n  [0x2e92, 0x5df3],\n  // ⺓ → 幺\n  [0x2e93, 0x5e7a],\n  // ⺔ → 彑\n  [0x2e94, 0x5f51],\n  // ⺕ → 彐\n  [0x2e95, 0x5f50],\n  // ⺖ → 忄\n  [0x2e96, 0x5fc4],\n  // ⺘ → 扌\n  [0x2e98, 0x624c],\n  // ⺙ → 攵\n  [0x2e99, 0x6535],\n  // ⺛ → 旡\n  [0x2e9b, 0x65e1],\n  // ⺝ → 月\n  [0x2e9d, 0x6708],\n  // ⺞ → 歺\n  [0x2e9e, 0x6b7a],\n  // ⺟ → 母\n  [0x2e9f, 0x6bcd],\n  // ⺠ → 民\n  [0x2ea0, 0x6c11],\n  // ⺡ → 氵\n  [0x2ea1, 0x6c35],\n  // ⺢ → 氺\n  [0x2ea2, 0x6c3a],\n  // ⺣ → 灬\n  [0x2ea3, 0x706c],\n  // ⺤ → 爫\n  [0x2ea4, 0x722b],\n  // ⺥ → 爫\n  [0x2ea5, 0x722b],\n  // ⺦ → 丬\n  [0x2ea6, 0x4e2c],\n  // ⺨ → 犭\n  [0x2ea8, 0x72ad],\n  // ⺫ → 罒\n  [0x2eab, 0x7f52],\n  // ⺯ → 糹\n  [0x2eaf, 0x7cf9],\n  // ⺰ → 纟\n  [0x2eb0, 0x7e9f],\n  // ⺱ → 罓\n  [0x2eb1, 0x7f53],\n  // ⺴ → 㓁\n  [0x2eb4, 0x34c1],\n  // ⺸ → 羋\n  [0x2eb8, 0x7f8b],\n  // ⺹ → 耂\n  [0x2eb9, 0x8002],\n  // ⺺ → 肀\n  [0x2eba, 0x8080],\n  // ⺽ → 臼\n  [0x2ebd, 0x81fc],\n  // ⺾ → 艹\n  [0x2ebe, 0x8279],\n  // ⻁ → 虎\n  [0x2ec1, 0x864e],\n  // ⻂ → 衤\n  [0x2ec2, 0x8864],\n  // ⻃ → 覀\n  [0x2ec3, 0x8980],\n  // ⻄ → 西\n  [0x2ec4, 0x897f],\n  // ⻅ → 见\n  [0x2ec5, 0x89c1],\n  // ⻆ → 角\n  [0x2ec6, 0x89d2],\n  // ⻈ → 讠\n  [0x2ec8, 0x8ba0],\n  // ⻉ → 贝\n  [0x2ec9, 0x8d1d],\n  // ⻋ → 车\n  [0x2ecb, 0x8f66],\n  // ⻐ → 钅\n  [0x2ed0, 0x9485],\n  // ⻑ → 長\n  [0x2ed1, 0x9577],\n  // ⻒ → 镸\n  [0x2ed2, 0x9578],\n  // ⻓ → 长\n  [0x2ed3, 0x957f],\n  // ⻔ → 门\n  [0x2ed4, 0x95e8],\n  // ⻖ → 阝\n  [0x2ed6, 0x961d],\n  // ⻘ → 青\n  [0x2ed8, 0x9752],\n  // ⻙ → 韦\n  [0x2ed9, 0x97e6],\n  // ⻚ → 页\n  [0x2eda, 0x9875],\n  // ⻛ → 风\n  [0x2edb, 0x98ce],\n  // ⻜ → 飞\n  [0x2edc, 0x98de],\n  // ⻝ → 食\n  [0x2edd, 0x98df],\n  // ⻟ → 飠\n  [0x2edf, 0x98e0],\n  // ⻠ → 饣\n  [0x2ee0, 0x9963],\n  // ⻢ → 马\n  [0x2ee2, 0x9a6c],\n  // ⻣ → 骨\n  [0x2ee3, 0x9aa8],\n  // ⻤ → 鬼\n  [0x2ee4, 0x9b3c],\n  // ⻥ → 鱼\n  [0x2ee5, 0x9c7c],\n  // ⻦ → 鸟\n  [0x2ee6, 0x9e1f],\n  // ⻧ → 卤\n  [0x2ee7, 0x5364],\n  // ⻨ → 麦\n  [0x2ee8, 0x9ea6],\n  // ⻩ → 黄\n  [0x2ee9, 0x9ec4],\n  // ⻪ → 黾\n  [0x2eea, 0x9efe],\n  // ⻫ → 斉\n  [0x2eeb, 0x6589],\n  // ⻬ → 齐\n  [0x2eec, 0x9f50],\n  // ⻭ → 歯\n  [0x2eed, 0x6b6f],\n  // ⻮ → 齿\n  [0x2eee, 0x9f7f],\n  // ⻯ → 竜\n  [0x2eef, 0x7adc],\n  // ⻰ → 龙\n  [0x2ef0, 0x9f99],\n  // ⻱ → 龜\n  [0x2ef1, 0x9f9c],\n  // ⻲ → 亀\n  [0x2ef2, 0x4e80],\n  // ⻳ → 龟\n  [0x2ef3, 0x9f9f],\n];\n\nlet RADICAL_TO_KANJI: Map<number, number> | undefined;\n\n// Converts:\n//\n// - half-width katakana to full-width katakana (e.g. ｶﾞｰﾃﾞﾝ → ガーデン)\n// - decomposed characters to their composed equivalents\n//   (e.g. ダイエット → ダイエット)\n// - various enclosed characters into their plain form\n//   (e.g. ㋕ → カ)\n// - various combined characters into their expanded form\n//   (e.g. ㌀ → アパート, ㋿ → 令和)\n// - characters with variation selectors into the base character only\n// - radicals into the equivalent kanji character\n//\n// while maintaining a mapping from output character offsets to input\n// offsets.\nexport function toNormalized(input: string): [string, number[]] {\n  // Lazily create the radical map to that RADICAL_TO_KANJI_CHARS can be\n  // tree-shaken when this function is not being used (unlike arrays, Maps()\n  // always seem to be included because presumably the ctor could have\n  // side-effects).\n  if (!RADICAL_TO_KANJI) {\n    RADICAL_TO_KANJI = new Map(RADICAL_TO_KANJI_CHARS);\n  }\n\n  let inputLengths = [0];\n  let result = '';\n\n  for (let i = 0; i < input.length; ++i) {\n    let c = input.charCodeAt(i);\n\n    // Drop Unicode variation selectors\n    if ((c >= 0xfe00 && c <= 0xfe0f) || (c >= 0xe0100 && c <= 0xe011f)) {\n      inputLengths[result.length] = i + 1;\n      continue;\n    }\n\n    // Half-width to full-width katakana\n    if (c >= 0xff61 && c <= 0xff9f) {\n      c = HANKAKU_KATAKANA_TO_ZENKAKU[c - 0xff61]!;\n    }\n\n    // Decomposed characters (including any half-width katakana which we just\n    // converted since half-width katakana is always decomposed).\n    const prevChar = result.length ? result.charCodeAt(result.length - 1) : 0;\n    if (c === 0x3099) {\n      const composed = VOICED_TO_COMPOSED.get(prevChar);\n      if (composed) {\n        result = result.slice(0, -1);\n        c = composed;\n      }\n    } else if (c === 0x309a) {\n      // Decomposed semi-voiced mark (full-width or half-width)\n      const composed = SEMIVOICED_TO_COMPOSED.get(prevChar);\n      if (composed) {\n        result = result.slice(0, -1);\n        c = composed;\n      }\n    }\n\n    // Look for an expanded character\n    let expanded: string | undefined;\n    if (c >= 0x3300 && c <= 0x3370) {\n      expanded = COMBINED_CHARS_A[c - 0x3300];\n    } else if (c >= 0x337b && c <= 0x337f) {\n      expanded = COMBINED_CHARS_B[c - 0x337b];\n    } else if (c >= 0x3220 && c <= 0x3247) {\n      expanded = ENCLOSED_CHARS_A[c - 0x3220];\n    } else if (c >= 0x3280 && c <= 0x32b0) {\n      expanded = ENCLOSED_CHARS_B[c - 0x3280];\n    } else if (c >= 0x32c0 && c <= 0x32cb) {\n      expanded = ENCLOSED_CHARS_C[c - 0x32c0];\n    } else if (c >= 0x32d0 && c <= 0x32ff) {\n      expanded = ENCLOSED_CHARS_D[c - 0x32d0];\n    }\n\n    // Look for radical characters to map to kanji\n    const radical = !expanded ? RADICAL_TO_KANJI.get(c) : undefined;\n    if (radical) {\n      expanded = String.fromCodePoint(radical);\n    }\n\n    if (expanded) {\n      result += expanded;\n      inputLengths.push(...Array(expanded.length - 1).fill(i));\n    } else {\n      result += String.fromCharCode(c);\n    }\n    inputLengths[result.length] = i + 1;\n  }\n\n  return [result, inputLengths];\n}\n","const SKIP_FOR_MORA_COUNT: ReadonlyArray<number> = [\n  0x3041,\n  0x3043,\n  0x3045,\n  0x3047,\n  0x3049,\n  0x3083,\n  0x3085,\n  0x3087,\n  0x308e,\n  0x30a1,\n  0x30a3,\n  0x30a5,\n  0x30a7,\n  0x30a9,\n  0x30e3,\n  0x30e5,\n  0x30e7,\n  0x30ee,\n];\n\n// Very basic mora counter\nexport function countMora(text: string): number {\n  return [...text].filter(\n    (c, i) => i === 0 || !SKIP_FOR_MORA_COUNT.includes(c.codePointAt(0)!)\n  ).length;\n}\n\nexport function moraSubstring(\n  input: string,\n  _start: number,\n  _end?: number\n): string {\n  let start = _start;\n  let end = _end;\n\n  if (start < 0) {\n    start = 0;\n  }\n  if (typeof end !== 'undefined' && end < 0) {\n    end = 0;\n  }\n\n  const moraLength = countMora(input);\n  if (start > moraLength) {\n    start = moraLength;\n  }\n  if (typeof end !== 'undefined' && end > moraLength) {\n    end = moraLength;\n  }\n\n  if (start === end) {\n    return '';\n  }\n\n  if (typeof end !== 'undefined' && start > end) {\n    const temp = end;\n    end = start;\n    start = temp;\n  }\n\n  let moraIndex = 0;\n  let charStart = input.length;\n  let charEnd: number | undefined;\n\n  for (let i = 0; i < input.length; i++, moraIndex++) {\n    if (moraIndex === start) {\n      charStart = i;\n      if (typeof end === 'undefined') {\n        break;\n      }\n    }\n\n    if (moraIndex === end) {\n      charEnd = i;\n      break;\n    }\n\n    // Skip forward if this is a skippable character\n    if (\n      i < input.length - 1 &&\n      SKIP_FOR_MORA_COUNT.includes(input.codePointAt(i + 1)!)\n    ) {\n      i++;\n    }\n  }\n\n  return input.substring(charStart, charEnd);\n}\n","export class AbortError extends Error {\n  constructor(...params: any[]) {\n    super(...params);\n    Object.setPrototypeOf(this, AbortError.prototype);\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n","export type DownloadErrorCode =\n  | 'VersionFileNotFound'\n  | 'VersionFileNotAccessible'\n  | 'VersionFileInvalid'\n  | 'MajorVersionNotFound'\n  | 'DatabaseFileNotFound'\n  | 'DatabaseFileNotAccessible'\n  | 'DatabaseFileHeaderMissing'\n  | 'DatabaseFileHeaderDuplicate'\n  | 'DatabaseFileVersionMismatch'\n  | 'DatabaseFileInvalidJSON'\n  | 'DatabaseFileInvalidRecord'\n  | 'DatabaseTooOld'\n  | 'Timeout';\n\ntype DownloadErrorOptions = {\n  code: DownloadErrorCode;\n  url?: string;\n};\n\nexport class DownloadError extends Error {\n  code: DownloadErrorCode;\n  url?: string;\n\n  constructor({ code, url }: DownloadErrorOptions, ...params: any[]) {\n    super(...params);\n    Object.setPrototypeOf(this, DownloadError.prototype);\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, DownloadError);\n    }\n\n    this.name = 'DownloadError';\n    this.code = code;\n    this.url = url;\n  }\n}\n","import * as s from 'superstruct';\n\nexport const safeInteger = (): s.Struct<number, null> =>\n  s.refine(s.integer(), 'safeInteger', (value) => Number.isSafeInteger(value));\n","import * as s from 'superstruct';\n\nimport { AbortError } from './abort-error';\nimport { DownloadError } from './download-error';\nimport {\n  getErrorMessage,\n  isAbortError,\n  isDownloadError,\n} from './error-parsing';\nimport { fetchWithTimeout } from './fetch';\nimport { safeInteger } from './validation-helpers';\n\nexport type VersionInfo = s.Infer<typeof VersionInfoStruct>;\n\nexport async function getVersionInfo({\n  baseUrl,\n  series,\n  lang,\n  majorVersion,\n  timeout,\n  signal,\n}: {\n  baseUrl: string;\n  series: string;\n  lang: string;\n  majorVersion: number;\n  timeout: number;\n  signal?: AbortSignal;\n}): Promise<VersionInfo> {\n  const versionInfoFile = await getVersionInfoFile({\n    baseUrl,\n    lang,\n    timeout,\n    signal,\n  });\n\n  // Extract the appropriate database version information\n  const dbVersionInfo = getCurrentVersionInfo(\n    versionInfoFile,\n    series,\n    majorVersion\n  );\n  if (!dbVersionInfo) {\n    throw new DownloadError(\n      { code: 'VersionFileInvalid' },\n      `Invalid version object: the requested series, ${series} was not available in this language ('${lang}')`\n    );\n  }\n\n  return dbVersionInfo;\n}\n\nexport function clearCachedVersionInfo() {\n  cachedVersionInfo = undefined;\n}\n\nconst CACHE_TIMEOUT = 3_000 * 60; // Cache version file contents for 3 minutes\n\nlet cachedVersionInfo:\n  | { lang: string; versionInfoFile: VersionInfoFile; accessTime: number }\n  | undefined;\n\nasync function getVersionInfoFile({\n  baseUrl,\n  lang,\n  timeout,\n  signal,\n}: {\n  baseUrl: string;\n  lang: string;\n  timeout: number;\n  signal?: AbortSignal;\n}): Promise<VersionInfoFile> {\n  if (\n    cachedVersionInfo?.lang === lang &&\n    cachedVersionInfo.accessTime > Date.now() - CACHE_TIMEOUT\n  ) {\n    return cachedVersionInfo.versionInfoFile;\n  }\n  cachedVersionInfo = undefined;\n  const accessTime = Date.now();\n\n  let rawVersionInfoFile;\n\n  const url = `${baseUrl}jpdict/reader/version-${lang}.json`;\n\n  let response;\n  try {\n    response = await fetchWithTimeout(url, { signal, timeout });\n  } catch (e) {\n    if (isAbortError(e) || isDownloadError(e)) {\n      throw e;\n    }\n\n    throw new DownloadError(\n      { code: 'VersionFileNotAccessible', url },\n      `Version file ${url} not accessible (${getErrorMessage(e)})`\n    );\n  }\n\n  // Fetch rejects the promise for network errors, but not for HTTP errors :(\n  if (!response.ok) {\n    const code =\n      response.status === 404\n        ? 'VersionFileNotFound'\n        : 'VersionFileNotAccessible';\n    throw new DownloadError(\n      { code, url },\n      `Version file ${url} not accessible (status: ${response.status})`\n    );\n  }\n\n  // Try to parse it\n  try {\n    rawVersionInfoFile = await response.json();\n  } catch (e) {\n    throw new DownloadError(\n      { code: 'VersionFileInvalid', url },\n      `Invalid version object: ${\n        getErrorMessage(e) || '(No detailed error message)'\n      }`\n    );\n  }\n\n  if (signal?.aborted) {\n    throw new AbortError();\n  }\n\n  const versionInfoFile = parseVersionInfoFile(rawVersionInfoFile);\n\n  cachedVersionInfo = { lang, versionInfoFile, accessTime };\n\n  return versionInfoFile;\n}\n\nconst VersionInfoStruct = s.type({\n  major: s.min(safeInteger(), 1),\n  minor: s.min(safeInteger(), 0),\n  patch: s.min(safeInteger(), 0),\n  parts: s.optional(s.min(safeInteger(), 1)),\n  databaseVersion: s.optional(s.string()),\n  dateOfCreation: s.nonempty(s.string()),\n});\n\nconst VersionInfoFileStruct = s.record(\n  s.string(),\n  s.record(s.string(), VersionInfoStruct)\n);\n\ntype VersionInfoFile = s.Infer<typeof VersionInfoFileStruct>;\n\nfunction parseVersionInfoFile(rawVersionInfoFile: unknown): VersionInfoFile {\n  if (!rawVersionInfoFile) {\n    throw new DownloadError(\n      { code: 'VersionFileInvalid' },\n      'Empty version info file'\n    );\n  }\n\n  const [error, versionInfoFile] = s.validate(\n    rawVersionInfoFile,\n    VersionInfoFileStruct\n  );\n\n  if (error) {\n    throw new DownloadError(\n      { code: 'VersionFileInvalid' },\n      `Version file was invalid: ${error}`\n    );\n  }\n\n  return versionInfoFile;\n}\n\nfunction getCurrentVersionInfo(\n  versionInfoFile: VersionInfoFile,\n  series: string,\n  majorVersion: number\n): VersionInfo | null {\n  if (!(series in versionInfoFile)) {\n    return null;\n  }\n\n  if (!(majorVersion in versionInfoFile[series])) {\n    throw new DownloadError(\n      { code: 'MajorVersionNotFound' },\n      `No ${majorVersion}.x version information for ${series} data`\n    );\n  }\n\n  return versionInfoFile[series][majorVersion];\n}\n","import * as s from 'superstruct';\n\nimport { DataSeries } from './data-series';\nimport { DataVersion } from './data-version';\nimport { DownloadError } from './download-error';\nimport { getVersionInfo } from './download-version-info';\nimport {\n  getErrorMessage,\n  isAbortError,\n  isDownloadError,\n} from './error-parsing';\nimport { fetchWithTimeout } from './fetch';\nimport { isObject } from './is-object';\nimport { ljsonStreamIterator } from './ljson-stream';\nimport { PartInfo } from './part-info';\nimport { stripFields } from './utils';\nimport { safeInteger } from './validation-helpers';\nimport { compareVersions, VersionNumber } from './version-number';\n\n// Produces an async interator of DownloadEvents\n\n//\n// Event types\n//\n\nexport type DownloadEvent =\n  | ResetEvent\n  | DownloadStartEvent\n  | DownloadEndEvent\n  | FileStartEvent\n  | FileEndEvent\n  | RecordEvent;\n\nexport type ResetEvent = { type: 'reset' };\nexport type DownloadStartEvent = { type: 'downloadstart'; files: number };\nexport type DownloadEndEvent = { type: 'downloadend' };\nexport type FileStartEvent = {\n  type: 'filestart';\n  version: DataVersion;\n  totalRecords: number;\n};\nexport type FileEndEvent = { type: 'fileend' };\nexport type RecordEvent = {\n  type: 'record';\n  mode: 'add' | 'change' | 'delete';\n  record: Record<string, unknown>;\n};\n\n//\n// Helper types\n//\n\nexport type CurrentVersion = VersionNumber & {\n  partInfo?: PartInfo;\n};\n\n//\n// Configuration constants\n//\n\nconst BASE_URL = 'https://data.10ten.life/';\n\nconst DOWNLOAD_TIMEOUT = 20_000;\n\nexport type DownloadOptions = {\n  series: DataSeries;\n  majorVersion: number;\n  currentVersion?: CurrentVersion;\n  lang: string;\n  signal: AbortSignal;\n};\n\nexport async function hasLanguage({\n  series,\n  majorVersion,\n  lang,\n  signal,\n}: {\n  baseUrl?: string;\n  series: DataSeries;\n  majorVersion: number;\n  lang: string;\n  signal?: AbortSignal;\n}): Promise<boolean> {\n  try {\n    const result = await getVersionInfo({\n      baseUrl: BASE_URL,\n      series,\n      lang,\n      majorVersion,\n      timeout: DOWNLOAD_TIMEOUT,\n      signal,\n    });\n    return !!result;\n  } catch {\n    return false;\n  }\n}\n\nexport async function* download({\n  series,\n  majorVersion,\n  currentVersion,\n  lang,\n  signal,\n}: DownloadOptions): AsyncIterableIterator<DownloadEvent> {\n  const versionInfo = await getVersionInfo({\n    baseUrl: BASE_URL,\n    series,\n    lang,\n    majorVersion,\n    timeout: DOWNLOAD_TIMEOUT,\n    signal,\n  });\n\n  const { files, type } = getDownloadList({\n    currentVersion,\n    latestVersion: versionInfo,\n  });\n\n  if (type === 'reset' && currentVersion) {\n    yield { type: 'reset' };\n  }\n\n  yield { type: 'downloadstart', files: files.length };\n\n  for (const file of files) {\n    yield* getEvents({\n      baseUrl: BASE_URL,\n      series,\n      lang,\n      version: file.version,\n      signal,\n      format: file.format,\n      partInfo: file.partInfo,\n    });\n  }\n\n  yield { type: 'downloadend' };\n}\n\ntype DownloadFileSpec =\n  | {\n      format: 'full';\n      version: VersionNumber;\n      partInfo?: PartInfo;\n    }\n  | {\n      format: 'patch';\n      version: VersionNumber;\n      partInfo?: never;\n    };\n\nfunction getDownloadList({\n  currentVersion,\n  latestVersion,\n}: {\n  currentVersion?: CurrentVersion;\n  latestVersion: {\n    major: number;\n    minor: number;\n    patch: number;\n    parts?: number;\n  };\n}): {\n  type: 'reset' | 'update';\n  files: Array<DownloadFileSpec>;\n} {\n  // Check the local database is not ahead of what we're about to download\n  //\n  // This can happen when the version file gets cached because we can\n  // download a more recent version (e.g. we have DevTools open with \"skip\n  // cache\" ticked) and then try again to fetch the file but get the older\n  // version.\n  if (currentVersion && compareVersions(currentVersion, latestVersion) > 0) {\n    const versionToString = ({ major, minor, patch }: VersionNumber) =>\n      `${major}.${minor}.${patch}`;\n    throw new DownloadError(\n      { code: 'DatabaseTooOld' },\n      `Database version (${versionToString(\n        latestVersion\n      )}) is older than the current version (${versionToString(\n        currentVersion\n      )})`\n    );\n  }\n\n  // If there's no current version or if there's been a change in major/minor\n  // version, reset any existing data.\n  let downloadType =\n    !currentVersion ||\n    compareVersions(currentVersion, { ...latestVersion, patch: 0 }) < 0\n      ? ('reset' as const)\n      : ('update' as const);\n\n  // Furthermore, if we're resuming a multi-part initial download but there have\n  // since been more than 10 new patches to that minor version, we should just\n  // start over.\n  //\n  // This will probably be faster and, more importantly, it means we can archive\n  // the full (i.e. non-patch) version files of any minor version that is more\n  // than 10 patches old without having to worry about really out-of-date\n  // clients later requesting those parts.\n  if (\n    downloadType === 'update' &&\n    currentVersion?.partInfo &&\n    latestVersion.patch - currentVersion.patch > 10\n  ) {\n    downloadType = 'reset';\n  }\n\n  // There are four cases to consider:\n  //\n  // 1. We are doing a full download of a partitioned data series\n  //    i.e. we need to download all the parts from 0 to `parts - 1`.\n  //\n  // 2. We are doing a full download of an unpartitioned data series\n  //    i.e. we simply need to download the data file for the current patch\n  //    level.\n  //\n  // 3. We are resuming a full download\n  //    i.e. we need to download all the remaining parts _and_ any\n  //    subsequent patches.\n  //\n  // 4. We are patching an existing series\n  //    i.e. we need to download each patch from the one after the current\n  //    version up to and including the latest patch.\n\n  // Case 1: Partitioned series\n  if (downloadType === 'reset' && latestVersion.parts) {\n    const files: Array<DownloadFileSpec> = [];\n    let nextPart = 1;\n\n    while (nextPart <= latestVersion.parts) {\n      files.push({\n        format: 'full',\n        version: {\n          major: latestVersion.major,\n          minor: latestVersion.minor,\n          patch: latestVersion.patch,\n        },\n        partInfo: {\n          part: nextPart,\n          parts: latestVersion.parts,\n        },\n      });\n      nextPart++;\n    }\n\n    return { type: downloadType, files };\n  }\n\n  // Case 2: Unpartitioned series\n  if (downloadType === 'reset') {\n    return {\n      type: downloadType,\n      files: [\n        {\n          format: 'full',\n          version: {\n            major: latestVersion.major,\n            minor: latestVersion.minor,\n            patch: latestVersion.patch,\n          },\n        },\n      ],\n    };\n  }\n\n  // The following is just to help TypeScript realise that `currentVersion` must\n  // be defined if `downloadType` is 'update'.\n  if (!currentVersion) {\n    throw new Error(\n      'We should have already dealt with the initial download case'\n    );\n  }\n\n  // Case 3 (part 1): Resumed partitioned series\n  const files: Array<DownloadFileSpec> = [];\n  if (currentVersion.partInfo) {\n    let nextPart = currentVersion.partInfo.part + 1;\n\n    while (nextPart <= currentVersion.partInfo.parts) {\n      files.push({\n        format: 'full',\n        version: {\n          major: currentVersion.major,\n          minor: currentVersion.minor,\n          patch: currentVersion.patch,\n        },\n        partInfo: {\n          part: nextPart,\n          parts: currentVersion.partInfo.parts,\n        },\n      });\n      nextPart++;\n    }\n  }\n\n  // Case 3 (part 2) and case 4: Updating a series\n  let nextPatch = currentVersion.patch + 1;\n  while (nextPatch <= latestVersion.patch) {\n    files.push({\n      format: 'patch',\n      version: {\n        major: latestVersion.major,\n        minor: latestVersion.minor,\n        patch: nextPatch,\n      },\n    });\n    nextPatch++;\n  }\n\n  return { type: downloadType, files };\n}\n\ntype GetEventsOptions = {\n  baseUrl: string;\n  series: DataSeries;\n  lang: string;\n  version: VersionNumber;\n  signal: AbortSignal;\n  format: 'full' | 'patch';\n  partInfo?: PartInfo;\n};\n\nconst HeaderLineStruct = s.type({\n  type: s.literal('header'),\n  version: s.type({\n    major: s.min(safeInteger(), 1),\n    minor: s.min(safeInteger(), 0),\n    patch: s.min(safeInteger(), 0),\n    databaseVersion: s.optional(s.string()),\n    dateOfCreation: s.nonempty(s.string()),\n  }),\n  records: s.min(safeInteger(), 0),\n  part: s.optional(s.min(safeInteger(), 0)),\n  format: s.enums(['patch', 'full']),\n});\n\nconst PatchLineStruct = s.type({\n  _: s.enums(['+', '-', '~']),\n});\n\nasync function* getEvents({\n  baseUrl,\n  series,\n  lang,\n  version,\n  signal,\n  format,\n  partInfo,\n}: GetEventsOptions): AsyncIterableIterator<DownloadEvent> {\n  const dottedVersion = `${version.major}.${version.minor}.${version.patch}`;\n  const commonUrlStart = `${baseUrl}jpdict/reader/${series}/${lang}/${dottedVersion}`;\n  const url =\n    format === 'patch'\n      ? `${commonUrlStart}-patch.jsonl`\n      : partInfo\n        ? `${commonUrlStart}-${partInfo.part}.jsonl`\n        : `${commonUrlStart}.jsonl`;\n\n  let response;\n  try {\n    response = await fetchWithTimeout(url, {\n      signal,\n      timeout: DOWNLOAD_TIMEOUT,\n    });\n  } catch (e) {\n    if (isAbortError(e) || isDownloadError(e)) {\n      throw e;\n    }\n\n    throw new DownloadError(\n      { code: 'DatabaseFileNotFound', url },\n      `Database file ${url} not accessible (${getErrorMessage(e)})`\n    );\n  }\n\n  if (!response.ok) {\n    const code =\n      response.status === 404\n        ? 'DatabaseFileNotFound'\n        : 'DatabaseFileNotAccessible';\n    throw new DownloadError(\n      { code, url },\n      `Database file ${url} not accessible (status: ${response.status})`\n    );\n  }\n\n  if (response.body === null) {\n    throw new DownloadError(\n      { code: 'DatabaseFileNotAccessible', url },\n      'Body is null'\n    );\n  }\n\n  let headerRead = false;\n\n  for await (const line of ljsonStreamIterator({\n    stream: response.body,\n    signal,\n    timeout: DOWNLOAD_TIMEOUT,\n    url,\n  })) {\n    if (s.is(line, HeaderLineStruct)) {\n      if (headerRead) {\n        throw new DownloadError(\n          { code: 'DatabaseFileHeaderDuplicate', url },\n          `Got duplicate database header: ${JSON.stringify(line)}`\n        );\n      }\n\n      if (compareVersions(line.version, version) !== 0) {\n        throw new DownloadError(\n          { code: 'DatabaseFileVersionMismatch', url },\n          `Got mismatched database versions (Expected: ${JSON.stringify(\n            version\n          )} got: ${JSON.stringify(line.version)})`\n        );\n      }\n\n      if (line.part !== partInfo?.part) {\n        throw new DownloadError(\n          { code: 'DatabaseFileVersionMismatch', url },\n          `Got mismatched database part number (Expected: ${partInfo?.part}, got: ${line.part})`\n        );\n      }\n\n      if (line.format !== format) {\n        throw new DownloadError(\n          { code: 'DatabaseFileVersionMismatch', url },\n          `Expected to get a data file in ${format} format but got '${line.format}' format instead`\n        );\n      }\n\n      let fileStartEvent: FileStartEvent;\n      if (line.part !== undefined) {\n        fileStartEvent = {\n          type: 'filestart',\n          totalRecords: line.records,\n          version: {\n            ...line.version,\n            partInfo: {\n              part: line.part,\n              parts: partInfo!.parts,\n            },\n            lang,\n          },\n        };\n      } else {\n        fileStartEvent = {\n          type: 'filestart',\n          totalRecords: line.records,\n          version: {\n            ...line.version,\n            lang,\n          },\n        };\n      }\n\n      yield fileStartEvent;\n\n      headerRead = true;\n    } else if (format === 'patch' && s.is(line, PatchLineStruct)) {\n      if (!headerRead) {\n        throw new DownloadError(\n          { code: 'DatabaseFileHeaderMissing', url },\n          `Expected database version but got ${JSON.stringify(line)}`\n        );\n      }\n\n      const mode =\n        line._ === '+' ? 'add' : line._ === '-' ? 'delete' : 'change';\n      yield { type: 'record', mode, record: stripFields(line, ['_']) };\n    } else if (format === 'full' && isObject(line)) {\n      if (!headerRead) {\n        throw new DownloadError(\n          { code: 'DatabaseFileHeaderMissing', url },\n          `Expected database version but got ${JSON.stringify(line)}`\n        );\n      }\n\n      if ('_' in line) {\n        throw new DownloadError(\n          { code: 'DatabaseFileInvalidRecord', url },\n          `Got patch-like '_' field in non-patch record: ${JSON.stringify(\n            line\n          )}`\n        );\n      }\n\n      yield { type: 'record', mode: 'add', record: line };\n    } else {\n      // If we encounter anything unexpected we should fail.\n      //\n      // It might be tempting to make this \"robust\" by ignoring unrecognized\n      // inputs but that could effectively leave us in an invalid state where\n      // we claim to be update-to-date with database version X but are\n      // actually missing some of the records.\n      //\n      // If anything unexpected shows up we should fail so we can debug\n      // exactly what happenned.\n      throw new DownloadError(\n        { code: 'DatabaseFileInvalidRecord', url },\n        `Got unexpected record: ${JSON.stringify(line)}`\n      );\n    }\n  }\n\n  yield { type: 'fileend' };\n}\n","export class QuotaExceededError extends Error {\n  constructor(...params: any[]) {\n    super(...params);\n    Object.setPrototypeOf(this, QuotaExceededError.prototype);\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, QuotaExceededError);\n    }\n\n    this.name = 'QuotaExceededError';\n    this.message = 'The current transaction exceeded its quota limitations.';\n  }\n}\n","import * as s from 'superstruct';\n\nimport { DataSeries } from './data-series';\nimport { KanjiMiscInfo, KanjiReading, KanjiRecord, Radical } from './kanji';\nimport { NameRecord, NameTranslation } from './names';\nimport { RadicalRecord } from './radicals';\nimport { Overwrite } from './type-helpers';\nimport { safeInteger } from './validation-helpers';\nimport {\n  Accent,\n  CrossReference,\n  KanjiMeta,\n  LangSource,\n  ReadingMeta,\n  WordRecord,\n  WordSense,\n} from './words';\n\n// ----------------------------------------------------------------------------\n//\n// Words\n//\n// ----------------------------------------------------------------------------\n\nconst KanjiMetaSchema: s.Describe<KanjiMeta> = s.type({\n  i: s.optional(s.array(s.string())),\n  p: s.optional(s.array(s.string())),\n  bv: s.optional(s.string()),\n  bg: s.optional(s.string()),\n});\n\nconst AccentSchema: s.Describe<Accent> = s.type({\n  i: s.min(safeInteger(), 0),\n  pos: s.optional(s.array(s.string())),\n});\n\nconst ReadingMetaSchema: s.Describe<ReadingMeta> = s.type({\n  i: s.optional(s.array(s.string())),\n  p: s.optional(s.array(s.string())),\n  app: s.optional(s.min(safeInteger(), 0)),\n  a: s.optional(s.union([s.min(safeInteger(), 0), s.array(AccentSchema)])),\n  bv: s.optional(s.string()),\n  bg: s.optional(s.string()),\n});\n\n// The following typing is because Describe struggles with union types\nconst CrossReferenceSchema: s.Struct<s.Describe<CrossReference>['TYPE'], null> =\n  s.union([\n    s.type({\n      k: s.nonempty(s.string()),\n      sense: s.optional(s.min(safeInteger(), 0)),\n    }),\n    s.type({\n      r: s.nonempty(s.string()),\n      sense: s.optional(s.min(safeInteger(), 0)),\n    }),\n    s.type({\n      k: s.nonempty(s.string()),\n      r: s.string(),\n      sense: s.optional(s.min(safeInteger(), 0)),\n    }),\n  ]);\n\nconst LangSourceSchema: s.Describe<LangSource> = s.type({\n  lang: s.optional(s.nonempty(s.string())),\n  src: s.optional(s.string()),\n  // The following should be:\n  //\n  //   part: s.optional(s.literal(true)),\n  //   wasei: s.optional(s.literal(true)),\n  //\n  // But Describe doesn't seem to handle optional boolean literals so we try\n  // this way for now.\n  part: s.union([s.literal(true), s.literal(undefined)]),\n  wasei: s.union([s.literal(true), s.literal(undefined)]),\n});\n\nconst WordSenseSchema: s.Describe<WordSense> = s.type({\n  g: s.nonempty(s.array(s.nonempty(s.string()))),\n  gt: s.optional(s.min(safeInteger(), 1)),\n  lang: s.optional(s.nonempty(s.string())),\n  kapp: s.optional(s.min(safeInteger(), 0)),\n  rapp: s.optional(s.min(safeInteger(), 0)),\n  pos: s.optional(s.array(s.string())),\n  field: s.optional(s.array(s.string())),\n  misc: s.optional(s.array(s.string())),\n  dial: s.optional(s.array(s.string())),\n  inf: s.optional(s.nonempty(s.string())),\n  xref: s.optional(s.nonempty(s.array(CrossReferenceSchema))),\n  ant: s.optional(s.nonempty(s.array(CrossReferenceSchema))),\n  lsrc: s.optional(s.nonempty(s.array(LangSourceSchema))),\n});\n\nconst WordIdSchema = s.min(safeInteger(), 1);\n\nexport type WordDownloadRecord = Overwrite<\n  WordRecord,\n  {\n    km?: Array<0 | KanjiMeta>;\n    rm?: Array<0 | ReadingMeta>;\n    s: Array<WordSense>;\n  }\n>;\n\nconst WordDownloadRecordSchema: s.Describe<WordDownloadRecord> = s.type({\n  id: WordIdSchema,\n  k: s.optional(s.nonempty(s.array(s.string()))),\n  km: s.optional(s.nonempty(s.array(s.union([s.literal(0), KanjiMetaSchema])))),\n  r: s.array(s.nonempty(s.nonempty(s.string()))),\n  rm: s.optional(\n    s.nonempty(s.array(s.union([s.literal(0), ReadingMetaSchema])))\n  ),\n  s: s.array(WordSenseSchema),\n});\n\nexport function validateWordDownloadRecord(\n  record: unknown\n): [Error, undefined] | [undefined, WordDownloadRecord] {\n  return s.validate(record, WordDownloadRecordSchema);\n}\n\n// -- Delete variant --\n\nexport type WordDownloadDeleteRecord = Pick<WordDownloadRecord, 'id'>;\n\nconst WordDownloadDeleteRecordSchema: s.Describe<WordDownloadDeleteRecord> =\n  s.type({\n    id: WordIdSchema,\n  });\n\nexport function validateWordDownloadDeleteRecord(\n  record: unknown\n): [Error, undefined] | [undefined, WordDownloadDeleteRecord] {\n  return s.validate(record, WordDownloadDeleteRecordSchema);\n}\n\n// ----------------------------------------------------------------------------\n//\n// Names\n//\n// ----------------------------------------------------------------------------\n\nconst NameTranslationSchema: s.Describe<NameTranslation> = s.type({\n  type: s.optional(s.array(s.string())),\n  det: s.array(s.nonempty(s.string())),\n  cf: s.optional(s.array(s.nonempty(s.string()))),\n});\n\nconst NameIdSchema = s.min(safeInteger(), 1);\n\nexport type NameDownloadRecord = NameRecord;\n\nconst NameDownloadRecordSchema: s.Describe<NameDownloadRecord> = s.type({\n  id: NameIdSchema,\n  k: s.optional(s.array(s.nonempty(s.string()))),\n  r: s.nonempty(s.array(s.nonempty(s.string()))),\n  tr: s.array(NameTranslationSchema),\n});\n\nexport function validateNameDownloadRecord(\n  record: unknown\n): [Error, undefined] | [undefined, NameDownloadRecord] {\n  return s.validate(record, NameDownloadRecordSchema);\n}\n\n// -- Delete variant --\n\nexport type NameDownloadDeleteRecord = Pick<NameDownloadRecord, 'id'>;\n\nconst NameDownloadDeleteRecordSchema: s.Describe<NameDownloadDeleteRecord> =\n  s.type({\n    id: NameIdSchema,\n  });\n\nexport function validateNameDownloadDeleteRecord(\n  record: unknown\n): [Error, undefined] | [undefined, NameDownloadDeleteRecord] {\n  return s.validate(record, NameDownloadDeleteRecordSchema);\n}\n\n// ----------------------------------------------------------------------------\n//\n// Kanji\n//\n// ----------------------------------------------------------------------------\n\nconst ReadingsStruct: s.Describe<KanjiReading> = s.type({\n  on: s.optional(s.array(s.string())),\n  kun: s.optional(s.array(s.string())),\n  na: s.optional(s.array(s.string())),\n  py: s.optional(s.array(s.string())),\n});\n\nconst RadicalStruct: s.Describe<Radical> = s.type({\n  x: s.min(safeInteger(), 0),\n  nelson: s.optional(s.min(safeInteger(), 0)),\n  name: s.optional(s.array(s.string())),\n  var: s.optional(s.string()),\n});\n\nconst MiscSchema: s.Describe<KanjiMiscInfo> = s.type({\n  gr: s.optional(safeInteger()),\n  sc: s.min(safeInteger(), 1),\n  freq: s.optional(s.min(safeInteger(), 0)),\n  // The following three items should really have a minimum value of 1, but in\n  // the interests of being (a bit) forgiving in what we accept, we allow 0 too.\n  jlpt: s.optional(s.min(safeInteger(), 0)),\n  jlptn: s.optional(s.min(safeInteger(), 0)),\n  kk: s.optional(s.min(safeInteger(), 0)),\n  // As with jlpt(n), we allow 0 here even though we expect WaniKani levels to\n  // be between 1 and 60.\n  wk: s.optional(s.min(safeInteger(), 0)),\n  meta: s.optional(s.array(s.string())),\n});\n\nconst KanjiIdSchema = s.nonempty(s.string());\n\nexport type KanjiDownloadRecord = KanjiRecord;\n\nconst KanjiDownloadRecordSchema: s.Describe<KanjiDownloadRecord> = s.type({\n  c: KanjiIdSchema,\n  r: ReadingsStruct,\n  m: s.array(s.string()),\n  m_lang: s.optional(s.string()),\n  rad: RadicalStruct,\n  refs: s.record(s.string(), s.union([s.string(), s.number()])),\n  misc: MiscSchema,\n  st: s.optional(s.string()),\n  comp: s.optional(s.string()),\n  var: s.optional(s.array(s.string())),\n  cf: s.optional(s.union([s.string(), s.array(s.string())])),\n});\n\nexport function validateKanjiDownloadRecord(\n  record: unknown\n): [Error, undefined] | [undefined, KanjiDownloadRecord] {\n  return s.validate(record, KanjiDownloadRecordSchema);\n}\n\n// -- Delete variant --\n\nexport type KanjiDownloadDeleteRecord = Pick<KanjiDownloadRecord, 'c'>;\n\nconst KanjiDownloadDeleteRecordSchema: s.Describe<KanjiDownloadDeleteRecord> =\n  s.type({\n    c: KanjiIdSchema,\n  });\n\nexport function validateKanjiDownloadDeleteRecord(\n  record: unknown\n): [Error, undefined] | [undefined, KanjiDownloadDeleteRecord] {\n  return s.validate(record, KanjiDownloadDeleteRecordSchema);\n}\n\n// ----------------------------------------------------------------------------\n//\n// Radicals\n//\n// ----------------------------------------------------------------------------\n\nconst RadicalIdSchema = s.nonempty(s.string());\n\nexport type RadicalDownloadRecord = Overwrite<\n  RadicalRecord,\n  {\n    // We don't validate the posn field for downloaded records because we don't\n    // want to force a major version bump every time we add a posn field.\n    posn?: string;\n  }\n>;\n\nconst RadicalDownloadRecordSchema: s.Describe<RadicalDownloadRecord> = s.type({\n  id: RadicalIdSchema,\n  r: s.min(safeInteger(), 1),\n  b: s.optional(s.nonempty(s.string())),\n  k: s.optional(s.nonempty(s.string())),\n  pua: s.optional(safeInteger()),\n  s: safeInteger(),\n  na: s.array(s.nonempty(s.string())),\n  posn: s.optional(s.nonempty(s.string())),\n  m: s.array(s.nonempty(s.string())),\n  m_lang: s.optional(s.nonempty(s.string())),\n});\n\nexport function validateRadicalDownloadRecord(\n  record: unknown\n): [Error, undefined] | [undefined, RadicalDownloadRecord] {\n  return s.validate(record, RadicalDownloadRecordSchema);\n}\n\n// -- Delete variant --\n\nexport type RadicalDownloadDeleteRecord = Pick<RadicalDownloadRecord, 'id'>;\n\nconst RadicalDownloadDeleteRecordSchema: s.Describe<RadicalDownloadDeleteRecord> =\n  s.type({\n    id: RadicalIdSchema,\n  });\n\nexport function validateRadicalDownloadDeleteRecord(\n  record: unknown\n): [Error, undefined] | [undefined, RadicalDownloadDeleteRecord] {\n  return s.validate(record, RadicalDownloadDeleteRecordSchema);\n}\n\n// ----------------------------------------------------------------------------\n//\n// Combined types\n//\n// ----------------------------------------------------------------------------\n\ntype DownloadRecordMapping = {\n  words: WordDownloadRecord;\n  names: NameDownloadRecord;\n  kanji: KanjiDownloadRecord;\n  radicals: RadicalDownloadRecord;\n};\n\nexport type DownloadRecord<T extends DataSeries> = DownloadRecordMapping[T];\n\nconst validateDownloadRecordMapping: {\n  [Series in DataSeries]: (\n    record: unknown\n  ) => [Error, undefined] | [undefined, DownloadRecord<Series>];\n} = {\n  words: validateWordDownloadRecord,\n  names: validateNameDownloadRecord,\n  kanji: validateKanjiDownloadRecord,\n  radicals: validateRadicalDownloadRecord,\n};\n\nexport function validateDownloadRecord<Series extends DataSeries>({\n  series,\n  record,\n}: {\n  series: Series;\n  record: unknown;\n}) {\n  return validateDownloadRecordMapping[series](record);\n}\n\n// -- Delete variant --\n\ntype DownloadDeleteRecordMapping = {\n  words: WordDownloadDeleteRecord;\n  names: NameDownloadDeleteRecord;\n  kanji: KanjiDownloadDeleteRecord;\n  radicals: RadicalDownloadDeleteRecord;\n};\n\nexport type DownloadDeleteRecord<T extends DataSeries> =\n  DownloadDeleteRecordMapping[T];\n\nconst validateDownloadDeleteRecordMapping: {\n  [Series in DataSeries]: (\n    record: unknown\n  ) => [Error, undefined] | [undefined, DownloadDeleteRecord<Series>];\n} = {\n  words: validateWordDownloadDeleteRecord,\n  names: validateNameDownloadDeleteRecord,\n  kanji: validateKanjiDownloadDeleteRecord,\n  radicals: validateRadicalDownloadDeleteRecord,\n};\n\nexport function validateDownloadDeleteRecord<Series extends DataSeries>({\n  series,\n  record,\n}: {\n  series: Series;\n  record: unknown;\n}) {\n  return validateDownloadDeleteRecordMapping[series](record);\n}\n","import { ExtendedSense } from './result-types';\n\nexport interface PosGroup<Sense> {\n  pos: Array<string>;\n  misc: Array<string>;\n  senses: Array<Sense>;\n}\n\nexport function groupSenses<Sense extends ExtendedSense>(\n  senses: Array<Sense>\n): Array<PosGroup<Sense>> {\n  const groups: Array<PosGroup<Sense>> = [];\n\n  // Do an initial grouping based on the first part-of-speech (POS)\n  let previousPos: string | undefined;\n  for (const sense of senses) {\n    // Look for a match. Note that a match can be one of two kinds:\n    //\n    // a) Where the sense includes the POS we are grouping on\n    // b) Where we currently have a group where there is no POS and the sense\n    //    also has no POS.\n    if (\n      (previousPos && sense.pos && sense.pos.includes(previousPos)) ||\n      (!previousPos && groups.length && (!sense.pos || !sense.pos.length))\n    ) {\n      groups[groups.length - 1].senses.push(dropPos(sense, previousPos));\n    } else {\n      // If there was no match, start a new group\n      const thisPos = sense.pos?.length ? sense.pos[0] : undefined;\n      const pos = thisPos ? [thisPos] : [];\n      groups.push({ pos, misc: [], senses: [dropPos(sense, thisPos)] });\n      previousPos = thisPos;\n    }\n  }\n\n  // Having done the initial grouping, see if there are any additional POS that\n  // are common to all senses that we can hoist to the group heading.\n  for (const group of groups) {\n    let commonPos = group.senses[0].pos;\n    if (!commonPos) {\n      continue;\n    }\n\n    for (const sense of group.senses.slice(1)) {\n      commonPos = commonPos.filter(\n        (pos) => sense.pos && sense.pos.includes(pos)\n      );\n      if (!commonPos.length) {\n        break;\n      }\n    }\n\n    if (commonPos.length) {\n      group.pos.push(...commonPos);\n      group.senses = group.senses.map((sense) => dropPos(sense, commonPos));\n    }\n  }\n\n  // Hoist any common misc readings\n  for (const group of groups) {\n    let commonMisc = group.senses[0].misc;\n    if (!commonMisc) {\n      continue;\n    }\n\n    for (const sense of group.senses.slice(1)) {\n      commonMisc = commonMisc.filter(\n        (misc) => sense.misc && sense.misc.includes(misc)\n      );\n      if (!commonMisc.length) {\n        break;\n      }\n    }\n\n    if (commonMisc.length) {\n      group.misc = commonMisc;\n      group.senses = group.senses.map((sense) => ({\n        ...sense,\n        misc: sense.misc?.filter((misc) => !commonMisc!.includes(misc)),\n      }));\n    }\n  }\n\n  return groups;\n}\n\n// Set up a utility to produce a copy of a sense with the specified\n// part(s)-of-speech removed.\nfunction dropPos<Sense extends ExtendedSense>(\n  sense: Sense,\n  posToDrop: string | Array<string> | undefined\n): Sense {\n  let pos = sense.pos\n    ? sense.pos.filter((pos) =>\n        Array.isArray(posToDrop) ? !posToDrop.includes(pos) : pos !== posToDrop\n      )\n    : undefined;\n  if (pos && !pos.length) {\n    pos = undefined;\n  }\n\n  return { ...sense, pos };\n}\n","export class OfflineError extends Error {\n  constructor(...params: any[]) {\n    super(...params);\n    Object.setPrototypeOf(this, OfflineError.prototype);\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, OfflineError);\n    }\n\n    this.name = 'OfflineError';\n  }\n}\n","export type WordRecord = {\n  id: number;\n\n  // Kanji readings for the entry\n  k?: Array<string>;\n  km?: Array<null | KanjiMeta>;\n\n  // Kana readings for the entry\n  r: Array<string>;\n  rm?: Array<null | ReadingMeta>;\n\n  // Sense information\n  s: Array<WordSense>;\n};\n\nexport type KanjiMeta = {\n  // Information about a kanji headword\n  //\n  // Typically this should be of type KanjiInfo but we allow it to be any string\n  // in case new types are introduced in future and the client has yet to be\n  // updated.\n  i?: Array<string>;\n\n  // Priority information\n  p?: Array<string>;\n\n  // Bunpro vocab fuzzy match source text\n  bv?: string;\n\n  // Bunpro grammar fuzzy match source text\n  bg?: string;\n};\n\nexport type ReadingMeta = {\n  // Information about the reading\n  //\n  // Typically this should be of type ReadingInfo but we allow it to be any\n  // string in case new types are introduced in future and the client has yet to\n  // be updated.\n  i?: Array<string>;\n\n  // Priority information\n  p?: Array<string>;\n\n  // Bitfield representing which kanji entries (based on their order in the k\n  // array) the reading applies to. 0 means it applies to none of them. If the\n  // field is absent, it means the reading applies to all of the kanji entries.\n  app?: number;\n\n  // Pitch accent information.\n  a?: number | Array<Accent>;\n\n  // Bunpro vocab fuzzy match source text\n  bv?: string;\n\n  // Bunpro grammar fuzzy match source text\n  bg?: string;\n};\n\nexport type Accent = {\n  // Syllable number of the accent (after which the drop occurs).\n  // 0 = 平板\n  i: number;\n\n  // This should typically be a PartOfSpeech value.\n  pos?: Array<string>;\n};\n\nexport type WordSense = {\n  g: Array<string>;\n  // A bitfield representing the type of the glosses in `g`. Two bits are used\n  // to represent the type of each item in `g`, where each two-bit value is one\n  // of the GlossType values below.\n  //\n  // Undefined if the value is 0 (i.e. no glosses have a type, the most common\n  // case).\n  gt?: number;\n  // undefined = 'en'\n  lang?: string;\n\n  // Bit field representing the kanji / kana entries this sense applies to.\n  // If the sense applies to all entries the field will be undefined.\n  kapp?: number;\n  rapp?: number;\n\n  // Extra information about the sense.\n\n  // Typically a PartOfSpeech value\n  pos?: Array<string>;\n  // Typically a FieldType value\n  field?: Array<string>;\n  // Typically a MiscType value\n  misc?: Array<string>;\n  // Typically a Dialect value\n  dial?: Array<string>;\n  inf?: string;\n  xref?: Array<CrossReference>;\n  ant?: Array<CrossReference>;\n\n  // Language source information.\n  lsrc?: Array<LangSource>;\n};\n\nexport const GlossTypes = ['none', 'expl', 'lit', 'fig', 'tm'] as const;\nexport type GlossType = (typeof GlossTypes)[number];\nexport const GLOSS_TYPE_MAX = GlossTypes.length;\nexport const BITS_PER_GLOSS_TYPE = Math.floor(Math.log2(GLOSS_TYPE_MAX)) + 1;\n\nexport type CrossReference =\n  | {\n      k: string;\n      sense?: number;\n    }\n  | {\n      r: string;\n      sense?: number;\n    }\n  | {\n      k: string;\n      r: string;\n      sense?: number;\n    };\n\nexport type LangSource = {\n  // undefined = 'en'\n  lang?: string;\n\n  // The term in the source language\n  //\n  // This may be empty in some cases.\n  src?: string;\n\n  // Partial source (i.e. this only represents part of the string)\n  // absent = false\n  part?: true;\n\n  // The Japanese word is made from words from another language but doesn't\n  // actually represent the meaning of those words literally.\n  wasei?: true;\n};\n\n// ----------------------------------------------------------------------------\n//\n// Supplemental types that may be used to further refine the fields above\n//\n// ----------------------------------------------------------------------------\n\n// KanjiInfo\n\nexport type KanjiInfo = (typeof kanjiInfoValues)[number];\n\nconst kanjiInfoValues = [\n  // ateji (phonetic) reading\n  'ateji',\n  // irregular okurigana usage\n  'io',\n  // word containing irregular kanji usage\n  'iK',\n  // word containing irregular kana usage\n  'ik',\n  // word containing out-dated kanji or kanji usage\n  'oK',\n  // rarely-used kanji form\n  'rK',\n  // search-only kanji form\n  'sK',\n] as const;\n\nexport function isKanjiInfo(a: unknown): a is KanjiInfo {\n  return typeof a === 'string' && kanjiInfoValues.includes(a as KanjiInfo);\n}\n\nexport function asKanjiInfo(a: unknown): KanjiInfo | undefined {\n  return isKanjiInfo(a) ? a : undefined;\n}\n\n// ReadingInfo\n\nexport type ReadingInfo = (typeof allReadingInfo)[number];\n\nconst allReadingInfo = [\n  // gikun (meaning as reading) or jukujikun (special kanji reading)\n  'gikun',\n  // word containing irregular kana usage\n  'ik',\n  // out-dated or obsolete kana usage\n  'ok',\n  // rarely-used kana form\n  'rk',\n  // search-only kana form\n  'sk',\n] as const;\n\nexport function isReadingInfo(a: unknown): a is ReadingInfo {\n  return typeof a === 'string' && allReadingInfo.includes(a as ReadingInfo);\n}\n\nexport function asReadingInfo(a: unknown): ReadingInfo | undefined {\n  return isReadingInfo(a) ? a : undefined;\n}\n\n// Part of speech\n\nexport type PartOfSpeech = (typeof allPartsOfSpeech)[number];\n\n// prettier-ignore\nconst allPartsOfSpeech = [\n  'adj-f', 'adj-i', 'adj-ix', 'adj-kari', 'adj-ku', 'adj-na', 'adj-nari',\n  'adj-no', 'adj-pn', 'adj-shiku', 'adj-t', 'adv', 'adv-to', 'aux', 'aux-adj',\n  'aux-v', 'conj', 'cop', 'ctr', 'exp', 'int', 'n', 'n-adv', 'n-pr', 'n-pref',\n  'n-suf', 'n-t', 'num', 'pn', 'pref', 'prt', 'suf', 'unc', 'v-unspec', 'v1',\n  'v1-s', 'v2a-s', 'v2b-k', 'v2b-s', 'v2d-k', 'v2d-s', 'v2g-k', 'v2g-s',\n  'v2h-k', 'v2h-s', 'v2k-k', 'v2k-s', 'v2m-k', 'v2m-s', 'v2n-s', 'v2r-k',\n  'v2r-s', 'v2s-s', 'v2t-k', 'v2t-s', 'v2w-s', 'v2y-k', 'v2y-s', 'v2z-s', 'v4b',\n  'v4g', 'v4h', 'v4k', 'v4m', 'v4n', 'v4r', 'v4s', 'v4t', 'v5aru', 'v5b', 'v5g',\n  'v5k', 'v5k-s', 'v5m', 'v5n', 'v5r', 'v5r-i', 'v5s', 'v5t', 'v5u', 'v5u-s',\n  'v5uru', 'vi', 'vk', 'vn', 'vr', 'vs', 'vs-c', 'vs-i', 'vs-s', 'vt', 'vz',\n] as const;\n\nexport function isPartOfSpeech(a: unknown): a is PartOfSpeech {\n  return typeof a === 'string' && allPartsOfSpeech.includes(a as PartOfSpeech);\n}\n\nexport function asPartOfSpeech(a: unknown): PartOfSpeech | undefined {\n  return isPartOfSpeech(a) ? a : undefined;\n}\n\n// Field\n\nexport type FieldType = (typeof allFieldTypes)[number];\n\n// prettier-ignore\nconst allFieldTypes = [\n  'agric', 'anat', 'archeol', 'archit', 'art', 'astron', 'audvid', 'aviat',\n  'baseb', 'biochem', 'biol', 'bot', 'boxing', 'Buddh', 'bus', 'cards', 'chem',\n  'chmyth', 'Christn', 'civeng', 'cloth', 'comp', 'cryst', 'dent', 'ecol',\n  'econ', 'elec', 'electr', 'embryo', 'engr', 'ent', 'figskt', 'film', 'finc',\n  'fish', 'food', 'gardn', 'genet', 'geogr', 'geol', 'geom', 'go', 'golf',\n  'gramm', 'grmyth', 'hanaf', 'horse', 'internet', 'jpmyth', 'kabuki', 'law',\n  'ling', 'logic', 'MA', 'mahj', 'manga', 'math', 'mech', 'med', 'met', 'mil',\n  'min', 'mining', 'motor', 'music', 'noh', 'ornith', 'paleo', 'pathol',\n  'pharm', 'phil', 'photo', 'physics', 'physiol', 'politics', 'print',\n  'prowres', 'psy', 'psyanal', 'psych', 'rail', 'rommyth', 'Shinto', 'shogi',\n  'ski', 'sports', 'stat', 'stockm', 'sumo', 'surg', 'telec', 'tradem', 'tv',\n  'vet', 'vidg', 'zool',\n] as const;\n\nexport function isFieldType(a: unknown): a is FieldType {\n  return typeof a === 'string' && allFieldTypes.includes(a as FieldType);\n}\n\nexport function asFieldType(a: unknown): FieldType | undefined {\n  return isFieldType(a) ? a : undefined;\n}\n\n// Misc types. A few of these are not used (e.g. male-sl, uK) but they have\n// entity definitions in the upstream XML file so we include them here.\n\nexport type MiscType = (typeof allMiscTypes)[number];\n\n// prettier-ignore\nconst allMiscTypes = [\n  'abbr', 'aphorism', 'arch', 'char', 'chn', 'col', 'company', 'creat', 'dated',\n  'dei', 'derog', 'doc', 'ev', 'euph', 'fam', 'fem', 'fict', 'form', 'given',\n  'group', 'hist', 'hon', 'hum', 'id', 'joc', 'leg', 'm-sl', 'male', 'myth',\n  'net-sl', 'obj', 'obs', 'obsc', 'on-mim', 'organization', 'oth', 'person',\n  'place', 'poet', 'pol', 'product', 'proverb', 'quote', 'rare', 'relig',\n  'sens', 'serv', 'ship', 'sl', 'station', 'surname', 'uk', 'unclass', 'vulg',\n  'work', 'X', 'yoji',\n] as const;\n\nexport function isMiscType(a: unknown): a is MiscType {\n  return typeof a === 'string' && allMiscTypes.includes(a as MiscType);\n}\n\nexport function asMiscType(a: unknown): MiscType | undefined {\n  return isMiscType(a) ? a : undefined;\n}\n\n// Dialects\n\nexport type Dialect = (typeof allDialects)[number];\n\nconst allDialects = [\n  'bra', // Brazilian\n  'ho', // Hokkaido\n  'tsug', // Tsugaru\n  'th', // Tohoku\n  'na', // Nagano\n  'kt', // Kanto\n  'ks', // Kansai\n  'ky', // Kyoto\n  'os', // Osaka\n  'ts', // Tosa\n  '9s', // Kyushu\n  'ok', // Ryuukyuu\n] as const;\n\nexport function isDialect(a: unknown): a is Dialect {\n  return typeof a === 'string' && allDialects.includes(a as Dialect);\n}\n\nexport function asDialect(a: unknown): Dialect | undefined {\n  return isDialect(a) ? a : undefined;\n}\n","import type { ExtendedKanaEntry, WordResult } from './result-types';\n\n// As with Array.prototype.sort, sorts `results` in-place, but returns the\n// result to support chaining.\nexport function sortWordResults(\n  results: Array<WordResult>,\n  { searchLength }: { searchLength?: number } = {}\n): Array<WordResult> {\n  const sortMeta: Map<\n    number,\n    { excessChars: number | undefined; priority: number; type: number }\n  > = new Map();\n\n  for (const result of results) {\n    // Calculate the number of excess characters in the matching headword\n    const matchingHeadword =\n      result.k.find((k) => k.matchRange) || result.r.find((r) => r.matchRange);\n    const excessChars =\n      searchLength && matchingHeadword\n        ? matchingHeadword.ent.length - searchLength\n        : undefined;\n\n    // Determine the headword match type\n    //\n    // 1 = match on a kanji, or kana which is not just the reading for a kanji\n    // 2 = match on a kana reading for a kanji\n    //\n    // TODO: Don't bother doing this unless the input is all kana\n    const kanaReading = result.r.find((r) => !!r.matchRange);\n    const rt = kanaReading ? getKanaHeadwordType(kanaReading, result) : 1;\n\n    // Priority\n    const priority = getPriority(result);\n\n    sortMeta.set(result.id, { excessChars, priority, type: rt });\n  }\n\n  results.sort((a, b) => {\n    const metaA = sortMeta.get(a.id)!;\n    const metaB = sortMeta.get(b.id)!;\n\n    if (\n      metaA.excessChars !== undefined &&\n      metaB.excessChars !== undefined &&\n      metaA.excessChars !== metaB.excessChars\n    ) {\n      return metaA.excessChars - metaB.excessChars;\n    }\n\n    if (metaA.type !== metaB.type) {\n      return metaA.type - metaB.type;\n    }\n\n    return metaB.priority - metaA.priority;\n  });\n\n  return results;\n}\n\nfunction getKanaHeadwordType(r: ExtendedKanaEntry, result: WordResult): 1 | 2 {\n  // We don't want to prioritize readings marked as `ok` etc. or else we'll end\n  // up prioritizing words like `檜` and `羆` being prioritized when searching\n  // for `ひ`.\n  const isReadingObscure =\n    r.i?.includes('ok') ||\n    r.i?.includes('rk') ||\n    r.i?.includes('sk') ||\n    r.i?.includes('ik');\n\n  if (isReadingObscure) {\n    return 2;\n  }\n\n  // Kana headwords are type 1 (i.e. they are a primary headword, not just a\n  // reading for a kanji headword) if:\n  //\n  // (a) the entry has no kanji headwords or all the kanji headwords are marked\n  //     as `rK`, `sK`, or `iK`.\n  if (\n    !result.k.length ||\n    result.k.every(\n      (k) => k.i?.includes('rK') || k.i?.includes('sK') || k.i?.includes('iK')\n    )\n  ) {\n    return 1;\n  }\n\n  // (b) most of the English senses for the entry have a `uk` (usually kana)\n  //     `misc` field and the reading is not marked as `ok` (old kana usage).\n  //\n  // We wanted to make the condition here be just one sense being marked as `uk`\n  // but then you get words like `梓` being prioritized when searching for `し`\n  // because of one sense out of many being usually kana.\n  //\n  // Furthermore, we don't want to require _all_ senses to be marked as `uk` or\n  // else that will mean that 成る fails to be prioritized when searching for\n  // `なる` because one sense out of 11 is not marked as `uk`.\n  if (mostMatchedEnSensesAreUk(result.s)) {\n    return 1;\n  }\n\n  // (c) the headword is marked as `nokanji`\n  return r.app === 0 ? 1 : 2;\n}\n\nfunction mostMatchedEnSensesAreUk(senses: WordResult['s']): boolean {\n  const matchedEnSenses = senses.filter(\n    (s) => s.match && (s.lang === undefined || s.lang === 'en')\n  );\n  if (matchedEnSenses.length === 0) {\n    return false;\n  }\n\n  const ukEnSenseCount = matchedEnSenses.filter((s) =>\n    s.misc?.includes('uk')\n  ).length;\n  return ukEnSenseCount >= matchedEnSenses.length / 2;\n}\n\nexport function getPriority(result: WordResult): number {\n  // Go through each _matching_ kanji / reading and look for priority\n  // information and return the highest score.\n  const scores: Array<number> = [0];\n  const isHeadwordSearch =\n    result.k.some((k) => !!k.matchRange) ||\n    result.r.some((r) => !!r.matchRange);\n\n  // Scores from kanji readings\n  for (const k of result.k) {\n    if ((isHeadwordSearch ? !k.matchRange : !k.match) || !k.p) {\n      continue;\n    }\n\n    scores.push(getPrioritySum(k.p));\n  }\n\n  // Scores from kana readings\n  for (const r of result.r) {\n    if ((isHeadwordSearch ? !r.matchRange : !r.match) || !r.p) {\n      continue;\n    }\n\n    scores.push(getPrioritySum(r.p));\n  }\n\n  // Return top score\n  return Math.max(...scores);\n}\n\n// Produce an overall priority from a series of priority strings.\n//\n// This should produce a value somewhere in the range 0~67.\n//\n// In general we report the highest priority, but if we have several priority\n// scores we add a decreasing fraction (10%) of the lesser scores as an\n// indication that several sources have attested to the priority.\n//\n// That should typically produce a maximum attainable score of 66.8.\n// Having a bounded range like this makes it easier to combine this value with\n// other metrics when sorting.\nfunction getPrioritySum(priorities: Array<string>): number {\n  const scores = priorities.map(getPriorityScore).sort().reverse();\n  return scores.length\n    ? scores[0] +\n        scores\n          .slice(1)\n          .reduce(\n            (total, score, index) => total + score / Math.pow(10, index + 1),\n            0\n          )\n    : 0;\n}\n\n// This assignment is pretty arbitrary however it's mostly used for sorting\n// entries where all we need to do is distinguish between the really common ones\n// and the obscure academic ones.\n//\n// Entries with (P) are those ones that are marked with (P) in Edict.\nconst PRIORITY_ASSIGNMENTS: Map<string, number> = new Map([\n  ['i1', 50], // Top 10,000 words minus i2 (from 1998) (P)\n  ['i2', 20],\n  ['n1', 40], // Top 12,000 words in newspapers (from 2003?) (P)\n  ['n2', 20], // Next 12,000\n  ['s1', 32], // \"Speculative\" annotations? Seem pretty common to me. (P)\n  ['s2', 20], // (P)\n  ['g1', 30], // (P)\n  ['g2', 15],\n]);\n\nexport function getPriorityScore(p: string): number {\n  if (PRIORITY_ASSIGNMENTS.has(p)) {\n    return PRIORITY_ASSIGNMENTS.get(p)!;\n  }\n\n  if (p.startsWith('nf')) {\n    // The wordfreq scores are groups of 500 words.\n    // e.g. nf01 is the top 500 words, and nf48 is the 23,501 ~ 24,000\n    // most popular words.\n    const wordfreq = parseInt(p.substring(2), 10);\n    if (wordfreq > 0 && wordfreq < 48) {\n      return 48 - wordfreq / 2;\n    }\n  }\n\n  return 0;\n}\n","// This is in part:\n//\n// - Missing typings for requestIdleCallback\n// - Polyfill for browsers that don't support requestIdleCallback\n// - Polyfill for non-Window contexts (e.g. workers)\n\ninterface IdleDeadline {\n  timeRemaining: () => number;\n  readonly didTimeout: boolean;\n}\n\ninterface IdleRequestOptions {\n  timeout: number;\n}\n\ntype IdleCallbackHandle = number;\n\ntype IdleRequestCallback = (deadline: IdleDeadline) => void;\n\nexport let requestIdleCallback: (\n  callback: IdleRequestCallback,\n  options?: IdleRequestOptions\n) => IdleCallbackHandle;\nexport let cancelIdleCallback: (handle: IdleCallbackHandle) => void;\n\nif (\n  typeof self === 'object' &&\n  typeof self.requestIdleCallback === 'function' &&\n  typeof self.cancelIdleCallback === 'function'\n) {\n  requestIdleCallback = (self as any).requestIdleCallback;\n  cancelIdleCallback = (self as any).cancelIdleCallback;\n} else {\n  requestIdleCallback = (\n    callback: IdleRequestCallback,\n    options?: IdleRequestOptions\n  ): IdleCallbackHandle => {\n    // Use half the specified timeout since it probably represents a worst-case\n    // scenario.\n    const timeout = options ? options.timeout / 2 : 0;\n    return self.setTimeout(() => {\n      callback({ timeRemaining: () => 0, didTimeout: true });\n    }, timeout);\n  };\n\n  cancelIdleCallback = (handle: IdleCallbackHandle) => {\n    clearTimeout(handle);\n  };\n}\n","import { DataSeries } from './data-series';\nimport { JpdictIdb } from './database';\nimport { uuid } from './uuid';\n\nconst dbToUuid: Map<JpdictIdb, string> = new Map();\n\nexport function getUpdateKey(obj: JpdictIdb, series: DataSeries): string {\n  if (!dbToUuid.has(obj)) {\n    dbToUuid.set(obj, uuid());\n  }\n  const baseId = dbToUuid.get(obj);\n\n  return `${baseId}-${series}`;\n}\n","import { DataSeries, MajorDataSeries } from './data-series';\nimport { ChangeCallback, ChangeTopic, JpdictIdb } from './database';\nimport { DownloadError } from './download-error';\nimport { OfflineError } from './offline-error';\nimport {\n  cancelIdleCallback,\n  requestIdleCallback,\n} from './request-idle-callback';\nimport { getUpdateKey } from './update-key';\nimport { UpdatingUpdateState } from './update-state';\n\nexport type UpdateCompleteCallback = () => void;\nexport type UpdateErrorCallback = (params: {\n  error: Error;\n  nextRetry?: Date;\n  retryCount?: number;\n}) => void;\n\n// We allow passing in a custom setTimeout implementation so that unit tests\n// can mock it, because overriding the global definition interferes with\n// playwright, and sinon can't mock ES6 dependencies:\n//\n// https://github.com/hugomrdias/playwright-test/issues/426\n// https://github.com/microsoft/playwright/issues/9123\n// https://github.com/sinonjs/sinon/issues/1711\ntype SetTimeoutFn = (cb: () => void, duration: number) => number;\n\n// Updates the passed-in database and retries in the case of failure due to\n// network failures or being offline.\n//\n// Note that if there is an existing call to this function in motion\n// (including waiting to retry) the existing call will be re-used.\n// As a result, if the passed-in callback functions differ between invocations,\n// only the originally passed-in callback functions will be called.\n//\n// (This is fixable but it introduces complexity and currently all clients\n// have a single point where they call into this so it is not necessary to try\n// and store a list of callback functions.)\n//\n// If the `updateNow` parameter is set then an existing call to this function\n// will be canceled first UNLESS it is already running or blocked due to being\n// offline. That is, the `updateNow` flag is meant to say, \"Update now if you\n// are not already.\"\n//\n// Furthermore, note that if an invocation is canceled there is no abort\n// callback or AbortError or anything of the sort. (Again, this is fixable but\n// it requires us to store the callbacks passed-in, and currently no client\n// needs this.)\nexport function updateWithRetry({\n  db,\n  lang,\n  series,\n  onUpdateComplete,\n  onUpdateError,\n  setTimeout = self.setTimeout,\n  updateNow = false,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n  setTimeout?: SetTimeoutFn;\n  onUpdateComplete?: UpdateCompleteCallback;\n  onUpdateError?: UpdateErrorCallback;\n  updateNow?: boolean;\n}) {\n  startUpdate({\n    db,\n    lang,\n    series,\n    setTimeout,\n    onUpdateComplete,\n    onUpdateError,\n    updateNow,\n  });\n}\n\nfunction runUpdate({\n  db,\n  lang,\n  series,\n  setTimeout,\n  onUpdateComplete,\n  onUpdateError,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n  setTimeout: SetTimeoutFn;\n  onUpdateComplete?: UpdateCompleteCallback;\n  onUpdateError?: UpdateErrorCallback;\n}) {\n  // If we are offline, wait until we are online.\n  if (!navigator.onLine) {\n    const onlineCallback = async () => {\n      runUpdate({\n        db,\n        lang,\n        series,\n        setTimeout,\n        onUpdateComplete,\n        onUpdateError,\n      });\n    };\n\n    addEventListener('online', onlineCallback, { once: true });\n    goOffline({ db, series, lang, onlineCallback });\n    onUpdateError?.({ error: new OfflineError() });\n    return;\n  }\n\n  // Transition to updating state.\n  beginUpdating({ db, series, lang });\n\n  // Actually run the update and handle any errors\n  void (async () => {\n    try {\n      await db.update({ series, lang });\n\n      resetUpdate({ db, series });\n\n      if (db.isVerbose) {\n        console.log('Successfully completed update.');\n      }\n\n      onUpdateComplete?.();\n    } catch (e) {\n      if (db.isVerbose) {\n        console.error('Got error while updating', e);\n      }\n\n      let retryCount: number | undefined;\n      let nextRetry: Date | undefined;\n      let suppressError = false;\n\n      // Retry network errors at decreasing intervals\n      const isNetworkError = e instanceof DownloadError;\n      if (isNetworkError) {\n        const scheduleResult = maybeScheduleRetry({\n          db,\n          lang,\n          series,\n          setTimeout,\n          onUpdateComplete,\n          onUpdateError,\n        });\n        if (scheduleResult) {\n          ({ nextRetry, retryCount } = scheduleResult);\n        }\n      } else if (e && e instanceof Error && e.name === 'ConstraintError') {\n        const scheduleResult = maybeScheduleIdleRetry({\n          db,\n          lang,\n          series,\n          setTimeout,\n          onUpdateComplete,\n          onUpdateError,\n        });\n        if (scheduleResult) {\n          ({ retryCount } = scheduleResult);\n        }\n\n        suppressError = !!scheduleResult;\n      } else {\n        resetUpdate({ db, series });\n      }\n\n      if (!suppressError && onUpdateError) {\n        const error = e instanceof Error ? e : new Error(String(e));\n        onUpdateError({ error, nextRetry, retryCount });\n      }\n    }\n  })();\n}\n\nfunction onDatabaseChange({\n  db,\n  series,\n  topic,\n}: {\n  db: JpdictIdb;\n  series: MajorDataSeries;\n  topic: ChangeTopic;\n}) {\n  // If the database was deleted, cancel any scheduled retries.\n  if (topic === 'deleted') {\n    resetUpdate({ db, series });\n    return;\n  }\n\n  // topic === 'stateupdated'\n  //\n  // If we successfully downloaded *something*, reset the retry interval.\n  //\n  // We should only do this when we have a retry interval set since we DON'T\n  // want to reset the retry count if we are retrying due to a database error.\n  const seriesHasProgress = (series: DataSeries) =>\n    db[series].updateState.type === 'updating' &&\n    (db[series].updateState as UpdatingUpdateState).fileProgress > 0;\n  const downloadedSomething =\n    series === 'kanji'\n      ? seriesHasProgress('kanji') || seriesHasProgress('radicals')\n      : seriesHasProgress(series);\n\n  if (downloadedSomething) {\n    clearRetryInterval({ db, series });\n  }\n}\n\nexport function cancelUpdateWithRetry({\n  db,\n  series,\n}: {\n  db: JpdictIdb;\n  series: MajorDataSeries;\n}) {\n  resetUpdate({ db, series });\n}\n\n// ---------------------------------------------------------------------------\n//\n// State management\n//\n// ---------------------------------------------------------------------------\n\ntype RetryState =\n  | {\n      type: 'offline';\n      lang: string;\n      changeCallback: ChangeCallback;\n      onlineCallback: () => any;\n    }\n  | {\n      type: 'updating';\n      lang: string;\n      changeCallback: ChangeCallback;\n      retryIntervalMs?: number;\n      retryCount?: number;\n    }\n  | {\n      type: 'waiting-for-timeout';\n      lang: string;\n      changeCallback: ChangeCallback;\n      setTimeoutHandle: number;\n      retryIntervalMs: number;\n      retryCount: number;\n    }\n  | {\n      type: 'waiting-for-idle';\n      lang: string;\n      changeCallback: ChangeCallback;\n      requestIdleCallbackHandle: number;\n      retryCount: number;\n    };\n\nconst inProgressUpdates: Map<string, RetryState> = new Map();\n\n// ---------------------------------------------------------------------------\n//\n// State transitions\n//\n// ---------------------------------------------------------------------------\n\nfunction startUpdate({\n  db,\n  lang,\n  series,\n  setTimeout,\n  onUpdateComplete,\n  onUpdateError,\n  updateNow,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n  setTimeout: SetTimeoutFn;\n  onUpdateComplete?: UpdateCompleteCallback;\n  onUpdateError?: UpdateErrorCallback;\n  updateNow: boolean;\n}) {\n  // Check if we have an in-progress update.\n  const updateKey = getUpdateKey(db, series);\n  let retryState = inProgressUpdates.get(updateKey);\n\n  // If the languages differ, we should cancel the existing update.\n  if (retryState && retryState.lang !== lang) {\n    if (db.isVerbose) {\n      console.info(\n        'Canceling existing call to updateWithRetry because the requested language has changed.'\n      );\n    }\n    resetUpdate({ db, series });\n  }\n\n  // Re-fetch the retry status since we may have canceled it.\n  retryState = inProgressUpdates.get(updateKey);\n  if (retryState) {\n    // If we are not trying to force an update then use the existing in-progress\n    // update.\n    if (!updateNow) {\n      if (db.isVerbose) {\n        console.info(\n          'Overlapping calls to updateWithRetry. Re-using existing invocation. This could be problematic if different callback functions were passed on each invocation.'\n        );\n      }\n      return;\n    }\n\n    // If we're offline, then we're not even going to try updating until we\n    // are online (at which point we will retry immediately).\n    if (retryState.type === 'offline') {\n      if (db.isVerbose) {\n        console.info('Deferring forced update. Currently offline.');\n      }\n      return;\n    }\n\n    // Even if we are trying to force the update, if we just started an update\n    // (or are retrying rapidly) then use the existing update.\n    if (retryState.type === 'updating') {\n      if (db.isVerbose) {\n        console.info('Skipping forced update. Already updating presently.');\n      }\n      return;\n    }\n\n    // Otherwise, cancel the in-progress update.\n    if (db.isVerbose) {\n      console.log('Canceling existing queued retry.');\n    }\n    resetUpdate({ db, series });\n  }\n\n  // If we _still_ have an in-progress update here, it means we got an\n  // overlapping call to this method while we were waiting to cancel the\n  // previous in-progress update.\n  retryState = inProgressUpdates.get(updateKey);\n  if (retryState) {\n    if (db.isVerbose) {\n      console.log('Skipping overlapping auto-retry request.');\n    }\n    return;\n  }\n\n  runUpdate({ db, lang, series, setTimeout, onUpdateComplete, onUpdateError });\n}\n\nfunction resetUpdate({\n  db,\n  series,\n}: {\n  db: JpdictIdb;\n  series: MajorDataSeries;\n}) {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n  if (!retryState) {\n    return;\n  }\n\n  switch (retryState.type) {\n    case 'offline':\n      removeEventListener('online', retryState.onlineCallback);\n      break;\n\n    case 'waiting-for-timeout':\n      clearTimeout(retryState.setTimeoutHandle);\n      break;\n\n    case 'waiting-for-idle':\n      cancelIdleCallback(retryState.requestIdleCallbackHandle);\n      break;\n  }\n\n  db.removeChangeListener(retryState.changeCallback);\n  inProgressUpdates.delete(updateKey);\n\n  db.cancelUpdate(series);\n}\n\nfunction goOffline({\n  db,\n  lang,\n  onlineCallback,\n  series,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  onlineCallback: () => any;\n  series: MajorDataSeries;\n}) {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n  if (retryState) {\n    resetUpdate({ db, series });\n  }\n\n  inProgressUpdates.set(updateKey, {\n    type: 'offline',\n    lang,\n    onlineCallback,\n    changeCallback: getOrRegisterChangeCallback({ db, series }),\n  });\n}\n\nfunction beginUpdating({\n  db,\n  lang,\n  series,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n}) {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n\n  inProgressUpdates.set(updateKey, {\n    type: 'updating',\n    lang,\n    changeCallback: getOrRegisterChangeCallback({ db, series }),\n    retryCount: getRetryCount(retryState),\n    retryIntervalMs: getRetryIntervalMs(retryState),\n  });\n}\n\nfunction maybeScheduleRetry({\n  db,\n  lang,\n  series,\n  setTimeout,\n  onUpdateComplete,\n  onUpdateError,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n  setTimeout: SetTimeoutFn;\n  onUpdateComplete?: UpdateCompleteCallback;\n  onUpdateError?: UpdateErrorCallback;\n}): { retryCount: number; nextRetry: Date } | undefined {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n\n  // If we are not updating to begin with, don't schedule a retry since it\n  // probably means we were canceled.\n  if (retryState?.type !== 'updating') {\n    return undefined;\n  }\n\n  let retryIntervalMs = retryState.retryIntervalMs;\n  if (retryIntervalMs) {\n    // Don't let the interval become longer than 12 hours\n    retryIntervalMs = Math.min(retryIntervalMs * 2, 12 * 60 * 60 * 1000);\n  } else {\n    // Randomize the initial interval to somewhere between 3s ~ 6s.\n    retryIntervalMs = 3000 + Math.random() * 3000;\n  }\n\n  let retryCount = retryState.retryCount;\n  retryCount = typeof retryCount === 'number' ? retryCount + 1 : 0;\n\n  if (db.isVerbose) {\n    console.log(`Scheduling retry of update in ${retryIntervalMs}ms`);\n  }\n\n  const setTimeoutHandle = setTimeout(() => {\n    if (db.isVerbose) {\n      console.log('Running automatic retry of update...');\n    }\n\n    runUpdate({\n      db,\n      lang,\n      series,\n      setTimeout,\n      onUpdateComplete,\n      onUpdateError,\n    });\n  }, retryIntervalMs) as unknown as number;\n\n  const nextRetry = new Date(Date.now() + retryIntervalMs);\n\n  inProgressUpdates.set(updateKey, {\n    type: 'waiting-for-timeout',\n    lang,\n    changeCallback: getOrRegisterChangeCallback({ db, series }),\n    retryCount,\n    retryIntervalMs,\n    setTimeoutHandle,\n  });\n\n  return { nextRetry, retryCount };\n}\n\nfunction clearRetryInterval({\n  db,\n  series,\n}: {\n  db: JpdictIdb;\n  series: MajorDataSeries;\n}) {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n\n  // The check here for `retryIntervalMs` being set ensures we don't clear the\n  // interval when we call this as a result of an idle callback running.\n  if (retryState?.type !== 'updating' || !retryState.retryIntervalMs) {\n    return;\n  }\n\n  inProgressUpdates.set(updateKey, {\n    ...retryState,\n    retryIntervalMs: undefined,\n    retryCount: undefined,\n  });\n}\n\nfunction maybeScheduleIdleRetry({\n  db,\n  lang,\n  series,\n  setTimeout,\n  onUpdateComplete,\n  onUpdateError,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n  setTimeout: SetTimeoutFn;\n  onUpdateComplete?: UpdateCompleteCallback;\n  onUpdateError?: UpdateErrorCallback;\n}): { retryCount: number } | undefined {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n\n  // If we are not updating to begin with, don't schedule a retry since it\n  // probably means we were canceled.\n  if (retryState?.type !== 'updating') {\n    return undefined;\n  }\n\n  // We only want to do this kind of rapid retry a few times (it's for database\n  // errors).\n  let retryCount = retryState.retryCount;\n  if (retryCount && retryCount >= 2) {\n    return undefined;\n  }\n\n  retryCount = typeof retryCount === 'number' ? retryCount + 1 : 0;\n\n  if (db.isVerbose) {\n    console.log('Retrying update momentarily');\n  }\n\n  const requestIdleCallbackHandle = requestIdleCallback(\n    () => {\n      if (db.isVerbose) {\n        console.log('Running automatic retry of update...');\n      }\n\n      runUpdate({\n        db,\n        lang,\n        series,\n        setTimeout,\n        onUpdateComplete,\n        onUpdateError,\n      });\n    },\n    { timeout: 2000 }\n  );\n\n  inProgressUpdates.set(updateKey, {\n    type: 'waiting-for-idle',\n    lang,\n    changeCallback: getOrRegisterChangeCallback({ db, series }),\n    requestIdleCallbackHandle,\n    retryCount,\n  });\n\n  return { retryCount };\n}\n\n// ----------------------------------------------------------------------------\n//\n// State helpers\n//\n// ----------------------------------------------------------------------------\n\nfunction getOrRegisterChangeCallback({\n  db,\n  series,\n}: {\n  db: JpdictIdb;\n  series: MajorDataSeries;\n}): ChangeCallback {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n  if (retryState) {\n    return retryState.changeCallback;\n  }\n\n  const changeCallback = (topic: ChangeTopic) =>\n    onDatabaseChange({ db, series, topic });\n  db.addChangeListener(changeCallback);\n\n  return changeCallback;\n}\n\nfunction getRetryCount(retryState: RetryState | undefined): number | undefined {\n  return retryState?.type !== 'offline' ? retryState?.retryCount : undefined;\n}\n\nfunction getRetryIntervalMs(\n  retryState: RetryState | undefined\n): number | undefined {\n  return retryState?.type === 'waiting-for-timeout' ||\n    retryState?.type === 'updating'\n    ? retryState?.retryIntervalMs\n    : undefined;\n}\n","const proverbTag = 'proverb';\n\nconst verbTags = [\n  'v1', // Ichidan verb\n  'v1-s', // Ichidan verb - kureru special class\n  'v2a-s', // Nidan verb with 'u' ending (archaic)\n  'v4h', // Yodan verb with `hu/fu' ending (archaic)\n  'v4r', // Yodan verb with `ru' ending (archaic)\n  'v5aru', // Godan verb - -aru special class\n  'v5b', // Godan verb with `bu' ending\n  'v5g', // Godan verb with `gu' ending\n  'v5k', // Godan verb with `ku' ending\n  'v5k-s', // Godan verb - Iku/Yuku special class\n  'v5m', // Godan verb with `mu' ending\n  'v5n', // Godan verb with `nu' ending\n  'v5r', // Godan verb with `ru' ending\n  'v5r-i', // Godan verb with `ru' ending (irregular verb)\n  'v5s', // Godan verb with `su' ending\n  'v5t', // Godan verb with `tsu' ending\n  'v5u', // Godan verb with `u' ending\n  'v5u-s', // Godan verb with `u' ending (special class)\n  'v5uru', // Godan verb - Uru old class verb (old form of Eru)\n  'vz', // Ichidan verb - zuru verb (alternative form of -jiru verbs)\n  'vi', // intransitive verb\n  'vk', // Kuru verb - special class\n  'vn', // irregular nu verb\n  'vr', // irregular ru verb, plain form ends with -ri\n  'vs', // noun or participle which takes the aux. verb suru\n  'vs-c', // su verb - precursor to the modern suru\n  'vs-s', // suru verb - special class\n  'vs-i', // suru verb - irregular\n  'vt', // transitive verb\n  'v-unspec', // verb unspecified\n  'v4k', // Yodan verb with `ku' ending (archaic)\n  'v4g', // Yodan verb with `gu' ending (archaic)\n  'v4s', // Yodan verb with `su' ending (archaic)\n  'v4t', // Yodan verb with `tsu' ending (archaic)\n  'v4n', // Yodan verb with `nu' ending (archaic)\n  'v4b', // Yodan verb with `bu' ending (archaic)\n  'v4m', // Yodan verb with `mu' ending (archaic)\n  'v2k-k', // Nidan verb (upper class) with `ku' ending (archaic)\n  'v2g-k', // Nidan verb (upper class) with `gu' ending (archaic)\n  'v2t-k', // Nidan verb (upper class) with `tsu' ending (archaic)\n  'v2d-k', // Nidan verb (upper class) with `dzu' ending (archaic)\n  'v2h-k', // Nidan verb (upper class) with `hu/fu' ending (archaic)\n  'v2b-k', // Nidan verb (upper class) with `bu' ending (archaic)\n  'v2m-k', // Nidan verb (upper class) with `mu' ending (archaic)\n  'v2y-k', // Nidan verb (upper class) with `yu' ending (archaic)\n  'v2r-k', // Nidan verb (upper class) with `ru' ending (archaic)\n  'v2k-s', // Nidan verb (lower class) with `ku' ending (archaic)\n  'v2g-s', // Nidan verb (lower class) with `gu' ending (archaic)\n  'v2s-s', // Nidan verb (lower class) with `su' ending (archaic)\n  'v2z-s', // Nidan verb (lower class) with `zu' ending (archaic)\n  'v2t-s', // Nidan verb (lower class) with `tsu' ending (archaic)\n  'v2d-s', // Nidan verb (lower class) with `dzu' ending (archaic)\n  'v2n-s', // Nidan verb (lower class) with `nu' ending (archaic)\n  'v2h-s', // Nidan verb (lower class) with `hu/fu' ending (archaic)\n  'v2b-s', // Nidan verb (lower class) with `bu' ending (archaic)\n  'v2m-s', // Nidan verb (lower class) with `mu' ending (archaic)\n  'v2y-s', // Nidan verb (lower class) with `yu' ending (archaic)\n  'v2r-s', // Nidan verb (lower class) with `ru' ending (archaic)\n  'v2w-s', // Nidan verb (lower class) with `u' ending and `we' conjugation (archaic)\n];\n\nfunction getFilteredTags(\n  pos: string[] | undefined,\n  misc: string[] | undefined\n) {\n  if (pos === undefined) {\n    return [];\n  }\n  if (misc === undefined) {\n    return pos;\n  }\n\n  if (misc.includes(proverbTag)) {\n    return pos.filter((tag) => !verbTags.includes(tag));\n  }\n\n  return pos;\n}\n\nexport { getFilteredTags };\n","import {\n  Gloss,\n  KanjiInfo,\n  LangSource,\n  ReadingInfo,\n  groupSenses,\n} from '@birchill/jpdict-idb';\nimport { countMora, moraSubstring } from '@birchill/normal-jp';\nimport browser from 'webextension-polyfill';\n\nimport { Sense, WordResult } from '../../background/search-result';\nimport { PartOfSpeechDisplay } from '../../common/content-config-params';\nimport { highPriorityLabels } from '../../common/priority-labels';\nimport { html } from '../../utils/builder';\nimport { getFilteredTags } from '../../utils/verb-tags';\n\nimport { NamePreview } from '../query';\n\nimport { CopyState } from './copy-state';\nimport { renderStar } from './icons';\nimport { getLangTag } from './lang-tag';\nimport { renderMetadata } from './metadata';\nimport { renderName } from './names';\nimport { getSelectedIndex } from './selected-index';\nimport { containerHasSelectedText } from './selection';\nimport type { ShowPopupOptions, StartCopyCallback } from './show-popup';\n\nexport function renderWordEntries({\n  entries,\n  matchLen,\n  more,\n  namePreview,\n  options,\n  title,\n}: {\n  entries: Array<WordResult>;\n  matchLen: number;\n  more: boolean;\n  namePreview: NamePreview | undefined;\n  options: ShowPopupOptions;\n  title: string | undefined;\n}): HTMLElement {\n  const container = html('div', { class: 'wordlist entry-data' });\n\n  if (title) {\n    container.append(html('div', { class: 'title', lang: 'ja' }, title));\n  }\n\n  // Pre-filter metadata\n  //\n  // If we have word matches longer than shogi metadata we drop the shogi\n  // metadata because the shogi shorthand in particular can turn up false\n  // positives on words like ドクター and ドキュメンテーション.\n  if (options.meta?.type === 'shogi' && matchLen >= options.meta.matchLen) {\n    delete options.meta;\n  }\n\n  if (options.meta) {\n    const metadata = renderMetadata({\n      fxData: options.fxData,\n      preferredUnits: options.preferredUnits,\n      isCombinedResult: true,\n      matchLen,\n      meta: options.meta,\n    });\n    if (metadata) {\n      container.append(metadata);\n    }\n  }\n\n  const numNames = namePreview?.names.length ?? 0;\n  const totalEntries = entries.length + numNames;\n  const selectedIndex = getSelectedIndex(options.copyState, totalEntries);\n\n  if (namePreview) {\n    container.append(\n      renderNamePreview(namePreview, {\n        copyKind: options.copyState.kind,\n        onStartCopy: options.onStartCopy,\n        selectedIndex,\n      })\n    );\n  }\n\n  let lastPointerType = 'touch';\n  let longestMatch = 0;\n\n  for (const [index, entry] of entries.entries()) {\n    // Work out where the fold is so we can make later entries appear in the\n    // scrolled-out-of-view range.\n    const matchLength = Math.max(\n      ...entry.k\n        .filter((k) => k.matchRange)\n        .map((k) => k.matchRange![1] - k.matchRange![0]),\n      ...entry.r\n        .filter((r) => r.matchRange)\n        .map((r) => r.matchRange![1] - r.matchRange![0]),\n      0\n    );\n    if (matchLength < longestMatch) {\n      container.append(html('div', { class: 'fold-point' }));\n      // Prevent adding any more fold points\n      longestMatch = -Infinity;\n    } else if (!longestMatch) {\n      longestMatch = matchLength;\n    }\n\n    const entryDiv = html('div', { class: 'entry' });\n    container.append(entryDiv);\n\n    if (index === selectedIndex - numNames) {\n      entryDiv.classList.add(\n        options.copyState.kind === 'active' ? '-selected' : '-flash'\n      );\n    }\n\n    entryDiv.addEventListener('pointerup', (evt) => {\n      lastPointerType = evt.pointerType;\n    });\n\n    entryDiv.addEventListener('click', (evt) => {\n      if (containerHasSelectedText(container)) {\n        return;\n      }\n\n      // Don't trigger copy mode if we clicked a nested link\n      if (evt.target instanceof HTMLAnchorElement) {\n        return;\n      }\n\n      const trigger = lastPointerType === 'mouse' ? 'mouse' : 'touch';\n      options.onStartCopy?.(index + numNames, trigger);\n    });\n\n    const headingDiv = html('div', {});\n    entryDiv.append(headingDiv);\n\n    const matchedOnKana = entry.r.some((r) => r.matchRange);\n\n    // If we matched on a search-only kanji or kana headword we want to show it\n    // prior to the main entry.\n    const matchedOnlyOnSearchOnlyKanji =\n      !matchedOnKana && entry.k.every((k) => !k.match || k.i?.includes('sK'));\n    const matchedOnlyOnSearchOnlyKana =\n      matchedOnKana && entry.r.every((r) => !r.match || r.i?.includes('sk'));\n    const searchOnlyMatch = matchedOnKana\n      ? matchedOnlyOnSearchOnlyKana\n        ? entry.r.find((r) => !!r.matchRange)?.ent\n        : undefined\n      : matchedOnlyOnSearchOnlyKanji\n        ? entry.k.find((k) => !!k.matchRange)?.ent\n        : undefined;\n\n    if (searchOnlyMatch) {\n      const searchOnlyDiv = html(\n        'div',\n        {\n          class: 'tp-mb-1 tp-text-sm tp-opacity-70',\n        },\n        browser.i18n.getMessage('content_sk_match_src', searchOnlyMatch)\n      );\n      headingDiv.append(searchOnlyDiv);\n    }\n\n    const kanjiHeadwords = entry.k\n      ? entry.k.filter((k) => !k.i?.includes('sK'))\n      : [];\n\n    // If we matched on kana, then any headwords which are _not_ matches should\n    // be hidden since they don't apply to the kana.\n    //\n    // This is because we mostly only show matching kana headwords and so if we\n    // start showing kanji that don't correspond to the kana headwords, the\n    // result will be misleading.\n    //\n    // For example, take the string さいだん. Entry 1385120 has readings\n    // さいだん and せつだん but さいだん is specifically bound to the 截断\n    // kanji.\n    //\n    // As a result if we look up さいだん we'll mark the さいだん kana headword\n    // as a match and the 截断 kanji headword too. As per our usual processing,\n    // we'll only show the さいだん kana headword, however, not せつだん.\n    //\n    // If we were also to show the unmatched 切断 kanji headword we'd end up\n    // displaying:\n    //\n    // 截断、切断  さいだん\n    //\n    // which would be misleading since 切断 can never have that reading.\n    const matchingKanji = matchedOnKana\n      ? kanjiHeadwords.filter((k) => k.match)\n      : kanjiHeadwords;\n\n    // Sort matched kanji entries first\n    matchingKanji.sort((a, b) => Number(b.match) - Number(a.match));\n    if (matchingKanji.length) {\n      const kanjiSpan = html('span', { class: 'w-kanji', lang: 'ja' });\n      for (const [i, kanji] of matchingKanji.entries()) {\n        if (i) {\n          kanjiSpan.append(html('span', { class: 'separator' }, '、'));\n        }\n\n        let headwordSpan = kanjiSpan;\n        const ki = new Set(kanji.i || []);\n        if (\n          // Always dim search-only kanji\n          ki.has('sK') ||\n          // Dim the non-matching kanji unless there are none because we\n          // matched only on search-only kanji headwords.\n          (!kanji.match && !matchedOnlyOnSearchOnlyKanji) ||\n          // If we matched on the reading, dim any kanji headwords that are\n          // irregular, old, or rare.\n          (matchedOnKana && (ki.has('iK') || ki.has('oK') || ki.has('rK')))\n        ) {\n          const dimmedSpan = html('span', { class: 'dimmed' });\n          kanjiSpan.append(dimmedSpan);\n          headwordSpan = dimmedSpan;\n        }\n\n        headwordSpan.append(kanji.ent);\n\n        appendHeadwordInfo(kanji.i, headwordSpan);\n        if (options.showPriority) {\n          appendPriorityMark(kanji.p, headwordSpan);\n        }\n        if (options.waniKaniVocabDisplay !== 'hide' && kanji.wk) {\n          appendWaniKaniLevelTag(kanji.wk, kanji.ent, headwordSpan);\n        }\n        if (options.bunproDisplay && kanji.bv) {\n          appendBunproTag(kanji.bv, 'vocab', headwordSpan);\n        }\n        if (options.bunproDisplay && kanji.bg) {\n          appendBunproTag(kanji.bg, 'grammar', headwordSpan);\n        }\n      }\n      headingDiv.append(kanjiSpan);\n    }\n\n    // Typically we only show the matching kana headwords but if we matched on\n    // an irregular form or a search-only form, we should show the regular kana\n    // headwords too, for reference.\n    //\n    // For example, if we looked up ふんいき (雰囲気) we should only show that\n    // headword, but if we looked up ふいんき, we should show the more correct\n    // ふんいき too.\n    const matchedOnIrregularKana =\n      matchedOnKana &&\n      entry.r.every(\n        (r) =>\n          !r.match ||\n          r.i?.includes('ik') ||\n          r.i?.includes('ok') ||\n          r.i?.includes('rk') ||\n          r.i?.includes('sk')\n      );\n\n    // For search-only kanji, we show them only if they are the ONLY matches.\n    const matchingKana = entry.r.filter(\n      (r) =>\n        !r.i?.includes('sk') &&\n        (r.match ||\n          (matchedOnIrregularKana &&\n            !r.i?.includes('ik') &&\n            !r.i?.includes('ok') &&\n            !r.i?.includes('rk') &&\n            !r.i?.includes('sk')))\n    );\n\n    if (matchingKana.length) {\n      const kanaSpan = html('span', { class: 'w-kana', lang: 'ja' });\n      for (const [i, kana] of matchingKana.entries()) {\n        if (i) {\n          kanaSpan.append(html('span', { class: 'separator' }, '、'));\n        }\n\n        // Dim irrelevant headwords\n        let headwordSpan = kanaSpan;\n        if (\n          // If we looked up by kanji, dim any kana headwords that are\n          // irregular, old, or rare.\n          !matchedOnKana &&\n          (kana.i?.includes('ik') ||\n            kana.i?.includes('ok') ||\n            kana.i?.includes('rk'))\n        ) {\n          const dimmedSpan = html('span', { class: 'dimmed' });\n          kanaSpan.append(dimmedSpan);\n          headwordSpan = dimmedSpan;\n        }\n\n        headwordSpan.append(renderKana(kana, options));\n        appendHeadwordInfo(kana.i, headwordSpan);\n        if (options.showPriority) {\n          appendPriorityMark(kana.p, headwordSpan);\n        }\n        if (options.bunproDisplay && kana.bv) {\n          appendBunproTag(kana.bv, 'vocab', headwordSpan);\n        }\n        if (options.bunproDisplay && kana.bg) {\n          appendBunproTag(kana.bg, 'grammar', headwordSpan);\n        }\n      }\n      headingDiv.append(kanaSpan);\n    }\n\n    if (entry.romaji?.length) {\n      headingDiv.append(\n        html('span', { class: 'w-romaji', lang: 'ja' }, entry.romaji.join(', '))\n      );\n    }\n\n    if (entry.reason) {\n      headingDiv.append(\n        html(\n          'span',\n          { class: 'w-conj', lang: getLangTag() },\n          `(${entry.reason})`\n        )\n      );\n    }\n\n    if (options.showDefinitions) {\n      // If we have hidden all the kanji headwords, then we shouldn't show\n      // \"usually kana\" annotations on definitions.\n      if (!matchingKanji.length) {\n        entry.s = entry.s.map((s) => ({\n          ...s,\n          misc: s.misc?.filter((m) => m !== 'uk'),\n        }));\n      }\n\n      entryDiv.append(renderDefinitions(entry, options));\n    }\n  }\n\n  if (more) {\n    container.append(html('div', { class: 'more' }, '…'));\n  }\n\n  return container;\n}\n\nfunction renderNamePreview(\n  { names, more }: NamePreview,\n  {\n    copyKind,\n    onStartCopy,\n    selectedIndex,\n  }: {\n    copyKind: CopyState['kind'];\n    onStartCopy?: StartCopyCallback;\n    selectedIndex?: number;\n  }\n): HTMLElement {\n  const container = html('div', { class: 'bonus-name' });\n\n  let lastPointerType = 'touch';\n\n  for (const [index, name] of names.entries()) {\n    const nameEntry = renderName(name);\n    if (index === selectedIndex) {\n      nameEntry.classList.add(copyKind === 'active' ? '-selected' : '-flash');\n    }\n\n    nameEntry.addEventListener('pointerup', (evt) => {\n      lastPointerType = evt.pointerType;\n    });\n\n    nameEntry.addEventListener('click', () => {\n      if (containerHasSelectedText(container)) {\n        return;\n      }\n\n      const trigger = lastPointerType === 'mouse' ? 'mouse' : 'touch';\n      onStartCopy?.(index, trigger);\n    });\n\n    container.append(nameEntry);\n  }\n\n  if (more) {\n    container.append(html('span', { class: 'more' }, '…'));\n  }\n\n  return container;\n}\n\nfunction appendHeadwordInfo(\n  info: Array<string> | undefined,\n  parent: ParentNode\n) {\n  if (!info || !info.length) {\n    return;\n  }\n\n  for (const i of info) {\n    const span = html(\n      'span',\n      { class: 'w-head-info', lang: getLangTag() },\n      '('\n    );\n\n    // Some KanjiInfo/RadicalInfo values differ only by case but\n    // addons-linter (as used by webext etc.) does not allow WebExtension i18n\n    // keys to differ by case only.\n    //\n    // I couldn't find the rationale for this, the rule just magically\n    // appears in https://github.com/mozilla/addons-linter/commit/3923b399f8166b59617071730b87048f45122c7e\n    // it seems.\n    const specialKeys: { [k in KanjiInfo | ReadingInfo]?: string } = {\n      iK: 'ikanji',\n      ik: 'ikana',\n      oK: 'okanji',\n      ok: 'okana',\n      rK: 'rkanji',\n      rk: 'rkana',\n      // We normally don't show search-only kanji/kana headwords unless they are\n      // exact matches. In those cases we should probably just indicate them as\n      // \"irregular\" kanji/kana.\n      sK: 'ikanji',\n      sk: 'ikana',\n    };\n    const key = specialKeys.hasOwnProperty(i)\n      ? specialKeys[i as KanjiInfo | ReadingInfo]\n      : i;\n\n    span.append(browser.i18n.getMessage(`head_info_label_${key}`) || i, ')');\n    parent.append(span);\n  }\n}\n\nfunction appendPriorityMark(\n  priority: Array<string> | undefined,\n  parent: ParentNode\n) {\n  if (!priority || !priority.length) {\n    return;\n  }\n\n  // These are the ones that are annotated with a (P) in the EDICT file.\n  const highPriorityLabelsSet = new Set(highPriorityLabels);\n  const highPriority = priority.some((p) => highPriorityLabelsSet.has(p));\n\n  parent.append(renderStar(highPriority ? 'full' : 'hollow'));\n}\n\nfunction appendWaniKaniLevelTag(\n  level: number,\n  ent: string,\n  parent: ParentNode\n) {\n  parent.append(\n    html(\n      'a',\n      {\n        class: 'wk-level',\n        href: `https://wanikani.com/vocabulary/${encodeURIComponent(ent)}`,\n        target: '_blank',\n        rel: 'noreferrer',\n        title: browser.i18n.getMessage('content_wk_link_title', ent),\n      },\n      html('span', {}, String(level))\n    )\n  );\n}\n\nfunction appendBunproTag(\n  data: { l: number; src?: string },\n  type: 'vocab' | 'grammar',\n  parent: ParentNode\n) {\n  const label = browser.i18n.getMessage(\n    type === 'vocab' ? 'popup_bp_vocab_tag' : 'popup_bp_grammar_tag',\n    [String(data.l)]\n  );\n  const outerSpan = html(\n    'span',\n    { class: `bp-tag -${type}` },\n    html('span', {}, label)\n  );\n  if (data.src) {\n    outerSpan.append(html('span', { class: 'bp-src' }, data.src));\n  }\n  parent.append(outerSpan);\n}\n\nfunction renderKana(\n  kana: WordResult['r'][0],\n  options: ShowPopupOptions\n): string | Element {\n  const accents = kana.a;\n  if (\n    options.accentDisplay === 'none' ||\n    typeof accents === 'undefined' ||\n    (Array.isArray(accents) && !accents.length)\n  ) {\n    return kana.ent;\n  }\n\n  const accentPos = typeof accents === 'number' ? accents : accents[0].i;\n\n  if (options.accentDisplay === 'downstep') {\n    if (!accentPos) {\n      // accentPos 0 (heiban) is special since there's no accent to show.\n      //\n      // At the same time we want to distinguish between heiban and\n      // \"no accent information\". So we indicate heiban with a dotted line\n      // across the top instead.\n      return html('span', { class: 'w-heiban' }, kana.ent);\n    } else {\n      return (\n        moraSubstring(kana.ent, 0, accentPos) +\n        'ꜜ' +\n        moraSubstring(kana.ent, accentPos)\n      );\n    }\n  }\n\n  // Generate binary pitch display\n  const wrapperSpan = html('span', { class: 'w-binary' });\n  if (options.accentDisplay === 'binary-hi-contrast') {\n    wrapperSpan.classList.add('-hi-contrast');\n  }\n\n  // Accent position 0 (heiban: LHHHHH) and accent position 1 (atamadaka: HLLLL)\n  // are sufficiently similar that we handle them together.\n  if (accentPos === 0 || accentPos === 1) {\n    const len = countMora(kana.ent);\n    wrapperSpan.append(\n      html(\n        'span',\n        { class: accentPos ? 'h-l' : len > 1 ? 'l-h' : 'h' },\n        moraSubstring(kana.ent, 0, 1)\n      )\n    );\n\n    if (len > 1) {\n      wrapperSpan.append(\n        html(\n          'span',\n          { class: accentPos ? 'l' : 'h' },\n          moraSubstring(kana.ent, 1)\n        )\n      );\n    }\n  } else {\n    // Otherwise we have nakadaka (LHHHHL) or odaka (LHHHH)\n    wrapperSpan.append(\n      html('span', { class: 'l-h' }, moraSubstring(kana.ent, 0, 1))\n    );\n\n    wrapperSpan.append(\n      html('span', { class: 'h-l' }, moraSubstring(kana.ent, 1, accentPos))\n    );\n\n    if (accentPos < countMora(kana.ent)) {\n      wrapperSpan.append(\n        html('span', { class: 'l' }, moraSubstring(kana.ent, accentPos))\n      );\n    }\n  }\n\n  return wrapperSpan;\n}\n\nfunction renderDefinitions(\n  entry: WordResult,\n  options: {\n    dictLang?: string;\n    posDisplay: PartOfSpeechDisplay;\n  }\n) {\n  const senses = entry.s.filter((s) => s.match);\n  if (!senses.length) {\n    return '';\n  }\n\n  const definitionsDiv = html('div', { class: 'w-def' });\n\n  if (senses.length === 1) {\n    definitionsDiv.append(renderSense(senses[0], options));\n    definitionsDiv.lang = senses[0].lang || 'en';\n    if (\n      options.dictLang &&\n      options.dictLang !== 'en' &&\n      senses[0].lang !== options.dictLang\n    ) {\n      definitionsDiv.classList.add('foreign');\n    }\n  } else {\n    // First extract any native language senses\n    const nativeSenses = senses.filter((s) => s.lang && s.lang !== 'en');\n    if (nativeSenses.length) {\n      const definitionList = html('ul', {});\n      for (const sense of nativeSenses) {\n        definitionList.append(\n          html('li', { lang: sense.lang || 'en' }, renderSense(sense, options))\n        );\n      }\n      definitionsDiv.append(definitionList);\n    }\n\n    // Try grouping the remaining (English) definitions by part-of-speech.\n    const enSenses = senses.filter((s) => !s.lang || s.lang === 'en');\n    const posGroups =\n      options.posDisplay !== 'none' ? groupSenses(enSenses) : [];\n    const isForeign = !!options.dictLang && options.dictLang !== 'en';\n\n    // Determine if the grouping makes sense\n    //\n    // If the group headings make the number of lines used to represent\n    // all the senses (ignoring word wrapping) grow by more than 50%, we should\n    // skip using groups. This will typically be the case where there are no\n    // common parts-of-speech, or at least very few.\n    const linesWithGrouping = posGroups.length + enSenses.length;\n    const linesWithoutGrouping = enSenses.length;\n    const useGroups =\n      posGroups.length && linesWithGrouping / linesWithoutGrouping <= 1.5;\n\n    if (useGroups) {\n      let startIndex = 1;\n      for (const group of posGroups) {\n        // Group heading\n        const groupHeading = html('p', { class: 'w-group-head' });\n\n        // Verb class tags were added to proverbs for inflection handling but\n        // aren't user-facing. Filter them out here.\n        const filteredPos = getFilteredTags(group.pos, group.misc);\n\n        for (const pos of filteredPos) {\n          const posSpan = html('span', { class: 'w-pos tag' });\n          if (options.posDisplay === 'expl') {\n            posSpan.lang = getLangTag();\n            posSpan.textContent =\n              browser.i18n.getMessage(`pos_label_${pos.replace(/-/g, '_')}`) ||\n              pos;\n          } else {\n            posSpan.textContent = pos;\n          }\n          groupHeading.append(posSpan);\n        }\n\n        for (const misc of group.misc) {\n          groupHeading.append(\n            html(\n              'span',\n              {\n                class: 'w-misc tag',\n                lang: getLangTag(),\n              },\n              browser.i18n.getMessage(\n                `misc_label_${misc.replace(/-/g, '_')}`\n              ) || misc\n            )\n          );\n        }\n\n        // If there is no group heading, just add a '-' placeholder\n        if (!group.pos.length && !group.misc.length) {\n          groupHeading.append(html('span', { class: 'w-pos tag' }, '-'));\n        }\n\n        definitionsDiv.append(groupHeading);\n\n        // Group items\n        const definitionList = html('ol', { start: String(startIndex) });\n        for (const sense of group.senses) {\n          definitionList.append(\n            html(\n              'li',\n              {\n                class: isForeign ? 'foreign' : undefined,\n                lang: sense.lang || 'en',\n              },\n              renderSense(sense, options)\n            )\n          );\n          startIndex++;\n        }\n        definitionsDiv.append(definitionList);\n      }\n    } else {\n      const definitionList = html('ol', {});\n      for (const sense of enSenses) {\n        definitionList.append(\n          html(\n            'li',\n            { class: isForeign ? 'foreign' : '', lang: sense.lang || 'en' },\n            renderSense(sense, options)\n          )\n        );\n      }\n      definitionsDiv.append(definitionList);\n    }\n  }\n\n  return definitionsDiv;\n}\n\nfunction renderSense(\n  sense: Sense,\n  options: { posDisplay: PartOfSpeechDisplay }\n): DocumentFragment {\n  const fragment = document.createDocumentFragment();\n\n  // Verb class tags were added to proverbs for inflection handling but\n  // aren't user-facing. Filter them out here.\n  const filteredPos = getFilteredTags(sense.pos, sense.misc);\n\n  if (options.posDisplay !== 'none') {\n    for (const pos of filteredPos) {\n      const posSpan = html('span', { class: 'w-pos tag' });\n      switch (options.posDisplay) {\n        case 'expl':\n          posSpan.lang = getLangTag();\n          posSpan.append(\n            browser.i18n.getMessage(`pos_label_${pos.replace(/-/g, '_')}`) ||\n              pos\n          );\n          break;\n\n        case 'code':\n          posSpan.append(pos);\n          break;\n      }\n      fragment.append(posSpan);\n    }\n  }\n\n  if (sense.field) {\n    for (const field of sense.field) {\n      fragment.append(\n        html(\n          'span',\n          { class: 'w-field tag', lang: getLangTag() },\n          browser.i18n.getMessage(`field_label_${field}`) || field\n        )\n      );\n    }\n  }\n\n  if (sense.misc) {\n    for (const misc of sense.misc) {\n      fragment.append(\n        html(\n          'span',\n          { class: 'w-misc tag', lang: getLangTag() },\n          browser.i18n.getMessage(`misc_label_${misc.replace(/-/g, '_')}`) ||\n            misc\n        )\n      );\n    }\n  }\n\n  if (sense.dial) {\n    for (const dial of sense.dial) {\n      fragment.append(\n        html(\n          'span',\n          { class: 'w-dial tag', lang: getLangTag() },\n          browser.i18n.getMessage(`dial_label_${dial}`) || dial\n        )\n      );\n    }\n  }\n\n  appendGlosses(sense.g, fragment);\n\n  if (sense.inf) {\n    fragment.append(\n      html(\n        'span',\n        {\n          class: 'w-inf',\n          // Mark inf as Japanese because it often contains Japanese text\n          lang: 'ja',\n        },\n        ` (${sense.inf})`\n      )\n    );\n  }\n\n  if (sense.lsrc?.length) {\n    fragment.append(renderLangSources(sense.lsrc));\n  }\n\n  return fragment;\n}\n\nfunction appendGlosses(glosses: Array<Gloss>, parent: ParentNode) {\n  for (const [i, gloss] of glosses.entries()) {\n    if (i) {\n      parent.append('; ');\n    }\n\n    if (gloss.type && gloss.type !== 'tm' && gloss.type !== 'none') {\n      const typeStr = browser.i18n.getMessage(`gloss_type_label_${gloss.type}`);\n      if (typeStr) {\n        parent.append(\n          html('span', { class: 'w-type', lang: getLangTag() }, `(${typeStr}) `)\n        );\n      }\n    }\n\n    parent.append(gloss.str);\n    if (gloss.type === 'tm') {\n      parent.append('™');\n    }\n  }\n}\n\nfunction renderLangSources(sources: Array<LangSource>): HTMLElement {\n  const sourceLangSpan = html('span', { class: 'w-lsrc', lang: getLangTag() });\n\n  const startsWithWasei = sources[0]?.wasei;\n  sourceLangSpan.append(\n    browser.i18n.getMessage(\n      startsWithWasei ? 'lang_lsrc_wasei_prefix' : 'lang_lsrc_prefix'\n    )\n  );\n\n  for (const [i, lsrc] of sources.entries()) {\n    if (i) {\n      sourceLangSpan.append(', ');\n    }\n\n    const lang =\n      browser.i18n.getMessage(`lang_label_${lsrc.lang || 'en'}`) ||\n      lsrc.lang ||\n      'English';\n    const prefix = lsrc.wasei\n      ? browser.i18n.getMessage('lang_lsrc_wasei', [lang])\n      : lang;\n\n    sourceLangSpan.append(lsrc.src ? `${prefix}: ` : prefix);\n\n    if (lsrc.src) {\n      sourceLangSpan.append(\n        html('span', { lang: lsrc.lang || 'en' }, lsrc.src)\n      );\n    }\n  }\n\n  sourceLangSpan.append(browser.i18n.getMessage('lang_lsrc_suffix'));\n\n  return sourceLangSpan;\n}\n","/// <reference path=\"../../common/css.d.ts\" />\nimport type { FontFace, FontSize } from '../../common/content-config-params';\nimport { html } from '../../utils/builder';\nimport { Point } from '../../utils/geometry';\nimport { getThemeClass } from '../../utils/themes';\n\nimport { getOrCreateEmptyContainer } from '../content-container';\nimport { DisplayMode } from '../popup-state';\nimport { LookupPuckId } from '../puck';\nimport { QueryResult } from '../query';\n\nimport { renderArrow } from './arrow';\nimport { renderCloseButton } from './close';\nimport { renderCopyOverlay } from './copy-overlay';\nimport { CopyState } from './copy-state';\nimport { updateExpandable } from './expandable';\nimport { addFontStyles, removeFontStyles } from './font-styles';\nimport { renderKanjiEntries } from './kanji';\nimport { renderMetadata } from './metadata';\nimport { renderNamesEntries } from './names';\nimport { getPopupContainer } from './popup-container';\nimport popupStyles from './popup.css?inline';\nimport { ShowPopupOptions } from './show-popup';\nimport { renderCopyDetails, renderUpdatingStatus } from './status';\nimport { onHorizontalSwipe } from './swipe';\nimport { renderTabBar } from './tabs';\nimport { renderWordEntries } from './words';\n\nexport function renderPopup(\n  result: QueryResult | undefined,\n  options: ShowPopupOptions\n): HTMLElement | null {\n  // We add most styles to the shadow DOM but it turns out that browsers don't\n  // load @font-face fonts from the shadow DOM [1], so we need to add @font-face\n  // definitions to the main document.\n  //\n  // [1] e.g see https://issues.chromium.org/issues/41085401\n  if (!options.fontFace || options.fontFace === 'bundled') {\n    addFontStyles();\n  } else {\n    removeFontStyles();\n  }\n\n  const container = options.container || getDefaultContainer();\n  const windowElem = resetContainer({\n    host: container,\n    displayMode: options.displayMode,\n    fontFace: options.fontFace || 'bundled',\n    fontSize: options.fontSize || 'normal',\n    popupStyle: options.popupStyle,\n  });\n  const contentContainer = html('div', { class: 'content' });\n\n  const hasResult = result && (result.words || result.kanji || result.names);\n  const showTabs =\n    hasResult &&\n    result.resultType !== 'db-unavailable' &&\n    !result.title &&\n    options.tabDisplay !== 'none';\n\n  if (showTabs) {\n    const enabledTabs = {\n      words: !!result?.words || !!options.meta,\n      kanji: !!result?.kanji,\n      names: !!result?.names,\n    };\n\n    windowElem.append(\n      renderTabBar({\n        closeShortcuts: options.closeShortcuts,\n        displayMode: options.displayMode,\n        enabledTabs,\n        onClosePopup: options.onClosePopup,\n        onShowSettings: options.onShowSettings,\n        onSwitchDictionary: options.onSwitchDictionary,\n        onTogglePin: options.onTogglePin,\n        pinShortcuts: options.pinShortcuts,\n        selectedTab: options.dictToShow,\n      })\n    );\n\n    windowElem.dataset.tabSide = options.tabDisplay || 'top';\n\n    onHorizontalSwipe(contentContainer, (direction) => {\n      options.onSwitchDictionary?.(direction === 'left' ? 'prev' : 'next');\n    });\n  }\n\n  const resultToShow = result?.[options.dictToShow];\n\n  switch (resultToShow?.type) {\n    case 'kanji':\n      contentContainer.append(\n        html(\n          'div',\n          { class: 'expandable' },\n          renderKanjiEntries({ entries: resultToShow.data, options })\n        )\n      );\n      break;\n\n    case 'names':\n      contentContainer.append(\n        renderNamesEntries({\n          entries: resultToShow.data,\n          matchLen: resultToShow.matchLen,\n          more: resultToShow.more,\n          options: {\n            ...options,\n            // Hide the meta if we have already shown it on the words tab\n            meta: result?.words ? undefined : options.meta,\n          },\n        })\n      );\n      break;\n\n    case 'words':\n      {\n        contentContainer.append(\n          html(\n            'div',\n            { class: 'expandable' },\n            renderWordEntries({\n              entries: resultToShow.data,\n              matchLen: resultToShow.matchLen,\n              more: resultToShow.more,\n              namePreview: result!.namePreview,\n              options,\n              title: result!.title,\n            })\n          )\n        );\n      }\n      break;\n\n    default:\n      {\n        if (!options.meta) {\n          return null;\n        }\n\n        const metadata = renderMetadata({\n          fxData: options.fxData,\n          preferredUnits: options.preferredUnits,\n          isCombinedResult: false,\n          matchLen: 0,\n          meta: options.meta,\n        });\n        if (!metadata) {\n          return null;\n        }\n        metadata.classList.add('-metaonly');\n\n        contentContainer.append(\n          html('div', { class: 'wordlist entry-data' }, metadata)\n        );\n      }\n      break;\n  }\n\n  // Render the copy overlay if needed\n  if (showOverlay(options.copyState)) {\n    contentContainer.append(\n      html(\n        'div',\n        { class: 'grid-stack' },\n        // Dictionary content\n        html('div', {}, ...contentContainer.children),\n        renderCopyOverlay({\n          copyState: options.copyState,\n          includeAllSenses: options.copy?.includeAllSenses !== false,\n          includeLessCommonHeadwords:\n            options.copy?.includeLessCommonHeadwords !== false,\n          includePartOfSpeech: options.copy?.includePartOfSpeech !== false,\n          kanjiReferences: options.kanjiReferences,\n          onCancelCopy: options.onCancelCopy,\n          onCopy: options.onCopy,\n          result: resultToShow ? result : undefined,\n          series: options.dictToShow,\n          showKanjiComponents: options.showKanjiComponents,\n        })\n      )\n    );\n\n    // Set the overlay styles for the window, but wait a moment so we can\n    // transition the styles in.\n    requestAnimationFrame(() => {\n      // TODO: Drop the class and just keep the data attribute once we've\n      // converted everything to Tailwind\n      windowElem.classList.add('-has-overlay');\n      windowElem.dataset.hasOverlay = 'true';\n    });\n  }\n\n  // Set copy styles\n  switch (options.copyState.kind) {\n    case 'active':\n      windowElem.classList.add('-copy-active');\n      break;\n\n    case 'error':\n      windowElem.classList.add('-copy-error');\n      break;\n\n    case 'finished':\n      windowElem.classList.add('-copy-finished');\n      break;\n  }\n\n  // Generate status bar contents\n  const copyDetails = renderCopyDetails({\n    copyNextKey: options.copyNextKey,\n    copyState: options.copyState,\n    series: resultToShow?.type || 'words',\n  });\n\n  let statusBar: HTMLElement | null = null;\n  if (copyDetails) {\n    statusBar = copyDetails;\n  } else if (hasResult && result?.resultType === 'db-updating') {\n    statusBar = renderUpdatingStatus();\n  }\n\n  let contentWrapper = contentContainer;\n  if (statusBar) {\n    contentWrapper = html(\n      'div',\n      { class: 'status-bar-wrapper' },\n      contentContainer,\n      statusBar\n    );\n  }\n\n  if (!showTabs && options.onClosePopup) {\n    windowElem.append(\n      html(\n        'div',\n        { class: 'close-button-wrapper' },\n        contentWrapper,\n        renderCloseButton(options.onClosePopup, options.closeShortcuts || [])\n      )\n    );\n  } else {\n    windowElem.append(contentWrapper);\n  }\n\n  // Collapse expandable containers\n  for (const expandable of contentContainer.querySelectorAll<HTMLElement>(\n    '.expandable'\n  )) {\n    updateExpandable(expandable, {\n      ...options,\n      showKeyboardShortcut: options.displayMode === 'static',\n    });\n  }\n\n  // Scroll any selected items into view.\n  //\n  // We need to wait until after the popup has been positioned, however, as\n  // otherwise we won't know if it's in view or not.\n  requestAnimationFrame(() => {\n    const selectedElem =\n      contentContainer.querySelector('.expandable .-selected') ||\n      contentContainer.querySelector('.-flash');\n    selectedElem?.scrollIntoView({ block: 'nearest' });\n  });\n\n  return container;\n}\n\nfunction getDefaultContainer(): HTMLElement {\n  const defaultContainer = getOrCreateEmptyContainer({\n    id: 'tenten-ja-window',\n    styles: popupStyles.toString(),\n    // Make sure the popup container appears _before_ the puck container so that\n    // we can assign them the same z-index and have the puck appear on top.\n    before: LookupPuckId,\n    legacyIds: ['rikaichamp-window'],\n  });\n\n  // Make sure our popup doesn't get inverted by Wikipedia's (experimental) dark\n  // mode.\n  if (document.location.hostname.endsWith('wikipedia.org')) {\n    defaultContainer.classList.add('mw-no-invert');\n    defaultContainer.style.filter = 'inherit';\n  }\n\n  return defaultContainer;\n}\n\nfunction resetContainer({\n  host,\n  displayMode,\n  fontFace,\n  fontSize,\n  popupStyle,\n}: {\n  host: HTMLElement;\n  displayMode: DisplayMode;\n  fontFace: FontFace;\n  fontSize: FontSize;\n  popupStyle: string;\n}): HTMLElement {\n  const container = html('div', { class: 'container' });\n  const windowDiv = html('div', {\n    class: 'window',\n    'data-type': 'window',\n  });\n  container.append(windowDiv);\n\n  // Set initial and interactive status\n  container.classList.toggle('ghost', displayMode === 'ghost');\n  container.classList.toggle('interactive', displayMode !== 'static');\n  container.classList.toggle('pinned', displayMode === 'pinned');\n\n  // Set theme\n  windowDiv.classList.add(getThemeClass(popupStyle));\n\n  // Font face\n  if (fontFace === 'bundled') {\n    windowDiv.classList.add('bundled-fonts');\n  }\n\n  // Font size\n  if (fontSize !== 'normal') {\n    windowDiv.classList.add(`font-${fontSize}`);\n  }\n\n  if (host.shadowRoot) {\n    host.shadowRoot.append(container);\n  } else {\n    host.append(container);\n  }\n\n  // Reset the container position and size so that we can consistently measure\n  // the size of the popup.\n  host.style.removeProperty('--left');\n  host.style.removeProperty('--top');\n  host.style.removeProperty('--max-width');\n  host.style.removeProperty('--max-height');\n\n  return windowDiv;\n}\n\nfunction showOverlay(copyState: CopyState): boolean {\n  return (\n    (copyState.kind === 'active' || copyState.kind === 'error') &&\n    (copyState.mode === 'touch' || copyState.mode === 'mouse')\n  );\n}\n\nexport function renderPopupArrow(options: {\n  direction: 'vertical' | 'horizontal';\n  popupPos: Point;\n  popupSize: { width: number; height: number };\n  side: 'before' | 'after';\n  target: Point;\n  theme: string;\n}) {\n  const popupContainer = getPopupContainer();\n  if (!popupContainer) {\n    return;\n  }\n\n  // Check for cases where the popup overlaps the target element\n  const { popupPos, popupSize, target } = options;\n  if (options.direction === 'vertical') {\n    if (options.side === 'before' && popupPos.y + popupSize.height > target.y) {\n      return;\n    } else if (options.side === 'after' && popupPos.y < target.y) {\n      return;\n    }\n  } else {\n    if (options.side === 'before' && popupPos.x + popupSize.width > target.x) {\n      return;\n    } else if (options.side === 'after' && popupPos.x < target.x) {\n      return;\n    }\n  }\n\n  renderArrow({ ...options, popupContainer, target });\n}\n","import type { MajorDataSeries } from '@birchill/jpdict-idb';\n\nimport type {\n  AccentDisplay,\n  ContentConfigParams,\n  FontFace,\n  FontSize,\n  PartOfSpeechDisplay,\n} from '../../common/content-config-params';\nimport type { CopyType } from '../../common/copy-keys';\nimport type { ReferenceAbbreviation } from '../../common/refs';\nimport type { Box, Point } from '../../utils/geometry';\nimport { stripFields } from '../../utils/strip-fields';\n\nimport type { SelectionMeta } from '../meta';\nimport type { DisplayMode } from '../popup-state';\nimport type { QueryResult } from '../query';\nimport { toScreenCoords } from '../scroll-offset';\nimport { isForeignObjectElement, isSvgDoc, isSvgSvgElement } from '../svg';\n\nimport type { CopyState } from './copy-state';\nimport {\n  type PopupPosition,\n  type PopupPositionConstraints,\n  type PopupPositionMode,\n  getPopupPosition,\n} from './popup-position';\nimport { renderPopup, renderPopupArrow } from './render-popup';\n\n// There are a _lot_ of options here. Once we've converted the popup to Preact\n// we should be able to move some of this state into component state.\nexport type ShowPopupOptions = {\n  allowOverlap?: boolean;\n  accentDisplay: AccentDisplay;\n  bunproDisplay: boolean;\n  closeShortcuts?: ReadonlyArray<string>;\n  container?: HTMLElement;\n  copyNextKey: string;\n  copyState: CopyState;\n  copy?: {\n    includeAllSenses: boolean;\n    includeLessCommonHeadwords: boolean;\n    includePartOfSpeech: boolean;\n  };\n  dictToShow: MajorDataSeries;\n  dictLang?: string;\n  displayMode: DisplayMode;\n  fixedPosition?: PopupPositionConstraints;\n  fixMinHeight?: boolean;\n  fontFace?: FontFace;\n  fontSize?: FontSize;\n  fxData: ContentConfigParams['fx'];\n  getCursorClearanceAndPos: () => { cursorClearance: Box; cursorPos?: Point };\n  expandShortcuts?: ReadonlyArray<string>;\n  interactive: boolean;\n  isExpanded: boolean;\n  isVerticalText: boolean;\n  kanjiReferences: Array<ReferenceAbbreviation>;\n  meta?: SelectionMeta;\n  onCancelCopy?: () => void;\n  onStartCopy?: StartCopyCallback;\n  onCopy?: (copyType: CopyType) => void;\n  onClosePopup?: () => void;\n  onExpandPopup?: () => void;\n  onShowSettings?: () => void;\n  onSwitchDictionary?: (newDict: MajorDataSeries | 'next' | 'prev') => void;\n  onTogglePin?: () => void;\n  pinShortcuts?: ReadonlyArray<string>;\n  pointerType: 'cursor' | 'puck';\n  posDisplay: PartOfSpeechDisplay;\n  positionMode: PopupPositionMode;\n  popupStyle: string;\n  preferredUnits: 'metric' | 'imperial';\n  previousHeight?: number;\n  safeArea: Box;\n  showDefinitions: boolean;\n  showPriority: boolean;\n  showKanjiComponents?: boolean;\n  switchDictionaryKeys: ReadonlyArray<string>;\n  tabDisplay: 'top' | 'left' | 'right' | 'none';\n  waniKaniVocabDisplay: 'hide' | 'show-matches';\n};\n\nexport type StartCopyCallback = (\n  index: number,\n  trigger: 'touch' | 'mouse'\n) => void;\n\nexport function showPopup(\n  result: QueryResult | undefined,\n  options: ShowPopupOptions\n): {\n  popup: HTMLElement;\n  size: { width: number; height: number };\n  pos: Omit<PopupPosition, 'constrainWidth' | 'constrainHeight'>;\n} | null {\n  const popup = renderPopup(result, options);\n  if (!popup) {\n    return null;\n  }\n\n  const { cursorClearance, cursorPos } = options.getCursorClearanceAndPos();\n\n  // Get the initial popup size\n\n  let popupSize = getPopupDimensions(popup);\n\n  // Apply any min height to the popup\n\n  let minHeight = 0;\n  if (\n    options.fixMinHeight &&\n    options.previousHeight &&\n    popupSize.height < options.previousHeight\n  ) {\n    minHeight = popupSize.height = options.previousHeight;\n  }\n\n  // Get the popup position\n\n  const popupPos = getPopupPosition({\n    allowVerticalOverlap: options.allowOverlap || !!options.fixMinHeight,\n    cursorClearance,\n    cursorPos,\n    fixedPosition: options.fixedPosition,\n    interactive: options.interactive,\n    isVerticalText: options.isVerticalText,\n    positionMode: options.positionMode,\n    popupSize,\n    safeArea: options.safeArea,\n    pointerType: options.pointerType,\n  });\n\n  //\n  // Apply the popup position\n  //\n\n  if (\n    isSvgDoc(document) &&\n    isSvgSvgElement(document.documentElement) &&\n    isForeignObjectElement(popup.parentElement)\n  ) {\n    // Set the x/y attributes on the <foreignObject> wrapper after converting\n    // to document space.\n    const svg: SVGSVGElement = document.documentElement;\n    const wrapper: SVGForeignObjectElement = popup.parentElement;\n    wrapper.x.baseVal.value = popupPos.x;\n    wrapper.y.baseVal.value = popupPos.y;\n    const ctm = svg.getScreenCTM();\n    if (ctm) {\n      const transform = svg.createSVGTransformFromMatrix(ctm.inverse());\n      wrapper.transform.baseVal.initialize(transform);\n    }\n  } else {\n    popup.style.setProperty('--left', `${popupPos.x}px`);\n    popup.style.setProperty('--top', `${popupPos.y}px`);\n\n    if (popupPos.constrainWidth) {\n      popup.style.setProperty('--max-width', `${popupPos.constrainWidth}px`);\n    } else {\n      popup.style.removeProperty('--max-width');\n    }\n\n    if (popupPos.constrainHeight) {\n      popup.style.removeProperty('--min-height');\n      popup.style.setProperty('--max-height', `${popupPos.constrainHeight}px`);\n    } else if (minHeight) {\n      popup.style.setProperty('--min-height', `${minHeight}px`);\n      popup.style.removeProperty('--max-height');\n    } else {\n      popup.style.removeProperty('--min-height');\n      popup.style.removeProperty('--max-height');\n    }\n  }\n\n  //\n  // Maybe add an arrow to it\n  //\n  // This needs to happen after positioning the popup so we can read back its\n  // final size (after applying any edge case CSS rules) and determine if\n  // there is room for the arrow or not.\n  //\n\n  if (\n    cursorPos &&\n    (options.displayMode === 'hover' || options.displayMode === 'pinned') &&\n    popupPos.direction !== 'disjoint' &&\n    popupPos.side !== 'disjoint'\n  ) {\n    // Update the popup size now that we have positioned it.\n    popupSize = getPopupDimensions(popup);\n\n    renderPopupArrow({\n      direction: popupPos.direction,\n      popupPos: toScreenCoords({ x: popupPos.x, y: popupPos.y }),\n      popupSize,\n      side: popupPos.side,\n      target: cursorPos,\n      theme: options.popupStyle,\n    });\n  }\n\n  return {\n    popup,\n    size: {\n      width: popupPos.constrainWidth ?? popupSize.width,\n      height: popupPos.constrainHeight ?? popupSize.height,\n    },\n    pos: stripFields(popupPos, ['constrainWidth', 'constrainHeight']),\n  };\n}\n\nfunction getPopupDimensions(hostElem: HTMLElement): {\n  width: number;\n  height: number;\n} {\n  // Measure the size of the inner window so that we don't include the padding\n  // for the shadow\n  const windowElem = hostElem.shadowRoot?.querySelector('.window');\n  const width =\n    (windowElem instanceof HTMLElement ? windowElem.offsetWidth : 0) || 200;\n  const height =\n    windowElem instanceof HTMLElement ? windowElem.offsetHeight : 0;\n  return { width, height };\n}\n","import browser from 'webextension-polyfill';\n\nimport { BackgroundRequest } from '../background/background-request';\nimport {\n  KanjiSearchResult,\n  NameResult,\n  NameSearchResult,\n  SearchOtherResult,\n  SearchWordsResult,\n  TranslateResult,\n  WordSearchResult,\n} from '../background/search-result';\nimport { hasKatakana } from '../utils/char-range';\nimport { stripFields } from '../utils/strip-fields';\n\nexport type QueryResult = {\n  words: WordSearchResult | null;\n  kanji?: KanjiSearchResult | null;\n  names?: NameSearchResult | null;\n\n  // Metadata\n  title?: string;\n  namePreview?: NamePreview;\n  resultType: 'db-unavailable' | 'db-updating' | 'initial' | 'full';\n};\n\nexport type NamePreview = {\n  names: Array<NameResult>;\n  more: boolean;\n};\n\nexport interface QueryOptions {\n  includeRomaji: boolean;\n  metaMatchLen?: number;\n  wordLookup: boolean;\n  updateQueryResult: (result: QueryResult | null) => void;\n}\n\ntype QueryCacheEntry =\n  | {\n      key: string;\n      state: 'searching';\n      wordsQuery: Promise<QueryResult | null>;\n      fullQuery: Promise<QueryResult | null>;\n    }\n  | {\n      key: string;\n      state: 'complete';\n      result: QueryResult;\n    };\n\nlet queryCache: Array<QueryCacheEntry> = [];\n\nexport async function query(\n  text: string,\n  options: QueryOptions\n): Promise<QueryResult | null> {\n  // Add a very very basic cache\n  const key = getCacheKey({ ...options, text });\n\n  // You'd think we'd use an actual hashmap (object) here but then we'd need to\n  // work out some sort of LRU scheme for removing entries. While there are\n  // plenty of libraries for that and we even use one such in the background\n  // script, this code is part of the content script which goes into every page\n  // so we try to keep it lean.\n  //\n  // As a result, we limit our cache size to 10 entries and just do a linear\n  // search of the array.\n  const cachedEntry = queryCache.find((q) => q.key === key);\n  if (cachedEntry) {\n    switch (cachedEntry.state) {\n      case 'searching':\n        void cachedEntry.fullQuery.then((result) => {\n          options.updateQueryResult(result);\n        });\n        return cachedEntry.wordsQuery;\n\n      case 'complete':\n        return cachedEntry.result;\n    }\n  }\n\n  // Limit the cache to 10 entries. This cache is really just here for the case\n  // when the user is moving the cursor back and forward along a word and\n  // therefore running the same query multiple times.\n  if (queryCache.length > 10) {\n    queryCache.shift();\n  }\n\n  // If the query throws, comes back empty, or is a result from the fallback\n  // database, drop it from the cache.\n\n  const rawWordsQuery = queryWords(text, options);\n  const fullQuery = queryOther(text, options, rawWordsQuery)\n    .then((result) => {\n      // Update the cache accordingly\n      if (!result || result === 'aborted') {\n        queryCache = queryCache.filter((q) => q.key !== key);\n        return null;\n      } else if (result.resultType === 'full') {\n        const cacheIndex = queryCache.findIndex((q) => q.key === key);\n        if (cacheIndex !== -1) {\n          queryCache[cacheIndex] = {\n            key,\n            state: 'complete',\n            result,\n          };\n        }\n      } else {\n        queryCache = queryCache.filter((q) => q.key !== key);\n      }\n\n      return result;\n    })\n    .catch(() => {\n      queryCache = queryCache.filter((q) => q.key !== key);\n      return null;\n    });\n\n  // The rawWordsQuery can return the 'aborted' value or an object with a\n  // null `words` property (so we can read its dbStatus property) so that the\n  // queryOther knows not to proceed, but we should simplify the result before\n  // returning it to the caller.\n  const wordsQuery = rawWordsQuery.then((result) => {\n    return result === 'aborted' || !result?.words ? null : result;\n  });\n\n  queryCache.push({\n    key,\n    state: 'searching',\n    wordsQuery,\n    fullQuery,\n  });\n\n  void fullQuery.then((result) => options.updateQueryResult(result));\n\n  return wordsQuery;\n}\n\nasync function queryWords(\n  text: string,\n  options: QueryOptions\n): Promise<QueryResult | 'aborted' | null> {\n  const message: BackgroundRequest = {\n    type: options.wordLookup ? 'searchWords' : 'translate',\n    input: text,\n    includeRomaji: options.includeRomaji,\n  };\n\n  let searchResult: SearchWordsResult | TranslateResult | 'aborted' | null;\n  try {\n    searchResult = await browser.runtime.sendMessage(message);\n  } catch (e) {\n    console.error(\n      '[10ten-ja-reader] Failed to call query. The page might need to be refreshed.',\n      e\n    );\n    searchResult = null;\n  }\n\n  if (!searchResult || searchResult === 'aborted') {\n    return searchResult;\n  }\n\n  // Convert the result into a suitably shaped QueryResult\n\n  let queryResult: QueryResult;\n  let resultType: 'db-unavailable' | 'db-updating' | 'initial' = 'initial';\n  const { dbStatus } = searchResult;\n  if (dbStatus === 'unavailable') {\n    resultType = 'db-unavailable';\n  } else if (dbStatus === 'updating') {\n    resultType = 'db-updating';\n  }\n\n  if (isTranslateResult(searchResult)) {\n    let title = text.substring(0, searchResult.textLen);\n    if (text.length > searchResult.textLen) {\n      title += '...';\n    }\n    queryResult = {\n      words: {\n        ...stripFields(searchResult, ['dbStatus', 'textLen']),\n        type: 'words',\n        matchLen: searchResult.textLen,\n      },\n      title,\n      resultType,\n    };\n  } else {\n    queryResult = { ...stripFields(searchResult, ['dbStatus']), resultType };\n  }\n\n  return queryResult;\n}\n\nfunction isTranslateResult(\n  result: SearchWordsResult | TranslateResult\n): result is TranslateResult {\n  return (result as TranslateResult).type === 'translate';\n}\n\nasync function queryOther(\n  text: string,\n  options: QueryOptions,\n  wordsQuery: Promise<QueryResult | 'aborted' | null>\n): Promise<QueryResult | 'aborted' | null> {\n  const words = await wordsQuery;\n  if (words === 'aborted') {\n    return 'aborted';\n  }\n\n  if (words?.resultType.startsWith('db-')) {\n    return words;\n  }\n\n  const message: BackgroundRequest = {\n    type: 'searchOther',\n    input: text,\n    includeRomaji: options.includeRomaji,\n    wordsMatchLen: Math.max(\n      words?.words?.matchLen || 0,\n      options.metaMatchLen || 0\n    ),\n  };\n\n  let searchResult: SearchOtherResult | 'aborted' | null;\n  try {\n    searchResult = await browser.runtime.sendMessage(message);\n  } catch (e) {\n    console.error(\n      '[10ten-ja-reader] Failed to call searchOther. The page might need to be refreshed.',\n      e\n    );\n    searchResult = null;\n  }\n\n  if (!searchResult) {\n    // If the words query was empty too, make sure the final result is null.\n    return words?.words ? words : null;\n  }\n\n  if (searchResult === 'aborted') {\n    return searchResult;\n  }\n\n  return addNamePreview({\n    words: words?.words ?? null,\n    names: searchResult.names,\n    kanji: searchResult.kanji,\n    resultType: 'full',\n  });\n}\n\nfunction addNamePreview(result: QueryResult): QueryResult {\n  if (!result.words || !result.names) {\n    return result;\n  }\n\n  // If we have a word result, check for a longer match in the names dictionary,\n  // but only if the existing match has some non-hiragana characters in it.\n  //\n  // The names dictionary contains mostly entries with at least some kanji or\n  // katakana but it also contains entries that are solely hiragana (e.g.  はなこ\n  // without any corresponding kanji). Generally we only want to show a name\n  // preview if it matches on some kanji or katakana as otherwise it's likely to\n  // be a false positive.\n  //\n  // While it might seem like it would be enough to check if the existing match\n  // from the words dictionary is hiragana-only, we can get cases where a longer\n  // match in the names dictionary _starts_ with hiragana but has kanji/katakana\n  // later, e.g. ほとけ沢.\n  const names: Array<NameResult> = [];\n  let more = false;\n\n  // Add up to three results provided that:\n  //\n  // - they have a kanji reading or katakana reading,\n  // - and are all are as long as the longest names match,\n  // - are all longer than the longest words match\n  const minLength = Math.max(result.names.matchLen, result.words.matchLen + 1);\n\n  for (const name of result.names.data) {\n    // Names should be in descending order of length so if any of them is less\n    // than the minimum length, we can skip the rest.\n    if (name.matchLen < minLength) {\n      break;\n    }\n\n    if (!name.k && !name.r.some(hasKatakana)) {\n      continue;\n    }\n\n    if (names.length > 2) {\n      more = true;\n      break;\n    }\n\n    names.push(name);\n  }\n\n  if (!names.length) {\n    return result;\n  }\n\n  // If we got a match, extend the matchLen of the words result.\n  //\n  // Reaching into the words result like this is cheating a little bit but it\n  // simplifies the places where we use the word result.\n  const matchLen = names[0].matchLen;\n\n  return {\n    ...result,\n    words: { ...result.words, matchLen },\n    namePreview: { names, more },\n  };\n}\n\nfunction getCacheKey({\n  text,\n  includeRomaji,\n  wordLookup,\n}: {\n  text: string;\n  includeRomaji: boolean;\n  wordLookup: boolean;\n}): string {\n  return [text, includeRomaji ? '1' : '0', wordLookup ? '1' : '0'].join('-');\n}\n","/// <reference path=\"../common/css.d.ts\" />\nimport safeAreaProviderStyles from '../../css/safe-area-provider.css?inline';\n\nimport { PaddingBox } from '../utils/geometry';\n\nimport {\n  getOrCreateEmptyContainer,\n  removeContentContainer,\n} from './content-container';\n\nexport type SafeAreaChangeListener = (safeArea: PaddingBox | null) => void;\n\nexport class SafeAreaProvider {\n  public static readonly id: string = 'tenten-safe-area-provider';\n\n  private cachedSafeArea: PaddingBox | null = null;\n\n  private element: HTMLDivElement | undefined;\n  private resizeObserver: ResizeObserver | undefined;\n\n  private listeners: Array<SafeAreaChangeListener> = [];\n\n  getSafeArea(): PaddingBox {\n    const safeAreaElem = this.element || this.startListening();\n\n    if (this.cachedSafeArea) {\n      return this.cachedSafeArea;\n    }\n\n    const computedStyle = getComputedStyle(safeAreaElem);\n    const safeArea: PaddingBox = {\n      top:\n        parseFloat(\n          computedStyle.getPropertyValue('--tenten-safe-area-inset-top')\n        ) || 0,\n      right:\n        parseFloat(\n          computedStyle.getPropertyValue('--tenten-safe-area-inset-right')\n        ) || 0,\n      bottom:\n        parseFloat(\n          computedStyle.getPropertyValue('--tenten-safe-area-inset-bottom')\n        ) || 0,\n      left:\n        parseFloat(\n          computedStyle.getPropertyValue('--tenten-safe-area-inset-left')\n        ) || 0,\n    };\n\n    this.setCachedSafeArea(safeArea);\n\n    return safeArea;\n  }\n\n  destroy() {\n    this.stopListening();\n  }\n\n  //\n  // Listeners\n  //\n\n  addEventListener(listener: SafeAreaChangeListener) {\n    if (this.listeners.includes(listener)) {\n      return;\n    }\n    this.listeners.push(listener);\n  }\n\n  removeEventListener(listener: SafeAreaChangeListener) {\n    this.listeners = this.listeners.filter((l) => l !== listener);\n  }\n\n  //\n  // Implementation helpers\n  //\n\n  private startListening() {\n    // Set up shadow tree\n    const container = getOrCreateEmptyContainer({\n      id: SafeAreaProvider.id,\n      styles: safeAreaProviderStyles.toString(),\n    });\n\n    // Create safe area provider element\n    this.element = document.createElement('div');\n    this.element.classList.add('safe-area-provider');\n\n    container.shadowRoot!.append(this.element);\n\n    // Listen for changes\n    if ('ResizeObserver' in window) {\n      // Ideally use ResizeObserver, as it fires updates even whilst the puck\n      // is being dragged.\n      this.resizeObserver = new ResizeObserver(this.onResizeObserved);\n      this.resizeObserver.observe(this.element, { box: 'border-box' });\n    } else {\n      // Otherwise, fall back to using window \"resize\" events.\n      (window as Window).addEventListener('resize', this.onWindowResize);\n    }\n\n    return this.element;\n  }\n\n  private stopListening() {\n    // Stop listening\n    if (this.resizeObserver) {\n      if (this.element) {\n        this.resizeObserver.unobserve(this.element);\n      }\n      this.resizeObserver = undefined;\n    } else {\n      window.removeEventListener('resize', this.onWindowResize);\n    }\n\n    // Drop the element\n    removeSafeAreaProvider();\n    this.element = undefined;\n  }\n\n  private setCachedSafeArea(safeArea: PaddingBox | null) {\n    this.cachedSafeArea = safeArea;\n    this.notifyListeners(safeArea);\n  }\n\n  private notifyListeners(safeArea: PaddingBox | null) {\n    const listenersCopy = [...this.listeners];\n    for (const listener of listenersCopy) {\n      listener(safeArea);\n    }\n  }\n\n  private readonly onResizeObserved = (entries: ResizeObserverEntry[]) => {\n    for (const entry of entries) {\n      if (entry.contentRect) {\n        // contentRect has changed, so invalidate our cached safe area insets.\n        this.setCachedSafeArea(null);\n        break;\n      }\n    }\n  };\n\n  private readonly onWindowResize = () => {\n    this.setCachedSafeArea(null);\n  };\n}\n\n// We expose this separately so that when the extension is upgraded, we can\n// clear up any artifacts left behind by the previous version.\nexport function removeSafeAreaProvider(): void {\n  removeContentContainer(SafeAreaProvider.id);\n}\n","import { isTextInputNode, isVerticalText } from '../utils/dom-utils';\nimport { Rect } from '../utils/geometry';\n\nimport { getContentType } from './content-type';\nimport { getGdocsRangeBboxes, isGdocsSpan } from './gdocs-canvas';\nimport { getScrollOffset, toPageCoords, toScreenCoords } from './scroll-offset';\nimport { TextRange } from './text-range';\n\n/// Properties about the target element from which we started lookup needed\n/// so that we can correctly position the popup in a way that doesn't overlap\n/// the element.\nexport type TargetProps = {\n  contentType: 'text' | 'image';\n  fromPuck: boolean;\n  fromTouch: boolean;\n  hasTitle: boolean;\n  isVerticalText: boolean;\n  textBoxSizes?: SelectionSizes;\n};\n\n// A range of t-shirt sizes for the first part of the text selection.\n//\n// This is a bit awkward because in the iframe case it is the text-handling\n// window that has access to the element needed to get bounding box sizes.\n// However, it doesn't know how much of the text will be matched.\n//\n// We don't want to be doing IPC calls as part of the popup positioning so we\n// just return a set of standard sizes and let the topmost window choose the\n// best fit.\nexport type SelectionSizes = {\n  1: Rect;\n  4: Rect;\n  8: Rect;\n  12: Rect;\n  16: Rect;\n};\n\n// Guaranteed to be arranged in ascending order\nexport const textBoxSizeLengths: ReadonlyArray<keyof SelectionSizes> = [\n  1, 4, 8, 12, 16,\n];\n\nexport function getPageTargetProps({\n  fromPuck,\n  fromTouch,\n  target,\n  textRange,\n}: {\n  fromPuck: boolean;\n  fromTouch: boolean;\n  target: Element;\n  textRange: TextRange | undefined;\n}): TargetProps {\n  let textBoxSizes: SelectionSizes | undefined;\n  if (textRange) {\n    textBoxSizes = getInitialClientBboxofTextSelection(textRange);\n\n    // Return as page coordinates\n    if (textBoxSizes) {\n      const scrollOffset = getScrollOffset();\n      for (const size of textBoxSizeLengths) {\n        textBoxSizes[size] = toPageCoords(textBoxSizes[size], scrollOffset);\n      }\n    }\n  }\n\n  return {\n    contentType: getContentType(target),\n    fromPuck,\n    fromTouch,\n    hasTitle: !!((target as HTMLElement) || null)?.title,\n    textBoxSizes,\n    isVerticalText: isVerticalText(target),\n  };\n}\n\nfunction getInitialClientBboxofTextSelection(\n  textRange: TextRange\n): SelectionSizes | undefined {\n  // Check we actually have some text selection available\n  //\n  // (We easily can't get the bbox of text selections in input elements\n  // unfortunately.)\n  if (!textRange.length || isTextInputNode(textRange[0].node)) {\n    return undefined;\n  }\n\n  // All this fiddling we do do get bboxes for Google docs spans is possibly\n  // not necessary. The bboxes are mostly useful on mobile devices when we are\n  // trying to position the popup to the side of the selection, but the Web\n  // version of Google docs is probably not often used on mobile devices.\n  //\n  // However, it's fairly easy to calculate these bboxes and doing so means we\n  // get a more consistent vertical gutter in non-Google docs cases so for now\n  // we put up with the complexity.\n  const node = textRange[0].node;\n  const gDocsStartSpan = isGdocsSpan(node) ? node : undefined;\n  const range = gDocsStartSpan ? undefined : node.ownerDocument!.createRange();\n  if (range) {\n    range.setStart(node, textRange[0].start);\n  }\n\n  let lastEnd = -1;\n  let lastSize: Rect | undefined;\n\n  const result: Partial<SelectionSizes> = {};\n  for (const size of textBoxSizeLengths) {\n    const end = Math.min(textRange[0].start + size, textRange[0].end);\n    if (end <= lastEnd) {\n      result[size] = lastSize!;\n    } else {\n      if (gDocsStartSpan) {\n        result[size] = getGdocsRangeBboxes({\n          startSpan: gDocsStartSpan,\n          offset: textRange[0].start,\n          length: end - textRange[0].start,\n        })[0];\n      } else if (range) {\n        range.setEnd(node, end);\n\n        // Safari will sometimes return zero-width bboxes when the range starts\n        // on a new line so we should make sure to choose the wider bbox.\n        const bbox = [...range.getClientRects()].reduce<DOMRect | undefined>(\n          (result, bbox) =>\n            (result?.width || 0) >= bbox.width ? result : bbox,\n          undefined\n        );\n\n        // Sometimes getClientRects can return an empty array\n        if (!bbox) {\n          return undefined;\n        }\n\n        result[size] = bbox;\n      }\n\n      lastEnd = end;\n      lastSize = result[size];\n    }\n  }\n\n  return result as SelectionSizes;\n}\n\nexport function getBestFitSize({\n  sizes,\n  length,\n}: {\n  sizes: SelectionSizes;\n  length: number;\n}): Rect | undefined {\n  // If the length is zero, it's probably best to say no size\n  if (!length) {\n    return undefined;\n  }\n\n  // Otherwise, find the first size that is _bigger_ than the provided length.\n  // And if there is none, just choose the biggest size.\n  const bestFitSize =\n    textBoxSizeLengths.slice().find((len) => len > length) ||\n    textBoxSizeLengths[textBoxSizeLengths.length - 1];\n\n  return sizes[bestFitSize];\n}\n\nexport function selectionSizesToScreenCoords(\n  sizes: Readonly<SelectionSizes> | undefined\n): SelectionSizes | undefined {\n  if (!sizes) {\n    return undefined;\n  }\n\n  const converted = { ...sizes };\n  const scrollOffset = getScrollOffset();\n  for (const size of textBoxSizeLengths) {\n    converted[size] = toScreenCoords(sizes[size], scrollOffset);\n  }\n  return converted;\n}\n","import browser from 'webextension-polyfill';\n\nimport { HighlightStyle } from '../common/content-config-params';\nimport { html } from '../utils/builder';\nimport {\n  isContentEditableNode,\n  isFocusable,\n  isSvg,\n  isTextInputNode,\n  isVerticalText,\n} from '../utils/dom-utils';\nimport { isChromium } from '../utils/ua-utils';\n\nimport {\n  clearGdocsHighlight,\n  highlightGdocsRange,\n  isGdocsSpan,\n} from './gdocs-canvas';\nimport { NodeRange, TextRange } from './text-range';\n\nexport class TextHighlighter {\n  private selectedWindow: Window | null = null;\n  private selectedText: string | null = null;\n\n  // Used to restore the selection of a textbox after we stop interacting\n  // with it (since we clobber the text box selection in order to highlight it).\n  private selectedTextBox: {\n    node: HTMLInputElement | HTMLTextAreaElement;\n    previousStart: number | null;\n    previousEnd: number | null;\n    previousDirection: 'forward' | 'backward' | 'none' | undefined;\n  } | null = null;\n\n  // Used restore the selection of a contenteditable node similar to the way\n  // we treat text boxes.\n  private previousSelection: { node: Node; offset: number } | null;\n\n  // We need to focus a textbox in order to set its selection so we store the\n  // previously focussed node so we can restore it after we're done.\n  private previousFocus: Element | null;\n\n  // Gross hack to ignore our own focus events.\n  private updatingFocus = false;\n\n  constructor() {\n    this.onFocusIn = this.onFocusIn.bind(this);\n    window.addEventListener('focusin', this.onFocusIn);\n  }\n\n  detach() {\n    window.removeEventListener('focusin', this.onFocusIn);\n    this.clearHighlight();\n    this.dropHighlightStyles();\n  }\n\n  highlight({\n    length,\n    textRange,\n    style,\n  }: {\n    length: number;\n    textRange: TextRange;\n    style?: HighlightStyle;\n  }) {\n    console.assert(textRange.length, 'Should have a non-empty range');\n    const selectedWindow = textRange[0].node.ownerDocument!.defaultView!;\n\n    // Check that the window isn't closed\n    if (!selectedWindow || selectedWindow.closed) {\n      this.clearHighlight();\n      return;\n    }\n\n    // Look for an existing selection.\n    //\n    // If there is no selection, we're probably dealing with an iframe that\n    // has now become display:none.\n    const selection = selectedWindow.getSelection();\n    if (!selection) {\n      this.clearHighlight();\n      return;\n    }\n\n    const canUseHighlightApi = this.canUseHighlightApi({ textRange, length });\n\n    // If there is already something selected in the page that is *not*\n    // what we selected then generally want to leave it alone, unless of course\n    // we're able to use the CSS Highlight API.\n    //\n    // The one exception to this is if the selection is in a contenteditable\n    // node. In that case we want to store and restore it to mimic the behavior\n    // of textboxes.\n    if (isContentEditableNode(selection.anchorNode)) {\n      if (\n        !this.previousSelection &&\n        selection.toString() !== this.selectedText\n      ) {\n        this.storeContentEditableSelection(selectedWindow);\n      }\n    } else if (\n      !canUseHighlightApi &&\n      !selection.isCollapsed &&\n      selection.toString() !== this.selectedText\n    ) {\n      this.clearHighlight();\n      return;\n    }\n\n    // Unconditionally clear any existing CSS highlights since we might end up\n    // using regular DOM selections in some cases.\n    CSS?.highlights?.delete('tenten-selection');\n    CSS?.highlights?.delete('tenten-selection-blue');\n\n    const startNode = textRange[0].node;\n    if (isTextInputNode(startNode)) {\n      this.highlightTextBox({\n        length,\n        offset: textRange[0].start,\n        selectedWindow,\n        textBox: startNode,\n      });\n    } else if (isGdocsSpan(startNode)) {\n      highlightGdocsRange({\n        startSpan: startNode,\n        offset: textRange[0].start,\n        length,\n        style,\n      });\n      this.selectedText = null;\n      this.selectedWindow = selectedWindow;\n    } else {\n      this.highlightRegularNode({\n        canUseHighlightApi,\n        length,\n        selectedWindow,\n        style,\n        textRange,\n      });\n    }\n  }\n\n  // The optional `currentElement` parameter here indicates the element we are\n  // currently interacting with.\n  //\n  // This is only used when we have been an interacting with a text box.\n  // As part of highlighting text in that text box we can cause it to scroll\n  // its contents. In particular, when we _clear_ the highlight in the text box\n  // we will restore its previous selection, but doing that might scroll the\n  // text box. If we are still interacting with that same text box (e.g. the\n  // mouse is still over the text box) then we take care not to restore its\n  // scroll position.\n  clearHighlight({\n    currentElement = null,\n  }: { currentElement?: Element | null } = {}) {\n    if (this.selectedWindow && !this.selectedWindow.closed) {\n      // Clear the selection if it's something we made.\n      const selection = this.selectedWindow.getSelection();\n      if (selection?.toString() && selection.toString() === this.selectedText) {\n        if (this.previousSelection) {\n          this.restoreContentEditableSelection();\n        } else {\n          selection.removeAllRanges();\n        }\n      }\n\n      // Delete any highlight we may have added using the CSS Highlight API.\n      CSS?.highlights?.delete('tenten-selection');\n      CSS?.highlights?.delete('tenten-selection-blue');\n      this.dropHighlightStyles();\n\n      // Likewise any Google docs selection\n      clearGdocsHighlight();\n\n      this.clearTextBoxSelection(currentElement);\n    }\n\n    this.selectedWindow = null;\n    this.selectedText = null;\n    this.selectedTextBox = null;\n    this.previousFocus = null;\n    this.previousSelection = null;\n  }\n\n  isUpdatingFocus() {\n    return this.updatingFocus;\n  }\n\n  private storeContentEditableSelection(selectedWindow: Window) {\n    const selection = selectedWindow.getSelection();\n    if (selection && isContentEditableNode(selection.anchorNode)) {\n      // We don't actually store the full selection, basically because we're\n      // lazy. Remembering the cursor position is hopefully good enough for\n      // now anyway.\n      this.previousSelection = {\n        node: selection.anchorNode!,\n        offset: selection.anchorOffset,\n      };\n    } else {\n      this.previousSelection = null;\n    }\n  }\n\n  private restoreContentEditableSelection() {\n    if (!this.previousSelection) {\n      return;\n    }\n\n    const { node, offset } = this.previousSelection;\n    const range = node.ownerDocument!.createRange();\n    range.setStart(node, offset);\n    range.setEnd(node, offset);\n\n    const selection = node.ownerDocument!.defaultView!.getSelection();\n    if (selection) {\n      selection.removeAllRanges();\n      selection.addRange(range);\n    }\n    this.previousSelection = null;\n  }\n\n  private highlightTextBox({\n    length,\n    offset,\n    selectedWindow,\n    textBox,\n  }: {\n    length: number;\n    offset: number;\n    selectedWindow: Window;\n    textBox: HTMLInputElement | HTMLTextAreaElement;\n  }) {\n    const start = offset;\n    const end = start + length;\n\n    // If we were previously interacting with a different text box, restore\n    // its range.\n    if (this.selectedTextBox && textBox !== this.selectedTextBox.node) {\n      this.restoreTextBoxSelection();\n    }\n\n    // If we were not already interacting with this text box, store its\n    // existing range and focus it.\n    if (!this.selectedTextBox || textBox !== this.selectedTextBox.node) {\n      // Record the original focus if we haven't already, so that we can\n      // restore it.\n      if (!this.previousFocus) {\n        this.previousFocus = document.activeElement;\n      }\n\n      // We want to be able to distinguish between changes to focus made by\n      // the user/app (which we want to reflect when we go to restore the focus)\n      // and changes to focus made by us.\n      const previousUpdatingFocus = this.updatingFocus;\n      this.updatingFocus = true;\n      textBox.focus();\n      this.updatingFocus = previousUpdatingFocus;\n\n      this.selectedTextBox = {\n        node: textBox,\n        previousStart: textBox.selectionStart,\n        previousEnd: textBox.selectionEnd,\n        previousDirection: textBox.selectionDirection || undefined,\n      };\n    }\n\n    // Store the current scroll range so we can restore it.\n    const { scrollTop, scrollLeft } = textBox;\n\n    // Clear any other selection happening in the page.\n    selectedWindow.getSelection()?.removeAllRanges();\n\n    textBox.setSelectionRange(start, end);\n    this.selectedText = textBox.value.substring(start, end);\n    this.selectedWindow = selectedWindow;\n\n    // Restore the scroll range. We need to do this on the next tick or else\n    // something else (not sure what) will clobber it.\n    requestAnimationFrame(() => {\n      textBox.scrollTo(scrollLeft, scrollTop);\n    });\n  }\n\n  private clearTextBoxSelection(currentElement: Element | null) {\n    if (!this.selectedTextBox) {\n      return;\n    }\n\n    const textBox = this.selectedTextBox.node;\n\n    // Store the previous scroll position so we can restore it, if need be.\n    const { scrollTop, scrollLeft } = textBox;\n\n    this.restoreTextBoxSelection();\n\n    // If we are still interacting with the text box, make sure to maintain its\n    // scroll position (rather than jumping back to wherever the restored\n    // selection is just because we didn't find a match).\n    if (currentElement === textBox) {\n      // Restore this in the next tick or else it will get clobbered.\n      // (Empirically two ticks seems to work better still.)\n      requestAnimationFrame(() => {\n        requestAnimationFrame(() => {\n          textBox.scrollTo(scrollLeft, scrollTop);\n        });\n      });\n    }\n\n    // If we only focussed the textbox in order to highlight text, restore the\n    // previous focus.\n    //\n    // (We need to do this even if currentElement === textBox since we'll lose\n    // the previous focus when we reset _selectedTextBox and we if we don't\n    // restore the focus now, when we next go to set previousFocus we'll end up\n    // using `textBox` instead.)\n    if (isFocusable(this.previousFocus) && this.previousFocus !== textBox) {\n      // First blur the text box since some Elements' focus() method does\n      // nothing.\n      this.selectedTextBox.node.blur();\n\n      // Very hacky approach to filtering out our own focus handling.\n      const previousUpdatingFocus = this.updatingFocus;\n      this.updatingFocus = true;\n      this.previousFocus.focus();\n      this.updatingFocus = previousUpdatingFocus;\n    }\n\n    this.selectedTextBox = null;\n    this.previousFocus = null;\n  }\n\n  private restoreTextBoxSelection() {\n    if (!this.selectedTextBox) {\n      return;\n    }\n\n    const {\n      node: textBox,\n      previousStart,\n      previousEnd,\n      previousDirection,\n    } = this.selectedTextBox;\n    textBox.setSelectionRange(previousStart, previousEnd, previousDirection);\n  }\n\n  private canUseHighlightApi({\n    length,\n    textRange,\n  }: {\n    length: number;\n    textRange: TextRange;\n  }) {\n    if (!CSS?.highlights) {\n      return false;\n    }\n\n    // We cannot highlight SVG\n    for (const { node } of new TextRangeWithLength(textRange, length)) {\n      if (isSvg(node)) {\n        return false;\n      }\n    }\n\n    // Chrome can't do highlights properly on vertical text\n    //\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1360724\n    if (isChromium()) {\n      for (const { node } of new TextRangeWithLength(textRange, length)) {\n        if (isVerticalText(node)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  private highlightRegularNode({\n    canUseHighlightApi,\n    length,\n    style,\n    selectedWindow,\n    textRange,\n  }: {\n    canUseHighlightApi: boolean;\n    length: number;\n    selectedWindow: Window;\n    style?: HighlightStyle;\n    textRange: TextRange;\n  }) {\n    // If we were previously interacting with a text box, restore its range\n    // and blur it.\n    this.clearTextBoxSelection(null);\n\n    const startNode = textRange[0].node;\n    const startOffset = textRange[0].start;\n    let endNode = startNode;\n    let endOffset = startOffset;\n\n    for (const { node, end } of new TextRangeWithLength(textRange, length)) {\n      endNode = node;\n      endOffset = end;\n    }\n\n    if (canUseHighlightApi) {\n      const range = new StaticRange({\n        startContainer: startNode,\n        startOffset,\n        endContainer: endNode,\n        endOffset,\n      });\n      CSS.highlights!.set(\n        style === 'blue' ? 'tenten-selection-blue' : 'tenten-selection',\n        new Highlight(range)\n      );\n      this.ensureHighlightStyles();\n      this.selectedText = null;\n    } else {\n      const range = startNode.ownerDocument!.createRange();\n      range.setStart(startNode, startOffset);\n      range.setEnd(endNode, endOffset);\n\n      // We only call this method if selectedWindow.getSelection() is not null.\n      this.updatingFocus = true;\n      const selection = selectedWindow.getSelection()!;\n      selection.removeAllRanges();\n      selection.addRange(range);\n      this.updatingFocus = false;\n\n      this.selectedText = selection.toString();\n    }\n\n    this.selectedWindow = selectedWindow;\n  }\n\n  private onFocusIn(event: FocusEvent) {\n    if (this.updatingFocus) {\n      return;\n    }\n\n    // Update the previous focus but only if we're already tracking the previous\n    // focus.\n    if (this.previousFocus && this.previousFocus !== event.target) {\n      this.previousFocus =\n        event.target instanceof Element ? event.target : null;\n\n      // Possibly updating the selection to restore if we're working with a\n      // contenteditable element.\n      if (this.previousFocus) {\n        this.storeContentEditableSelection(\n          this.previousFocus.ownerDocument!.defaultView!\n        );\n      }\n    }\n  }\n\n  private ensureHighlightStyles() {\n    if (document.getElementById('tenten-selection-styles')) {\n      return;\n    }\n\n    (document.head || document.documentElement).append(\n      html('link', {\n        id: 'tenten-selection-styles',\n        rel: 'stylesheet',\n        href: browser.runtime.getURL('css/selection.css'),\n      })\n    );\n  }\n\n  private dropHighlightStyles() {\n    document.getElementById('tenten-selection-styles')?.remove();\n  }\n}\n\n// Iterator for a TextRange that enforces the supplied length\nclass TextRangeWithLength implements Iterable<NodeRange> {\n  constructor(\n    public textRange: TextRange,\n    public length: number\n  ) {}\n\n  [Symbol.iterator](): Iterator<NodeRange> {\n    let i = 0;\n    let currentLen = 0;\n\n    return {\n      next: () => {\n        if (currentLen >= this.length || i >= this.textRange.length) {\n          return { done: true, value: undefined };\n        }\n\n        const { start, end, node } = this.textRange[i];\n        const len = Math.min(end - start, this.length - currentLen);\n        currentLen += len;\n\n        i++;\n\n        return { value: { start, end: start + len, node } };\n      },\n    };\n  }\n}\n","export type NodeRange = {\n  node: Node;\n  start: number;\n  end: number;\n};\n\nexport type TextRange = Array<NodeRange>;\n\nexport function textRangesEqual(\n  a: TextRange | null | undefined,\n  b: TextRange | null | undefined\n): boolean {\n  if (!a && !b) {\n    return true;\n  }\n\n  if (!a || !b) {\n    return false;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; ++i) {\n    if (\n      a[i].node !== b[i].node ||\n      a[i].start !== b[i].start ||\n      a[i].end !== b[i].end\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","export async function hasReasonableTimerResolution(): Promise<boolean> {\n  const waitALittle = async () =>\n    new Promise((resolve) => setTimeout(resolve, 10));\n\n  // If performance.now() returns different times at least three out of five\n  // times then we can assume that we're not doing timer clamping of the sort\n  // that would confuse our speed calculations.\n  const numSamples = 5;\n  const samples: number[] = [];\n  samples.push(performance.now());\n  for (let i = 1; i < numSamples; i++) {\n    await waitALittle();\n    samples.push(performance.now());\n  }\n\n  const context: { same: number; previous?: number } = { same: 0 };\n  const { same: identicalPairs } = samples.reduce(\n    (context, current) => ({\n      same: current === context.previous ? context.same + 1 : context.same,\n      previous: current,\n    }),\n    context\n  );\n\n  return identicalPairs < 2;\n}\n","export class TouchClickTracker {\n  private wasTouch = false;\n  private ignoring = false;\n  private disabled = false;\n  private clickHandlerRegistered = false;\n  onTouchClick?: (event: MouseEvent) => void;\n\n  constructor() {\n    this.onTouchStart = this.onTouchStart.bind(this);\n    this.onTouchEnd = this.onTouchEnd.bind(this);\n    this.onClick = this.onClick.bind(this);\n\n    this.addEventListeners();\n  }\n\n  destroy() {\n    this.removeEventListeners();\n  }\n\n  disable() {\n    if (this.disabled) {\n      return;\n    }\n\n    this.disabled = true;\n    this.removeEventListeners();\n  }\n\n  enable() {\n    if (!this.disabled) {\n      return;\n    }\n\n    this.disabled = false;\n    this.addEventListeners();\n  }\n\n  startIgnoringClicks() {\n    this.ignoring = true;\n  }\n\n  stopIgnoringClicks() {\n    this.ignoring = false;\n  }\n\n  private addEventListeners() {\n    window.addEventListener('touchstart', this.onTouchStart, { passive: true });\n    window.addEventListener('touchend', this.onTouchEnd, { passive: true });\n    // We need to register for clicks on the _body_ because if there is no\n    // click handler on the body element, iOS won't generate click events\n    // from touch taps.\n    document.body?.addEventListener('click', this.onClick);\n    this.clickHandlerRegistered = !!document.body;\n  }\n\n  private removeEventListeners() {\n    window.removeEventListener('touchstart', this.onTouchStart);\n    window.removeEventListener('touchend', this.onTouchEnd);\n    document.body?.removeEventListener('click', this.onClick);\n    this.clickHandlerRegistered = false;\n  }\n\n  private onTouchStart() {\n    if (!this.clickHandlerRegistered) {\n      document.body?.addEventListener('click', this.onClick);\n      this.clickHandlerRegistered = !!document.body;\n    }\n    this.wasTouch = false;\n  }\n\n  private onTouchEnd() {\n    this.wasTouch = !this.ignoring;\n  }\n\n  private onClick(event: MouseEvent) {\n    const { wasTouch } = this;\n    this.wasTouch = false;\n    if (wasTouch) {\n      this.onTouchClick?.(event);\n    }\n  }\n}\n","/// <reference path=\"../common/constants.d.ts\" />\n\n/*\n\n  10ten Japanese Reader\n  by Brian Birtles\n  https://github.com/birchill/10ten-ja-reader\n\n  ---\n\n  Originally based on Rikaikun\n  by Erek Speed\n  http://code.google.com/p/rikaikun/\n\n  ---\n\n  Originally based on Rikaichan 1.07\n  by Jonathan Zarate\n  http://www.polarcloud.com/\n\n  ---\n\n  Originally based on RikaiXUL 0.4 by Todd Rudick\n  http://www.rikai.com/\n  http://rikaixul.mozdev.org/\n\n  ---\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation; either version 2 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n  ---\n\n  Please do not change or remove any of the copyrights or links to web pages\n  when modifying any of the files. - Jon\n\n*/\nimport type { MajorDataSeries } from '@birchill/jpdict-idb';\nimport * as s from 'superstruct';\nimport browser, { Runtime } from 'webextension-polyfill';\n\nimport { BackgroundMessageSchema } from '../background/background-message';\nimport {\n  AutoExpandableEntry,\n  ContentConfigParams,\n} from '../common/content-config-params';\nimport { CopyKeys, CopyType } from '../common/copy-keys';\nimport { isEditableNode, isInteractiveElement } from '../utils/dom-utils';\nimport {\n  MarginBox,\n  Point,\n  Rect,\n  addMarginToPoint,\n  getMarginAroundPoint,\n  union,\n} from '../utils/geometry';\nimport { mod } from '../utils/mod';\nimport { stripFields } from '../utils/strip-fields';\nimport { WithRequired } from '../utils/type-helpers';\nimport { isSafari } from '../utils/ua-utils';\n\nimport { copyText } from './clipboard';\nimport { ContentConfig, ContentConfigChange } from './content-config';\nimport { CopyEntry, getTextToCopy } from './copy-text';\nimport { injectGdocsStyles, removeGdocsStyles } from './gdocs-canvas';\nimport { getCopyEntryFromResult } from './get-copy-entry';\nimport { getTextAtPoint } from './get-text';\nimport {\n  IframeSearchParams,\n  IframeSourceParams,\n  findIframeElement,\n  getIframeOrigin,\n  getWindowDimensions,\n} from './iframes';\nimport { hasModifiers, normalizeKey, normalizeKeys } from './keyboard';\nimport { SelectionMeta } from './meta';\nimport { DisplayMode, PopupState, clearPopupTimeout } from './popup-state';\nimport { type CopyState, getCopyMode } from './popup/copy-state';\nimport {\n  hidePopup,\n  isPopupVisible,\n  removePopup,\n  setFontFace,\n  setFontSize,\n  setPopupStyle,\n} from './popup/popup';\nimport { isPopupWindowHostElem } from './popup/popup-container';\nimport {\n  type PopupPositionConstraints,\n  PopupPositionMode,\n} from './popup/popup-position';\nimport { type ShowPopupOptions, showPopup } from './popup/show-popup';\nimport {\n  LookupPuck,\n  PuckPointerEvent,\n  isPuckPointerEvent,\n  removePuck,\n} from './puck';\nimport { QueryResult, query } from './query';\nimport { SafeAreaProvider, removeSafeAreaProvider } from './safe-area-provider';\nimport { getScrollOffset, toPageCoords, toScreenCoords } from './scroll-offset';\nimport {\n  type SelectionSizes,\n  type TargetProps,\n  getBestFitSize,\n  getPageTargetProps,\n  selectionSizesToScreenCoords,\n  textBoxSizeLengths,\n} from './target-props';\nimport { TextHighlighter } from './text-highlighter';\nimport { TextRange, textRangesEqual } from './text-range';\nimport { hasReasonableTimerResolution } from './timer-precision';\nimport { TouchClickTracker } from './touch-click-tracker';\n\nconst enum HoldToShowKeyType {\n  None = 0,\n  Text = 1 << 0,\n  Images = 1 << 1,\n  All = Text | Images,\n}\n\nexport class ContentHandler {\n  // The content script is injected into every frame in a page but we delegate\n  // some responsibilities to the top-most window since that allows us to,\n  // for example, show the popup without it being clipped by its iframe\n  // boundary. Furthermore, we want to handle key events regardless of which\n  // iframe is currently in focus.\n  //\n  // As a result, we can divide the state and methods in this class into:\n  //\n  // 1. Things done by the window / iframe where the text lives,\n  //    e.g. processing mouse events, extracting text, highlighting text, etc.\n  //\n  // 2. Things only the topmost window does,\n  //    e.g. querying the dictionary, showing the popup, etc.\n  //\n  // There are a few exceptions like copyMode which is mirrored in both and\n  // popup visibility tracking which only iframes need to care about but\n  // roughly these categories hold.\n  //\n  // One day we might actually separating these out into separate classes but\n  // for now we just document which is which here.\n\n  //\n  // Common concerns\n  //\n  private config: ContentConfig;\n  private frameId: number | undefined;\n\n  //\n  // Text handling window concerns\n  //\n  private textHighlighter: TextHighlighter;\n\n  private currentTextRange: TextRange | undefined;\n  // The current point is used both by the text handling window to detect\n  // redundant mouse moves and by the topmost window to know where to position\n  // the popup.\n  private currentPagePoint: Point | undefined;\n\n  // We keep track of the last element that was the target of a mouse move so\n  // that we can popup the window later using its properties.\n  private lastMouseTarget: Element | null = null;\n  private lastMouseMoveScreenPoint = { x: -1, y: -1 };\n\n  // Safari-only redundant pointermove/mousemove event handling\n  //\n  // See notes in `onPointerMove` for why we need to do this.\n  private ignoreNextPointerMove = false;\n\n  // Track the state of the popup\n  //\n  // This is used by top-most windows and child iframes alike to detect if\n  // a mouse movement is \"between\" `currentPoint` and the popup so we can avoid\n  // hiding the popup in that case (provided the popup is configured to be\n  // interactive).\n  //\n  // Note, however, that the position of the popup (i.e. the `pos` member) is\n  // only ever stored on the top-most window and on the child iframe which\n  // contains the content that the popup is positioned relative to (if any).\n  //\n  // This is also used to determine how to handle keyboard keys since. For\n  // example, we should ignore keyboard events (and certainly _not_ call\n  // preventDefault on them) if the popup is not showing.\n  private popupState: PopupState | undefined;\n\n  // Mouse tracking\n  //\n  // We don't show the popup when the mouse is moving at speed because it's\n  // mostly distracting and introduces unnecessary work.\n  private static MOUSE_SPEED_SAMPLES = 2;\n  private static MOUSE_SPEED_THRESHOLD = 0.5;\n\n  private mouseSpeedRollingSum = 0;\n  private mouseSpeeds: Array<number> = [];\n  private previousMousePosition: Point | undefined;\n  private previousMouseMoveTime: number | undefined;\n  // We disable this feature by default and only turn it on once we've\n  // established that we have a sufficiently precise timer. If\n  // privacy.resistFingerprinting is enabled then the timer won't be precise\n  // enough for us to test the speed of the mouse.\n  private hidePopupWhenMovingAtSpeed = false;\n\n  // Keyboard support\n  private kanjiLookupMode = false;\n  private pinToggleState: 'idle' | 'keydown' | 'ignore' = 'idle';\n\n  // Used to try to detect when we are typing so we know when to ignore key\n  // events.\n  private typingMode = false;\n\n  // Detect touch taps so we can show the popup for them, but not for\n  // regular mouse clicks.\n  private touchClickTracker: TouchClickTracker = new TouchClickTracker();\n\n  //\n  // Top-most window concerns\n  //\n\n  // This should be enough for most (but not all) entries for now.\n  //\n  // See https://github.com/birchill/10ten-ja-reader/issues/319#issuecomment-655545971\n  // for a snapshot of the entry lengths by frequency.\n  //\n  // Once we have switched all databases to IndexedDB, we should investigate the\n  // performance impact of increasing this further.\n  private static MAX_LENGTH = 16;\n\n  private isEffectiveTopMostWindow = false;\n\n  private currentLookupParams:\n    | {\n        text: string;\n        wordLookup: boolean;\n        meta?: SelectionMeta;\n        source: IframeSourceParams | null;\n      }\n    | undefined;\n  private currentSearchResult: QueryResult | undefined;\n  private currentTargetProps: TargetProps | undefined;\n  private currentDict: MajorDataSeries = 'words';\n\n  // Copy support\n  //\n  // (copyMode is actually used by the text-handling window too to know which\n  // keyboard events to handle and how to interpret them.)\n  private copyState: CopyState = { kind: 'inactive' };\n\n  // Manual positioning support\n  private popupPositionMode: PopupPositionMode = PopupPositionMode.Auto;\n\n  // Content collapsing\n  private isPopupExpanded = false;\n\n  // Consulted in order to determine safe area\n  private safeAreaProvider: SafeAreaProvider = new SafeAreaProvider();\n\n  // Consulted in order to determine popup positioning\n  private puck: LookupPuck | null = null;\n\n  constructor(config: ContentConfigParams) {\n    this.config = new ContentConfig(config);\n    this.textHighlighter = new TextHighlighter();\n\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.onMouseDown = this.onMouseDown.bind(this);\n    this.onKeyDown = this.onKeyDown.bind(this);\n    this.onKeyUp = this.onKeyUp.bind(this);\n    this.onFocusIn = this.onFocusIn.bind(this);\n    this.onFullScreenChange = this.onFullScreenChange.bind(this);\n    this.onInterFrameMessage = this.onInterFrameMessage.bind(this);\n    this.onBackgroundMessage = this.onBackgroundMessage.bind(this);\n\n    this.onConfigChange = this.onConfigChange.bind(this);\n    this.config.addListener(this.onConfigChange);\n\n    window.addEventListener('pointermove', this.onPointerMove);\n    window.addEventListener('mousedown', this.onMouseDown);\n    window.addEventListener('keydown', this.onKeyDown, { capture: true });\n    window.addEventListener('keyup', this.onKeyUp, { capture: true });\n    window.addEventListener('focusin', this.onFocusIn);\n    window.addEventListener('fullscreenchange', this.onFullScreenChange);\n    window.addEventListener('message', this.onInterFrameMessage, {\n      capture: true,\n    });\n    browser.runtime.onMessage.addListener(this.onBackgroundMessage);\n\n    this.touchClickTracker.onTouchClick = (event: MouseEvent) => {\n      // Ignore clicks on interactive elements\n      if (event.target instanceof Node && isInteractiveElement(event.target)) {\n        return;\n      }\n\n      // If the puck is showing but inactive, use that as a signal that the user\n      // doesn't want to do lookups at the moment.\n      if (this.puck?.getEnabledState() === 'inactive') {\n        return;\n      }\n\n      // We need to ensure the 'buttons' field of the event is zero since\n      // normally we ignore mousemoves when the buttons are being pressed, but\n      // we've decided to allow this \"click\".\n      //\n      // This is, unfortunately, a little involved since:\n      //\n      // (a) the 'buttons' member of `event` is readonly,\n      // (b) the object spread operator only deals with enumerable _own_\n      //     properties so we can't just spread the values from `event` into a\n      //     new object, and\n      // (c) we use `getModifierState` etc. on `PointerEvent` elsewhere so we\n      //     actually need to generate a `PointerEvent` object rather than just\n      //     a property bag.\n      const pointerMoveEvent = new PointerEvent('pointermove', {\n        altKey: event.altKey,\n        bubbles: true,\n        button: 0,\n        buttons: 0,\n        clientX: event.clientX,\n        clientY: event.clientY,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        pointerType: 'mouse',\n        relatedTarget: event.relatedTarget,\n        screenX: event.screenX,\n        screenY: event.screenY,\n        shiftKey: event.shiftKey,\n      });\n      (pointerMoveEvent as TouchClickEvent).fromTouch = true;\n\n      (event.target || document.body).dispatchEvent(pointerMoveEvent);\n    };\n\n    if (!this.config.enableTapLookup) {\n      this.touchClickTracker.disable();\n    }\n\n    void hasReasonableTimerResolution().then((isReasonable) => {\n      if (isReasonable) {\n        this.hidePopupWhenMovingAtSpeed = true;\n      }\n    });\n\n    // If we are an iframe, check if the popup is currently showing\n    if (!this.isTopMostWindow()) {\n      void browser.runtime.sendMessage({ type: 'top:isPopupShowing' });\n    }\n\n    this.applyPuckConfig();\n\n    if (document.location.host === 'docs.google.com') {\n      injectGdocsStyles();\n    }\n  }\n\n  applyPuckConfig() {\n    if (!this.isTopMostWindow()) {\n      return;\n    }\n\n    if (this.config.showPuck === 'show') {\n      this.setUpPuck();\n    } else {\n      this.tearDownPuck();\n    }\n  }\n\n  setUpPuck() {\n    if (!this.puck) {\n      this.puck = new LookupPuck({\n        initialPosition: this.config.puckState,\n        safeAreaProvider: this.safeAreaProvider,\n        onLookupDisabled: () => {\n          this.clearResult();\n        },\n        onPuckStateChanged: (state) => {\n          void browser.runtime.sendMessage({\n            type: 'puckStateChanged',\n            value: state,\n          });\n        },\n      });\n    }\n\n    this.puck.render({\n      icon: this.config.toolbarIcon,\n      theme: this.config.popupStyle,\n    });\n    this.puck.setEnabledState(\n      this.config.puckState?.active === false ? 'inactive' : 'active'\n    );\n  }\n\n  tearDownPuck() {\n    this.puck?.unmount();\n    this.puck = null;\n\n    removePuck();\n  }\n\n  setConfig(config: Readonly<ContentConfigParams>) {\n    this.config.set(config);\n  }\n\n  get canHover() {\n    return this.config.canHover;\n  }\n\n  onConfigChange(changes: readonly ContentConfigChange[]) {\n    for (const { key, value } of changes) {\n      switch (key) {\n        case 'accentDisplay':\n        case 'posDisplay':\n        case 'readingOnly':\n        case 'showKanjiComponents':\n        case 'showPriority':\n        case 'tabDisplay':\n          if (this.isTopMostWindow()) {\n            this.updatePopup();\n          }\n          break;\n\n        case 'enableTapLookup':\n          if (value) {\n            this.touchClickTracker.enable();\n          } else {\n            this.touchClickTracker.disable();\n          }\n          break;\n\n        case 'fontFace':\n          setFontFace(value);\n          break;\n\n        case 'fontSize':\n          setFontSize(value);\n          break;\n\n        case 'showRomaji':\n          // Enabling romaji currently means we need to re-run the lookup\n          if (\n            this.isTopMostWindow() &&\n            this.currentLookupParams &&\n            this.currentTargetProps\n          ) {\n            const lookupParams: Parameters<typeof this.lookupText>[0] = {\n              dictMode: 'default',\n              ...this.currentLookupParams,\n              targetProps: this.currentTargetProps,\n            };\n\n            void this.lookupText(lookupParams);\n          }\n          break;\n\n        case 'popupInteractive':\n          if (this.isTopMostWindow()) {\n            // We can't use updatePopup here since it will try to re-use the\n            // existing popup display mode but we specifically want to change it\n            // in this case.\n            this.showPopup({\n              allowOverlap: this.popupState?.pos?.allowOverlap,\n              displayMode: value ? 'hover' : 'static',\n            });\n          }\n          break;\n\n        case 'popupStyle':\n          setPopupStyle(value);\n          this.puck?.setTheme(value);\n          break;\n\n        case 'puckState':\n          if (value) {\n            this.puck?.setState(value);\n          }\n          break;\n\n        case 'showPuck':\n          this.applyPuckConfig();\n          break;\n\n        case 'toolbarIcon':\n          this.puck?.setIcon(value);\n          break;\n\n        case 'canHover':\n          void browser.runtime.sendMessage({ type: 'canHoverChanged', value });\n          break;\n      }\n    }\n  }\n\n  onDbUpdated() {\n    // Re-trigger lookup now that the database has been updated (typically going\n    // from being in the initial updating state to the updated state).\n    if (\n      this.isTopMostWindow() &&\n      this.currentLookupParams &&\n      this.currentTargetProps\n    ) {\n      const lookupParams: Parameters<typeof this.lookupText>[0] = {\n        dictMode: 'default',\n        ...this.currentLookupParams,\n        targetProps: this.currentTargetProps,\n      };\n\n      void this.lookupText(lookupParams);\n    }\n  }\n\n  detach() {\n    this.config.removeListener(this.onConfigChange);\n\n    window.removeEventListener('pointermove', this.onPointerMove);\n    window.removeEventListener('mousedown', this.onMouseDown);\n    window.removeEventListener('keydown', this.onKeyDown, { capture: true });\n    window.removeEventListener('keyup', this.onKeyUp, { capture: true });\n    window.removeEventListener('focusin', this.onFocusIn);\n    window.removeEventListener('fullscreenchange', this.onFullScreenChange);\n    window.removeEventListener('message', this.onInterFrameMessage, {\n      capture: true,\n    });\n    browser.runtime.onMessage.removeListener(this.onBackgroundMessage);\n\n    this.clearResult();\n    this.tearDownPuck();\n\n    this.textHighlighter.detach();\n    this.copyState = { kind: 'inactive' };\n    this.isPopupExpanded = false;\n    this.safeAreaProvider.destroy();\n    this.touchClickTracker.destroy();\n\n    removePopup();\n    removeGdocsStyles();\n  }\n\n  setEffectiveTopMostWindow() {\n    const wasTopMost = this.isTopMostWindow();\n    this.isEffectiveTopMostWindow = true;\n\n    // If we are now the top most we might now be the puck host\n    if (!wasTopMost) {\n      this.applyPuckConfig();\n    }\n  }\n\n  isTopMostWindow() {\n    // If a descendant of an iframe is being displayed full-screen, that iframe\n    // can temporarily act as the topmost window.\n    if (document.fullscreenElement) {\n      if (document.fullscreenElement.tagName === 'IFRAME') {\n        return false;\n      }\n      if (document.fullscreenElement.ownerDocument === document) {\n        return true;\n      }\n    }\n\n    return (\n      this.isEffectiveTopMostWindow || window.self === this.getTopMostWindow()\n    );\n  }\n\n  getTopMostWindow() {\n    return this.isEffectiveTopMostWindow\n      ? window.self\n      : window.top || window.self;\n  }\n\n  getFrameId(): number | undefined {\n    if (typeof this.frameId === 'number') {\n      return this.frameId;\n    }\n\n    if (typeof browser.runtime.getFrameId === 'function') {\n      const frameId = browser.runtime.getFrameId(window);\n      if (frameId !== -1) {\n        return frameId;\n      }\n    }\n\n    return undefined;\n  }\n\n  setFrameId(frameId: number) {\n    this.frameId = frameId;\n  }\n\n  onPointerMove(event: PointerEvent) {\n    this.typingMode = false;\n\n    // Safari has an odd bug where it dispatches extra pointermove/mousemove\n    // events when you press any modifier key (e.g. Shift).\n    //\n    // It goes something like this:\n    //\n    // * Press Shift down\n    // -> mousemove with shiftKey = true\n    // -> keydown with shiftKey = true\n    //\n    // * Release Shift key\n    // -> mousemove with shiftKey = false\n    // -> keyup with shiftKey = false\n    //\n    // We really need to ignore these events since they will intefere with\n    // detecting taps of the \"pin popup\" key as well as when using Shift to only\n    // show kanji.\n    //\n    // For now the best way we know of doing that is to just check if the\n    // position has changed.\n    //\n    // 2022-09-12: This is tracked as WebKit bug\n    // https://bugs.webkit.org/show_bug.cgi?id=16271\n    // which was apparently fixed in July 2021 but in September 2022 I can still\n    // reproduce it, at least with the control key.\n    //\n    // 2023-08-03: It looks like this was finally fixed in May 2023 in\n    // https://github.com/WebKit/WebKit/pull/14221\n    // It will be some time before that's available in release Safari everywhere\n    // we care about.\n    if (isSafari()) {\n      if (\n        (event.shiftKey ||\n          event.altKey ||\n          event.metaKey ||\n          event.ctrlKey ||\n          this.ignoreNextPointerMove) &&\n        this.lastMouseMoveScreenPoint.x === event.clientX &&\n        this.lastMouseMoveScreenPoint.y === event.clientY\n      ) {\n        // We need to ignore the mousemove event corresponding to the keyup\n        // event too.\n        this.ignoreNextPointerMove = !this.ignoreNextPointerMove;\n        return;\n      }\n\n      this.ignoreNextPointerMove = false;\n    }\n    this.lastMouseMoveScreenPoint = { x: event.clientX, y: event.clientY };\n\n    // If we start moving the mouse, we should stop trying to recognize a tap on\n    // the \"pin\" key as such since it's no longer a tap (and very often these\n    // keys overlap with the hold-to-show keys which are held while moving the\n    // mouse).\n    //\n    // Note that it's not enough just to check if `pinToggleState` is in the\n    // 'keydown' state because it seems like sometimes browsers (at least\n    // Firefox) batch up input events so that all the mousemove events arrive\n    // before the keyboard events.\n    //\n    // In order to handle that case, we need to check if the relevant key for\n    // pinning are being held (and hence we are likely to get a keydown event\n    // soon).\n    if (\n      this.pinToggleState === 'keydown' ||\n      (this.pinToggleState === 'idle' && this.hasPinKeysPressed(event))\n    ) {\n      this.pinToggleState = 'ignore';\n    }\n\n    // Ignore mouse events while buttons are being pressed.\n    if (event.buttons) {\n      return;\n    }\n\n    // If we are ignoring taps, ignore events that are not from the mouse\n    //\n    // You might think, \"Why don't we just listen for mousemove events in the\n    // first place?\" but iOS Safari will dispatch mousemove events for touch\n    // events too (e.g. if you start to select text) and we need to ignore them\n    // so we need to know what kind of \"mousemove\" event we got.\n    //\n    // If we are NOT ignoring taps then we probably should allow other pointer\n    // types since it's probably useful to look up things with a pen?\n    if (!this.config.enableTapLookup && event.pointerType !== 'mouse') {\n      return;\n    }\n\n    // We don't know how to deal with anything that's not an element\n    if (!(event.target instanceof Element)) {\n      return;\n    }\n\n    // Ignore mouse moves if we are pinned\n    if (\n      !isTouchClickEvent(event) &&\n      this.popupState?.display.mode === 'pinned'\n    ) {\n      this.lastMouseTarget = event.target;\n      return;\n    }\n\n    // Ignore mouse events on the popup window\n    if (isPopupWindowHostElem(event.target)) {\n      return;\n    }\n\n    // Check if we have released the hold-to-show keys such that a ghosted popup\n    // should be committed.\n    //\n    // Normally we'd handle this case in onKeyUp, but it's possible, even common\n    // to have the focus in a different window/frame while mousing over content.\n    //\n    // Our window/frame will still get mousemove events with the corresponding\n    // modifier key attributes set so we can _show_ the popup, but we _won't_\n    // get the `keyup` event(s) when the modifier(s) are released so instead\n    // we need to try and detect when that happens on the next mousemove event.\n    if (\n      !isTouchClickEvent(event) &&\n      this.popupState?.display.mode === 'ghost' &&\n      this.popupState.display.trigger === 'keys' &&\n      !(this.getActiveHoldToShowKeys(event) & this.popupState.display.keyType)\n    ) {\n      this.commitPopup();\n      return;\n    }\n\n    // Check if any required \"hold to show keys\" are held.\n    //\n    // We do this before checking throttling since that can be expensive and\n    // when this is configured, typically the user will have the extension\n    // more-or-less permanently enabled so we don't want to add unnecessary\n    // latency to regular mouse events.\n    //\n    // Note that the \"hold to show keys\" setting is only relevant for mouse\n    // events, not puck events.\n    const contentsToMatch =\n      this.getActiveHoldToShowKeys(event) |\n      (isPuckPointerEvent(event) || isTouchClickEvent(event)\n        ? HoldToShowKeyType.All\n        : 0);\n    const matchText = !!(contentsToMatch & HoldToShowKeyType.Text);\n    const matchImages = !!(contentsToMatch & HoldToShowKeyType.Images);\n\n    // If nothing is going to match, close the popup. If we're in hover mode,\n    // however, we need to proceed with the regular processing to see if we are\n    // hovering over the arrow area or not.\n    //\n    // (For pinned mode and touch mode, contentsToMatch is guaranteed to be\n    // non-zero. For static mode we certainly want to close the popup, and we\n    // never seem to hit this case in ghost mode but presumably if we did we'd\n    // want to close the popup.)\n    if (!contentsToMatch && this.popupState?.display.mode !== 'hover') {\n      if (this.popupState) {\n        this.clearResult({ currentElement: event.target });\n      }\n\n      // We still want to set the current position and element information so\n      // that if the user presses the hold-to-show keys later we can show the\n      // popup immediately.\n      this.currentPagePoint = toPageCoords({\n        x: event.clientX,\n        y: event.clientY,\n      });\n      this.lastMouseTarget = event.target;\n      return;\n    }\n\n    // If the mouse have moved in a triangular shape between the original popup\n    // point and the popup, don't hide it, but instead allow the user to\n    // interact with the popup.\n    if (this.isEnRouteToPopup(event)) {\n      return;\n    }\n\n    // If the mouse is moving too quickly, don't show the popup\n    if (this.shouldThrottlePopup(event)) {\n      this.clearResult({ currentElement: event.target });\n      return;\n    }\n\n    let dictMode: 'default' | 'kanji' = 'default';\n    if (event.shiftKey && this.config.keys.kanjiLookup.includes('Shift')) {\n      this.kanjiLookupMode = event.shiftKey;\n      dictMode = 'kanji';\n    }\n\n    // Record the last mouse target in case we need to trigger the popup\n    // again.\n    this.lastMouseTarget = event.target;\n\n    void this.tryToUpdatePopup({\n      fromPuck: isPuckPointerEvent(event),\n      fromTouch: isTouchClickEvent(event),\n      matchText,\n      matchImages,\n      screenPoint: { x: event.clientX, y: event.clientY },\n      eventElement: event.target,\n      dictMode,\n    });\n  }\n\n  isEnRouteToPopup(event: PointerEvent) {\n    if (isPuckPointerEvent(event) || isTouchClickEvent(event)) {\n      return false;\n    }\n\n    if (\n      this.popupState?.display.mode !== 'hover' ||\n      !this.popupState.pos?.lookupPoint\n    ) {\n      return false;\n    }\n\n    const {\n      x: popupX,\n      y: popupY,\n      width: popupWidth,\n      height: popupHeight,\n      direction,\n      lookupPoint: {\n        x: lookupX,\n        y: lookupY,\n        marginX: lookupMarginX,\n        marginY: lookupMarginY,\n      },\n    } = this.popupState.pos;\n\n    // If the popup is not related to the mouse position we don't want to allow\n    // mousing over it as it might require making most of the screen\n    // un-scannable.\n    if (direction === 'disjoint') {\n      return false;\n    }\n\n    // Check block axis range\n\n    const lookupBlockPos = direction === 'vertical' ? lookupY : lookupX;\n\n    // Get the closest edge of the popup edge\n    const popupBlockPos = direction === 'vertical' ? popupY : popupX;\n    const popupBlockSize = direction === 'vertical' ? popupHeight : popupWidth;\n    const popupEdge =\n      popupBlockPos >= lookupBlockPos\n        ? popupBlockPos\n        : popupBlockPos + popupBlockSize;\n\n    // Work out the distance between the lookup point and the edge of the popup\n    const popupDist = popupEdge - lookupBlockPos;\n\n    // Work out the mouse distance from the lookup point\n    //\n    // NOTE: We _don't_ want to use event.pageY/pageX since that will return the\n    // wrong result when we are in full-screen mode. Instead we should manually\n    // add the scroll offset in.\n    const { scrollX, scrollY } = getScrollOffset();\n    const mouseBlockPos =\n      direction === 'vertical'\n        ? event.clientY + scrollY\n        : event.clientX + scrollX;\n\n    // Work out the portion of the distance we are in the gap between the lookup\n    // point and the edge of the popup.\n    const blockOffset =\n      popupDist < 0\n        ? lookupBlockPos - mouseBlockPos\n        : mouseBlockPos - lookupBlockPos;\n    const blockRange = Math.abs(popupDist);\n    const blockMargin =\n      direction === 'vertical' ? lookupMarginY : lookupMarginX;\n\n    // Check if we are in the gap (or the margin)\n    if (blockOffset < -blockMargin || blockOffset > blockRange) {\n      return false;\n    }\n\n    // Check the inline range\n    //\n    // We do this by basically drawing a triangle from the lookup point spanning\n    // outwards towards the edge of the popup using the defined angle.\n    //\n    // e.g.\n    //\n    //                    +\n    //                  /  \\\n    //                 / x  \\\n    //                /<-D-->\\\n    //               /        \\\n    //  +----------------------------------------------+\n    //  |           <----B---->                        |\n    //  |           ^                                  |\n    //  |           C                                  |\n    //  A\n    //\n    // + = Lookup point (lookup inline position)\n    // x = Mouse position\n    // A = Inline popup start\n    // B = Max inline range (i.e. the inline range at the edge)\n    // C = Max inline range start\n    // D = Proportional inline range\n\n    const lookupInlinePos = direction === 'vertical' ? lookupX : lookupY;\n\n    const mouseInlinePos =\n      direction === 'vertical'\n        ? event.clientX + scrollX\n        : event.clientY + scrollY;\n\n    const ENVELOPE_SPREAD_DEGREES = 120;\n    const inlineHalfRange =\n      Math.tan(((ENVELOPE_SPREAD_DEGREES / 2) * Math.PI) / 180) * blockOffset;\n    const inlineMargin =\n      direction === 'vertical' ? lookupMarginX : lookupMarginY;\n    const inlineRangeStart =\n      lookupInlinePos - Math.max(inlineHalfRange, inlineMargin);\n    const inlineRangeEnd =\n      lookupInlinePos + Math.max(inlineHalfRange, inlineMargin);\n\n    if (mouseInlinePos < inlineRangeStart || mouseInlinePos > inlineRangeEnd) {\n      return false;\n    }\n\n    return true;\n  }\n\n  shouldThrottlePopup(event: PointerEvent) {\n    if (!this.hidePopupWhenMovingAtSpeed) {\n      return false;\n    }\n\n    let averageSpeed = 0;\n\n    if (this.previousMousePosition && this.previousMouseMoveTime) {\n      // If the events are backed up their times might be equal. Likewise, if\n      // the events are more than a couple of animation frames apart either the\n      // mouse stopped, or the system is backed up and the OS can't even\n      // dispatch the events.\n      //\n      // In either case we should:\n      //\n      // - Update the previous mouse position and time so that when we get the\n      //   *next* event we can accurately measure the speed.\n      //\n      // - Not throttle the popup since for some content we might always be\n      //   backed up (YouTube with browser console open seems particularly bad)\n      //   and its safer to just allow the popup in this case rather than risk\n      //   permanently hiding it.\n      //\n      if (\n        event.timeStamp === this.previousMouseMoveTime ||\n        event.timeStamp - this.previousMouseMoveTime > 32\n      ) {\n        this.previousMousePosition = { x: event.pageX, y: event.pageY };\n        this.previousMouseMoveTime = event.timeStamp;\n        return false;\n      }\n\n      const distance = Math.sqrt(\n        Math.pow(event.pageX - this.previousMousePosition.x, 2) +\n          Math.pow(event.pageY - this.previousMousePosition.y, 2)\n      );\n      const speed = distance / (event.timeStamp - this.previousMouseMoveTime);\n\n      this.mouseSpeeds.push(speed);\n      this.mouseSpeedRollingSum += speed;\n\n      if (this.mouseSpeeds.length > ContentHandler.MOUSE_SPEED_SAMPLES) {\n        this.mouseSpeedRollingSum -= this.mouseSpeeds.shift()!;\n      }\n\n      averageSpeed = this.mouseSpeedRollingSum / this.mouseSpeeds.length;\n    }\n\n    this.previousMousePosition = { x: event.pageX, y: event.pageY };\n    this.previousMouseMoveTime = event.timeStamp;\n\n    return averageSpeed >= ContentHandler.MOUSE_SPEED_THRESHOLD;\n  }\n\n  onMouseDown(event: MouseEvent) {\n    // Ignore mouse events on the popup window\n    if (isPopupWindowHostElem(event.target)) {\n      return;\n    }\n\n    // Clear the highlight since it interferes with selection.\n    this.clearResult({ currentElement: event.target as Element });\n  }\n\n  onKeyDown(event: KeyboardEvent) {\n    const textBoxInFocus =\n      document.activeElement && isEditableNode(document.activeElement);\n\n    // If the user pressed the hold-to-show key combination, show the popup\n    // if possible.\n    //\n    // It's important we only do this when the popup is not visible, however,\n    // since these keys may overlap with the keys we've defined for pinning the\n    // popup--which only apply when the popup is visible.\n    const matchedHoldToShowKeys = this.isHoldToShowKeyStroke(event);\n    if (matchedHoldToShowKeys && !this.isVisible()) {\n      event.preventDefault();\n\n      // We don't do this when the there is a text box in focus because we\n      // we risk interfering with the text selection when, for example, the\n      // hold-to-show key is Ctrl and the user presses Ctrl+V etc.\n      if (!textBoxInFocus && this.currentPagePoint && this.lastMouseTarget) {\n        void this.tryToUpdatePopup({\n          fromPuck: false,\n          fromTouch: false,\n          matchText: !!(matchedHoldToShowKeys & HoldToShowKeyType.Text),\n          matchImages: !!(matchedHoldToShowKeys & HoldToShowKeyType.Images),\n          screenPoint: toScreenCoords(this.currentPagePoint),\n          eventElement: this.lastMouseTarget,\n          dictMode: 'default',\n        });\n      }\n      return;\n    }\n\n    // If we got shift in combination with something else, ignore.\n    //\n    // We need to allow shift by itself because it is used for switching\n    // dictionaries. However, if the user presses, Cmd + Shift + 3, for example,\n    // we should ignore the last two keystrokes.\n    //\n    // TODO: We should refine this somehow so that it's possible to toggle\n    // dictionaries using Shift while pressing the hold-to-show keys.\n    //\n    // See https://github.com/birchill/10ten-ja-reader/issues/658\n    if (\n      event.shiftKey &&\n      (event.ctrlKey || event.altKey || event.metaKey || event.key !== 'Shift')\n    ) {\n      this.typingMode = true;\n      return;\n    }\n\n    // If we're not visible we should ignore any keystrokes.\n    if (!this.isVisible()) {\n      this.typingMode = true;\n      return;\n    }\n\n    // If we're focussed on a text-editable node and in typing mode, don't try\n    // to handle keystrokes. This is so that if the user has accidentally left\n    // their mouse sitting over some Japanese text we don't interfere with\n    // typing.\n    //\n    // The one exception to this is Google Docs. In Google Docs when the\n    // document canvas is in focus it puts the focus on a contenteditable\n    // element in a 1 pixel high iframe.\n    //\n    // Normally, whenever we see a mousemove event we will reset the\n    // `typingMode` flag but becuase the iframe is only 1 pixel high, the iframe\n    // will never see those mousemove events and hence `typingMode` will only\n    // get cleared on the top-most document and not the iframe.\n    //\n    // The `keydown` events, however, will go to the iframe. If we ignore them\n    // because `typingMode` is true we will end up ignoring all keyboard events\n    // while the canvas is in focus.\n    //\n    // Instead we just allow these events through on Google docs and accept that\n    // if the popup is showing it might interfere with typing.\n    const isGoogleDocsIframe = () => {\n      try {\n        return (\n          // On Firefox the iframe src is javascript:undefined which ends up\n          // getting host docs.google.com, while on Chrome the iframe src is\n          // about:blank which has an empty host.\n          //\n          // We wrap the whole thing in try/catch because I'm paranoid about\n          // cross-origin things throwing security exceptions.\n          (document.location.host === 'docs.google.com' ||\n            window.top?.location.host === 'docs.google.com') &&\n          window.frameElement\n        );\n      } catch {\n        return false;\n      }\n    };\n\n    if (textBoxInFocus && this.typingMode && !isGoogleDocsIframe()) {\n      return;\n    }\n\n    if (this.handleKey(event)) {\n      // We handled the key stroke so we should break out of typing mode.\n      this.typingMode = false;\n\n      event.stopPropagation();\n      event.preventDefault();\n    } else if (textBoxInFocus) {\n      // If we are focussed on a textbox and the keystroke wasn't one we handle\n      // one, enter typing mode and hide the pop-up.\n      this.clearResult({\n        currentElement: this.lastMouseTarget,\n      });\n      this.typingMode = true;\n    }\n  }\n\n  onKeyUp(event: KeyboardEvent) {\n    // If we are showing a popup that required certain hold keys, check if they\n    // are now no longer held, and, if they are not, trigger an update of the\n    // popup where we mark it as interactive\n    if (\n      this.popupState?.display.mode === 'ghost' &&\n      this.popupState.display.trigger === 'keys' &&\n      !(this.getActiveHoldToShowKeys(event) & this.popupState.display.keyType)\n    ) {\n      this.commitPopup();\n    }\n\n    const pinPopup = normalizeKeys(this.config.keys.pinPopup);\n    // On Chrome, if we auto-fill a text box, the event.key member can be\n    // undefined.\n    const key = event.key ? normalizeKey(event.key) : '';\n    if (pinPopup.includes(key)) {\n      if (this.pinToggleState === 'keydown' && this.togglePin()) {\n        event.preventDefault();\n      }\n      this.pinToggleState = 'idle';\n    }\n\n    if (!this.kanjiLookupMode) {\n      return;\n    }\n\n    if (event.key === 'Shift') {\n      this.kanjiLookupMode = false;\n      event.preventDefault();\n    }\n  }\n\n  handleKey(event: KeyboardEvent): boolean {\n    // Make an upper-case version of the list of keys so that we can do\n    // a case-insensitive comparison. This is so that the keys continue to work\n    // even when the user has Caps Lock on.\n    const { keys } = this.config;\n    const [\n      nextDictionary,\n      toggleDefinition,\n      expandPopup,\n      closePopup,\n      pinPopup,\n      movePopupUp,\n      movePopupDown,\n      startCopy,\n    ] = [\n      normalizeKeys(keys.nextDictionary),\n      normalizeKeys(keys.toggleDefinition),\n      normalizeKeys(keys.expandPopup),\n      normalizeKeys(keys.closePopup),\n      normalizeKeys(keys.pinPopup),\n      normalizeKeys(keys.movePopupUp),\n      normalizeKeys(keys.movePopupDown),\n      normalizeKeys(keys.startCopy),\n    ];\n\n    const key = normalizeKey(event.key);\n\n    if (nextDictionary.includes(key)) {\n      // If we are in kanji lookup mode, ignore 'Shift' keydown events since it\n      // is also the key we use to trigger lookup mode.\n      if (key === 'SHIFT' && this.kanjiLookupMode) {\n        return true;\n      }\n      this.showNextDictionary();\n    } else if (toggleDefinition.includes(key)) {\n      try {\n        // We don't wait on the following because we're only really interested\n        // in synchronous failures which occur in some browsers when the content\n        // script is stale.\n        void browser.runtime.sendMessage({ type: 'toggleDefinition' });\n      } catch {\n        console.warn(\n          '[10ten-ja-reader] Failed to call toggleDefinition. The page might need to be refreshed.'\n        );\n        return false;\n      }\n      this.toggleDefinition();\n    } else if (movePopupDown.includes(key)) {\n      this.movePopup('down');\n    } else if (movePopupUp.includes(key)) {\n      this.movePopup('up');\n    } else if (\n      // It's important we _don't_ enter copy mode when the Ctrl key is being\n      // pressed since otherwise if the user simply wants to copy the selected\n      // text by pressing Ctrl+C they will end up entering copy mode.\n      !hasModifiers(event) &&\n      startCopy.includes(key)\n    ) {\n      if (\n        this.copyState.kind === 'inactive' ||\n        this.copyState.kind === 'finished'\n      ) {\n        this.enterCopyMode({ trigger: 'keyboard' });\n      } else {\n        this.nextCopyEntry();\n      }\n    } else if (this.copyState.kind !== 'inactive' && key === 'ESC') {\n      this.exitCopyMode();\n    } else if (expandPopup.includes(key)) {\n      this.expandPopup();\n    }\n    // This needs to come _after_ the above check so that if the user has\n    // configured Escape to close the popup but they are in copy mode, we first\n    // escape copy mode (and if they press it a second time we close the popup).\n    else if (closePopup.includes(key)) {\n      this.clearResult();\n    } else if (\n      pinPopup.includes(key) &&\n      // We don't want to detect a pin keystroke if we are still in the ghost\n      // state since otherwise when the hold-to-show keys and pin keys overlap\n      // we'll end up going straight into the pin state if the user happens\n      // to be still when they release the hold-to-show keys.\n      this.popupState?.display.mode !== 'ghost' &&\n      // Likewise if we got a mouse move since the first keydown event occurred\n      // we should ignore subsequent keydown events.\n      this.pinToggleState !== 'ignore'\n    ) {\n      this.pinToggleState = 'keydown';\n    } else if (this.isHoldToShowKeyStroke(event)) {\n      return true;\n    } else if (\n      this.copyState.kind !== 'inactive' &&\n      this.copyState.kind !== 'finished'\n    ) {\n      let copyType: CopyType | undefined;\n      for (const copyKey of CopyKeys) {\n        if (key === copyKey.key.toUpperCase()) {\n          copyType = copyKey.type;\n          break;\n        }\n      }\n\n      if (typeof copyType === 'undefined') {\n        // Unrecognized key\n        return false;\n      }\n\n      this.copyCurrentEntry(copyType);\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  onFocusIn(event: FocusEvent) {\n    if (this.textHighlighter.isUpdatingFocus()) {\n      return;\n    }\n\n    // If we focussed on a text box, assume we want to type in it and ignore\n    // keystrokes until we get another mousemove.\n    this.typingMode = !!event.target && isEditableNode(event.target as Node);\n\n    // If we entered typing mode clear the highlight.\n    if (this.typingMode) {\n      this.clearResult({ currentElement: this.lastMouseTarget });\n    }\n  }\n\n  // Test if an incoming keyboard event matches the hold-to-show key sequence.\n  isHoldToShowKeyStroke(event: KeyboardEvent): HoldToShowKeyType {\n    // Check if it is a modifier at all\n    if (!['Alt', 'AltGraph', 'Control'].includes(event.key)) {\n      return HoldToShowKeyType.None;\n    }\n\n    const definedKeys =\n      (this.config.holdToShowKeys.length ? HoldToShowKeyType.Text : 0) |\n      (this.config.holdToShowImageKeys.length ? HoldToShowKeyType.Images : 0);\n\n    return definedKeys & this.getActiveHoldToShowKeys(event);\n  }\n\n  // Test if hold-to-show keys are set for a given a UI event\n  getActiveHoldToShowKeys(\n    event: PointerEvent | KeyboardEvent\n  ): HoldToShowKeyType {\n    const areKeysDownForSetting = (\n      setting: 'holdToShowKeys' | 'holdToShowImageKeys'\n    ) => {\n      if (\n        typeof this.config[setting] === 'undefined' ||\n        !Array.isArray(this.config[setting]) ||\n        !this.config[setting].length\n      ) {\n        return true;\n      }\n\n      // Check if all the configured hold-to-show keys are pressed down\n      const hasAltGraph = event.getModifierState('AltGraph');\n      if (\n        this.config[setting].includes('Alt') &&\n        !event.altKey &&\n        !hasAltGraph\n      ) {\n        return false;\n      }\n      if (this.config[setting].includes('Ctrl') && !event.ctrlKey) {\n        return false;\n      }\n\n      return true;\n    };\n\n    return (\n      (areKeysDownForSetting('holdToShowKeys') ? HoldToShowKeyType.Text : 0) |\n      (areKeysDownForSetting('holdToShowImageKeys')\n        ? HoldToShowKeyType.Images\n        : 0)\n    );\n  }\n\n  hasPinKeysPressed(event: PointerEvent): boolean {\n    const pinPopupKeys = this.config.keys.pinPopup;\n    const hasAltGraph = event.getModifierState('AltGraph');\n    return (\n      (pinPopupKeys.includes('Ctrl') && event.ctrlKey) ||\n      (pinPopupKeys.includes('Alt') && (event.altKey || hasAltGraph))\n    );\n  }\n\n  isVisible(): boolean {\n    return this.isTopMostWindow() ? isPopupVisible() : !!this.popupState;\n  }\n\n  onFullScreenChange() {\n    if (this.popupState?.display.mode === 'pinned') {\n      this.unpinPopup();\n    }\n\n    // If entering / leaving fullscreen caused a change in who is the topmost\n    // window we might have some setup / clean up to do.\n    if (this.isTopMostWindow()) {\n      this.applyPuckConfig();\n    } else {\n      removePopup();\n      this.clearResult();\n      this.tearDownPuck();\n    }\n  }\n\n  onInterFrameMessage(event: MessageEvent) {\n    // NOTE: Please do not add additional messages here.\n    //\n    // We want to avoid using postMessage at all costs. Please see the rationale\n    // for this one exception here:\n    //\n    // https://github.com/birchill/10ten-ja-reader/issues/747#issuecomment-918774588\n    //\n    const PuckMovedMessageSchema = s.type({\n      type: s.literal('10ten(ja):puckMoved'),\n      clientX: s.number(),\n      clientY: s.number(),\n    });\n    if (!s.is(event.data, PuckMovedMessageSchema)) {\n      return;\n    }\n\n    // Make sure no-one else sees this message since some apps will get confused\n    // if they see unrecognized messages.\n    event.stopImmediatePropagation();\n    event.preventDefault();\n\n    const { clientX, clientY } = event.data;\n    const pointerEvent = new PointerEvent('pointermove', {\n      // Make sure the event bubbles up to the listener on the window\n      bubbles: true,\n      clientX,\n      clientY,\n      pointerType: 'mouse',\n    });\n    (pointerEvent as PuckPointerEvent).fromPuck = true;\n\n    const documentBody = window.self.document.body;\n    if (!documentBody) {\n      // Hasn't loaded yet\n      return;\n    }\n\n    documentBody.dispatchEvent(pointerEvent);\n  }\n\n  async onBackgroundMessage(request: unknown): Promise<string> {\n    s.assert(request, BackgroundMessageSchema);\n\n    // Most messages are targeted at specific frames and should only arrive\n    // there. However, Safari doesn't support sending to specific frames so we\n    // also explicitly indicate the target within each message so we can ignore\n    // those not intended for us.\n    if (request.frame === 'top' && !this.isTopMostWindow()) {\n      return 'ok';\n    }\n    if (request.frame === 'children' && this.isTopMostWindow()) {\n      return 'ok';\n    }\n    if (\n      typeof request.frame === 'number' &&\n      this.getFrameId() !== request.frame\n    ) {\n      return 'ok';\n    }\n\n    switch (request.type) {\n      case 'popupShown':\n        {\n          // Check if this request has translated the popup geometry for us\n          //\n          // If not, we should leave `pos` as undefined so we know not to use\n          // it.\n          let pos: PopupState['pos'];\n          const { pos: requestPos } = request.state;\n          if (requestPos && this.getFrameId() === requestPos.frameId) {\n            const { scrollX, scrollY } = getScrollOffset();\n            const { x, y, lookupPoint } = requestPos;\n            pos = {\n              ...requestPos,\n              x: x + scrollX,\n              y: y + scrollY,\n              lookupPoint: lookupPoint\n                ? {\n                    x: lookupPoint.x + scrollX,\n                    y: lookupPoint.y + scrollY,\n                    marginX: lookupPoint.marginX,\n                    marginY: lookupPoint.marginY,\n                  }\n                : undefined,\n            };\n          }\n\n          // We don't need to worry about clearing any timeout that may have\n          // been set in `this.popupState.ghost.timeout` because that timeout\n          // is cleared by the top-most window (which we are not).\n          this.popupState = { ...request.state, pos };\n        }\n        break;\n\n      case 'popupHidden':\n        this.currentTextRange = undefined;\n        this.currentPagePoint = undefined;\n        this.copyState = { kind: 'inactive' };\n        this.isPopupExpanded = false;\n        this.popupState = undefined;\n        break;\n\n      case 'isPopupShowing':\n        if (this.isVisible() && this.popupState) {\n          void browser.runtime.sendMessage({\n            type: 'frame:popupShown',\n            frameId: request.frameId,\n            state: this.getTranslatedPopupState(\n              { frameId: request.frameId },\n              this.popupState\n            ),\n          });\n        }\n        break;\n\n      case 'highlightText':\n        this.highlightText(request.length);\n        break;\n\n      case 'clearTextHighlight':\n        this.clearTextHighlight();\n        break;\n\n      case 'lookup':\n        {\n          const iframe = findIframeElement({\n            frameId: request.source.frameId,\n            initialSrc: request.source.initialSrc,\n            currentSrc: request.source.currentSrc,\n            dimensions: request.source.dimensions,\n          });\n\n          let iframeOriginPoint;\n          if (!iframe) {\n            console.warn(\"[10ten-ja-reader] Couldn't find iframe element\");\n            // Just use the top-left corner since that's probably better than\n            // not showing the popup at all.\n            iframeOriginPoint = { x: 0, y: 0 };\n          } else {\n            iframeOriginPoint = getIframeOrigin(iframe);\n          }\n\n          // Translate the point from the iframe's coordinate system to ours.\n          const { point } = request;\n          this.currentPagePoint = toPageCoords({\n            x: point.x + iframeOriginPoint.x,\n            y: point.y + iframeOriginPoint.y,\n          });\n\n          // Similarly translate any text box sizes.\n          let targetProps = request.targetProps as TargetProps;\n          if (targetProps.textBoxSizes) {\n            const scrollOffset = getScrollOffset();\n            targetProps = JSON.parse(JSON.stringify(targetProps));\n            const { textBoxSizes } = targetProps;\n            for (const size of textBoxSizeLengths) {\n              const { left, top, width, height } = textBoxSizes![size];\n\n              // We pass sizes around in screen coordinates but store them in\n              // page coordinates.\n              textBoxSizes![size] = toPageCoords(\n                {\n                  left: left + iframeOriginPoint.x,\n                  top: top + iframeOriginPoint.y,\n                  width,\n                  height,\n                },\n                scrollOffset\n              );\n            }\n          }\n\n          // We are doing a lookup based on an iframe's contents so we should\n          // clear any mouse target we previously stored.\n          this.lastMouseTarget = null;\n\n          const meta = request.meta as SelectionMeta | undefined;\n          void this.lookupText({\n            ...request,\n            meta,\n            targetProps,\n            source: request.source,\n          });\n        }\n        break;\n\n      case 'pinPopup':\n        this.pinPopup();\n        break;\n\n      case 'unpinPopup':\n        this.unpinPopup();\n        break;\n\n      case 'commitPopup':\n        this.commitPopup();\n        break;\n\n      case 'clearResult':\n        this.clearResult();\n        break;\n\n      case 'nextDictionary':\n        this.showNextDictionary();\n        break;\n\n      case 'toggleDefinition':\n        this.toggleDefinition();\n        break;\n\n      case 'expandPopup':\n        this.expandPopup();\n        break;\n\n      case 'movePopup':\n        this.movePopup(request.direction);\n        break;\n\n      case 'enterCopyMode':\n        this.enterCopyMode({ trigger: 'keyboard' });\n        break;\n\n      case 'exitCopyMode':\n        this.exitCopyMode();\n        break;\n\n      case 'nextCopyEntry':\n        this.nextCopyEntry();\n        break;\n\n      case 'copyCurrentEntry':\n        this.copyCurrentEntry(request.copyType);\n        break;\n    }\n\n    return 'ok';\n  }\n\n  showNextDictionary() {\n    if (!this.isTopMostWindow()) {\n      void browser.runtime.sendMessage({ type: 'top:nextDictionary' });\n      return;\n    }\n\n    if (this.currentPagePoint) {\n      this.showDictionary('next');\n    }\n  }\n\n  toggleDefinition() {\n    if (!this.isTopMostWindow()) {\n      void browser.runtime.sendMessage({ type: 'top:toggleDefinition' });\n      return;\n    }\n\n    this.config.readingOnly = !this.config.readingOnly;\n    this.updatePopup();\n  }\n\n  expandPopup() {\n    if (!this.isTopMostWindow()) {\n      void browser.runtime.sendMessage({ type: 'top:expandPopup' });\n      return;\n    }\n\n    if (this.isPopupExpanded) {\n      return;\n    }\n\n    this.isPopupExpanded = true;\n    this.updatePopup({ allowOverlap: true, fixPosition: true });\n  }\n\n  movePopup(direction: 'up' | 'down') {\n    if (!this.isTopMostWindow()) {\n      void browser.runtime.sendMessage({ type: 'top:movePopup', direction });\n      return;\n    }\n\n    if (direction === 'down') {\n      this.popupPositionMode =\n        (this.popupPositionMode + 1) % (PopupPositionMode.End + 1);\n    } else {\n      this.popupPositionMode = mod(\n        this.popupPositionMode - 1,\n        PopupPositionMode.End + 1\n      );\n    }\n    this.updatePopup();\n  }\n\n  enterCopyMode({\n    trigger,\n    index = 0,\n  }: {\n    trigger: 'keyboard' | 'touch' | 'mouse';\n    index?: number;\n  }) {\n    // In the iframe case, we mirror the copyMode state in both iframe and\n    // topmost window because:\n    //\n    // - The topmost window needs to know the copyMode state so that it can\n    //   render the popup correctly, but\n    // - The iframe needs to know the copyMode state so that it can determine\n    //   how to handle copyMode-specific keystrokes.\n    //\n    this.copyState = { kind: 'active', index, mode: trigger };\n\n    if (!this.isTopMostWindow()) {\n      console.assert(\n        trigger === 'keyboard',\n        \"[10ten-ja-reader] We probably should't be receiving touch or mouse events in the iframe\"\n      );\n      void browser.runtime.sendMessage({ type: 'top:enterCopyMode' });\n      return;\n    }\n\n    this.updatePopup({ allowOverlap: true, fixPosition: true });\n  }\n\n  exitCopyMode() {\n    // Use the existing copyState to determine if we need to maintain the popup\n    // size and position.\n    const fixPopup = this.shouldFixPopupWhenExitingCopyMode();\n\n    // As with enterCopyMode, we mirror the copyMode state in both iframe and\n    // topmost window.\n    this.copyState = { kind: 'inactive' };\n\n    if (!this.isTopMostWindow()) {\n      void browser.runtime.sendMessage({ type: 'top:exitCopyMode' });\n      return;\n    }\n\n    this.updatePopup({ fixPosition: fixPopup, fixMinHeight: fixPopup });\n  }\n\n  private shouldFixPopupWhenExitingCopyMode() {\n    return (\n      getCopyMode(this.copyState) === 'mouse' &&\n      // If the popup is pinned, there's no need to fix the height\n      this.popupState?.display.mode !== 'pinned'\n    );\n  }\n\n  nextCopyEntry() {\n    if (!this.isTopMostWindow()) {\n      void browser.runtime.sendMessage({ type: 'top:nextCopyEntry' });\n      return;\n    }\n\n    if (this.copyState.kind === 'active' || this.copyState.kind === 'error') {\n      this.copyState = {\n        kind: 'active',\n        index: this.copyState.index + 1,\n        mode: this.copyState.mode,\n      };\n    }\n    this.updatePopup({ fixPosition: true });\n  }\n\n  copyCurrentEntry(copyType: CopyType) {\n    if (!this.isTopMostWindow()) {\n      void browser.runtime.sendMessage({\n        type: 'top:copyCurrentEntry',\n        copyType,\n      });\n      return;\n    }\n\n    const copyEntry = this.getCopyEntry();\n    if (!copyEntry) {\n      return;\n    }\n\n    const textToCopy = getTextToCopy({\n      entry: copyEntry,\n      copyType,\n      getMessage: browser.i18n.getMessage.bind(browser.i18n),\n      includeAllSenses: this.config.copySenses !== 'first',\n      includePartOfSpeech: this.config.copyPos !== 'none',\n      includeLessCommonHeadwords: this.config.copyHeadwords !== 'common',\n      kanjiReferences: this.config.kanjiReferences,\n      showKanjiComponents: this.config.showKanjiComponents,\n    });\n\n    void this.copyString(textToCopy!, copyType);\n  }\n\n  private getCopyEntry(): CopyEntry | null {\n    if (this.copyState.kind !== 'active') {\n      console.error('[10ten-ja-reader] Expected to be in copy mode');\n      return null;\n    }\n\n    if (!this.currentSearchResult) {\n      return null;\n    }\n\n    const copyEntry = getCopyEntryFromResult({\n      result: this.currentSearchResult,\n      series: this.currentDict,\n      index: this.copyState.index,\n    });\n    if (!copyEntry) {\n      const fixPopup = this.shouldFixPopupWhenExitingCopyMode();\n      this.copyState = { kind: 'inactive' };\n      this.updatePopup({ fixPosition: fixPopup, fixMinHeight: fixPopup });\n    }\n\n    return copyEntry;\n  }\n\n  private async copyString(message: string, copyType: CopyType) {\n    if (this.copyState.kind === 'inactive') {\n      return;\n    }\n\n    const fixPopup = this.shouldFixPopupWhenExitingCopyMode();\n    const { index, mode } = this.copyState;\n    try {\n      await copyText(message);\n      this.copyState = { kind: 'finished', type: copyType, index, mode };\n    } catch (e) {\n      console.error(e);\n      this.copyState = { kind: 'error', index, mode };\n    }\n\n    this.updatePopup({ fixPosition: fixPopup, fixMinHeight: fixPopup });\n\n    // Reset the copy state so that it doesn't re-appear next time we re-render\n    // the popup.\n    this.copyState = { kind: 'inactive' };\n  }\n\n  highlightText(length: number) {\n    if (!this.currentTextRange?.length) {\n      return;\n    }\n\n    this.textHighlighter.highlight({\n      length,\n      textRange: this.currentTextRange,\n      style: this.config.highlightStyle,\n    });\n\n    this.puck?.highlightMatch();\n  }\n\n  clearTextHighlight(currentElement: Element | null = null) {\n    this.textHighlighter.clearHighlight({ currentElement });\n    this.puck?.clearHighlight();\n  }\n\n  // The currentElement here is _only_ used to avoid resetting the scroll\n  // position when we clear the text selection of a text box.\n  //\n  // That is, if we go to clear the text selection of a text box but we are\n  // still interacting with that element, then we take extra steps to ensure\n  // the scroll position does not change.\n  clearResult({\n    currentElement = null,\n  }: {\n    currentElement?: Element | null;\n  } = {}) {\n    this.currentTextRange = undefined;\n    this.currentPagePoint = undefined;\n    this.lastMouseTarget = null;\n    this.copyState = { kind: 'inactive' };\n\n    clearPopupTimeout(this.popupState);\n    this.popupState = undefined;\n\n    if (this.isTopMostWindow() && this.currentLookupParams?.source) {\n      const {\n        source: { frameId },\n      } = this.currentLookupParams;\n      void browser.runtime.sendMessage({\n        type: 'frame:clearTextHighlight',\n        frameId,\n      });\n      this.puck?.clearHighlight();\n    } else {\n      this.clearTextHighlight(currentElement);\n    }\n\n    if (this.isTopMostWindow()) {\n      this.hidePopup();\n    } else {\n      void browser.runtime.sendMessage({ type: 'top:clearResult' });\n    }\n\n    // Start tracking touch taps again now that the window is hidden.\n    this.touchClickTracker.stopIgnoringClicks();\n  }\n\n  async tryToUpdatePopup({\n    fromPuck,\n    fromTouch,\n    matchText,\n    matchImages,\n    screenPoint,\n    eventElement,\n    dictMode,\n  }: {\n    fromPuck: boolean;\n    fromTouch: boolean;\n    matchText: boolean;\n    matchImages: boolean;\n    screenPoint: Point;\n    eventElement: Element;\n    dictMode: 'default' | 'kanji';\n  }) {\n    const textAtPoint = getTextAtPoint({\n      matchCurrency: !!this.config.fx,\n      matchText,\n      matchImages,\n      point: screenPoint,\n      maxLength: ContentHandler.MAX_LENGTH,\n    });\n\n    // We might have failed to find a match because we didn't have the\n    // necessary keys held down.\n    //\n    // In that case, we still want to store the current point so that if those\n    // keys are pressed later, we can show the pop-up immediately.\n    if (!textAtPoint && (!matchText || !matchImages)) {\n      this.currentPagePoint = toPageCoords(screenPoint);\n    }\n\n    // Check if the text range was the same as the last time.\n    //\n    // The following is not strictly correct since if dictMode was 'kanji'\n    // but is now 'default' then technically we shouldn't return early\n    // since the result will likely differ.\n    //\n    // In practice, however, locking the result to the previously shown\n    // dictionary in this case is not a problem. On the contrary it makes\n    // toggling dictionaries a little less sensitive to minor mouse movements\n    // and hence easier to work with.\n    if (\n      // We require that at least one of the text ranges was set (or for there\n      // to be no text discovered at all), however, since otherwise for the case\n      // of a non-text element (e.g. an <img> with a title attribute) where\n      // textAtPoint.textRange is null but textAtPoint.text is set, we'll end up\n      // returning early and not displaying the popup.\n      (this.currentTextRange || !textAtPoint || textAtPoint.textRange) &&\n      textRangesEqual(this.currentTextRange, textAtPoint?.textRange) &&\n      dictMode === 'default'\n    ) {\n      return;\n    }\n\n    // If we got no result, clear the result.\n    if (!textAtPoint) {\n      this.clearResult({ currentElement: eventElement });\n      return;\n    }\n\n    this.currentPagePoint = toPageCoords(screenPoint);\n    this.currentTextRange = textAtPoint?.textRange || undefined;\n\n    const pageTargetProps = getPageTargetProps({\n      fromPuck,\n      fromTouch,\n      target: eventElement,\n      textRange: textAtPoint?.textRange || undefined,\n    });\n\n    const lookupParams = {\n      dictMode,\n      meta: textAtPoint.meta,\n      source: null,\n      text: textAtPoint.text,\n      targetProps: pageTargetProps,\n      wordLookup: !!textAtPoint.textRange,\n    };\n\n    if (this.isTopMostWindow()) {\n      void this.lookupText(lookupParams);\n    } else {\n      void browser.runtime.sendMessage({\n        ...lookupParams,\n        type: 'top:lookup',\n        // We use screen coordinates for values we pass between frames\n        point: screenPoint,\n        targetProps: {\n          ...pageTargetProps,\n          textBoxSizes: selectionSizesToScreenCoords(\n            pageTargetProps.textBoxSizes\n          ),\n        },\n        source: {\n          // The background page will fill in our frame ID for us\n          src: document.location.href,\n          dimensions: getWindowDimensions(),\n        },\n      });\n    }\n  }\n\n  // ------------------------------------------------------------------------\n  //\n  // (Mostly) Top-most window concerns\n  //\n  // ------------------------------------------------------------------------\n\n  async lookupText({\n    dictMode,\n    meta,\n    source,\n    text,\n    targetProps,\n    wordLookup,\n  }: {\n    dictMode: 'default' | 'kanji';\n    meta?: SelectionMeta;\n    source: IframeSourceParams | null;\n    targetProps: TargetProps;\n    text: string;\n    wordLookup: boolean;\n  }) {\n    this.currentLookupParams = { text, meta, wordLookup, source };\n\n    // Presumably the text or dictionary has changed so break out of copy mode\n    this.copyState = { kind: 'inactive' };\n\n    // Likewise reset the expanded state\n    this.isPopupExpanded = false;\n\n    const queryResult = await query(text, {\n      includeRomaji: this.config.showRomaji,\n      metaMatchLen: meta?.matchLen,\n      wordLookup,\n      updateQueryResult: (queryResult: QueryResult | null) => {\n        void this.applyQueryResult({\n          dictMode,\n          meta,\n          queryResult,\n          targetProps,\n          text,\n          wordLookup,\n        });\n      },\n    });\n\n    void this.applyQueryResult({\n      dictMode,\n      meta,\n      queryResult,\n      targetProps,\n      text,\n      wordLookup,\n    });\n  }\n\n  async applyQueryResult({\n    dictMode,\n    meta,\n    queryResult,\n    targetProps,\n    text,\n    wordLookup,\n  }: {\n    dictMode: 'default' | 'kanji';\n    meta?: SelectionMeta;\n    queryResult: QueryResult | null;\n    targetProps: TargetProps;\n    text: string;\n    wordLookup: boolean;\n  }) {\n    const lookupParams = { text, meta, wordLookup };\n\n    // Check if we have triggered a new query or been disabled while running\n    // the previous query.\n    if (\n      !this.currentLookupParams ||\n      JSON.stringify(lookupParams) !==\n        JSON.stringify(stripFields(this.currentLookupParams, ['source']))\n    ) {\n      return;\n    }\n\n    if (!queryResult && !meta) {\n      this.clearResult({ currentElement: this.lastMouseTarget });\n      return;\n    }\n\n    // Determine the dictionary to show\n    let dict: MajorDataSeries = 'words';\n\n    if (queryResult) {\n      switch (dictMode) {\n        case 'default':\n          if (!queryResult.words && !meta) {\n            // Prefer the names dictionary if we have a names result of more\n            // than one character or if we have no kanji results.\n            //\n            // Otherwise, follow the usual fallback order words -> kanji ->\n            // names.\n            dict =\n              (queryResult.names && queryResult.names.matchLen > 1) ||\n              !queryResult.kanji\n                ? 'names'\n                : 'kanji';\n          }\n          break;\n\n        case 'kanji':\n          if (!queryResult.kanji) {\n            queryResult = null;\n          } else {\n            dict = 'kanji';\n          }\n          break;\n      }\n\n      this.currentDict = dict;\n    }\n\n    this.currentSearchResult = queryResult || undefined;\n    this.currentTargetProps = targetProps;\n\n    this.highlightTextForCurrentResult();\n    this.showPopup();\n  }\n\n  showDictionary(\n    dictToShow: 'next' | 'prev' | MajorDataSeries,\n    options: { fixPopupPosition?: boolean } = {}\n  ) {\n    if (!this.currentSearchResult) {\n      return;\n    }\n\n    let dict: MajorDataSeries;\n    const cycleOrder: Array<MajorDataSeries> = ['words', 'kanji', 'names'];\n\n    if (dictToShow === 'next') {\n      dict = this.currentDict;\n\n      let next = (cycleOrder.indexOf(this.currentDict) + 1) % cycleOrder.length;\n      while (cycleOrder[next] !== this.currentDict) {\n        const nextDict = cycleOrder[next];\n        if (\n          this.currentSearchResult[nextDict] ||\n          (nextDict === 'words' && !!this.currentLookupParams?.meta)\n        ) {\n          dict = nextDict;\n          break;\n        }\n        next = ++next % cycleOrder.length;\n      }\n    } else if (dictToShow === 'prev') {\n      dict = this.currentDict;\n\n      let prev = mod(\n        cycleOrder.indexOf(this.currentDict) - 1,\n        cycleOrder.length\n      );\n      while (cycleOrder[prev] !== this.currentDict) {\n        const prevDict = cycleOrder[prev];\n        if (\n          this.currentSearchResult[prevDict] ||\n          (prevDict === 'words' && !!this.currentLookupParams?.meta)\n        ) {\n          dict = prevDict;\n          break;\n        }\n        prev = mod(--prev, cycleOrder.length);\n      }\n    } else {\n      dict = dictToShow;\n    }\n\n    if (dict === this.currentDict) {\n      return;\n    }\n\n    this.currentDict = dict;\n\n    // Exit copy state if we are changing tabs\n    this.copyState = { kind: 'inactive' };\n\n    // Reset expanded state since we are changing tabs\n    this.isPopupExpanded = false;\n\n    this.highlightTextForCurrentResult();\n    this.updatePopup({\n      allowOverlap: options?.fixPopupPosition,\n      fixPosition: options?.fixPopupPosition,\n    });\n  }\n\n  highlightTextForCurrentResult() {\n    const highlightLength = this.getHighlightLengthForCurrentResult();\n\n    // Check we have something to highlight\n    if (highlightLength < 1) {\n      return;\n    }\n\n    if (this.currentLookupParams?.source) {\n      const {\n        source: { frameId },\n      } = this.currentLookupParams;\n      void browser.runtime.sendMessage({\n        type: 'frame:highlightText',\n        frameId,\n        length: highlightLength,\n      });\n      this.puck?.highlightMatch();\n      return;\n    }\n\n    this.highlightText(highlightLength);\n  }\n\n  getHighlightLengthForCurrentResult(): number {\n    if (this.config.noTextHighlight) {\n      return 0;\n    }\n\n    const searchResult = this.currentSearchResult?.[this.currentDict];\n\n    return Math.max(\n      searchResult?.matchLen || 0,\n      this.currentLookupParams?.meta?.matchLen || 0\n    );\n  }\n\n  showPopup(\n    options: {\n      allowOverlap?: boolean;\n      displayMode?: DisplayMode;\n      fixPosition?: boolean;\n      fixMinHeight?: boolean;\n    } = {}\n  ) {\n    if (!this.isTopMostWindow()) {\n      console.warn('[10ten-ja-reader] Called showPopup from iframe.');\n      return;\n    }\n\n    if (!this.currentSearchResult && !this.currentLookupParams?.meta) {\n      this.clearResult({ currentElement: this.lastMouseTarget });\n      return;\n    }\n\n    const allowOverlap = options.allowOverlap || false;\n    const displayMode =\n      options.displayMode || this.getInitialDisplayMode('ghost');\n\n    // Precalculate the selection sizes\n    const { textBoxSizes: pageTextBoxSizes } = this.currentTargetProps || {};\n    const screenTextBoxSizes = selectionSizesToScreenCoords(pageTextBoxSizes);\n\n    const popupOptions: ShowPopupOptions = {\n      allowOverlap: options.allowOverlap,\n      accentDisplay: this.config.accentDisplay,\n      bunproDisplay: this.config.bunproDisplay,\n      closeShortcuts: this.config.keys.closePopup,\n      copy: {\n        includeAllSenses: this.config.copySenses !== 'first',\n        includePartOfSpeech: this.config.copyPos !== 'none',\n        includeLessCommonHeadwords: this.config.copyHeadwords !== 'common',\n      },\n      copyNextKey: this.config.keys.startCopy[0] || '',\n      copyState: this.copyState,\n      dictLang: this.config.dictLang,\n      dictToShow: this.currentDict,\n      displayMode,\n      fixedPosition: options?.fixPosition ? this.getFixedPosition() : undefined,\n      fixMinHeight: options.fixMinHeight,\n      fontFace: this.config.fontFace,\n      fontSize: this.config.fontSize,\n      fxData: this.config.fx,\n      getCursorClearanceAndPos: this.getCursorClearanceAndPos.bind(\n        this,\n        screenTextBoxSizes\n      ),\n      expandShortcuts: this.config.keys.expandPopup,\n      interactive: this.config.popupInteractive,\n      isExpanded:\n        this.isPopupExpanded ||\n        this.config.autoExpand.includes(\n          this.currentDict as AutoExpandableEntry\n        ) ||\n        // When selecting items by keyboard, expand the content so the user can\n        // see what else is available to select, but not for kanji since it\n        // would make the window massive.\n        (this.copyState.kind === 'active' &&\n          this.copyState.mode === 'keyboard' &&\n          this.currentDict !== 'kanji'),\n      isVerticalText: !!this.currentTargetProps?.isVerticalText,\n      kanjiReferences: this.config.kanjiReferences,\n      meta: this.currentLookupParams?.meta,\n      onCancelCopy: () => this.exitCopyMode(),\n      onExpandPopup: () => this.expandPopup(),\n      onStartCopy: (index: number, trigger: 'touch' | 'mouse') =>\n        this.enterCopyMode({ trigger, index }),\n      onCopy: (copyType: CopyType) => this.copyCurrentEntry(copyType),\n      onClosePopup: () => {\n        this.clearResult({ currentElement: this.lastMouseTarget });\n      },\n      onShowSettings: () => {\n        browser.runtime.sendMessage({ type: 'options' }).catch(() => {\n          // Ignore\n        });\n      },\n      onSwitchDictionary: (dict: MajorDataSeries | 'next' | 'prev') => {\n        this.showDictionary(dict, { fixPopupPosition: true });\n      },\n      onTogglePin: () => {\n        if (displayMode === 'pinned') {\n          this.unpinPopup();\n        } else {\n          this.pinPopup();\n        }\n      },\n      pinShortcuts: this.config.keys.pinPopup,\n      pointerType: this.currentTargetProps?.fromPuck ? 'puck' : 'cursor',\n      popupStyle: this.config.popupStyle,\n      posDisplay: this.config.posDisplay,\n      positionMode: this.popupPositionMode,\n      preferredUnits: this.config.preferredUnits,\n      previousHeight: this.popupState?.pos?.height,\n      safeArea: this.safeAreaProvider.getSafeArea(),\n      showDefinitions: !this.config.readingOnly,\n      showKanjiComponents: this.config.showKanjiComponents,\n      showPriority: this.config.showPriority,\n      switchDictionaryKeys: this.config.keys.nextDictionary,\n      tabDisplay: this.config.tabDisplay,\n      waniKaniVocabDisplay: this.config.waniKaniVocabDisplay,\n    };\n\n    const showPopupResult = showPopup(this.currentSearchResult, popupOptions);\n    if (!showPopupResult) {\n      this.clearResult({ currentElement: this.lastMouseTarget });\n      return;\n    }\n    const { size: popupSize, pos: popupPos } = showPopupResult;\n\n    // Inform the touch click tracker to ignore taps since the popup is now\n    // showing.\n    //\n    // We can't simply check if the popup is visible when we get the touch click\n    // callback since by that point we will already have hidden it.\n    this.touchClickTracker.startIgnoringClicks();\n\n    // Store the popup's display mode so that:\n    //\n    // (a) we can fix the popup's position when changing tabs, and\n    // (b) we can detect if future mouse events lie between the popup and\n    //     the lookup point (and _not_ close or update the popup in that case)\n    // (c) we know how to handle keyboard events based on whether or not the\n    //     popup is showing\n\n    clearPopupTimeout(this.popupState);\n\n    this.popupState = {\n      pos: {\n        frameId: this.getFrameId() || 0,\n        x: popupPos.x,\n        y: popupPos.y,\n        width: popupSize.width,\n        height: popupSize.height,\n        direction: popupPos.direction,\n        side: popupPos.side,\n        allowOverlap,\n        lookupPoint: this.getPopupLookupPoint({\n          currentPagePoint: this.currentPagePoint,\n          firstCharBbox: screenTextBoxSizes?.[1],\n        }),\n      },\n      contentType: this.currentTargetProps?.contentType || 'text',\n      display: this.getNextDisplay(displayMode),\n    };\n\n    //\n    // Tell child iframes\n    //\n    let childState = this.popupState!;\n    if (this.currentLookupParams?.source) {\n      childState = this.getTranslatedPopupState(\n        this.currentLookupParams.source,\n        this.popupState\n      );\n    }\n\n    void browser.runtime.sendMessage({\n      type: 'children:popupShown',\n      state: childState,\n    });\n  }\n\n  getCursorClearanceAndPos(screenTextBoxSizes: SelectionSizes | undefined) {\n    const cursorPos = this.currentPagePoint\n      ? toScreenCoords(this.currentPagePoint)\n      : undefined;\n    let cursorClearance: MarginBox;\n    if (this.currentTargetProps?.fromPuck && this.puck) {\n      const { top, bottom, left, right } = this.puck.getPuckClearance();\n\n      // Although we can't tell whether the left or right thumb is in use\n      // (so we don't make corresponding adjustments to left/right), we can at\n      // least be reasonably sure that the thumb extends downwards!\n      const extraMarginToClearThumb =\n        this.puck.getTargetOrientation() === 'above' ? 100 : 0;\n      cursorClearance = {\n        top,\n        right,\n        bottom: bottom + extraMarginToClearThumb,\n        left,\n      };\n    } else {\n      const tooltipClearance = this.currentTargetProps?.hasTitle ? 20 : 0;\n      cursorClearance = {\n        top: 0,\n        right: 0,\n        bottom: tooltipClearance,\n        left: 0,\n      };\n    }\n\n    // Add the first part of the matched text to the cursor clearance.\n    //\n    // We don't want to add _all_ of it since we might have a selection that\n    // wraps lines and that would produce a massive area that would be too hard\n    // to avoid.\n    if (screenTextBoxSizes && cursorPos) {\n      const bbox = getBestFitSize({\n        sizes: screenTextBoxSizes,\n        length: this.getHighlightLengthForCurrentResult(),\n      });\n      if (bbox) {\n        const cursorClearanceAsRect = addMarginToPoint(\n          cursorClearance,\n          cursorPos\n        );\n\n        // Adjust the cursorPos to use the middle of the first character of\n        // the selected text.\n        //\n        // This should cause the popup to be better aligned with the selected\n        // text which, apart from appearing a little bit neater, also makes\n        // mousing over the popup easier since it should be closer.\n        //\n        // (It's important we do this _after_ calling addMarginToPoint above\n        // since, when we are using the puck, the original value of\n        // `cursorClearance` is relative to this.currentPoint, i.e. the\n        // original value of cursorPos, so we need to supply that value when\n        // converting to a rect.)\n        const firstCharBbox = screenTextBoxSizes[1];\n        cursorPos.x = Math.max(0, firstCharBbox.left + firstCharBbox.width / 2);\n        cursorPos.y = Math.max(0, firstCharBbox.top + firstCharBbox.height / 2);\n\n        const expandedClearance = union(bbox, cursorClearanceAsRect);\n        cursorClearance = getMarginAroundPoint(cursorPos, expandedClearance);\n      }\n    }\n\n    return { cursorClearance, cursorPos };\n  }\n\n  getInitialDisplayMode(interactive: 'ghost' | 'hover'): DisplayMode {\n    if (\n      this.currentTargetProps?.fromPuck ||\n      this.currentTargetProps?.fromTouch\n    ) {\n      return 'touch';\n    } else if (this.config.popupInteractive) {\n      return interactive;\n    } else {\n      return 'static';\n    }\n  }\n\n  getNextDisplay(prevDisplayMode: DisplayMode): PopupState['display'] {\n    let display: PopupState['display'];\n\n    if (prevDisplayMode === 'ghost') {\n      if (\n        this.config.holdToShowKeys.length &&\n        this.currentTargetProps?.contentType === 'text'\n      ) {\n        display = {\n          mode: 'ghost',\n          trigger: 'keys',\n          keyType: HoldToShowKeyType.Text,\n        };\n      } else if (\n        this.config.holdToShowImageKeys.length &&\n        this.currentTargetProps?.contentType === 'image'\n      ) {\n        display = {\n          mode: 'ghost',\n          trigger: 'keys',\n          keyType: HoldToShowKeyType.Images,\n        };\n      } else {\n        display = {\n          mode: 'ghost',\n          trigger: 'timeout',\n          timeout: window.setTimeout(() => this.commitPopup(), 400),\n        };\n      }\n    } else {\n      display = { mode: prevDisplayMode };\n    }\n\n    return display;\n  }\n\n  updatePopup(\n    options: {\n      allowOverlap?: boolean;\n      fixPosition?: boolean;\n      fixMinHeight?: boolean;\n    } = {}\n  ) {\n    if (!this.isTopMostWindow()) {\n      console.warn('[10ten-ja-reader] Called updatePopup within iframe');\n      return;\n    }\n\n    const displayMode = this.popupState?.display.mode;\n    this.showPopup({\n      allowOverlap: options.allowOverlap ?? this.popupState?.pos?.allowOverlap,\n      displayMode,\n      fixPosition: options.fixPosition,\n      fixMinHeight: options.fixMinHeight,\n    });\n  }\n\n  pinPopup() {\n    if (!this.isTopMostWindow()) {\n      void browser.runtime.sendMessage({ type: 'top:pinPopup' });\n      return;\n    }\n\n    // If the popup is interactive, then we shouldn't move it when pinning it\n    // but if, for example, the user has turned off popup interactivity and so\n    // the popup is rendered with the narrow tab bar, when we go to pin it\n    // we'll expand the tab bar so we should re-position it as necessary since\n    // it might take more space.\n    this.showPopup({\n      allowOverlap: this.popupState?.pos?.allowOverlap,\n      displayMode: 'pinned',\n      fixPosition: this.config.popupInteractive,\n    });\n  }\n\n  unpinPopup() {\n    if (!this.isTopMostWindow()) {\n      void browser.runtime.sendMessage({ type: 'top:unpinPopup' });\n      return;\n    }\n\n    this.showPopup({\n      allowOverlap: this.popupState?.pos?.allowOverlap,\n      displayMode: this.getInitialDisplayMode('hover'),\n      fixPosition: this.config.popupInteractive,\n    });\n\n    // Typically when you unpin the popup you want it to disappear immediately\n    // (unless the mouse is currently over it or still over the original text).\n    //\n    // To try to make that happen we dispatch another mouse event with the last\n    // mouse position.\n    //\n    // Unfortunately this won't necessarily help if the user has since moused\n    // over an iframe since our last recorded mouse position and target element\n    // will be based on the last mousemove event we received in _this_ frame.\n    if (this.lastMouseTarget) {\n      const mouseMoveEvent = new MouseEvent('mousemove', {\n        bubbles: true,\n        screenX: this.lastMouseMoveScreenPoint.x,\n        screenY: this.lastMouseMoveScreenPoint.y,\n        clientX: this.lastMouseMoveScreenPoint.x,\n        clientY: this.lastMouseMoveScreenPoint.y,\n        ctrlKey: false,\n        shiftKey: false,\n        altKey: false,\n        metaKey: false,\n        button: 0,\n        buttons: 0,\n      });\n      this.lastMouseTarget.dispatchEvent(mouseMoveEvent);\n    }\n  }\n\n  togglePin() {\n    if (!this.popupState) {\n      return false;\n    }\n\n    if (this.popupState.display.mode === 'pinned') {\n      this.unpinPopup();\n    } else {\n      this.pinPopup();\n    }\n\n    return true;\n  }\n\n  commitPopup() {\n    if (!this.isTopMostWindow()) {\n      void browser.runtime.sendMessage({ type: 'top:commitPopup' });\n      return;\n    }\n\n    if (this.popupState?.display.mode !== 'ghost') {\n      return;\n    }\n\n    this.showPopup({\n      allowOverlap: this.popupState?.pos?.allowOverlap,\n      displayMode: 'hover',\n      fixPosition: false,\n    });\n  }\n\n  hidePopup() {\n    const wasShowing = !!this.currentSearchResult;\n\n    this.currentLookupParams = undefined;\n    this.currentSearchResult = undefined;\n    this.currentTargetProps = undefined;\n\n    hidePopup();\n\n    if (wasShowing && this.isTopMostWindow()) {\n      void browser.runtime.sendMessage({ type: 'children:popupHidden' });\n    }\n  }\n\n  getFixedPosition(): PopupPositionConstraints | undefined {\n    if (!this.popupState?.pos || this.config.tabDisplay === 'none') {\n      return undefined;\n    }\n\n    const { x, y, width, direction, side } = this.popupState.pos;\n\n    return {\n      // If the tabs are on the right, the x position is the right edge of the\n      // popup.\n      x: this.config.tabDisplay === 'right' ? x + width : x,\n      y,\n      anchor: this.config.tabDisplay,\n      direction,\n      side,\n    };\n  }\n\n  getPopupLookupPoint({\n    currentPagePoint,\n    firstCharBbox,\n  }: {\n    currentPagePoint?: Point;\n    firstCharBbox?: Rect;\n  }): NonNullable<PopupState['pos']>['lookupPoint'] {\n    const { scrollX, scrollY } = getScrollOffset();\n\n    if (firstCharBbox) {\n      const marginX = firstCharBbox.width / 2;\n      const marginY = firstCharBbox.height / 2;\n      const x = firstCharBbox.left + marginX + scrollX;\n      const y = firstCharBbox.top + marginY + scrollY;\n      return { x, y, marginX, marginY };\n    }\n\n    return currentPagePoint\n      ? {\n          x: currentPagePoint.x,\n          y: currentPagePoint.y,\n          marginX: 10,\n          marginY: 10,\n        }\n      : undefined;\n  }\n\n  getTranslatedPopupState(\n    frameSource: WithRequired<IframeSearchParams, 'frameId'>,\n    popupState: Readonly<PopupState>\n  ): Readonly<PopupState> {\n    const iframe = findIframeElement(frameSource);\n    if (!iframe) {\n      return popupState;\n    }\n\n    if (!popupState.pos) {\n      return popupState;\n    }\n\n    const iframeOrigin = getIframeOrigin(iframe);\n    const { scrollX, scrollY } = getScrollOffset();\n    const { x, y, lookupPoint } = popupState.pos;\n\n    return {\n      ...popupState,\n      pos: {\n        ...popupState.pos,\n        frameId: frameSource.frameId,\n        x: x - iframeOrigin.x - scrollX,\n        y: y - iframeOrigin.y - scrollY,\n        lookupPoint: lookupPoint\n          ? {\n              x: lookupPoint.x - iframeOrigin.x - scrollX,\n              y: lookupPoint.y - iframeOrigin.y - scrollY,\n              marginX: lookupPoint.marginX,\n              marginY: lookupPoint.marginY,\n            }\n          : undefined,\n      },\n    };\n  }\n}\n\nexport function isTouchClickEvent(\n  pointerEvent: PointerEvent\n): pointerEvent is TouchClickEvent {\n  return !!(pointerEvent as TouchClickEvent).fromTouch;\n}\n\nexport interface TouchClickEvent extends PointerEvent {\n  fromTouch: true;\n}\n\ndeclare global {\n  interface Window {\n    postMessage<T = any>(\n      message: T,\n      targetOrigin: string,\n      transfer?: Transferable[]\n    ): void;\n    readerScriptVer?: string;\n    removeReaderScript?: () => void;\n  }\n}\n\n(function () {\n  // Check that we should be running at all. We can only handle HTML and SVG\n  // content and if we start messing with other documents (e.g. random XML\n  // documents) we can break their styling.\n  const { namespaceURI } = document.documentElement;\n  if (\n    namespaceURI !== 'http://www.w3.org/1999/xhtml' &&\n    namespaceURI !== 'http://www.w3.org/2000/svg'\n  ) {\n    return;\n  }\n\n  // Ensure the content script is not loaded twice or that an incompatible\n  // version of the script is not used.\n  //\n  // This is only needed when we are injecting the script via executeScript\n  // when running in \"activeTab\" mode.\n  //\n  // Furthermore, with regards to incompatible versions, as far as I can tell\n  // Firefox will remove old versions of injected scripts when it reloads an\n  // add-on. I'm not sure if that behavior is reliable across all browsers,\n  // however, (update: it's not) so for now we try our best to ensure we have\n  // the correct version of the script here.\n  if (window.readerScriptVer === __VERSION__) {\n    return;\n  } else if (\n    typeof window.readerScriptVer !== 'undefined' &&\n    typeof window.removeReaderScript === 'function'\n  ) {\n    console.info(\n      '[10ten-ja-reader] Found incompatible version of script. Removing.'\n    );\n    try {\n      window.removeReaderScript();\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  let contentHandler: ContentHandler | null = null;\n\n  // Port to the background page.\n  //\n  // This is only used when we are running in \"activeTab\" mode. It serves to:\n  //\n  // - Provide an extra means to ensure the tab is removed from the list of\n  //   enabled tabs when the tab is destroyed (in case we fail to get a pagehide\n  //   event), and\n  //\n  // - Ensure the background page is kept alive so long as we have an enabled\n  //   tab when the background page is running as an event page.\n  //\n  let port: Runtime.Port | undefined;\n\n  window.readerScriptVer = __VERSION__;\n  window.removeReaderScript = () => {\n    disable();\n    browser.runtime.onMessage.removeListener(onMessage);\n  };\n\n  // Track if we are the top-most window or not.\n  //\n  // Normally we detect the top-most window by comparing window.top ===\n  // window.self but in some cases the actual top-most window does not have the\n  // content script injected and hence we have a concept of the effective\n  // top-most window.\n  //\n  // This only happens in Firefox and only really with the Live TL extension\n  // where the top-most window in some cases is a moz-extension:// URL and hence\n  // does not have the content script injected. Instead a child iframe (a\n  // regular YouTube page) has the content script injected and should be treated\n  // as the top-most window for the purposes of showing the popup.\n  let isEffectiveTopMostWindow = false;\n  function isTopMostWindow() {\n    return isEffectiveTopMostWindow || window.self === window.top;\n  }\n\n  browser.runtime.onMessage.addListener(onMessage);\n\n  // Check if we should be enabled or not.\n  //\n  // We don't need to do this in activeTab mode since the background page will\n  // send us an 'enable' message after injecting the script.\n  //\n  // However, when the content script is injected using content_scripts the\n  // background script might not have been initialized yet in which case this\n  // will fail. However, presumably once the background script has initialized\n  // it will call us if we need to be enabled.\n  if (!__ACTIVE_TAB_ONLY__) {\n    browser.runtime.sendMessage({ type: 'enable?' }).catch(() => {\n      // Ignore\n    });\n  }\n\n  // Poll the background page until it finishes updating\n  void (async function checkIfUpdating() {\n    try {\n      const isDbUpdating = await browser.runtime.sendMessage({\n        type: 'isDbUpdating',\n      });\n      if (isDbUpdating) {\n        // Wait 20s between checks\n        setTimeout(checkIfUpdating, 20_000);\n      }\n    } catch {\n      // Ignore, probably we're out of date with the background\n    }\n  })();\n\n  async function onMessage(request: unknown): Promise<string> {\n    s.assert(request, BackgroundMessageSchema);\n\n    // As with onBackgroundMessage we need to ensure that we are the\n    // intended recipient for these messages because Safari.\n\n    switch (request.type) {\n      case 'enable':\n        console.assert(\n          typeof request.config === 'object',\n          'No config object provided with enable message'\n        );\n        console.assert(request.frame === '*');\n\n        enable({\n          tabId: request.id,\n          config: request.config as ContentConfigParams,\n        });\n        break;\n\n      case 'disable':\n        console.assert(request.frame === '*');\n        disable();\n        break;\n\n      case 'dbUpdated':\n        contentHandler?.onDbUpdated();\n        break;\n\n      case 'isTopMost':\n        if (contentHandler?.getFrameId() === request.frame) {\n          isEffectiveTopMostWindow = true;\n          contentHandler?.setEffectiveTopMostWindow();\n        }\n        break;\n    }\n\n    return 'ok';\n  }\n\n  function enable({\n    tabId,\n    config,\n  }: {\n    tabId?: number;\n    config: ContentConfigParams;\n  }) {\n    if (contentHandler) {\n      contentHandler.setConfig(config);\n      if (isEffectiveTopMostWindow) {\n        contentHandler.setEffectiveTopMostWindow();\n      }\n    } else {\n      // When the extension is upgraded, we can still have the old popup window\n      // or puck hanging around so make sure to clear it.\n      removePopup();\n      removePuck();\n      removeSafeAreaProvider();\n      removeGdocsStyles();\n\n      contentHandler = new ContentHandler(config);\n    }\n\n    // If we are running in \"activeTab\" mode we will get passed our tab ID\n    // so we can set up a Port which will allow the background script to\n    // know when we disappear so it can update the browser action status.\n    //\n    // We only need to do that if we're the root-most frame, however.\n    if (typeof tabId !== 'undefined' && isTopMostWindow() && !port) {\n      try {\n        port = browser.runtime.connect(undefined, {\n          name: `tab-${tabId}`,\n        });\n      } catch (e) {\n        console.error(e);\n      }\n    }\n\n    browser.runtime\n      .sendMessage<unknown, { frameId: number } | undefined>({\n        type: 'enabled',\n        src: document.location.href,\n      })\n      .then((resp) => {\n        if (!resp) {\n          return;\n        }\n\n        const { frameId } = resp;\n        if (contentHandler) {\n          contentHandler.setFrameId(frameId);\n        }\n        if (window.frameElement instanceof HTMLElement) {\n          window.frameElement.dataset.frameId = frameId.toString();\n        }\n      })\n      .catch((e) => {\n        console.warn(e);\n      });\n\n    // Let the background know the current state of hover devices since this\n    // might be its first chance to access the DOM.\n    void browser.runtime.sendMessage({\n      type: 'canHoverChanged',\n      value: contentHandler.canHover,\n    });\n\n    window.addEventListener('pageshow', onPageShow);\n    window.addEventListener('pagehide', onPageHide);\n  }\n\n  function disable() {\n    if (contentHandler) {\n      contentHandler.detach();\n      contentHandler = null;\n    }\n\n    if (port) {\n      port.disconnect();\n      port = undefined;\n    }\n\n    window.removeEventListener('pageshow', onPageShow);\n    window.removeEventListener('pagehide', onPageHide);\n  }\n\n  function onPageShow() {\n    void browser.runtime.sendMessage({ type: 'enable?' });\n  }\n\n  function onPageHide() {\n    void browser.runtime.sendMessage({ type: 'disabled' });\n  }\n})();\n"],"names":["jsonEqualish","actual","expected","Object","is","objEquiv","a","b","Date","getTime","Array","isArray","constructor","Error","aKeys","definedKeys","bKeys","length","sort","i","key","keys","filter","globalThis","chrome","runtime","id","browser","CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE","wrapAPIs","extensionAPIs","apiMetadata","DefaultWeakMap","WeakMap","createItem","items","undefined","super","this","get","has","set","isThenable","value","then","makeCallback","promise","metadata","callbackArgs","lastError","reject","message","singleCallbackArg","resolve","pluralizeArguments","numArgs","wrapAsyncFunction","name","target","args","minArgs","maxArgs","Promise","fallbackToNoCallback","cbError","console","warn","noCallback","wrapMethod","method","wrapper","Proxy","apply","targetMethod","thisObj","call","hasOwnProperty","Function","bind","prototype","wrapObject","wrappers","cache","create","handlers","proxyTarget","prop","receiver","defineProperty","configurable","enumerable","desc","Reflect","deleteProperty","wrapEvent","wrapperMap","addListener","listener","hasListener","removeListener","onRequestFinishedWrappers","req","wrappedReq","getContent","onMessageWrappers","sender","sendResponse","didCallSendResponse","wrappedSendResponse","sendResponsePromise","response","result","err","isResultThenable","sendPromisedResult","msg","error","__mozWebExtensionPolyfillReject__","catch","wrappedSendMessageCallback","reply","wrappedSendMessage","apiNamespaceObj","wrappedCb","push","sendMessage","staticWrappers","devtools","network","onRequestFinished","onMessage","onMessageExternal","tabs","settingMetadata","clear","privacy","services","websites","module","exports","StructError","TypeError","failure","failures","cached","rest","path","join","explanation","cause","assign","isIterable","x","isObject","Symbol","iterator","isNonArrayObject","print","toString","JSON","stringify","shiftIterator","input","next","done","toFailure","context","struct","type","refinement","branch","toFailures","r","run","options","ctx","mask","coerce","coercer","status","validator","k","v","s","entries","ts","t","Map","Set","add","refiner","Struct","props","schema","assert","validate","tuples","tuple","Structs","isType","schemas","map","array","Element","slice","enums","values","description","includes","integer","isNaN","Number","isInteger","literal","constant","never","knowns","Never","unknowns","delete","coerced","optional","record","Key","Value","string","union","S","first","getSize","size","threshold","refine","exclusive","nonempty","extend","discriminatorSchema","mapping","discriminator","field","getStructForValue","branchStruct","PopupStateSchema","pos","frameId","y","width","height","direction","side","allowOverlap","lookupPoint","marginX","marginY","contentType","display","static","ghost","timeout","keyType","hover","pinned","touch","clearPopupTimeout","popupState","mode","trigger","window","clearTimeout","BackgroundMessageSchema","disable","frame","enable","config","dbUpdated","isTopMost","popupShown","state","popupHidden","isPopupShowing","highlightText","clearTextHighlight","lookup","dictMode","meta","point","targetProps","text","wordLookup","source","initialSrc","currentSrc","dimensions","pinPopup","unpinPopup","commitPopup","clearResult","nextDictionary","toggleDefinition","expandPopup","movePopup","enterCopyMode","exitCopyMode","nextCopyEntry","copyCurrentEntry","copyType","CopyKeys","optionsString","popupString","CopyKanjiKeyStrings","CopyNextKeyStrings","SVG_NS","HTML_NS","empty","elem","firstChild","remove","isContentEditableNode","node","nodeOrParent","nodeOrParentElement","HTMLElement","currentNode","contentEditable","parentElement","nodeType","Node","ELEMENT_NODE","isEditableNode","isTextInputNode","isInteractiveElement","isElement","tagName","isFocusable","element","focus","allowedInputTypes","addMarginToPoint","margin","left","top","right","bottom","getMarginAroundPoint","rect","Math","max","min","bboxIncludesPoint","bbox","getBboxForNodeList","nodes","reduce","child","thisBbox","isTextNode","range","Range","selectNode","getBoundingClientRect","getComputedStyle","childNodes","mod","n","stripFields","o","fields","isFirefox","navigator","userAgent","indexOf","isFenix","isChromium","isSafari","isIOS","platform","document","html","attributes","children","createElementNS","val","setAttribute","append","svg","async","copyText","clipboard","writeText","callbackCalled","copy","event","clipboardData","setData","preventDefault","addEventListener","execCommand","removeEventListener","selection","getSelection","span","body","documentElement","getHoverCapabilityMql","matchMedia","getMouseCapabilityMql","ContentConfig","params","before","contentKey","changes","objectKeysWeCareAbout","notifyListeners","hadListeners","listeners","mouseCapabilityMql","onMouseCapabilityChange","hoverCapabilityMql","onHoverCapabilityChange","l","listenersCopy","accentDisplay","autoExpand","copyHeadwords","copyPos","copySenses","bunproDisplay","dictLang","enableTapLookup","fx","fontFace","fontSize","highlightStyle","holdToShowKeys","holdToShowImageKeys","kanjiReferences","noTextHighlight","popupInteractive","popupStyle","posDisplay","preferredUnits","puckState","readingOnly","showKanjiComponents","showPriority","showPuck","canHover","showRomaji","tabDisplay","toolbarIcon","waniKaniVocabDisplay","matches","highPriorityLabels","SUPPORTED_REFERENCES","REFERENCE_LABELS","conning","full","short","lang","sh_kk2","halpern_njecd","halpern_kkld_2ed","heisig6","henshall","busy_people","kanji_in_context","kodansha_compact","maniette","nelson_c","nelson_n","py","skip","sh_desc","wk","getReferenceValue","entry","ref","rad","nelson","String","fromCodePoint","radChar","base","renderKanKen","misc","kk","jlpt","c","codePointAt","toUpperCase","refs","level","getTextToCopy","injectGdocsStyles","removeGdocsStyles","style","createElement","textContent","head","appendChild","getCopyEntryFromResult","numberOfCopyableEntries","series","namePreview","names","words","data","getRangeForSingleCodepoint","offset","isLowSurrogate","charCodeAt","isHighSurrogate","end","setStart","setEnd","codepoint","getBboxForSingleCodepointRange","getClientRects","getContentType","getPopupContainer","hostElem","getElementById","shadowRoot","querySelector","isPopupWindowHostElem","getScrollOffset","fullscreenElement","scrollX","scrollLeft","scrollY","scrollTop","defaultView","toPageCoords","screen","scrollOffset","isPoint","getCursorPosition","elements","initialElements","initialResult","getCursorPositionForElement","isTextNodePosition","isTextInputPosition","isGdocsOverlayPosition","stylesToRestore","firstElement","shift","SVGElement","treatElementAsInvisible","zIndex","isVisible","getAttribute","setProperty","restoreStyles","position","offsetNode","location","host","isGdocsOverlayElem","getElementForPosition","positionIntersectsPoint","userSelectResult","lookupPointWithNormalizedUserSelect","isResultCloseToPoint","positionElement","checkVisibility","checkOpacity","checkVisibilityCSS","opacity","visibility","getCaretPosition","getVisualOffset","caretPositionFromPoint","shadowRoots","getDescendantShadowRoots","caretRangeFromPoint","previousCharacterBbox","startOffset","currentElem","ok","userSelect","webkitUserSelect","styles","removeAttribute","getBboxForPosition","distanceResult","getDistanceFromTextNode","distance","glyphExtent","namespaceURI","xDist","abs","yDist","sqrt","getCursorPositionFromTextInput","startContainer","limitToDescendants","contains","expandShadowDomInRange","adjustForRangeBoundary","trim","mirrorElement","createMirrorElement","cloneNodeWithStyles","cs","stylesToSet","item","getPropertyValue","boxSizing","offsetWidth","parseFloat","paddingLeft","paddingRight","borderLeftWidth","borderRightWidth","isFinite","offsetHeight","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","marginTop","marginLeft","screenPoint","scrollTo","cloneNode","clone","getShadowRoot","shadowNode","getShadowNodeAtPoint","localShadowRoot","getRootNode","ShadowRoot","shadowRange","getRangeForShadowTextNode","shadowContainer","getRangeForShadowElement","shadowElement","getBboxForShadowHost","root","traverse","textChildren","bboxes","some","hitElements","elementsFromPoint","hitElement","find","halfWidthNumbers","fullWidthAlphanumerics","zeroWidthNonJoiner","whiteCircle","radicals","nonDelimitingIdeographicPunctuation","hiragana","katakana","enclosedChars","shorthandChars","tenChars","eraChars","kabushikiGaisha","kanji","rareKanji","halfwidthKatakanaChar","hentaigana","getCombinedCharRange","ranges","flags","isCharacterClassRange","substring","RegExp","re","startsWith","endsWith","japaneseChar","getNegatedCharRange","negated","nonJapaneseChar","hasKatakana","test","startsWithDigit","transliterateMap","kanjiToNumberMap","parseNumber","inputText","replace","digits","ch","digit","parseInt","numbers","digitsAndPowersOfTen","getDigitsAndPowersOfTen","powersOfTen","multiplier","acc","d","p","second","decimal","pow","validSequence","breakDownNumbers","arr","lastPowerOfTen","every","c1","c2","third","numberRegex","extractNumberMetadata","exec","index","valueStr","src","matchLen","lookForCurrency","textDelimiter","originalTextDelimiter","sourceText","currentText","nodeText","mightBeCurrency","startsWithNumeral","toLowerCase","japaneseOrPrice","textEnd","search","currencyRegex","extractCurrencyMetadata","metricSuffix","lookForMeasure","includeSeparators","japaneseOrUnit","jouRegex","squareMeterRegex","extractMeasureMetadata","unit","alternateJouSizes","label","ratio","convertMeasure","measure","alt","m2Conversion","m2f","lookForShogi","shogiDelimiter","unprefixedShogiStart","expandedDelimiter","shogiRegex","shogiWithoutPrefixRegex","sides","sameDest","pieces","movements","promotions","nonPromotions","extractShogiMetadata","splice","sideStr","destStr","pieceStr","movementStr","promotionStr","dest","parts","split","lookForEra","startsWithEraName","japaneseOrSpace","endOfEra","maxEraLength","from","yearMap","reading","start","yomi","yearRegex","extractEraMetadata","era","isEraName","year","getEraInfo","lookForMetadata","matchCurrency","scanText","startNode","startPosition","inlineAncestor","isInline","isRubyAnnotationElement","acceptNode","closest","NodeFilter","FILTER_REJECT","FILTER_ACCEPT","treeWalker","createNodeIterator","SHOW_TEXT","referenceNode","nextNode","textStart","textRange","maxLength","maxEnd","extractGetTextMetadata","previousResult","getTextAtPoint","firstCharBbox","scanNode","matchText","getTextNodeStart","synthesizedPosition","findIframeElement","iframes","getIframes","iframe","frameIdMatch","f","dataset","candidates","normalizeKey","upperKey","normalizeKeys","hasModifiers","getCopyMode","kind","getThemeClass","theme","getHash","h1","h2","imul","asNum","substr","isSvgDoc","doc","isForeignObjectElement","nodeName","isSvgSvgElement","getOrCreateEmptyContainer","legacyIds","legacyContainers","querySelectorAll","container","removeContainerElement","existingContainers","resetContent","resetStyles","addFullScreenChangeCallback","addContainerElement","all","removeContentContainer","containerIds","containers","removeFullScreenChangeCallback","previousParent","insertBefore","parent","beforeElem","namedItem","foreignObject","fullScreenChangedCallbacks","existingCallback","callback","styleHash","attachShadow","hash","existingStyle","addFontStyles","isPopupVisible","popupContainer","classList","hidePopup","removePopup","removeFontStyles","setFontFace","popupWindow","getPopupWindow","setFontSize","className","setPopupStyle","elems","getPopupArrow","isPuckPointerEvent","pointerEvent","POPUP_ROUNDING","renderArrow","popupPos","popupX","popupY","arrow","arrowWidth","arrowHeight","popupSize","renderBook","bookSvg","viewBox","role","lineGroup","fill","stroke","lines","x1","y1","x2","y2","line","circle","cx","cy","renderClipboard","renderCog","renderCross","renderKanjiIcon","renderPerson","renderPin","renderSpinner","renderStar","class","renderCloseButton","onClosePopup","closeShortcuts","title","closeButton","onclick","langTag","getLangTag","renderCopyOverlay","copyOverlay","entryToCopy","copyState","wordToCopy","getMessage","heading","list","entryPreviewText","includeAllSenses","includeLessCommonHeadwords","includePartOfSpeech","button","renderButtonWithPreview","previewText","onCopy","tabSeparatedPreviewText","copyWordButton","icon","copyWordLabel","cancelButton","onCancelCopy","previewRow","round","number","precision","factor","EPSILON","updateExpandable","expandable","isExpanded","expandableTop","expandedHeight","foldPoint","getFoldPoint","collapsedHeight","isCollapsed","expandShortcuts","expandButton","onExpandPopup","showKeyboardShortcut","resizeObserver","ResizeObserver","blockSize","expandableRenderedHeight","contentBoxSize","observe","requestAnimationFrame","scrollSnapType","foldPointElem","prev","previousElementSibling","nextElementSibling","previousBottom","nextTop","vnodeId","rerenderQueue","prevDebounce","defer","depthSort","eventClock","eventProxy","eventProxyCapture","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","obj","removeNode","parentNode","removeChild","normalizedProps","arguments","defaultProps","createVNode","original","vnode","__k","__","__b","__e","__d","__c","__v","__i","__u","Fragment","BaseComponent","getDomSibling","childIndex","sibling","updateParentDomPointers","enqueueRender","process","__r","debounceRendering","renderQueueLength","component","newVNode","oldVNode","oldDom","commitQueue","refQueue","__P","diff","__n","commitRoot","diffChildren","parentDom","renderResult","newParentVNode","oldParentVNode","globalContext","namespace","excessDomChildren","isHydrating","childVNode","newDom","firstChildDom","oldChildren","newChildrenLength","constructNewChildrenArray","applyRef","insert","nextSibling","skewedIndex","matchingIndex","oldChildrenLength","remainingOldChildren","skew","findMatchingIndex","unmount","parentVNode","toChildArray","out","setStyle","dom","oldValue","useCapture","cssText","_attached","e","createEventProxy","eventHandler","_dispatched","tmp","isNew","oldProps","oldState","snapshot","clearProcessingException","newProps","isClassComponent","provider","componentContext","renderHook","count","newType","outer","render","contextType","__E","doRender","sub","__h","_sb","__s","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","MODE_HYDRATE","diffElementNodes","diffed","cb","newHtml","oldHtml","newChildren","inputValue","checked","localName","createTextNode","__m","__html","innerHTML","hasRefUnmount","current","skipRemove","componentWillUnmount","replaceNode","createContext","defaultValue","contextId","Consumer","contextValue","Provider","subs","_props","old","errorInfo","ctor","handled","getDerivedStateFromError","setState","componentDidCatch","update","forceUpdate","setTimeout","currentIndex","currentComponent","previousComponent","prevRaf","currentHook","afterPaintEffects","_options","oldBeforeDiff","oldBeforeRender","oldAfterDiff","oldCommit","oldBeforeUnmount","oldRoot","getHookState","hooks","__H","useState","initialState","useReducer","invokeOrReturn","reducer","init","hookState","_reducer","action","currentValue","__N","nextValue","_hasScuFromHooks","updateHookState","stateHooks","prevScu","shouldUpdate","forEach","hookItem","prevCWU","useEffect","argsChanged","_pendingArgs","useLayoutEffect","useRef","initialValue","useMemo","factory","useCallback","useContext","flushAfterPaintEffects","invokeCleanup","invokeEffect","afterNextFrame","hasErrored","HAS_RAF","raf","cancelAnimationFrame","hook","comp","cleanup","oldArgs","newArgs","arg","shallowDiffers","PureComponent","memo","comparer","nextProps","updateRef","Memoed","displayName","isReactComponent","__f","Component","isPureReactComponent","oldDiffHook","REACT_FORWARD_SYMBOL","for","forwardRef","fn","Forwarded","$$typeof","mapFn","Children","only","normalized","toArray","oldCatchError","oldUnmount","detachedClone","detachedParent","effect","removeOriginal","originalParent","Suspense","_suspenders","suspended","__a","lazy","loader","prom","Lazy","default","SuspenseList","_next","_map","__R","suspendingVNode","suspendingComponent","resolved","onResolved","onSuspensionComplete","suspendedVNode","__O","pop","detachedComponent","fallback","revealOrder","ContextProvider","Portal","_this","_container","_temp","createPortal","el","containerInfo","delegated","unsuspend","wrappedUnsuspend","reverse","REACT_ELEMENT_TYPE","CAMEL_PROPS","ON_ANI","CAMEL_REPLACE","IS_DOM","onChangeInputType","preactRender","hydrate","preactHydrate","writable","oldEventHook","isPropagationStopped","cancelBubble","isDefaultPrevented","defaultPrevented","persist","nativeEvent","classNameDescriptorNonEnumberable","oldVNodeHook","isNonDashedType","lowerCased","multiple","selected","oldDiffed","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","readContext","useDebugValue","useDeferredValue","useId","useImperativeHandle","useInsertionEffect","useSyncExternalStore","useTransition","createFactory","isValidElement","isFragment","isMemo","cloneElement","preactCloneElement","unmountComponentAtNode","findDOMNode","unstable_batchedUpdates","flushSync","StrictMode","startTransition","subscribe","getSnapshot","_useState","_instance","_getSnapshot","didSnapshotChange","inst","latestGetSnapshot","prevValue","createRef","isStaticChildren","__source","__self","classes","classNames","Boolean","i18nContext","useLocale","FrequencyIndicator","rx","ry","frequency","GradeIndicator","gr","KanjiComponents","componentsIncludesRadical","RadicalRow","na","m_lang","m","colspan","KanjiMeta","tags","tag","KanjiReadings","on","kun","hasPreceding","KunReading","highlightIndex","StrokeCount","strokeLabel","sc","points","KanjiInfo","freq","showComponents","KanjiReferencesTable","referenceTableInfo","referenceNames","getSelectedReferenceLabels","highlight","cellInfo","row","ceil","gridAutoFlow","gridTemplateRows","ReferenceEntryWrapper","refCode","href","encodeURIComponent","containerStyles","rel","STROKE_SPEED","STROKE_GAP","FREEZE_LENGTH","TIMELINE_RANGE","SCRUBBER_DRAG_RANGE","TIMELINE_OFFSET","KanjiStrokeAnimation","animatedStrokeContainer","timelineSvg","scrubberContainer","isPlaying","setIsPlaying","currentAnimations","useScrubber","subpaths","st","animations","paths","strokeDurations","getTotalLength","totalDuration","cumulativeDuration","duration","endOffset","interactive","popupOptionsContext","PopupOptionsProvider","usePopupOptions","containerHasSelectedText","focusNode","KanjiEntry","kanjiTable","selectState","KanjiCharacter","onClick","onStartCopy","StaticKanjiCharacter","lastPointerType","onPointerUp","evt","pointerType","getSelectedIndex","numEntries","renderKanjiEntries","selectedIndex","renderKanjiEntry","containerElement","h","renderMetadata","eraInfo","renderEraInfo","renderMeasureInfo","fxData","renderCurrencyInfo","renderNumberInfo","isCombinedResult","renderShogiInfo","seireki","converted","metaDiv","toLocaleString","renderUnit","renderValue","altRow","altLabel","expl","altExplLabel","showRuby","toPrecision","places","unitSpan","Intl","NumberFormat","currency","format","renderCurrencyValue","rate","timestampRow","timestampAsDate","timestamp","timestampAsString","dateStyle","timeStyle","toFixed","formattedValue","currencyDisplay","serializeShogi","piece","serializeShogiDest","movement","move","promotion","regularAgeRegex","backwardsAgeRegex","getDob","month","approx","day","date","renderNamesEntries","namesTable","entryDiv","renderName","more","entryTitleDiv","MAX_KANJI","trimKanji","kanjiToDisplay","kana","definitionBlock","tr","renderNameTranslation","definitionSpan","annotateDetailFn","annotateAge","det","tagText","dob","today","age","getFullYear","getMonth","getDate","ageString","renderCopyDetails","statusDiv","keysDiv","copyKeys","l10nKey","copyNextKey","copyKey","renderCopyStatus","getCopiedString","renderUpdatingStatus","statusText","spinner","onHorizontalSwipe","handler","xMinThreshold","yMaxThreshold","allowedTime","startTime","startX","startY","changedTouches","pageX","pageY","performance","now","deltaX","deltaY","elapsedTime","isSwipe","renderTabBar","tabBar","sections","renderIcon","li","selectedTab","enabledTabs","onSwitchDictionary","showPin","onTogglePin","displayMode","renderPinButton","pinShortcuts","onShowSettings","renderSettingsButton","pinButton","settingsButton","instanceOfAny","object","constructors","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","IDBDatabase","IDBObjectStore","IDBIndex","IDBCursor","IDBTransaction","getCursorAdvanceMethods","advance","continue","continuePrimaryKey","transactionDoneMap","transformCache","reverseTransformCache","promisifyRequest","request","unlisten","success","wrap","cacheDonePromiseForTransaction","tx","complete","DOMException","idbProxyTraps","objectStoreNames","objectStore","replaceTraps","wrapFunction","func","unwrap","transformCachableValue","IDBRequest","newValue","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","useIndex","isWrite","storeName","transaction","store","oldTraps","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","cursor","openCursor","proxiedCursor","isIteratorProp","asyncIterator","SKIP_FOR_MORA_COUNT","countMora","moraSubstring","_start","_end","moraLength","temp","moraIndex","charStart","charEnd","safeInteger","isSafeInteger","VersionInfoStruct","major","minor","patch","databaseVersion","dateOfCreation","version","records","part","_","KanjiMetaSchema","bv","bg","AccentSchema","ReadingMetaSchema","app","CrossReferenceSchema","sense","LangSourceSchema","wasei","WordSenseSchema","g","gt","kapp","rapp","dial","inf","xref","ant","lsrc","WordIdSchema","km","rm","NameTranslationSchema","cf","NameIdSchema","ReadingsStruct","RadicalStruct","var","MiscSchema","jlptn","KanjiIdSchema","RadicalIdSchema","pua","posn","groupSenses","senses","groups","previousPos","dropPos","thisPos","group","commonPos","commonMisc","_a","posToDrop","GlossTypes","GLOSS_TYPE_MAX","floor","log2","self","requestIdleCallback","cancelIdleCallback","proverbTag","verbTags","getFilteredTags","renderWordEntries","numNames","totalEntries","renderNamePreview","copyKind","longestMatch","matchLength","matchRange","renderPopup","getDefaultContainer","windowElem","resetContainer","contentContainer","hasResult","showPopup","popup","getCursorClearanceAndPos","getPopupDimensions","minHeight","fixMinHeight","previousHeight","getPopupPosition","allowVerticalOverlap","cursorClearance","cursorPos","fixedPosition","isVerticalText","positionMode","safeArea","baseVal","ctm","getScreenCTM","transform","createSVGTransformFromMatrix","inverse","initialize","constrainWidth","removeProperty","constrainHeight","renderPopupArrow","toScreenCoords","queryCache","query","getCacheKey","cachedEntry","q","fullQuery","updateQueryResult","wordsQuery","rawWordsQuery","queryWords","queryOther","resultType","cacheIndex","findIndex","includeRomaji","searchResult","queryResult","dbStatus","isTranslateResult","textLen","SafeAreaProvider","getSafeArea","safeAreaElem","startListening","cachedSafeArea","computedStyle","setCachedSafeArea","destroy","stopListening","safeAreaProviderStyles","onResizeObserved","box","onWindowResize","unobserve","removeSafeAreaProvider","contentRect","textBoxSizeLengths","getPageTargetProps","textBoxSizes","getInitialClientBboxofTextSelection","fromPuck","fromTouch","hasTitle","TextHighlighter","detach","onFocusIn","clearHighlight","dropHighlightStyles","selectedWindow","ownerDocument","closed","canUseHighlightApi","anchorNode","previousSelection","selectedText","storeContentEditableSelection","CSS","highlights","highlightTextBox","textBox","isGdocsSpan","highlightGdocsRange","startSpan","highlightRegularNode","restoreContentEditableSelection","removeAllRanges","clearGdocsHighlight","clearTextBoxSelection","currentElement","selectedTextBox","previousFocus","isUpdatingFocus","updatingFocus","anchorOffset","createRange","addRange","restoreTextBoxSelection","activeElement","previousUpdatingFocus","previousStart","selectionStart","previousEnd","selectionEnd","previousDirection","selectionDirection","setSelectionRange","blur","TextRangeWithLength","isSvg","endNode","StaticRange","endContainer","Highlight","ensureHighlightStyles","textRangesEqual","hasReasonableTimerResolution","waitALittle","numSamples","samples","same","identicalPairs","previous","TouchClickTracker","removeEventListeners","disabled","addEventListeners","startIgnoringClicks","ignoring","stopIgnoringClicks","onTouchStart","passive","onTouchEnd","clickHandlerRegistered","wasTouch","onTouchClick","ContentHandler","applyPuckConfig","isTopMostWindow","setUpPuck","tearDownPuck","puck","LookupPuck","initialPosition","safeAreaProvider","onLookupDisabled","onPuckStateChanged","setEnabledState","active","removePuck","setConfig","onConfigChange","updatePopup","touchClickTracker","currentLookupParams","currentTargetProps","lookupParams","lookupText","setTheme","setIcon","onDbUpdated","onPointerMove","onMouseDown","onKeyDown","capture","onKeyUp","onFullScreenChange","onInterFrameMessage","onBackgroundMessage","textHighlighter","isPopupExpanded","setEffectiveTopMostWindow","wasTopMost","isEffectiveTopMostWindow","getTopMostWindow","getFrameId","setFrameId","typingMode","shiftKey"],"mappings":"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"}