class ClockifyIntegrationBase{static async takeTimeEntryInProgress(t){if(await isNavigatorOffline())return void t("Connection is offline");const{entry:a,error:e}=await TimeEntry.getEntryInProgress();!a||e?(setTimeEntryInProgress(null),aBrowser.action.setIcon({path:iconPathEnded})):(setTimeEntryInProgress(a),aBrowser.action.setIcon({path:iconPathStarted})),t({status:clockifyLocales.OK_BTN})}static async endInProgress({endedFromIntegration:t,integrationName:a,endEntryInProgressToContinueOtherEntry:e},s){if(await isNavigatorOffline())return void s("Connection is offline");const{error:i}=await TimeEntry.endInProgress({endedFromIntegration:t,integrationName:a,endEntryInProgressToContinueOtherEntry:e});i?s({status:i.status,message:i.message}):(aBrowser.notifications.clear("idleDetection"),aBrowser.runtime.sendMessage({eventName:"entryEnded"}),aBrowser.action.setIcon({path:iconPathEnded}),s({status:clockifyLocales.OK_BTN}))}static async startWithDescription(t,a){if(await isNavigatorOffline())return void a("Connection is offline");const{entry:e,error:s}=await TimeEntry.getEntryInProgress();if(s)return void a({status:s.status});if(e){const{error:e}=await TimeEntry.endInProgress({endedFromIntegration:!0,integrationName:t.integrationName??null});if(e)return void a({status:e.status})}const{data:i,error:r,status:n}=await TimeEntry.integrationStartTimerWithDescription(t.description,t);if(r)a({status:r.status});else{const{trackerStarted:e,entryAdded:s,entryContinued:r}=AnalyticsService.events;if(201===n){if(t&&!t.isStartedFromIntegration)if(t?.manualMode){const t={analyticsEventName:"entry_mode",eventParameters:{start_time:i.timeInterval.start,end_time:i.timeInterval.end,duration:i.timeInterval.duration,browser:"chrome"}};await this.sendAnalyticsEvent(t),await AnalyticsService.storeAnalyticsEvents([s])}else{const a={analyticsEventName:"entry_mode",eventParameters:{timer_start:!0,browser:"chrome"}};await this.sendAnalyticsEvent(a),await AnalyticsService.storeAnalyticsEvents([t.continueEntryByStartingEntryAgain?r:e])}else if(t?.manualMode){const a={analyticsEventName:"entry_mode_integration",eventParameters:{integrationName:t.integrationName,start_time:i.timeInterval.start,end_time:i.timeInterval.end,duration:i.timeInterval.duration,browser:"chrome"}};await this.sendAnalyticsEvent(a),await AnalyticsService.storeAnalyticsEvents([s])}else{const a={analyticsEventName:"entry_mode_integration",eventParameters:{integrationName:t.integrationName,timer_start:!0,browser:"chrome"}};await this.sendAnalyticsEvent(a),await AnalyticsService.storeAnalyticsEvents([e])}t.manualMode||(aBrowser.action.setIcon({path:iconPathStarted}),aBrowser.runtime.sendMessage({eventName:"entryStarted",options:{entry:i}}),aBrowser.storage.local.set({timeEntryInProgress:i}))}a({status:n,data:i})}}static async generateManualEntryData({projectName:t,taskName:a,tagNames:e},s){if(await isNavigatorOffline())return void s("Connection is offline");let i,r,n;if(t){let{projectDB:e}=await ProjectTaskService.getOrCreateProject(t);if(i=e,i&&a){let{taskDB:t}=await ProjectTaskService.getOrCreateProjectAndTask(i.name,{name:a});r=t}}if(e){const{tagovi:t}=await TagService.getOrCreateTags(e.map((t=>t.trim())));n=t}s({project:i,task:r,tags:n})}static async getProjectsByIds({projectIds:t,taskIds:a},e){if(await isNavigatorOffline())return void e("Connection is offline");const{projectDB:s,error:i,status:r}=await ProjectTaskService.getProjectsByIds(t,a);e(i?i.message?i.message:i.status:s?{status:r,data:[s]}:{status:r,data:[]})}static async getDefaultProjectTask(t){if(await isNavigatorOffline())return void t("Connection is offline");const{projectDB:a,taskDB:e,msg:s,msgId:i}=await DefaultProject.getProjectTaskFromDB();t({projectDB:a,taskDB:e,msg:s,msgId:i})}static async getProjects({filter:t,page:a,pageSize:e,forceTasks:s,alreadyIds:i},r){if(await isNavigatorOffline())return void r("Connection is offline");const{data:n,error:o}=await ProjectTaskService.getProjectsWithFilter(t,a,e,s,i);o&&r(o.message?o.message:o.status),r({status:201,data:n})}static async getLastUsedProjectFromTimeEntries({forceTasks:t},a){if(await isNavigatorOffline())return void a("Connection is offline");const{data:e,error:s}=await ProjectTaskService.getLastUsedProjectFromTimeEntries(t);s&&a(s.message?s.message:s.status),a({status:201,data:e})}static async getTaskOfProject({projectId:t,taskName:a},e){if(await isNavigatorOffline())return void e("Connection is offline");const{data:s,error:i}=await ProjectTaskService.getTaskOfProject({projectId:t,taskName:a});i&&e(i.message?i.message:i.status),e({status:201,data:s})}static async getProjectTasks({projectId:t,filter:a,page:e},s){if(await isNavigatorOffline())return void s("Connection is offline");const{data:i,status:r}=await ProjectTaskService.getProjectTasksWithFilter(t,a,e);s({status:r,data:i})}static async submitDescription({id:t,description:a},e){if(await isNavigatorOffline())return void e("Connection is offline");const{data:s,error:i,status:r}=await TimeEntry.setDescription(t,a.trim());e(i?i.message?i.message:i.status:{data:s,status:r})}static async createProject({project:t,createdFromPopup:a},e){if(await isNavigatorOffline())return void e("Connection is offline");const{data:s,error:i,status:r}=await ProjectTaskService.createProject(t);i?e({error:i}):(a&&AnalyticsService.storeAnalyticsEvents([AnalyticsService.events.projectAdded]),e({status:r,data:s}))}static async editProject({id:t,project:a},e){if(await isNavigatorOffline())e("Connection is offline");else if(a){const{data:s,error:i,status:r}=await TimeEntry.updateProject(t,a);if(i)return void e(i.message?i.message:i.status);e({status:r,data:s})}else{const{data:a,error:s,status:i}=await TimeEntry.removeProject(t);if(s)return void e(s.message?s.message:s.status);e({status:i,data:a})}}static async createTask({task:t},a){if(await isNavigatorOffline())return void a("Connection is offline");const{data:e,error:s,status:i}=await ProjectTaskService.createTask(t);a(s?{error:s}:{status:i,data:e})}static async editTask({id:t,project:a,task:e},s){if(await isNavigatorOffline())s("Connection is offline");else if(e){const{data:i,error:r,status:n}=await TimeEntry.updateTask(e,a,t);if(r)return void s(r.message?r.message:r.status);s({status:n,data:i})}else{const{data:a,error:e,status:i}=await TimeEntry.removeTask(t);if(e)return void s(e.message?e.message:e.status);s({status:i,data:a})}}static async getTags({filter:t,page:a,pageSize:e},s){if(await isNavigatorOffline())return void s("Connection is offline");const{data:i,error:r,status:n}=await TagService.getAllTagsWithFilter(a,e,t);s(r?r.message?r.message:r.status:{status:n,data:i})}static async createTag({tag:t},a){if(await isNavigatorOffline())return void a("Connection is offline");const{data:e,error:s,status:i}=await TagService.createTag(t);console.log({data:e,error:s,status:i}),a(s||{status:i,data:e})}static async editTags({id:t,tagIds:a},e){if(await isNavigatorOffline())return void e("Connection is offline");const{data:s,error:i,status:r}=await TimeEntry.updateTags(a,t);e(i?{error:i}:{status:r,data:s})}static async fetchEntryInProgress(t){if(await isNavigatorOffline())return void t("Connection is offline");const{entry:a,error:e}=await TimeEntry.getEntryInProgress(!0);t(e?e.message?e.message:e.status:{entry:a})}static async removeProjectAsFavorite({projectId:t},a){if(await isNavigatorOffline())return void a("Connection is offline");const{error:e,status:s}=await ProjectTaskService.removeProjectAsFavorite(t);a(e?e.message?e.message:e.status:{status:s})}static async makeProjectFavorite({projectId:t},a){if(await isNavigatorOffline())return void a("Connection is offline");const{error:e,status:s}=await ProjectTaskService.makeProjectFavorite(t);a(e?e.message?e.message:e.status:{status:s})}static async editBillable({id:t,billable:a},e){if(await isNavigatorOffline())return void e("Connection is offline");const{entry:s,error:i,status:r}=await TimeEntry.updateBillable(t,a);e(i?i.message?i.message:i.status:{entry:s,status:r})}static async submitTime({totalMins:t,timeEntryOptions:a,integrationName:e},s){if(await isNavigatorOffline())return void s("Connection is offline");const{entry:i,error:r}=await TimeEntry.getEntryInProgress();if(r)return void s({status:r.status});if(i){const{error:t}=await TimeEntry.endInProgress();if(t)return void s({status:t.status,endInProgressStatus:!0})}const{timeInterval:n}=a;if(n?.start&&n?.end)a.start=n.start,a.end=n.end;else{const e=new Date;a.start=e,a.end=new Date(e.getTime()+6e4*t),a.isSubmitTime=!0}const{entry:o,error:c,status:f}=await TimeEntry.integrationStartTimerWithDescription(a.description,a);if(c)c.status&&400===c.status?s({entry:o,status:400}):s(c.message?c.message:c.status);else{{const{entryAdded:t}=AnalyticsService.events,s="entry_mode_integration",i=moment(moment.duration(moment(a.end).diff(moment(a.start)))).format("HH:mm:ss"),r={analyticsEventName:s,eventParameters:{integrationName:e,start_time:a.start,end_time:a.end,duration:i,browser:"chrome"}};await this.sendAnalyticsEvent(r),await AnalyticsService.storeAnalyticsEvents([t])}s({entry:o,status:f})}}static async getWSCustomField({name:t},a){if(await isNavigatorOffline())return void a("Connection is offline",0);const e=await CustomFieldService.getWSCustomField(t);if(e){const{data:t,error:s,status:i}=e;if(s)return void a(s.message,s.status);a({data:t,status:i})}else a("Connection is offline",0)}static async getUserRoles(t){if(await isNavigatorOffline())return void t("Connection is offline",0);const{data:a,error:e,status:s}=await UserService.getUserRoles();e?t(e.message,e.status):t({data:a,status:s})}static async getUser(t){if(await isNavigatorOffline())return void t("Connection is offline",0);const{data:a,error:e,status:s}=await UserService.getUser();e?t(e.message,e.status):t({data:a,status:s})}static async getMemberProfile({userId:t,workspaceId:a},e){if(await isNavigatorOffline())return void e("Connection is offline",0);const{data:s,error:i,status:r}=await UserService.getMemberProfile(a,t);i?e(i.message,i.status):e({data:s,status:r})}static async getBoot(t){if(await isNavigatorOffline())return void t("Connection is offline",0);const{data:a,error:e,status:s}=await UserService.getBoot();e?t(e.message,e.status):t({data:a,status:s})}static async setDefaultWorkspace({workspaceId:t},a){if(await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await UserService.setDefaultWorkspace(t);s?a(s.message,s.status):a({data:e,status:i})}static async resendVerificationEmail(t){if(await isNavigatorOffline())return void t("Connection is offline",0);const{data:a,error:e,status:s}=await UserService.resendVerificationEmail();e?t(e.message,e.status):t({data:a,status:s})}static async getPermissionsForUser(t){if(await isNavigatorOffline())return void t("Connection is offline",0);const{data:a,error:e,status:s}=await UserWorkspaceStorage.getPermissionsForUser();e?t(e.message,e.status):t({data:a,status:s})}static async getWorkspaceSettings(t){if(await isNavigatorOffline())return void t("Connection is offline",0);const{data:a,error:e,status:s}=await UserWorkspaceStorage.getSetWorkspaceSettings();e?t(e.message,e.status):t({data:a,status:s})}static async getWorkspacesOfUser(t){if(await isNavigatorOffline())return void t("Connection is offline",0);const{data:a,error:e,status:s}=await UserWorkspaceStorage.getWorkspacesOfUser();e?t(e.message,e.status):(a&&aBrowser.storage.local.set({userWorkspaces:a}),t({data:a,status:s}))}static async getWasRegionalEverAllowed(t){if(await isNavigatorOffline())return void t("Connection is offline",0);const{data:a,error:e,status:s}=await UserWorkspaceStorage.getWasRegionalEverAllowed();e?t(e.message,e.status):t({data:a,status:s})}static async signup({email:t,password:a,timeZone:e},s){if(await isNavigatorOffline())return void s("Connection is offline",0);const{data:i,error:r,status:n}=await AuthService.signup(t,a,e);r?s(r.message,r.status):s({data:i,status:n})}static async getClientsWithFilter({page:t,pageSize:a,filter:e},s){if(await isNavigatorOffline())return void s("Connection is offline",0);const{data:i,error:r,status:n}=await ClientService.getClientsWithFilter(t,a,e);r?s(r.message,r.status):s({data:i,status:n})}static async createClient({client:t},a){if(await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await ClientService.createClient(t);a(s?{error:s}:{data:e,status:i})}static async submitCustomField({timeEntryId:t,customFieldId:a,value:e},s){if(await isNavigatorOffline())return void s("Connection is offline",0);const{data:i,error:r,status:n}=await CustomFieldService.updateCustomField(t,a,e);r?s(r.message,r.status):s({data:i,status:n})}static async getTimeEntries({page:t},a){if(await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await TimeEntry.getTimeEntries(t);s?a(s.message,s.status):a({data:e,status:i})}static async changeStart({start:t,timeEntryId:a},e){if(await isNavigatorOffline())return void e("Connection is offline",0);const{data:s,error:i,status:r}=await TimeEntry.changeStart(t,a);i?e(i.message,i.status):e({data:s,status:r})}static async editTimeInterval({entryId:t,timeInterval:a},e){if(await isNavigatorOffline())return void e("Connection is offline",0);const{data:s,error:i,status:r}=await TimeEntry.editTimeInterval(t,a);i?e(i.message,i.status):e({data:s,status:r})}static async getEntryInProgress(t){if(await isNavigatorOffline())return void t("Connection is offline",0);const{entry:a,error:e,status:s}=await TimeEntry.getEntryInProgress();e?t(e.message,e.status):t({data:a,status:s})}static async setDescription({entryId:t,description:a},e){if(await isNavigatorOffline())return void e("Connection is offline",0);const{data:s,error:i,status:r}=await TimeEntry.setDescription(t,a);i?e(i.message,i.status):e({data:s,status:r})}static async removeProject({entryId:t},a){if(await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await TimeEntry.removeProject(t);s?a(s.message,s.status):a({data:e,status:i})}static async removeTask({entryId:t},a){if(await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await TimeEntry.removeTask(t);s?a(s.message,s.status):a({data:e,status:i})}static async continueEntry({timeEntryId:t},a){if(await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await TimeEntry.continueEntry(t);s?a(s.message,s.status):a({data:e,status:i})}static async deleteTimeEntry({entryId:t},a){if(await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await TimeEntry.deleteTimeEntry(t);s?a(s.message,s.status):a({data:e,status:i})}static async deleteTimeEntries({entryIds:t},a){if(await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await TimeEntry.deleteTimeEntries(t);s?a(s.message,s.status):a({data:e,status:i})}static async updateTimeEntryValues({entryId:t,body:a},e){if(await isNavigatorOffline())return void e("Connection is offline",0);const{data:s,error:i,status:r}=await TimeEntry.updateTimeEntryValues(t,a);i?e(i.message,i.status):e({data:s,status:r})}static async duplicateTimeEntry({entryId:t},a){if(await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await TimeEntry.duplicateTimeEntry(t);s?a(s.message,s.status):a({data:e,status:i})}static async searchEntries({searchValue:t},a){if(await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await TimeEntry.searchEntries(t);s?a(s.message,s.status):a({data:e,status:i})}static async getRecentTimeEntries(t){if(await isNavigatorOffline())return void t("Connection is offline",0);const{data:a,error:e,status:s}=await TimeEntry.getRecentTimeEntries();e?t(e.message,e.status):t({data:a,status:s})}static async invalidateToken(t){if(await isNavigatorOffline())return void t("Connection is offline",0);const{data:a,error:e,status:s}=await AuthService.invalidateToken();e?t(e.message,e.status):t({data:a,status:s})}static async checkInternetConnection(t){t(await UserService.checkInternetConnection())}static async sendAnalyticsEvent(t,a){if(!await isNavigatorOffline())try{await AnalyticsService.sendAnalyticsEvent(t)}catch(t){console.error("API call failed:",t)}}static async sendAnalyticsEvents({forceClearEvents:t},a){if(!await isNavigatorOffline())try{await AnalyticsService.sendAnalyticsEvents({forceClearEvents:t}),a({error:null})}catch(t){console.error("API call failed:",t),a({error:t})}}static async clearAnalyticsEvents(t){try{await AnalyticsService.clearAnalyticsEvents(),t({error:null})}catch(a){console.error(a),t({error:a})}}static async getNotificationsForUser(t){if(await isNavigatorOffline())return void t("Connection is offline",0);const{data:a,error:e,status:s}=await NotificationService.getNotificationsForUser();t(e?{error:e}:{data:a,status:s})}static async getVerificationNotificationsForUser(t){if(await isNavigatorOffline())return void t("Connection is offline",0);const{data:a,error:e,status:s}=await NotificationService.getVerificationNotificationsForUser();t(e?{error:e}:{data:a,status:s})}static async getNewsForUser(t){if(await isNavigatorOffline())return void t("Connection is offline",0);const{data:a,error:e,status:s}=await NotificationService.getNewsForUser();t(e?{error:e}:{data:a,status:s})}static async readSingleNotificationForUser({notificationId:t},a){if(console.log("readSingleNotificationForUser",{notificationId:t}),await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await NotificationService.readSingleNotificationForUser({notificationId:t});a(s?{error:s}:{data:e,status:i})}static async readSingleOrMultipleVerificationNotificationForUser(t,a){if(await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await NotificationService.readSingleOrMultipleVerificationNotificationForUser(t);a(s?{error:s}:{data:e,status:i})}static async readSingleOrMultipleNewsForUser({newsIds:t},a){if(console.log("readSingleOrMultipleNewsForUser",{newsIds:t}),await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await NotificationService.readSingleOrMultipleNewsForUser({newsIds:t});a(s?{error:s}:{data:e,status:i})}static async readManyNotificationsForUser({notificationIds:t},a){if(await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await NotificationService.readManyNotificationsForUser({notificationIds:t});a(s?{error:s}:{data:e,status:i})}static async sendEmailVerification(t){if(await isNavigatorOffline())return void t("Connection is offline",0);const{data:a,error:e,status:s}=await UserService.sendEmailVerification();t(e?{error:e}:{data:a,status:s})}static async subscribeToNewsletter(t){if(await isNavigatorOffline())return void t("Connection is offline",0);const{data:a,error:e,status:s}=await UserService.subscribeToNewsletter();t(e?{error:e}:{data:a,status:s})}static async removeDeclinedUserFromWorkspace(t,a){if(await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await UserService.removeDeclinedUserFromWorkspace(t);a(s?{error:s}:{data:e,status:i})}static async changeWorkspaceStatus(t,a){if(await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await UserService.changeWorkspaceStatus(t);console.log("changeworkspace data:",e),a(s?{error:s}:{data:e,status:i})}static async setDefaultUserWorkspace(t,a){if(await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await UserService.setDefaultUserWorkspace(t);a(s?{error:s}:{data:e,status:i})}static async changeTimezone(t,a){if(await isNavigatorOffline())return void a("Connection is offline",0);const{data:e,error:s,status:i}=await UserService.changeTimezone(t);a(s?{error:s}:{data:e,status:i})}}class ClockifyIntegration extends ClockifyIntegrationBase{static callFunction(t,a,e){return isChrome()?(a&&a.options?super[t](a.options,e):super[t](e),!0):new Promise((e=>{a&&a.options?super[t](a.options,e):super[t](e)}))}}